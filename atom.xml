<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CAIWEI的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-24T09:34:46.906Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>CAIWEI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>腾讯广告大数据平台核心架构设计</title>
    <link href="http://example.com/2021/11/22/%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/11/22/%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-11-22T05:12:32.000Z</published>
    <updated>2021-11-24T09:34:46.906Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯广告大数据架构</p><a id="more"></a><blockquote><p>转载自<a href="https://mp.weixin.qq.com/s/1bVUOnKgpC5mjCvCz4TLdg" target="_blank" rel="noopener">广告大数据平台核心架构设计</a>，侵删</p><p>本篇文章讲解了腾讯广告大数据的整体架构，讲解了具体细分的模块以及多年的更新迭代，个人觉得对大数据领域的广告业务很有参考价值，故转载。</p></blockquote><p>腾讯广告平台产品部大数据平台承担着腾讯视频、腾讯新闻客户端、腾讯网、腾讯体育、QQ音乐等腾讯系媒体和部分外部媒体的广告数据的接入、处理和应用。在过去的几年中，伴随着广告业务的快速发展，大数据平台架构也经历了一系列的升级。本文将从广告数据接入、处理、应用三个层面剖析大数据平台的核心架构设计，重点分享百亿级广告日志数据的接入架构设计（云落地系统）、广告数据  session 化实现（ logjoin 系统)、PB 级数据的 OLAP 查询 Lambda 架构设计。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145919366.png" srcset="/img/loading.gif" lazyload="" alt="图1. 大数据平台整体架构"></p><h2 id="1-数据接入"><a href="#1-数据接入" class="headerlink" title="1 数据接入"></a><strong>1 数据接入</strong></h2><hr><p>大数据平台接入的数据主要包括3个大类：业务维度数据、媒体流量数据、广告流量数据，如图2所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145950146.png" srcset="/img/loading.gif" lazyload="" alt="图2. 数据接入架构"></p><h3 id="1-1-业务维度数据"><a href="#1-1-业务维度数据" class="headerlink" title="1.1 业务维度数据"></a><strong>1.1 业务维度数据</strong></h3><hr><p>业务维度数据主要包括广告客户数据、广告下单数据、广告排期数据、广告位数据，这些数据原生位于广告投放体系中的其他业务系统如CRM系统、Order系统、Planning系统。大数据平台使用3种方式获取这种维度数据：</p><p>1）业务提供数据接口，平台主动拉</p><p>2）业务提供表schema/IP/端口，平台编写业务逻辑SQL，主动拉取</p><p>3）平台提供接口，业务主动调用接口上传</p><h3 id="1-2-媒体流量数据"><a href="#1-2-媒体流量数据" class="headerlink" title="1.2 媒体流量数据"></a><strong>1.2 媒体流量数据</strong></h3><hr><p>媒体流量数据来源于媒体，主要包括腾讯视频播放数据、腾讯新闻浏览数据，这些媒体数据通过腾讯公司级数据仓库TDW出库到大数据平台侧的Hadoop集群。媒体流量数据主要有两大类用途：</p><p>1）结合媒体数据分析广告的投放效果和售卖效果</p><p>2）ETL清洗后为算法服务提供原始特征数据</p><h3 id="1-3-广告流量数据"><a href="#1-3-广告流量数据" class="headerlink" title="1.3 广告流量数据"></a><strong>1.3 广告流量数据</strong></h3><hr><p>广告流量数据包括广告的检索、曝光、点击数据，是整个大数据平台自有的核心数据。鉴于腾讯视频、腾讯新闻客户端、腾讯网等媒体的巨大流量（日均百亿级广告PV、峰值QPS40万），如何采集和传输这海量广告日志数据成为大数据平台首先需要面对的挑战，这个挑战主要体现在以下3个方面：</p><p>1）数据总量大、峰值压力高</p><p>2）数据的可靠性、实时性要求极高</p><p>3）业务数据种类繁多且业务变化快</p><p>因此，一个良好的数据采集传输系统需要具备下述特性：</p><p>1）高可靠性和高可扩展性，完善的容错和负载均衡机制，可水平扩展的处理能力；</p><p>2）支持离线分析系统和实时计算系统；</p><p>3）能够灵活快速响应业务需求，实现数据字段新增、修改。</p><p>大数据平台2016年前的广告流量数据接入架构如图3-1所示。在这套广告流量数据接入架构中，广告流量数据落地功能是和业务server耦合的，共同部署在接入层server上，通过本地的各配置文件生成多个落地器，在单机上实现数据分拣（分拣：不同流量来源的数据落地到不同的目的路径），并按照配置的字段挑选数据。落地数据定时批量从server磁盘上传HDFS集群。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150022801.png" srcset="/img/loading.gif" lazyload="" alt="图3 - 1. 广告流量数据接入架构（就）"></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150047975.png" srcset="/img/loading.gif" lazyload="" alt="图3 - 2. 广告流量数据接入架构（新）"></p><p>这个广告流量数据接入架构的主要缺陷在于：</p><p>1）通过白名单式的配置挑选落地字段，没有完整请求数据，没有可恢复的数据现场</p><p>2）和业务server重度耦合，每条数据都要串行遍历所有落地器处理，性能较差</p><p>3）配置修改比较复杂，在业务较多的服务，如点击服务器，修改配置的复杂度不低于修改代码，易出错</p><p>4）业务变化涉及众多服务器升级，运维工作量大，一致性难保证。</p><p>为了解决这个广告流量数据接入架构存在的上述问题，大数据平台对此架构进行了重构升级，搭建了新一代广告流量数据接入系统——云落地。云落地系统的设计目标是建成广告效果数据总线以实现数据集中接入、秒级实时处理、下游业务各取所需、业务变更不停数据流。</p><p>云落地系统主要由Storm、TDBank(腾讯自研的分布式消息队列)、Hadoop等分布式系统组件构建，总体架构采用分层结构，如图4所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150113763.png" srcset="/img/loading.gif" lazyload="" alt="图4. 云落地系统架构"></p><p>业务服务器包含云落地系统所对接的各种业务日志服务器。发送Agent包含收集业务日志数据并进行转发的Sender。传输层使用TDBank，接收Agent发送的日志数据。核心分拣层包含2个分拣引擎：实时分拣引擎以及作为容错机制的离线分拣引擎。实时分拣在Storm Topology中实现。离线分拣使用Hadoop MapReduce实现。当实时分拣数据流出现问题时，可用离线分拣进行数据分拣，依然能保证数据完整性。存储层是HDFS分布式文件系统以及TDBank，其中HDFS存储支持下游离线数据应用，TDBank存储支持下游实时计算系统。云落地系统整体数据流如图5所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150142550.png" srcset="/img/loading.gif" lazyload="" alt="图5. 云落地系统整体数据流"></p><p>云落地目前接入了腾讯网，腾讯视频，腾讯新闻客户端，微信/手Q新闻插件等业务，已覆盖所有广平数据业务。日均接收原始请求数百亿级，峰值QPS 40W/S。平均处理延迟7.5s。云落地系统将服务和数据解耦，提高了业务响应能力；配置中心化，一个业务，只需要维护一个配置，数据一致性得到保障；Hadoop和Storm结合保证了数据接入和传输的高可靠性和高可扩展性；云落地系统强化数据总线概念，所有的数据都从云分拣“入”，所有的数据需求都从云分拣“出”。</p><h2 id="2-数据处理"><a href="#2-数据处理" class="headerlink" title="2 数据处理"></a><strong>2 数据处理</strong></h2><h3 id="2-1-业务维度表构建"><a href="#2-1-业务维度表构建" class="headerlink" title="2.1 业务维度表构建"></a><strong>2.1 业务维度表构建</strong></h3><hr><p>针对上文中提到的业务维度数据，数据处理流程做的主要工作是生成一系列的维度表，这一系列的维度表将被用于数据建模时维度的扩展。例如对于广告下单数据，数据平台会生成以订单号oid为key的维度表，该维度表中还包括如客户ID，广告排期等其他订单号相关的属性。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150204557.png" srcset="/img/loading.gif" lazyload="" alt="图6. 维度表Schema设计"></p><p>一个维度表最终的物理存储形式为HDFS上的一个文件，大数据平台目前维护着数百份维度表，这些维度表的更新周期包括按天、按小时等等。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150226743.png" srcset="/img/loading.gif" lazyload="" alt="图7. 维度表物理存储"></p><h3 id="2-2-媒体流量数据ETL"><a href="#2-2-媒体流量数据ETL" class="headerlink" title="2.2 媒体流量数据ETL"></a><strong>2.2 媒体流量数据ETL</strong></h3><hr><p>媒体流量数据通过TDW由媒体侧出库到大数据平台侧的Hadoop集群，之后数据平台将进行必要的数据清洗和转换以构建数据模型。</p><h3 id="2-3-广告流量数据ETL"><a href="#2-3-广告流量数据ETL" class="headerlink" title="2.3 广告流量数据ETL"></a><strong>2.3 广告流量数据ETL</strong></h3><hr><p>对于通过云落地系统接入的广告流量数据，ETL流程通过清洗、关联和转换以实现数据的一致性、完整性、标准化。数据平台2017年前的ETL流程和业界通用的ETL流程类似，通过离线的Map/Reduce程序对广告日志进行清洗、关联和转换,清洗程序包括小时级的和天级的，清洗程序的调度通过TDW LZ平台实现，如图8所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150249741.png" srcset="/img/loading.gif" lazyload="" alt="图8. ETL清洗任务"></p><p>这种离线数据ETL方式主要存在以下问题：</p><p>1）数据时效性差: </p><p>采用离线清洗,不能给下游实时统计提供实时流量，下游统计分析仅支持到T+1（1表示小时或者天，绝大部分数据为天）</p><p>2）离线清洗计算引擎落后: </p><p>离线清洗基于Hadoop MapReduce, 一方面计算中间结果需要存放到hdfs中，效率较低，另一方面支持的算子仅有Map和Reduce，表达能力欠缺，需要手工写很多代码，较难维护。</p><p>针对以上不足，大数据平台在2017年对数据ETL系统进行了重构升级，升级后的ETL系统架构如图9所示。新的ETL系统由两大部分组成，实时ETL和离线ETL。</p><p>1）实时ETL: 基于实时LogJoin(下文会介绍)的输出，构建实时清洗，为下游实时业务提供基础数据。</p><p>2）离线ETL: 清洗计算引擎升级为spark，提升处理速度。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150312441.png" srcset="/img/loading.gif" lazyload="" alt="图9. 实时ETL架构图"></p><p>实时ETL分事实数据生成维度数据Join两个主模块。事实数据生成模块主要负责数据过滤，转换，格式化处理，生成事实表模型；维度数据Join模块负责根据不同的实时业务需求，关联不同的维度数据。实时ETL生成的数据将被用于实时查询引擎实时数据的查询以及算法需要的实时特征数据。</p><h3 id="2-4-广告数据Session化"><a href="#2-4-广告数据Session化" class="headerlink" title="2.4 广告数据Session化"></a><strong>2.4 广告数据Session化</strong></h3><hr><p>广告数据session化，即构建从用户产生一个广告请求到曝光以及最终产生点击的session级数据模型，实时logjoin就是用来实现广告数据session化的系统。广告检索日志、曝光日志、点击日志三路数据将通过实时logjoin模块进行整合，曝光、点击数据只需携带关键信息，其他信息由检索数据填充。目前广告曝光点击等效果日志关联是离线任务方式执行，延迟至少2个小时，通过实时logjoin可以有效服务算法实时CTR。LogJoin整体架构图如图10所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150334025.png" srcset="/img/loading.gif" lazyload="" alt="图10. 实时LogJoin架构"></p><p>LogJoin项目主要意义：</p><p>1）提升数据一致性。以发布测数据为准，曝光、点击、动作数据都向发布数据靠，保证数据一条线的一致性；</p><p>2）提升数据完整性。减少大字段导致的http截断等用户侧上报场景下的问题；</p><p>3）提升数据时效性。基于Storm做流式logjoin，秒级完成数据ETL。可供实时CTR预估，在线学习等，提升广告收益，并为海象等下游业务提速打下基础；</p><p>4）精简曝光点击请求上报，节省用户流量；</p><p>5）解耦SDK和数据采集，提升新需求的响应速度；</p><p>6）基础数据底层schema重构优化，对各种业务不同格式数据建立统一底层数据模型，降低系统复杂度；</p><p>7）实时补全日志，纬度信息更加丰富，可支持实时多维分析。</p><h3 id="核心业务逻辑"><a href="#核心业务逻辑" class="headerlink" title="核心业务逻辑"></a><strong>核心业务逻辑</strong></h3><p>LogJoin的核心业务逻辑是将用户产生的一个广告从请求到曝光以及最终产生点击的完整日志数据Join到一起，LogJoin通过将一个广告的请求、曝光、点击写到Hbase的同一行中的Column Family并通过不同的qualifier来标识请求、曝光、点击来实现Join的功能,如图11所示。LogJoin中数据的实时清洗以及读写HBase的操作都是在JStorm中完成。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150359628.png" srcset="/img/loading.gif" lazyload="" alt="图11. 实时LogJoin业务逻辑"></p><p>在HBase里一次广告检索对应后续的所有曝光和点击日志都保存在同一个RowKey对应的行，三种日志放在不同的列里，如图12所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150438918.png" srcset="/img/loading.gif" lazyload="" alt="图12. 实时LogJoin HBase设计"></p><p>HBase设计中包含一个Family，其他数据包括</p><p>qualifier[common]  #检索日志中所有订单共享的信息，单列</p><p>qualifier[q_soid]   #检索日志中选中订单相关信息，每个soid占1列</p><p>qualifier[v_soid]   #曝光日志，每个曝光（soid）单独1列</p><p>qualifier[c_soid]   #点击日志，每个点击（soid）单独1列</p><p>LogJoin遇到的一个挑战是同一个用户的一次完整的广告session所产生的请求、曝光、点击数据是乱序上报的。对于用户的一次完整广告，理论上是按照先有请求，接着是曝光，最后是点击的顺序上报，但现实环境中，由于请求、曝光、点击日志数据在不同的服务器上产生，每台服务器的负载不同导致数据上报的速度不一致，这就造成LogJoin的JStorm程序会乱序接收到请求、曝光、点击数据，如图13所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150506771.png" srcset="/img/loading.gif" lazyload="" alt="图13. 检索曝光点击乱序上报"></p><p>针对这种现象，LogJoin采用HBase行级锁并以CheckAndPut方式写入来保证数据的原子性。</p><h3 id="LogJoin-JStorm核心设计"><a href="#LogJoin-JStorm核心设计" class="headerlink" title="LogJoin JStorm核心设计"></a><strong>LogJoin JStorm核心设计</strong></h3><p>LogJoin的核心处理逻辑在JStorm中实现，核心设计如图14所示，设计要点：</p><p>1）流量隔离：按流量分为检索，曝光，点击等Spout，方便task数调整。</p><p>2）多线程&amp;批处理：提升并发度，减少网络IO，提升吞吐量batch_num设为50，性能提升5倍。</p><p>3）多级重试队列：提升点击join的时效性</p><p>4）在线升级：落地字段增减，分拣规则调整等在线升级</p><p>5）优雅重启：发送停止消费命令，先停止tube消费，再停止应用。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150532231.png" srcset="/img/loading.gif" lazyload="" alt="图14. LogJoin JStorm核心设计"></p><h3 id="LogJoin-HBase核心设计"><a href="#LogJoin-HBase核心设计" class="headerlink" title="LogJoin HBase核心设计"></a><strong>LogJoin HBase核心设计</strong></h3><p>LogJoin中HBase设计要点是保证高吞吐与稳定性。HBase高吞吐与稳定性的保证主要通过RowKey的合理设计来防热点。LogJoin中HBase的RowKey长度设计固定为16字节，包括1字节前缀、2字节时间、13字节request_id，如图15所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150615727.png" srcset="/img/loading.gif" lazyload="" alt="图15. Rowkey设计"></p><p>唯一键为广告投放体系生成的的request_id，request_id的生成规则如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150644744.png" srcset="/img/loading.gif" lazyload="" alt="图16. request_id设计"></p><p>离线数据统计分析发现request_id不够散列，容易造成访问热点，需要增加散列前缀，因此RowKey中增加了1个字节长度的前缀，前缀计算方法为:</p><p>(byte)Math.abs(hashCode(request_id)%256)</p><p>RowKey中增加2字节的时间是为了实现基于时间局部性的IO优化。分析数据发现98%以上的Join动作可以在1分钟内完成，具有很强的时间相关性，BlockCache读缓存命中率低导致频繁访问HFile，造成IO利用率过高。对此的改进思路是尽可能的把相同时间的记录写到HFile中相邻的数据块(HBlock),从而提升 BlockCache缓存命中率。因此在RowKey中增加了时间信息，两个字节(小时,分钟)。效果是单机IO利用率从50%下降到20%以下。</p><p>针对HBase，LogJoin还做了一系列的优化，这些优化包括：预分区，避免region split带来集群访问毛刺;BlockCache优化提升读效率;启用压缩算法:节省存储空间;MajorCompaction优化: 禁用，夜间流量低时，定时手工触发。</p><p>截止目前，LogJoin系统运行指标：</p><p>1）高吞吐：日均接入60亿检索，16亿曝光，峰值QPS 20w/s</p><p>2）低延迟：数据秒级延迟，延迟（处理时间-数据时间）超过30s的比例&lt;0.16%, 超过60s的比例&lt;0.11%</p><p>3）Join成功率高：曝光join检索的成功率&gt;99.4%;点击join曝光和检索的成功率&gt;99%</p><p>4）业务效果: 实时CTR预估提升2%；点击过滤系统中可以将点击关联到的曝光、检索相关的信息作为过滤依据。</p><h2 id="3-数据服务"><a href="#3-数据服务" class="headerlink" title="3 数据服务"></a><strong>3 数据服务</strong></h2><hr><p>数据平台的数据服务可以分成在线数据服务和离线数据服务两大类。在线数据服务包括为实时CTR预估提供数据的LogJoin数据流、实时播控、点击过滤、计费，如图17所示。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150717487.png" srcset="/img/loading.gif" lazyload="" alt="图17. 在线数据服务"></p><p>离线数据服务主要包括广告效果分析平台(Measurement)、广告运营分析平台(灯塔)以及自助查询OLAP系统 (盖亚 &amp; Walrus)、各个业务系统所需的广告执行数据的推送服务(涉及公司20+个部分，100+团队)。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150744034.png" srcset="/img/loading.gif" lazyload="" alt="图18. 离线数据服务"></p><h3 id="3-1-数据建模"><a href="#3-1-数据建模" class="headerlink" title="3.1 数据建模"></a><strong>3.1 数据建模</strong></h3><hr><p>离线数据服务的核心是数据的建模以及基于建模的异构数据的OLAP查询。</p><p>数据建模的目标是基于业务视角，将原始的广告日志数据转化成业务所需的数据模型以便于业务侧的高效查询，这个过程中做的主要工作是维度的聚合、指标的计算。数据平台的数据模型包括实时模型和离线模型两个部分。</p><p>实时模型通过接入实时ETL的结果数据利用Spark-streaming或Storm进行窗口聚合提供40+维度的广告曝光点击数据的实时查询(数据延迟在分钟级)。</p><p>离线模型主要通过Spark或Hadoop任务基于任务DAG生成数据模型，数据平台现有模型21个，每个模型可查询维度40~250个，时间跨度为最近2年。</p><h3 id="3-2-数据查询"><a href="#3-2-数据查询" class="headerlink" title="3.2 数据查询"></a><strong>3.2 数据查询</strong></h3><hr><p>数据平台的数据查询服务主要包括两大类：</p><p>1）通用型的多维聚合类查询，如库存计算、频次计算</p><p>2）广告明细提取，人群包提取</p><p>数据查询的挑战在于：</p><p>1）数据量大（PB级别）、纬度多（单表200+纬）</p><p>2）查询时间跨度大、聚合纬度多</p><p>3）数据准确性高（不允许非精确值）</p><p>4）查询性能要求高</p><p>随着业务的不停增长，数据平台的查询引擎从也进行了一系列的升级</p><p>1）第1代：以开源Infobright为基础的查询引擎</p><p>2）第2代：以PIG为主要计算引擎的查询引擎(查询耗时小时级)</p><p>3）第3代：Rocket AdHoc查询引擎(查询耗时秒级)</p><p>4）第4代：当前的lambda架构查询引擎。</p><h4 id="第1代查询引擎"><a href="#第1代查询引擎" class="headerlink" title="第1代查询引擎"></a><strong>第1代查询引擎</strong></h4><p>Infobright是开源的MySQL数据仓库解决方案，它将列存储、高强度的数据压缩、优化的统计计算引入到了MySQL中，对于处理亿级规模以下的数据具有较好的性能，但无法支持百亿级、千亿级数据的查询。随着业务的发展，数据平台需要查询的数据规模达到了万亿级，Infobright因为其有限的吞吐量已不能满足业务需求。</p><h4 id="第2代查询引擎"><a href="#第2代查询引擎" class="headerlink" title="第2代查询引擎"></a><strong>第2代查询引擎</strong></h4><p>为了处理万亿级规模的数据，Pig被引入到了查询引擎中。Pig本质上是Map Reduce ON HDFS，由Yahoo在2006年开始开发，在2010成为Apache顶级项目。Pig是MapReduce的一个抽象，它提供了一种称为Pig Latin的高级语言来编写数据处理脚本。所有这些脚本都在Pig内部的Pig Engine组件转换为Map和Reduce任务。</p><p>Pig提供了丰富的运算符集如join，sort，filer等来操作数据;Pig内部也会对Pig脚本进行优化，开发人员只需要关注语言的语义而不需要过度关注底层Map Reduce实现;Pig提供UDF(用户定义函数)的功能,开发人员可以通过其他编程语言（如Java、Python）创建UDF的功能，并且可以调用或嵌入到Pig脚本中。</p><p>和其他基于Map Reduce的批处理工具类似，基于Pig的数据处理也是典型的IO密集型计算，其效率相对低下。对于例行化的批处理任务，Pig由于其支持大吞吐量的特性是一个不错的选择，但对于面向用户的查询引擎，Pig效率的低下(用户查询耗时在小时级)，越来越不能满足业务需求。</p><h4 id="第3代查询引擎"><a href="#第3代查询引擎" class="headerlink" title="第3代查询引擎"></a><strong>第3代查询引擎</strong></h4><p>为了解决基于Pig的查询引擎查询性能低下的缺陷，Rocket查询引擎应运而生，其架构如图19所示。Rocket查询引擎是SparkSQL和Paruqet存储格式的结合。数据平台查询引擎的业务特点是计算多个维度聚合下的指标，计算引擎的查询压力集中在reduce端，极易发生数据倾和大规模shuffle的触发。因此Rocket采用了大宽表结构的数据模型。通过合理的数据预处理和Parquet列式存储的选择，Rocket查询引擎将用户查询的时间开销降低到了秒级。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150805588.png" srcset="/img/loading.gif" lazyload="" alt="图19. Rocket查询引擎架构图"></p><p>Rocket查询引擎的数据预处理包括：</p><p>1）大宽表构建：预先join所有常用维度;</p><p>2）String转Int：更高的数据压缩比、更好的查询性能；</p><p>3）行转列：高效数据压缩。</p><p>Rocket查询引擎的数据组织：</p><p>1）多分区方式：按全量、年、月分区，各分区独立schema、独立中间表。</p><p>2）多版本管理：读写分离</p><p>3）视图模型：多模型联合查询</p><p>4）广播模型： 小表预先broadcast</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150831504.png" srcset="/img/loading.gif" lazyload="" alt="图20. Rocket查询引擎数据组织方式"></p><h4 id="第4代查询引擎"><a href="#第4代查询引擎" class="headerlink" title="第4代查询引擎"></a><strong>第4代查询引擎</strong></h4><p>数据平台当前的查询引擎采用了lambda架构的经典设计，相比于之前3代查询引擎只支持离线数据的查询，当前lambda架构引入了实时数据的查询。</p><p>Lambda 架构由Storm的作者NathanMarz提出，其设计目的在于提供一个能满足大数据系统关键特性的架构，包括高容错、低延迟、可扩展等。其整合离线计算与实时计算，融合不可变性、读写分离和复杂性隔离等原则，可集成Hadoop, Kafka, Spark，Storm等各类大数据组件。Lambda 架构可分解为三层Layer，即Batch Layer, Real-Time(Speed) Layer和ServingLayer。其中Batch Layer用于离线数据的处理和查询，Speed Layer用于实时数据的处理和查询，Serving Layer用于合并离线数据的查询结果和实时数据的查询结果作为最终的数据结果集。</p><p>当前查询引擎lambda架构如图21所示，该设计架构支持万级别数据的查询能力，支持任意纬度的聚合、明细提取，95%的任务查询时间开销在秒级。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122150900580.png" srcset="/img/loading.gif" lazyload="" alt="图21. 查询引擎Lambda 架构设计"></p><p>在接口层，当前架构支持两种类型的接口，包括HTTP接口和类SQL查询，{模型名，时间范围，筛选条件，聚合维度，指标} 五元素定义一个查询。在视图层，当前架构屏蔽了底层异构计算引擎；屏蔽模型中实体表与维度表的关联关系，对外以大宽表形式，降低使用门槛。在计算层，当前架构整体构建在spark on yarn之上。</p><p>当前查询引擎的运营指标数据：</p><p>1)当前对外开放查询数据总量：1.5P</p><p>2)当前对方开放查询数据维度：250+</p><p>3)日均查询读取数据量：500T</p><p>4)近半年数据推送及查询涉及团队：28个部门、112个团队</p><p>5)曝光收入类查询中位数耗时15s</p><p>本文从数据接入、数据处理、数据应用三个层面剖析了大数据平台的架构设计，鉴于篇幅的限制，本文无法对数据平台中的每一个模块进行细致而全面的介绍，之后我们将通过开辟新的文章的方式对上文中提到的核心系统进行全面的分享。除了上文中提到的应用和服务之外，数据平台还负责着统一缓存服务(提供用户的基础属性等的查询)、TencentAdId服务、Poseidon海量标签检索服务等相对独立的数据服务，后面我们也将对此进行分享。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯广告大数据架构&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据平台" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>十种常见的排序算法</title>
    <link href="http://example.com/2021/11/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2021/11/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2021-11-21T12:29:01.000Z</published>
    <updated>2021-11-24T09:35:42.147Z</updated>
    
    <content type="html"><![CDATA[<p>常见的排序算法</p><a id="more"></a><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><blockquote><p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</p></blockquote><div class="hljs code-wrapper"><pre class="mermaid">flowchart LR    P[排序算法] --&gt; A(非线性时间比较类排序)    P --&gt; B(线性时间非比较类排序)    A --&gt; A1(交换排序)    A1 --&gt; A11(冒泡排序)    A1 --&gt; A12(快速排序)    A --&gt; A2(插入排序)    A2 --&gt; A21(简单插入排序)    A2 --&gt; A22(希尔排序)    A --&gt; A3(选择排序)    A3 --&gt; A31(简单选择排序)    A3 --&gt; A32(堆插入排序)    A --&gt; A4(归并排序)    B --&gt; B1(基排序)    B --&gt; B2(桶排序)    B --&gt; B3(基数排序)</pre></div><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><table><thead><tr><th>排序算法</th><th>时间复杂度（平均）</th><th>时间复杂度（最好）</th><th>时间复杂度（最坏）</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>插入排序</td><td>$O(n^2)$</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>稳定</td></tr><tr><td>希尔排序</td><td>$O(n \log  n)$</td><td>$O(n \log n)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>归并排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n)$</td><td>稳定</td></tr><tr><td>快速排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n^2)$</td><td>$O(\log n)$</td><td>不稳定</td></tr><tr><td>堆排序</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(n \log n)$</td><td>$O(1)$</td><td>不稳定</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(k)$</td><td>稳定</td></tr><tr><td>桶排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n^2)$</td><td>$O(n+k)$</td><td>稳定</td></tr><tr><td>基数排序</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n \times k)$</td><td>$O(n+k)$</td><td>稳定</td></tr></tbody></table><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s/ZLjGz2Tci3a-2Mj152Oosg" target="_blank" rel="noopener">十大经典排序算法</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的排序算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>《Java核心技术 卷I》阅读笔记</title>
    <link href="http://example.com/2021/11/20/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7I%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/11/20/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7I%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-20T14:47:44.000Z</published>
    <updated>2021-11-24T08:00:53.539Z</updated>
    
    <content type="html"><![CDATA[<p>仅阅读了Java基础部分，完结撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em></p><a id="more"></a><h2 id="第1章-Java程序设计概述"><a href="#第1章-Java程序设计概述" class="headerlink" title="第1章 Java程序设计概述"></a>第1章 Java程序设计概述</h2><h3 id="1-1-Java程序设计平台"><a href="#1-1-Java程序设计平台" class="headerlink" title="1.1 Java程序设计平台"></a>1.1 Java程序设计平台</h3><p>Java是一个完整的平台，提供了可移植性、垃圾回收、庞大的库、网络连接以及数据块存取等功能。</p><h3 id="1-2-Java“白皮书”的关键术语"><a href="#1-2-Java“白皮书”的关键术语" class="headerlink" title="1.2 Java“白皮书”的关键术语"></a>1.2 Java“白皮书”的关键术语</h3><p>关键术语：</p><p>1）简单性</p><p>2）面向对象</p><p>3）分布式</p><p>4）健壮性</p><p>5）安全性</p><p>6）体系结构中立</p><p>7）可移植性</p><p>8）解释型</p><p>9）高性能</p><p>10）多线程</p><p>11）动态性</p><h2 id="第2章-Java程序设计环境"><a href="#第2章-Java程序设计环境" class="headerlink" title="第2章 Java程序设计环境"></a>第2章 Java程序设计环境</h2><p>下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads" target="_blank" rel="noopener">www.oracle.com/technetwork/java/javase/downloads</a></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118140650.png" srcset="/img/loading.gif" lazyload="" alt="表2-1 Java术语"></p><p>接下来，Java SE会大量出现，相对于Java EE（Enterprise Edition）和Java ME（Micro Edition），它是Java的标准版。</p><h2 id="第3章-Java的基本程序设计结构"><a href="#第3章-Java的基本程序设计结构" class="headerlink" title="第3章 Java的基本程序设计结构"></a>第3章 Java的基本程序设计结构</h2><h3 id="3-1-一个简单的Java应用程序"><a href="#3-1-一个简单的Java应用程序" class="headerlink" title="3.1 一个简单的Java应用程序"></a>3.1 一个简单的Java应用程序</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstSample</span> </span>{    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><span class="hljs-function">    </span>{        System.out.println(<span class="hljs-string">"Hello World"</span>);    }}</code></pre></div><p>关键字<strong>public</strong>称为访问修饰符（accessmodifier），这些修饰符用于控制程序的其他部分对这段代码的访问级别。</p><p>关键字<strong>class</strong>表明Java程序中的全部内容都包含在类中，class后面是类名（文件名跟公共类名必须相同，即这个文件为<code>FirstSample.java</code>），此外<strong>Java区分大小写</strong></p><p>static void声明这个主程序的类型（Java的main方法必须是静态的，void也表示没有返回值），Java SE7 及之后的版本<strong>每个java程序都必须有一个main方法</strong></p><h3 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h3><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 单行注释</span><span class="hljs-comment">/*</span><span class="hljs-comment">多行注释</span><span class="hljs-comment">多行注释</span><span class="hljs-comment">*/</span></code></pre></div><h3 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h3><table><thead><tr><th>类型</th><th>存储占用</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>-2147483648 ~ 2147483647</td></tr><tr><td>short</td><td>2字节</td><td>-32768 ~ 32767</td></tr><tr><td>long</td><td>8字节</td><td></td></tr><tr><td>byte</td><td>1字节</td><td>-128 ~ 127</td></tr><tr><td>float</td><td>4字节</td><td></td></tr><tr><td>double</td><td>8字节</td><td></td></tr><tr><td>char</td><td></td><td>false 或 true</td></tr><tr><td>boolean</td><td></td><td></td></tr></tbody></table><h3 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4 变量"></a>3.4 变量</h3><ul><li>变量声明</li></ul><p>变量声明示例：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span> salary;<span class="hljs-comment">//注意：需要以分号结尾</span><span class="hljs-keyword">int</span> vacationDats;<span class="hljs-keyword">int</span> i,j;<span class="hljs-comment">//一行声明多个变量（不提倡）</span></code></pre></div><p>变量名必须是一个以字母开头并由字母或数字构成的序列</p><ul><li>初始化变量</li></ul><p>声明变量之后，需要初始化这个变量，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i;i = <span class="hljs-number">1</span>;</code></pre></div><p>也可以写成：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;</code></pre></div><ul><li>常量</li></ul><p>关键字final表示这个变量只能被赋值一次（习惯上，常量名使用全大写），例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> CM_PER_INCH = <span class="hljs-number">2.54</span>;</code></pre></div><h3 id="3-5-运算符"><a href="#3-5-运算符" class="headerlink" title="3.5 运算符"></a>3.5 运算符</h3><p><strong>+</strong>   ：加</p><p><strong>-</strong>    ：减</p><p>*****    ：乘</p><p><strong>/</strong>    ：除</p><h4 id="3-5-1-数学函数与常量"><a href="#3-5-1-数学函数与常量" class="headerlink" title="3.5.1 数学函数与常量"></a>3.5.1 数学函数与常量</h4><p>计算平方根：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span> = <span class="hljs-number">4</span>;<span class="hljs-keyword">double</span> y = Math.sqrt(x);System.out.println(y);<span class="hljs-comment">//输出结果：2.0</span></code></pre></div><p>幂运算：</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> y = Math.<span class="hljs-built_in">pow</span>(x,a);<span class="hljs-comment">//x的a次幂</span></code></pre></div><p>此外Math类还提供了一些其他常用的函数：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Math.sinMath.cosmath.tanMath.expMath.logMath.log10</code></pre></div><h4 id="3-5-2-数值类型之间的转换"><a href="#3-5-2-数值类型之间的转换" class="headerlink" title="3.5.2 数值类型之间的转换"></a>3.5.2 数值类型之间的转换</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118151550.png" srcset="/img/loading.gif" lazyload="" alt="数值类型之间的合法转换"></p><p>实心箭头：表示无信息丢失的转换；</p><p>虚箭头：表示可能有精度损失的转换。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118151836.png" srcset="/img/loading.gif" lazyload="" alt=" int型转成 float型会丢失一定精度"></p><blockquote><p>当使用上面两个数值进行二元操作时（例如n + f, n是整数，f是浮点数），先要将两个操作数转换为同一种类型，然后再进行计算。</p><ul><li>如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。</li><li>否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。</li><li>否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。</li><li>否则，两个操作数都将被转换为int类型。</li></ul></blockquote><h4 id="3-5-3-强制类型转换"><a href="#3-5-3-强制类型转换" class="headerlink" title="3.5.3 强制类型转换"></a>3.5.3 强制类型转换</h4><p>int型可能会转换成 double型，但是也可以把double型强制转换为 int型，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span> x = <span class="hljs-number">9.99</span>;<span class="hljs-keyword">int</span> nx = (<span class="hljs-keyword">int</span>)x;<span class="hljs-comment">//此时nx变为9</span><span class="hljs-keyword">int</span> nx = (<span class="hljs-keyword">int</span>)Math.round(x);<span class="hljs-comment">//此时nx变为10</span></code></pre></div><h4 id="3-5-4-结合赋值和运算符"><a href="#3-5-4-结合赋值和运算符" class="headerlink" title="3.5.4 结合赋值和运算符"></a>3.5.4 结合赋值和运算符</h4><p>可以在赋值中使用二元运算符来简化写法，例如</p><div class="hljs code-wrapper"><pre><code class="hljs java">x += <span class="hljs-number">4</span>;x = x + <span class="hljs-number">4</span>;<span class="hljs-comment">//上面两行语句是一样的</span></code></pre></div><h4 id="3-5-5-自增与自减运算符"><a href="#3-5-5-自增与自减运算符" class="headerlink" title="3.5.5 自增与自减运算符"></a>3.5.5 自增与自减运算符</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = <span class="hljs-number">12</span>;n++ ;<span class="hljs-comment">//n为13</span></code></pre></div><h4 id="3-5-6-关系和boolean运算符"><a href="#3-5-6-关系和boolean运算符" class="headerlink" title="3.5.6 关系和boolean运算符"></a>3.5.6 关系和boolean运算符</h4><p>3 == 7； //false<br>3 != 7； //true</p><h4 id="3-5-7-位运算符"><a href="#3-5-7-位运算符" class="headerlink" title="3.5.7 位运算符"></a>3.5.7 位运算符</h4><p><strong>&amp;</strong> ：and</p><p><strong>|</strong>   ：or</p><p><strong>^</strong>  ：xor</p><p><strong>~</strong>  ：not</p><h4 id="3-5-8-括号与运算符级别"><a href="#3-5-8-括号与运算符级别" class="headerlink" title="3.5.8 括号与运算符级别"></a>3.5.8 括号与运算符级别</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118152825.png" srcset="/img/loading.gif" lazyload="" alt="运算符优先级"></p><h4 id="3-5-9-枚举类型"><a href="#3-5-9-枚举类型" class="headerlink" title="3.5.9 枚举类型"></a>3.5.9 枚举类型</h4><p>有时候，变量的取值只在一个有限的集合内（比如衣服只有几种尺寸）。针对这种情况，可以自定义枚举类型。枚举类型包括有限个命名的值。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE};</code></pre></div><p>现在，可以声明这种类型的变量：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Size s = Size.MEDIUM;</code></pre></div><p>Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者null值，null表示这个变量没有设置任何值。</p><h3 id="3-6-字符串"><a href="#3-6-字符串" class="headerlink" title="3.6 字符串"></a>3.6 字符串</h3><h4 id="3-6-1-子串"><a href="#3-6-1-子串" class="headerlink" title="3.6.1 子串"></a>3.6.1 子串</h4><p>String类的substring方法可以从一个较大的字符串提取出一个子串。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">"Hello"</span>;String s = s.substring(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//s是"Hel"</span></code></pre></div><p><code>s.substring(a, b)</code>表示字符串 s 取 a到 b，其字符长度为 b - a </p><h4 id="3-6-2-拼接"><a href="#3-6-2-拼接" class="headerlink" title="3.6.2 拼接"></a>3.6.2 拼接</h4><p>Java允许使用+号连接（拼接）两个字符串，例如</p><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">"Em"</span>;String b = <span class="hljs-string">"mmm"</span>;String c = a + b;</code></pre></div><h4 id="3-6-3-不可变字符串"><a href="#3-6-3-不可变字符串" class="headerlink" title="3.6.3 不可变字符串"></a>3.6.3 不可变字符串</h4><p>字符串的部分内容不可修改，比如”Hello”不能直接修改为”Help! “，但是可以通过拼接实现，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">"Hello"</span>String a = a.substring(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) + <span class="hljs-string">"p!"</span></code></pre></div><h4 id="3-6-4-检测字符串是否相等"><a href="#3-6-4-检测字符串是否相等" class="headerlink" title="3.6.4 检测字符串是否相等"></a>3.6.4 检测字符串是否相等</h4><p>可以使用equals方法检测两个字符串是否相等。对于表达式：</p><div class="hljs code-wrapper"><pre><code class="hljs java">s = <span class="hljs-string">"Hello"</span>t = <span class="hljs-string">"World"</span>s.equals(t)</code></pre></div><p>如果字符串s与字符串t相等，则返回true；否则，返回false。</p><p>上述也可以写成：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-string">"Hello"</span>.equals(<span class="hljs-string">"World"</span>)</code></pre></div><h4 id="3-6-5-空串与Null串"><a href="#3-6-5-空串与Null串" class="headerlink" title="3.6.5 空串与Null串"></a>3.6.5 空串与Null串</h4><p>空串是长度为0的字符串，检验：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(str.length()==<span class="hljs-number">0</span>)<span class="hljs-comment">//或</span><span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">""</span>))</code></pre></div><p>空串是一个Java对象，有自己的串长度（0）和内容（空）。而 <strong>null</strong> 表示目前没有任何对象与该变量关联，用以下语句判断：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(str == <span class="hljs-keyword">null</span>)</code></pre></div><p>检查一个字符串既不是null也不为空串：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(str.length() !=<span class="hljs-number">0</span>) &amp;&amp; str != <span class="hljs-keyword">null</span>)</code></pre></div><p>（因为显示问题，代码框中的 != 变成了<code>!=</code>，记住实际上是写<strong>!=</strong> ）</p><h4 id="3-6-6-码点与代码单元"><a href="#3-6-6-码点与代码单元" class="headerlink" title="3.6.6 码点与代码单元"></a>3.6.6 码点与代码单元</h4><div class="hljs code-wrapper"><pre><code class="hljs java">String a = <span class="hljs-string">"Hello"</span>;<span class="hljs-keyword">int</span> n = a.length(); <span class="hljs-comment">// n = 5</span><span class="hljs-keyword">char</span> b = a.charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">// b = "H"</span></code></pre></div><h3 id="3-7-输入输出"><a href="#3-7-输入输出" class="headerlink" title="3.7 输入输出"></a>3.7 输入输出</h3><h4 id="3-7-1-读取输入"><a href="#3-7-1-读取输入" class="headerlink" title="3.7.1 读取输入"></a>3.7.1 读取输入</h4><p>要想通过控制台进行输入，首先需要构造一个Scanner对象，并与“标准输入流”System.in关联</p><div class="hljs code-wrapper"><pre><code class="hljs java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);</code></pre></div><p>现在，就可以使用Scanner类的各种方法实现输入操作了。例如，nextLine方法将输入一行</p><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-string">"What is your name?"</span>);String name = in.nextLine();</code></pre></div><p>在这里，使用nextLine方法是因为在输入行中有可能包含空格。要想读取一个单词（以空白符作为分隔符），就调用</p><div class="hljs code-wrapper"><pre><code class="hljs java">String firstName = in.next();<span class="hljs-keyword">int</span> age = in.nextInt();<span class="hljs-comment">//读取整数</span></code></pre></div><h4 id="3-7-2-格式化输出"><a href="#3-7-2-格式化输出" class="headerlink" title="3.7.2 格式化输出"></a>3.7.2 格式化输出</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span> x = <span class="hljs-number">10000.00</span>/<span class="hljs-number">3.0</span>;System.out.print(x);<span class="hljs-comment">//输出3333.3333333333335</span>System.out.printf(<span class="hljs-string">"%8.2f"</span>,x);<span class="hljs-comment">//表示8个字符的宽度和小数点后两位，输出3333.33</span>System.out.printf(<span class="hljs-string">"%.2f"</span>,<span class="hljs-number">10000.00</span>/<span class="hljs-number">3.0</span>);<span class="hljs-comment">//输出3,333.33</span>System.out.printf(<span class="hljs-string">"%tc"</span>,<span class="hljs-keyword">new</span> Date());<span class="hljs-comment">//打印当前日期和时间</span></code></pre></div><h4 id="3-7-3-文件输入与输出"><a href="#3-7-3-文件输入与输出" class="headerlink" title="3.7.3 文件输入与输出"></a>3.7.3 文件输入与输出</h4><div class="hljs code-wrapper"><pre><code class="hljs java">Scanner in = <span class="hljs-keyword">new</span> Scanner(Paths.get(<span class="hljs-string">"myfile.txt"</span>),<span class="hljs-string">"UTF-8"</span>);</code></pre></div><h3 id="3-8-控制流程"><a href="#3-8-控制流程" class="headerlink" title="3.8 控制流程"></a>3.8 控制流程</h3><h4 id="3-8-1-块作用域"><a href="#3-8-1-块作用域" class="headerlink" title="3.8.1 块作用域"></a>3.8.1 块作用域</h4><p>块（block）是指由一对大括号括起来的若干条简单的Java语句，块确定了变量的作用域</p><h4 id="3-8-2-条件语句"><a href="#3-8-2-条件语句" class="headerlink" title="3.8.2 条件语句"></a>3.8.2 条件语句</h4><p>条件语句格式：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(condition) statement<span class="hljs-comment">//或</span><span class="hljs-keyword">if</span>(condition) statement <span class="hljs-keyword">else</span> statement</code></pre></div><p>例如：</p><ul><li>case1</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(yourSales &gt; target){performance = <span class="hljs-string">"Satisfactory"</span>;bonus = <span class="hljs-number">100</span>;}</code></pre></div><ul><li>case2</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(yourSales &gt; target){performance = <span class="hljs-string">"Satisfactory"</span>;bonus =<span class="hljs-number">100</span>;}<span class="hljs-keyword">else</span>{performance = <span class="hljs-string">"UnSatisfactory"</span>;bonus = <span class="hljs-number">0</span>;}</code></pre></div><h4 id="3-8-3-while循环"><a href="#3-8-3-while循环" class="headerlink" title="3.8.3 while循环"></a>3.8.3 while循环</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(condition) statement<span class="hljs-comment">//或</span><span class="hljs-function"><span class="hljs-keyword">do</span> statement <span class="hljs-title">while</span><span class="hljs-params">(condition)</span></span></code></pre></div><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">1</span>){    i = i - <span class="hljs-number">1</span>;}<span class="hljs-comment">// 或</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">do</span>{    i = i - <span class="hljs-number">1</span>;}<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">1</span>)</code></pre></div><h4 id="3-8-4-for循环"><a href="#3-8-4-for循环" class="headerlink" title="3.8.4 for循环"></a>3.8.4 for循环</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>（<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++)System.out.println(i);</code></pre></div><h4 id="3-8-5-多重选择：switch语句"><a href="#3-8-5-多重选择：switch语句" class="headerlink" title="3.8.5 多重选择：switch语句"></a>3.8.5 多重选择：switch语句</h4><div class="hljs code-wrapper"><pre><code class="hljs java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);System.out.print(<span class="hljs-string">"select an option (1,2)"</span>);<span class="hljs-keyword">int</span> choice = in.nextln();<span class="hljs-keyword">switch</span> (choice){    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:        ...        <span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        ...        <span class="hljs-keyword">break</span>;    <span class="hljs-keyword">default</span>:        ...        <span class="hljs-keyword">break</span>;}</code></pre></div><h4 id="3-8-6-中断控制流程语句"><a href="#3-8-6-中断控制流程语句" class="headerlink" title="3.8.6 中断控制流程语句"></a>3.8.6 中断控制流程语句</h4><ul><li>break：跳出该层循环（抵消掉整个for/while语句）</li><li>continue：跳过这一次循环（抵消掉for/while中的一次执行）</li></ul><h3 id="3-9-大数值"><a href="#3-9-大数值" class="headerlink" title="3.9 大数值"></a>3.9 大数值</h3><p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类：<strong>BigInteger</strong>（任意精度的整数运算）和<strong>BigDecimal</strong>（任意精度的浮点数运算）。</p><h3 id="3-10-数组"><a href="#3-10-数组" class="headerlink" title="3.10 数组"></a>3.10 数组</h3><p>声明数组（仅仅声明）：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a;<span class="hljs-comment">// 也可以写成 int a[]</span></code></pre></div><p>（书上说Java程序员喜欢写第一种，我喜欢写成第二种）</p><p>声明并初始化数组：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a =<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<span class="hljs-comment">//创建一个可以存储100个整数的数组</span></code></pre></div><h4 id="3-10-1-for-each循环"><a href="#3-10-1-for-each循环" class="headerlink" title="3.10.1 for each循环"></a>3.10.1 for each循环</h4><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> element:a)System.out.println(element);</code></pre></div><p>这个循环读作“循环a中的每一个元素”（for each element in a），当然也可以用传统的for循环代替：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; a.length; i++)System.out.println(a[i]);</code></pre></div><h4 id="3-10-2-数组初始化以及匿名数组"><a href="#3-10-2-数组初始化以及匿名数组" class="headerlink" title="3.10.2 数组初始化以及匿名数组"></a>3.10.2 数组初始化以及匿名数组</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] smallPrimes = {<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>};</code></pre></div><p>这种写法不需要new，甚至还可以初始化一个匿名数组：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {<span class="hljs-number">17</span>,<span class="hljs-number">19</span>,<span class="hljs-number">23</span>,<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">37</span>}</code></pre></div><p>（备注：匿名数组一般用在只用一次的时候）</p><h4 id="3-10-3-数组拷贝"><a href="#3-10-3-数组拷贝" class="headerlink" title="3.10.3 数组拷贝"></a>3.10.3 数组拷贝</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span> [] luckyNumbers = smallPrimes;luckyNumbers[<span class="hljs-number">5</span>] = <span class="hljs-number">12</span>;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118181002.png" srcset="/img/loading.gif" lazyload="" alt="拷贝一个数组变量"></p><p>如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的copyOf方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] luckyNumbers2 = Arrays.copyOf(luckyNumbers,luckyNumbers.length);</code></pre></div><h4 id="3-10-5-数组排序"><a href="#3-10-5-数组排序" class="headerlink" title="3.10.5 数组排序"></a>3.10.5 数组排序</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];Arrays.sort(a)</code></pre></div><h4 id="3-10-6-多维数组"><a href="#3-10-6-多维数组" class="headerlink" title="3.10.6 多维数组"></a>3.10.6 多维数组</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">double</span>[][] a;a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];</code></pre></div><p>如果知道数组元素，就可以不调用new，而直接使用简化的书写形式对多维数组进行初始化。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] magicSquare = {{<span class="hljs-number">16</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">13</span>},{<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">8</span>},{<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">12</span>},{<span class="hljs-number">4</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">1</span>}}</code></pre></div><p>（可以看出：Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组。）</p><h2 id="第4章-对象与类"><a href="#第4章-对象与类" class="headerlink" title="第4章 对象与类"></a>第4章 对象与类</h2><h3 id="4-1-面向对象程序设计概述"><a href="#4-1-面向对象程序设计概述" class="headerlink" title="4.1 面向对象程序设计概述"></a>4.1 面向对象程序设计概述</h3><ul><li>面向过程与面向对象的程序设计对比</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118191554.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><h4 id="4-1-1-类"><a href="#4-1-1-类" class="headerlink" title="4.1.1 类"></a>4.1.1 类</h4><p>由类（class）构造（construct）对象的过程称为创建类的实例（instance）</p><p>封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。</p><h4 id="4-1-2-对象"><a href="#4-1-2-对象" class="headerlink" title="4.1.2 对象"></a>4.1.2 对象</h4><p>要想使用面向对象程序设计（OOP），一定要清楚对象的三个主要特性：</p><ul><li>对象的行为（behavior）——可以对对象施加哪些操作，或可以对对象施加哪些方法？</li><li>对象的状态（state）——当施加那些方法时，对象如何响应？</li><li>对象标识（identity）——如何辨别具有相同行为与状态的不同对象？</li></ul><h4 id="4-1-3-识别类"><a href="#4-1-3-识别类" class="headerlink" title="4.1.3 识别类"></a>4.1.3 识别类</h4><p>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。例如，在订单处理系统中，有这样一些名词：</p><ul><li>商品（Item）</li><li>订单（Order）</li><li>送货地址（Shipping address）</li><li>付款（Payment）</li><li>账户（Account）</li></ul><p>这些名词很可能成为类Item、Order等</p><h4 id="4-1-4-类之间的关系"><a href="#4-1-4-类之间的关系" class="headerlink" title="4.1.4 类之间的关系"></a>4.1.4 类之间的关系</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211118194943.png" srcset="/img/loading.gif" lazyload="" alt="表达类关系的UML符号"></p><h3 id="4-2-使用预定义类"><a href="#4-2-使用预定义类" class="headerlink" title="4.2 使用预定义类"></a>4.2 使用预定义类</h3><p>在Java中，没有类就无法做任何事情</p><p>并不是所有的类都具有面些对象特征，例如Math类，在程序中可以使用Math类的方法Math.random</p><h4 id="4-2-1-对象与对象变量"><a href="#4-2-1-对象与对象变量" class="headerlink" title="4.2.1 对象与对象变量"></a>4.2.1 对象与对象变量</h4><p>在Java程序设计语言中，使用构造器（constructor）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。</p><p>在标准Java库中包含一个Date类。它的对象将描述一个时间点，例如：“December 31, 1999, 23:59:59GMT”。</p><p>构造器的名字应该与类名相同。因此Date类的构造器名为Date。要想构造一个Date对象，需要在构造器前面加上new操作符，如下所示：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Date()</code></pre></div><p>这个表达式构造了一个新对象。这个对象被初始化为当前的日期和时间。</p><p>如果需要的话，也可以将这个对象传递给一个方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(<span class="hljs-keyword">new</span> Date())</code></pre></div><p>Date类中有一个toString方法。这个方法将返回日期的字符串描述：</p><div class="hljs code-wrapper"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> Date().toString</code></pre></div><h4 id="4-2-2-Java类库中的LocalDate类"><a href="#4-2-2-Java类库中的LocalDate类" class="headerlink" title="4.2.2 Java类库中的LocalDate类"></a>4.2.2 Java类库中的LocalDate类</h4><p>不要使用构造器来构造LocalDate类的对象。实际上，应当使用静态工厂方法（factory method）代表你调用构造器。下面的表达式：</p><div class="hljs code-wrapper"><pre><code class="hljs java">LocalDate.now()</code></pre></div><p>会构造一个新对象，表示构造这个对象时的日期。</p><p>可以提供年、月和日来构造对应一个特定日期的对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java">LocalDate.of(<span class="hljs-number">1999</span>,<span class="hljs-number">12</span>,<span class="hljs-number">31</span>)</code></pre></div><h4 id="4-2-3-更改器方法与访问器方法"><a href="#4-2-3-更改器方法与访问器方法" class="headerlink" title="4.2.3 更改器方法与访问器方法"></a>4.2.3 更改器方法与访问器方法</h4><div class="hljs code-wrapper"><pre><code class="hljs java">LocalDate aThousandDaysLater = newYearsEve.plusDays(<span class="hljs-number">1000</span>);</code></pre></div><p>newYearsEve日期没变化，aThousandDaysLater是newYearsEve的1000天之后</p><h3 id="4-3-用户自定义类"><a href="#4-3-用户自定义类" class="headerlink" title="4.3 用户自定义类"></a>4.3 用户自定义类</h3><h4 id="4-3-1-Employee类"><a href="#4-3-1-Employee类" class="headerlink" title="4.3.1 Employee类"></a>4.3.1 Employee类</h4><p>在Java中，最简单的类定义形式为：</p><div class="hljs code-wrapper"><pre><code class="hljs java">calss ClassName{    field_1    field_2    ...    constructor_1    constructor_2    ...    method_1    method_2}</code></pre></div><p>下面看一个非常简单的Employee类（在编写薪金管理系统时可能会用到）：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Class Employee{    <span class="hljs-comment">// instance fields（所有的实例域）</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> LocalDate hireDay;        <span class="hljs-comment">// constructor（构造器）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span><span class="hljs-function">    </span>{        name = n;        salary = s;        hireDay = LocalDate.of(year, month, day);    }        <span class="hljs-comment">// a method（方法）</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> name;    }        <span class="hljs-comment">// more methods</span>    <span class="hljs-comment">// ...</span>}</code></pre></div><h4 id="4-3-2-多个源文件的使用"><a href="#4-3-2-多个源文件的使用" class="headerlink" title="4.3.2 多个源文件的使用"></a>4.3.2 多个源文件的使用</h4><p>如果有多个.java文件，编译其中一个使用了另一个时会自动跨文件查找另一个类</p><h4 id="4-3-3-剖析Employee类"><a href="#4-3-3-剖析Employee类" class="headerlink" title="4.3.3 剖析Employee类"></a>4.3.3 剖析Employee类</h4><p>从Employee类开始，通过查看源码会发现这个类包含了1个<strong>构造器</strong>和4个<strong>方法</strong>：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title">getHireDay</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> byPercent)</span></span></code></pre></div><p>这个类的所有方法都被标记为public，关键字<strong>public</strong>意味着任何类的<strong>任何方法都可以调用这个方法</strong>（共有4种访问级别）</p><p>接下来，需要注意在Employee类的实例中有三个实例域用来存放将要操作的数据：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title">getHireDay</span><span class="hljs-params">()</span></span></code></pre></div><blockquote><p>注释：</p><p>可以用public标记实例域，但这是一种极为不提倡的做法。public数据域允许程序中的任何方法对其进行读取和修改。这就完全破坏了封装。任何类的任何方法都可以修改public域，某些代码将使用这种存取权限，这样并不合适。</p><p>因此，这里强烈建议将实例域标记为private。最后，请注意，有两个实例域本身就是对象：name域是String类对象，hireDay域是LocalDate类对象。这种情形十分常见：类通常包括类型属于某个类类型的实例域。</p><p>最后，请注意，有两个实例域本身就是对象：name域是String类对象，hireDay域是LocalDate类对象。这种情形十分常见：类通常包括类型属于某个类类型的实例域。</p></blockquote><h4 id="4-3-4-从构造器开始"><a href="#4-3-4-从构造器开始" class="headerlink" title="4.3.4 从构造器开始"></a>4.3.4 从构造器开始</h4><p>下面来看看Employee类的构造器：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span><span class="hljs-function"></span>{    name = n;    salary = s;    hireDay = LocalDate.of(year,month,day)}</code></pre></div><p>可以看到，构造器与类同名。在构造Employee类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 例如，当使用下面这条代码创建Employee类实例时：</span><span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"James Bond"</span>,<span class="hljs-number">100000</span>,<span class="hljs-number">1950</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<span class="hljs-comment">// 将会把实例域设置为：</span>name = <span class="hljs-string">"James Bond"</span>;salary = <span class="hljs-number">100000</span>;hireDay = LocalDate.of(<span class="hljs-number">1950</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// January 1,1950</span></code></pre></div><p>构造器与其他的方法有一个重要的不同。构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。例如以下操作会产生<code>编译错误</code>：</p><div class="hljs code-wrapper"><pre><code class="hljs java">james.Employee(<span class="hljs-string">"James Bond"</span>,<span class="hljs-number">100000</span>,<span class="hljs-number">1950</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</code></pre></div><p>（即构造器只能 new一个对象，而不能对已经存在的这个<code>james</code>对象重新设置数据）</p><blockquote><p>构造器的特点：</p><ul><li>构造器与类同名</li><li>每个类可以有一个以上的构造器</li><li>构造器可以有0个、1个或多个参数</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作一起调用</li></ul></blockquote><p>警告：请注意，不要在构造器中<strong>定义</strong>与实例域重名的局部变量。例如，下面的构造器将无法设置name和salary：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s ...)</span></span><span class="hljs-function"></span>{    String name = n;<span class="hljs-comment">//Error</span>    <span class="hljs-keyword">double</span> salary = s;<span class="hljs-comment">//Error</span>...}</code></pre></div><p>注意：上面的name、salary前面不应该写String、double（注意在所有的方法中不要命名与实例域同名的变量）</p><h4 id="4-3-5-隐式参数与显式参数"><a href="#4-3-5-隐式参数与显式参数" class="headerlink" title="4.3.5 隐式参数与显式参数"></a>4.3.5 隐式参数与显式参数</h4><p>方法用于操作对象以及存取它们的实例域。例如，方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> byPercent)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">double</span> raise = salary * byPercent / <span class="hljs-number">100</span>;    salary += raise;<span class="hljs-comment">//也可以写成 this.salary += raise;</span>}</code></pre></div><p>将调用这个方法的对象的salary实例域设置为新值：</p><div class="hljs code-wrapper"><pre><code class="hljs java">number007.raiseSalary(<span class="hljs-number">5</span>);</code></pre></div><p>它的结果将number007.salary域的值增加5%</p><p>raiseSalary方法有两个参数。第一个参数称为隐式（implicit）参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面括号中的数值，这是一个显式（explicit）参数。在raiseSalary方法中，隐式参数是salary，显式参数是byPercent。</p><h4 id="4-3-6-封装的优点"><a href="#4-3-6-封装的优点" class="headerlink" title="4.3.6 封装的优点"></a>4.3.6 封装的优点</h4><p>有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：</p><ul><li>一个私有的数据域；（实例域private）</li><li>一个公有的域访问器方法；（方法public）</li><li>一个公有的域更改器方法。（构造器）</li></ul><p>这样做要比提供一个简单的公有数据域复杂些，但是却有着下列明显的好处：</p><p>首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。</p><p>警告：注意不要编写返回引用可变对象的访问器方法。在Employee类中就违反了这个设计原则，其中的getHireDay方法返回了一个Date类对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-function"><span class="hljs-keyword">private</span> Date <span class="hljs-title">getHireDay</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">return</span> hireDay;<span class="hljs-comment">//bad</span>    }}</code></pre></div><h4 id="4-3-7基于类的访问权限"><a href="#4-3-7基于类的访问权限" class="headerlink" title="4.3.7基于类的访问权限"></a>4.3.7基于类的访问权限</h4><p>方法可以访问所调用对象的私有数据，此外一个方法可以访问所属类的所有对象的私有数据。</p><h4 id="4-3-8-私有方法"><a href="#4-3-8-私有方法" class="headerlink" title="4.3.8 私有方法"></a>4.3.8 私有方法</h4><p>在实现一个类时，由于公有数据非常危险，所以应该将所有的数据域都设置为私有的。</p><p>在Java中，为了实现一个私有的方法，只需将关键字public改为private即可。</p><h4 id="4-3-9-final实例域"><a href="#4-3-9-final实例域" class="headerlink" title="4.3.9 final实例域"></a>4.3.9 final实例域</h4><p>final声明的实例域在被构造器执行之后无法再修改</p><p>例如，Employee类中的name域声明为final，因为咋对象构建之后这个值不会再被修改，即没有setName方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java">calss Employee{<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    ...}</code></pre></div><p>final修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域</p><p>（如果类中的每个方法都不会改变其对象，这种类就是不可变的类。例如，String类就是一个不可变的类）</p><h3 id="4-4-静态域与静态方法"><a href="#4-4-静态域与静态方法" class="headerlink" title="4.4 静态域与静态方法"></a>4.4 静态域与静态方法</h3><h4 id="4-4-1-静态域"><a href="#4-4-1-静态域" class="headerlink" title="4.4.1 静态域"></a>4.4.1 静态域</h4><p>如果将域定义为static，每个类中只有一个这样的域。</p><p>例如，假定需要给每一个雇员赋予唯一的标识码。这里给Employee类添加一个实例域id和一个静态域nextId：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextId = <span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;...}</code></pre></div><p>每一个雇员对象都有一个自己的id域（多个id），但这个类的所有实例将共享一个nextId域（一个静态数据域）。</p><p>（即使没有一个雇员对象，静态域nextId也存在。它属于类，而不属于任何独立的对象。）</p><h4 id="4-4-2-静态常量"><a href="#4-4-2-静态常量" class="headerlink" title="4.4.2 静态常量"></a>4.4.2 静态常量</h4><p>静态变量使用得比较少，但静态常量却使用得比较多。例如，在Math类中定义了一个静态常量</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> calss Math{...<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-number">3.14159265358979323846</span>;...}</code></pre></div><h4 id="4-4-3-静态方法"><a href="#4-4-3-静态方法" class="headerlink" title="4.4.3 静态方法"></a>4.4.3 静态方法</h4><p>静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。表达式</p><div class="hljs code-wrapper"><pre><code class="hljs java">Math.pow(x,a)</code></pre></div><p>这里Math类是对象，显然没法对Math类施加操作</p><h4 id="4-4-4-工厂方法"><a href="#4-4-4-工厂方法" class="headerlink" title="4.4.4 工厂方法"></a>4.4.4 工厂方法</h4><p>类似<code>LocalDate</code>和<code>NumberFormat</code>的类使用静态工厂方法（factory method）来构造对象。</p><h4 id="4-4-5-main方法"><a href="#4-4-5-main方法" class="headerlink" title="4.4.5 main方法"></a>4.4.5 main方法</h4><p>不需要使用对象调用静态方法，例如：不需要构造Math类对象就可以调用Math.pow</p><p>每一个类都有且只有一个main方法</p><h3 id="4-6-对象构造"><a href="#4-6-对象构造" class="headerlink" title="4.6 对象构造"></a>4.6 对象构造</h3><p>象构造非常重要，所以Java提供了多种编写构造器的机制。</p><h4 id="4-6-1-重载"><a href="#4-6-1-重载" class="headerlink" title="4.6.1 重载"></a>4.6.1 重载</h4><p>如果多个方法有相同的名字、不同的参数，便产生了重载。</p><blockquote><p>Java允许重载任何方法，而不只是构造器方法</p></blockquote><h4 id="4-6-2-默认域初始化"><a href="#4-6-2-默认域初始化" class="headerlink" title="4.6.2 默认域初始化"></a>4.6.2 默认域初始化</h4><p>如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。（不提倡这样做，菜鸟才这样写）</p><p>比如Employee类，假定没有在构造器中对某些域进行初始化，就会默认地将salary域初始化为0，将name和hireDay域初始化为null。</p><h4 id="4-6-3-无参数的构造器"><a href="#4-6-3-无参数的构造器" class="headerlink" title="4.6.3 无参数的构造器"></a>4.6.3 无参数的构造器</h4><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{name = <span class="hljs-string">""</span>;salary = <span class="hljs-number">0</span>;hireDay = LocalDate.now();}</code></pre></div><p>如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。</p><h4 id="4-6-4-显式域初始化"><a href="#4-6-4-显式域初始化" class="headerlink" title="4.6.4 显式域初始化"></a>4.6.4 显式域初始化</h4><p>通过重载类的构造器方法，有很多形式可以设置类的实例域的初始状态。确保不管怎样调用构造器，每个实例域都可以被设置为一个有意义的初值，这是一种很好的设计习惯。</p><p>例如，可以在类定义中，直接将一个值赋给任何域：</p><div class="hljs code-wrapper"><pre><code class="hljs java">calss Employee{<span class="hljs-keyword">private</span> String name = <span class="hljs-string">""</span>;}</code></pre></div><h4 id="4-6-5-参数名"><a href="#4-6-5-参数名" class="headerlink" title="4.6.5 参数名"></a>4.6.5 参数名</h4><p>参数名写通俗易懂点，比如可以写成这样：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String aName, <span class="hljs-keyword">double</span> aSalary)</span><span class="hljs-comment">//如果这两个参数写成 n和 s别人就看不懂了</span></span><span class="hljs-function"></span>{name = aName;salary = aSalary;}</code></pre></div><h4 id="4-6-6-调用另一个构造器"><a href="#4-6-6-调用另一个构造器" class="headerlink" title="4.6.6 调用另一个构造器"></a>4.6.6 调用另一个构造器</h4><p><code>this</code>除了可以引用方法的隐式参数以外，还能调用同一个类的另一个构造器，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span><span class="hljs-function"></span>{<span class="hljs-comment">// 调用 Employee(String,double)</span><span class="hljs-keyword">this</span>(<span class="hljs-string">"Employee #"</span> + nextId, s);nextId++;}</code></pre></div><p>当调用new Employee(60000)时，Employee(double)构造器将调用Employee(String, double)构造器。</p><h4 id="4-6-7-初始化块"><a href="#4-6-7-初始化块" class="headerlink" title="4.6.7 初始化块"></a>4.6.7 初始化块</h4><p>前面已经讲过两种初始化数据域的方法：</p><ul><li>在构造器中设置值</li><li>在声明中赋值</li></ul><p>此外，还有第三种机制：初始化块（initialization block）</p><p>在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextId;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<span class="hljs-comment">// 初始化块</span>{id = nextId;nextId++;}<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String aName ,<span class="hljs-keyword">double</span> aSalary)</span></span><span class="hljs-function"></span>{name = aName;        salary = aSalary;}        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        name = <span class="hljs-string">""</span>;        salary = <span class="hljs-number">0</span>;    }    <span class="hljs-comment">//...</span>}</code></pre></div><p>在这个示例中，无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分。（很少用这种，通常会直接将初始化代码放在构造器中）</p><h4 id="4-6-8-对象析构与finalize方法"><a href="#4-6-8-对象析构与finalize方法" class="headerlink" title="4.6.8 对象析构与finalize方法"></a>4.6.8 对象析构与finalize方法</h4><p>C++中每个类都能有一个析构函数，用来回收分配给对象的存储空间。</p><p>由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。</p><p>可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。（一般不用，因为很难知道什么时候调用）</p><h3 id="4-7-包"><a href="#4-7-包" class="headerlink" title="4.7 包"></a>4.7 包</h3><p>Java允许使用包（package）将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。使用包的主要原因是<strong>确保类名的唯一性</strong></p><p>Sun公司建议将域名以逆序的形式作为包名，比如 horstmann.com 的逆序形式是 com.horstmann，这个包还可以被进一步地划分成子包，如com.horstmann. corejava</p><h4 id="4-7-1-类的导入"><a href="#4-7-1-类的导入" class="headerlink" title="4.7.1 类的导入"></a>4.7.1 类的导入</h4><p>一个类可以使用所属包中的所有类，以及其他包中的公有类（public class），可以在每个类名前添加完整的包名访问，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">java.time.LocalDate today = java.time.LocalDate.now()</code></pre></div><p>写起来太麻烦，所以一般用<code>import</code>的方式导入（之后就不用写完整的包名了），例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.*<span class="hljs-comment">//导入 java.time 包中所有的类</span>   LocalDate today = LocalDate.now()<span class="hljs-comment">//调用</span></code></pre></div><h4 id="4-7-2-静态导入"><a href="#4-7-2-静态导入" class="headerlink" title="4.7.2 静态导入"></a>4.7.2 静态导入</h4><p><code>import</code>语句不仅可以导入类，还增加了导入静态方法和静态域的功能，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*</code></pre></div><p>就可以使用System类的静态方法和静态域，而不必加类名前缀：</p><div class="hljs code-wrapper"><pre><code class="hljs java">out.println(<span class="hljs-string">"Goodbye, World!"</span>)</code></pre></div><h4 id="4-7-3-将类放入包中"><a href="#4-7-3-将类放入包中" class="headerlink" title="4.7.3 将类放入包中"></a>4.7.3 将类放入包中</h4><p>如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包（defaulf package）中，默认包是一个没有名字的包。</p><p>下面将类分别放在不同的包中（com. horstmann.corejava和com.mycompany）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211119203950.png" srcset="/img/loading.gif" lazyload="" width="40%"></p><p>在这种情况下，仍然要从基目录编译和运行类：</p><p><code>java com/horstmann/corejava/Employee.java</code></p><p><code>java com/horstmann/corejava/Employee</code></p><h4 id="4-7-4-包作用域"><a href="#4-7-4-包作用域" class="headerlink" title="4.7.4 包作用域"></a>4.7.4 包作用域</h4><p>标记为public的部分可以被任意的类使用；标记为private的部分只能被定义它们的类使用</p><p>如果没有指定public或private，这个部分（类、方法或变量）可以被同一个包中的所有方法访问。</p><blockquote><p>注意：声明和定义变量别忘了在前面加 private</p></blockquote><h3 id="4-8-类路径"><a href="#4-8-类路径" class="headerlink" title="4.8 类路径"></a>4.8 类路径</h3><p>类路径包括：</p><ul><li>基目录/home/user/classdir或c:\classes；</li><li>当前目录(.)；</li><li>JAR文件/home/user/archives/archive.jar或c:\archives\archive.jar</li></ul><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">/home/user/calssdir:.:/home/user/archives/archive.jar</code></pre></div><p>（在UNIX环境中，类路径中的不同项目之间采用冒号<code>:</code>分隔，window中用分号<code>;</code>分隔）</p><p>SE6 开始用<code>*</code>或<code>'*'</code>表示通配符（但是UNIX中禁止使用<code>*</code>以防止shell命令进一步扩展，所以推荐用<code>'*'</code>）</p><h3 id="4-9-文档注释"><a href="#4-9-文档注释" class="headerlink" title="4.9 文档注释"></a>4.9 文档注释</h3><p>JDK包含一个很有用的工具，叫做javadoc，它可以由源文件生成一个HTML文档。</p><h4 id="4-9-1-注释的插入"><a href="#4-9-1-注释的插入" class="headerlink" title="4.9.1 注释的插入"></a>4.9.1 注释的插入</h4><p>这几部分一般要写一下注释：</p><ul><li>包</li><li>公有类与接口</li><li>公有的和受保护的构造器及方法</li><li>公有的和受保护的域</li></ul><h4 id="4-9-2-类注释"><a href="#4-9-2-类注释" class="headerlink" title="4.9.2 类注释"></a>4.9.2 类注释</h4><p>类注释一般放在import语句之后，类定义之前</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">这里写类注释</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{...}</code></pre></div><h4 id="4-9-3-方法注释"><a href="#4-9-3-方法注释" class="headerlink" title="4.9.3 方法注释"></a>4.9.3 方法注释</h4><p>每一个方法注释必须放在所描述的方法之前。除了通用标记之外，还可以使用下面的标记：</p><ul><li>@param变量描述这个标记将对当前方法的“param”（参数）部分添加一个条目。这个描述可以占据多行，并可以使用HTML标记。一个方法的所有@param标记必须放在一起。</li><li>@return描述这个标记将对当前方法添加“return”（返回）部分。这个描述可以跨越多行，并可以使用HTML标记。</li><li>@throws类描述这个标记将添加一个注释，用于表示这个方法有可能抛出异常。</li></ul><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">员工涨薪</span><span class="hljs-comment">@param byPercent涨薪百分比</span><span class="hljs-comment">@return 涨过后的资薪</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">raiseSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> byPercent)</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">double</span> raise = salary * byPercent / <span class="hljs-number">100</span>;    <span class="hljs-keyword">this</span>.salary += raise;    <span class="hljs-keyword">return</span> raise;}</code></pre></div><h3 id="4-10-类设计技巧"><a href="#4-10-类设计技巧" class="headerlink" title="4.10 类设计技巧"></a>4.10 类设计技巧</h3><ol><li>一定要保证数据私有</li><li>一定要对数据初始化</li><li>不要在类中使用过多的实例域</li><li>不是所有的域都需要独立的域访问器和域更改器</li><li>将职责过多的类进行分解</li><li>类名和方法名要能够体现它们的职责</li><li>优先使用不可变的类（涉及在多个线程间的安全共享）</li></ol><h2 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h2><p>继承（inheritance）就是基于已存在的类构造一个新的类，简单讲就是复用类的方法和实例域</p><h3 id="5-1-类、超类和子类"><a href="#5-1-类、超类和子类" class="headerlink" title="5.1 类、超类和子类"></a>5.1 类、超类和子类</h3><h4 id="5-1-1-定义子类"><a href="#5-1-1-定义子类" class="headerlink" title="5.1.1 定义子类"></a>5.1.1 定义子类</h4><p>由继承Employee类来定义Manager类的格式，关键字extends表示继承：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-comment">// 添加实例域和方法</span>}</code></pre></div><ul><li>已存在的类称为：<strong>父类</strong>（parent class）、超类（<code>superclass</code>）或基类（base class）</li><li>新类称为<strong>子类</strong>（subclass）、派生类（derived class）或孩子类（child class）</li></ul><p>子类一般比它的父类有更丰富的功能</p><h4 id="5-1-2-覆盖方法"><a href="#5-1-2-覆盖方法" class="headerlink" title="5.1.2 覆盖方法"></a>5.1.2 覆盖方法</h4><p>父类中的有些方法对子类并不一定适用，所以需要提供一个新的方法来<strong>覆盖（override）</strong>父类中的这个方法，具体实现方式为直接在子类里<code>重写</code>这个方法。</p><p>注意，子类不能直接访问父类的私有域，此外如果子类和父类有同一个方法名，那么子类会优先调用自己的方法。</p><p><strong>调用子类的方法而不是当前类</strong>的方法，可以通过关键字<strong>super</strong>实现，例如继承了Employee类的Manager类调用Employee类中的getSalary方法：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><span class="hljs-class"></span>{<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>{        <span class="hljs-keyword">double</span> baseSalary = <span class="hljs-keyword">super</span>.getSalary();        <span class="hljs-keyword">return</span> baseSalary += bonus;    }}</code></pre></div><p>如果只写<code>super(a,b,c)</code>表示调用父类中有(a,b,c)参数的构造器</p><h4 id="5-1-3-子类构造器"><a href="#5-1-3-子类构造器" class="headerlink" title="5.1.3 子类构造器"></a>5.1.3 子类构造器</h4><p>由于子类的构造器不饿能访问子类的私有域，所以必须通过父类的构造器对这部分私有域进行初始化，可以通过<code>super</code>实现对子类构造器的调用。（使用<code>super</code>调用构造器必须是子类构造器的第一条语句）</p><blockquote><ul><li><code>this</code>的用途：<ul><li>引用隐式参数</li><li>调用该类的其他构造器</li></ul></li><li><code>super</code>的用途：<ul><li>调用父类的方法</li><li>调用父类的构造器</li></ul></li></ul></blockquote><h4 id="5-1-4-继承层次"><a href="#5-1-4-继承层次" class="headerlink" title="5.1.4 继承层次"></a>5.1.4 继承层次</h4><p>继承了父类的子类还能派生出新的类，由一个共给父类派生出来的所有类的集合称为<strong>继承层次</strong>。</p><p>从某个特定的类到其祖先的路径被称为该类的继承链，一个祖先类可以拥有多个子孙继承链。</p><h4 id="5-1-5-多态"><a href="#5-1-5-多态" class="headerlink" title="5.1.5 多态"></a>5.1.5 多态</h4><p>如果程序中出现超类对象的任何地方都可以用子类对象置换，那么就应该设计为继承，这是<strong>“is-a”规则</strong>。</p><p>在Java中，对象变量是多态的。多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211121215148079.png" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li>多态存在的三个必要条件：<ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211121215328365.png" srcset="/img/loading.gif" lazyload="" width="60%"></p><ul><li>多态的优点：<ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul></li></ul><h4 id="5-1-6-理解方法调用"><a href="#5-1-6-理解方法调用" class="headerlink" title="5.1.6 理解方法调用"></a>5.1.6 理解方法调用</h4><p>方式调用过程的详细描述：</p><ol><li>编译器查看对象的声明类型和方法名</li><li>编译器查看调用方法时提供的参数类型</li><li>如果是private方法、static方法、final方法或者构造器，编译器应该知道调用哪个方法</li><li>程序运行</li></ol><h4 id="5-1-7-阻止继承：final类和方法"><a href="#5-1-7-阻止继承：final类和方法" class="headerlink" title="5.1.7 阻止继承：final类和方法"></a>5.1.7 阻止继承：final类和方法</h4><p>不允许扩展的类被称为<strong>final类</strong>，如果类中的某个方法声明了final，那么它的子类就不能覆盖（重写）这个方法。</p><h4 id="5-1-8-强制类型转换"><a href="#5-1-8-强制类型转换" class="headerlink" title="5.1.8 强制类型转换"></a>5.1.8 强制类型转换</h4><p>将某个类的对象引用转换成另外一个类的对象引用，就是对象引用的强制转换。</p><p>对象引用的转换语法与数值表达式的类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Manager boss = (Manager) staff[<span class="hljs-number">0</span>];<span class="hljs-comment">//对象引用强制转换</span><span class="hljs-keyword">int</span> nx = (<span class="hljs-keyword">int</span>) x;<span class="hljs-comment">//这是数据类型强制转换</span></code></pre></div><h4 id="5-1-9-抽象类"><a href="#5-1-9-抽象类" class="headerlink" title="5.1.9 抽象类"></a>5.1.9 抽象类</h4><p>为了提高程序的清晰度，包含一个或多个<strong>抽象方法</strong>的类本身必须通过关键字<code>abstract</code>声明为抽象类。例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><span class="hljs-class"></span>{...<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;}</code></pre></div><blockquote><p><strong>抽象方法</strong>：指不确定的方法，即没有明确定义的方法</p></blockquote><h4 id="5-1-10-受保护访问"><a href="#5-1-10-受保护访问" class="headerlink" title="5.1.10 受保护访问"></a>5.1.10 受保护访问</h4><p>众所周知，最好将类中的域标记为private，而方法标记为public。任何声明为private的内容对其他类都是不可见的（包括子类也不能访问父类的私有域）</p><p>而如果将实例域或方法声明为<strong>protected</strong>，子类就能够访问这个实例域或方法。</p><h3 id="5-2-Object：所有类的父类"><a href="#5-2-Object：所有类的父类" class="headerlink" title="5.2 Object：所有类的父类"></a>5.2 Object：所有类的父类</h3><p>Java中所有类都由Object类扩展而来，如果没有明确指出父类，Object就被认为是这个类的父类。</p><p>例如可以使用Object类型的变量引用任何类型的对象：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Object obj = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"Harry Hacker"</span>,<span class="hljs-number">35000</span>)</code></pre></div><p>Object类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Employee e = (Employee) obj;</code></pre></div><blockquote><p>在Java中，只有基本类型（primitive types）不是对象，例如，数值、字符和布尔类型的值都不是对象</p></blockquote><h4 id="5-2-1-equals方法"><a href="#5-2-1-equals方法" class="headerlink" title="5.2.1 equals方法"></a>5.2.1 equals方法</h4><p>Object类中的equals方法用于检,测一个对象是否等于另外一个对象（Java中变量也是对象，虽然变量的值不是）</p><h4 id="5-2-2-相等测试与继承"><a href="#5-2-2-相等测试与继承" class="headerlink" title="5.2.2 相等测试与继承"></a>5.2.2 相等测试与继承</h4><p>Java语言规范要求equals方法具有下面的特性：</p><ul><li>自反性：对于任何非空引用x,<code>x.equals(x)</code>应该返回true</li><li>对称性：对于任何引用x和y，当且仅当<code>y.equals(x)</code>返回true, <code>x.equals(y)</code>也应该返回true</li><li>传递性：对于任何引用x、y和z，如果<code>x.equals(y)</code>返回true, <code>y.equals(z)</code>返回true, <code>x.equals(z)</code>也应该返回true</li><li>一致性：如果x和y引用的对象没有发生变化，反复调用<code>x.equals(y)</code>应该返回同样的结果。</li><li>对于任意非空引用x, <code>x.equals(null)</code>应该返回false。</li></ul><p>（这里涉及一个“如果隐式和显式的参数不属于同一个类，equals方法将如何处理”的问题，解决步骤较长，略…）</p><h4 id="5-2-3-hashCode方法"><a href="#5-2-3-hashCode方法" class="headerlink" title="5.2.3 hashCode方法"></a>5.2.3 hashCode方法</h4><p>散列码（hash code）是由对象导出的一个整型值。</p><p>如果x和y是两个不同的对象，x.hashCode( )与y.hashCode( )基本上不会相同。</p><h4 id="5-2-4-toString方法"><a href="#5-2-4-toString方法" class="headerlink" title="5.2.4 toString方法"></a>5.2.4 toString方法</h4><p>Object中的<code>toString</code>方法用于返回表示对象值的字符串，例如Employee类中的toString方法的实现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"Employee[name="</span> + name <span class="hljs-string">",salary="</span> + salary + <span class="hljs-string">",hireDay="</span> + hireDay + <span class="hljs-string">"]"</span>;}</code></pre></div><h3 id="5-3-泛型数组列表"><a href="#5-3-泛型数组列表" class="headerlink" title="5.3 泛型数组列表"></a>5.3 泛型数组列表</h3><p>Java中运行时确定数组的大小（而不是在编译时就必须确定），可以通过<code>ArrayList</code>类来实现。</p><p>ArrayList是一个采用类型参数（type parameter）的泛型类（generic class）。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面，例如：<code>ArrayList&lt;Employee&gt;</code></p><p>下面声明和构造一个保存Employee对象的数组列表：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Employee&gt; staff = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre></div><p>使用add方法可以将元素添加到数组列表中。例如，下面展示了如何将Employee对象添加到数组列表中：</p><div class="hljs code-wrapper"><pre><code class="hljs java">staff.add(<span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"Harry Hacker"</span>,...));</code></pre></div><p>如果知道要存储多少个元素，可以通过<code>ensureCapacity</code>方法分配空间（然后还是要add）：</p><div class="hljs code-wrapper"><pre><code class="hljs java">staff.ensureCapacity(<span class="hljs-number">100</span>);</code></pre></div><p>通过<code>size</code>方法查看数组列表的实际元素数目：</p><div class="hljs code-wrapper"><pre><code class="hljs java">staff.size()</code></pre></div><p>使用<strong>get</strong>和<strong>set</strong>方法实现访问或改变数组元素的操作（而不常见的<code>变量[ ]</code>语法格式）</p><div class="hljs code-wrapper"><pre><code class="hljs java">Employee e = staff.get(i);<span class="hljs-comment">// 获取数组列表的元素,类似: Employee e = a[i]</span>staff.set(i,harry);<span class="hljs-comment">// 设置第i个元素的值,类似: staff[i] = harry</span></code></pre></div><h3 id="5-4-对象包装器与自动装箱"><a href="#5-4-对象包装器与自动装箱" class="headerlink" title="5.4 对象包装器与自动装箱"></a>5.4 对象包装器与自动装箱</h3><p>Java中int这样的基本类型也可以转换为对象。所有的基本类型都有一个与之对应的类。例如，Integer类对应基本类型int。通常，这些类称为包装器（wrapper）。包装器类拥有的关键字：Integer、Long、Float、Double、Short、Byte、Character、Void和Boolean。</p><blockquote><p>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，对象包装器类还是final，因此不能定义它们的子类</p></blockquote><p>比如声明一个整型数组列表（尖括号参数不能是基本类型，即不能写成 ArrayList&lt; int &gt;），通过Integer对象包装器来声明：</p><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre></div><p>元素添加还是和ArrayList操作一样，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs java">list.add(<span class="hljs-number">3</span>); <span class="hljs-comment">// 自动装箱：自动转为成 list.add(Integer.valueOf(3))</span>    <span class="hljs-keyword">int</span> n = list.get(i); <span class="hljs-comment">// 自动拆箱：自动转换成 list.get(i).intValue()</span></code></pre></div><h3 id="5-5-参数数量可变的方法"><a href="#5-5-参数数量可变的方法" class="headerlink" title="5.5 参数数量可变的方法"></a>5.5 参数数量可变的方法</h3><p>Java SE 5.0之后的版本提供了可以用可变的参数数量调用的方法，例如下面这段代码接受任意个double类型的参数，从中寻找其中的最大值并在控制台输出：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">double</span>...values)</span> </span>{<span class="hljs-keyword">double</span> largest=Double.MIN_VALUE;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">double</span> v:values) {<span class="hljs-keyword">if</span>(v&gt;largest) {largest=v;}}<span class="hljs-keyword">return</span> largest;}<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<span class="hljs-keyword">double</span> m=max(<span class="hljs-number">1.2</span>,<span class="hljs-number">3.4</span>,<span class="hljs-number">56.7</span>,<span class="hljs-number">345.45</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>);System.out.println(m);}}</code></pre></div><h3 id="5-6-枚举类"><a href="#5-6-枚举类" class="headerlink" title="5.6 枚举类"></a>5.6 枚举类</h3><p>所有的枚举类型都是Enum类的子类，最常用的方法是<code>toString</code>（所有的枚举类型都是Enum类的子类）</p><p>toString的逆方法是静态方法<code>valueOf</code></p><div class="hljs code-wrapper"><pre><code class="hljs java">Size.SMALL.toString() <span class="hljs-comment">//返回字符串"SMALL"</span>Size s = Enum.valueOf(Size.calss,<span class="hljs-string">"SMALL"</span>)<span class="hljs-comment">//将s设置成Size.SMALL</span></code></pre></div><p>每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组</p><h3 id="5-7-反射"><a href="#5-7-反射" class="headerlink" title="5.7 反射"></a>5.7 反射</h3><p>能够分析类能力的程序称为<strong>反射（reflective）</strong>，有个反射库用以编写能够动态操纵Java代码的程序。</p><p>反射机制可以用来：</p><ul><li>在运行时分析类的能力</li><li>在运行时查看对象（例如编写一个toString方法供所有类使用）</li><li>实现通用的数组操作代码</li><li>利用方法对象（这个对象很像C++中的函数指针）</li></ul><h4 id="5-7-1-Class类"><a href="#5-7-1-Class类" class="headerlink" title="5.7.1 Class类"></a>5.7.1 Class类</h4><p>Java会为所有对象维护一个被称为<strong>运行时</strong>的类型标识，这个信息跟踪着每个对象所属的类，保存这些信息的类被称为<strong>Class</strong>。（最常用的Class方法是getName，例如<code>a.getClass( ).getName( )</code>，<code>b.getName( )</code>）</p><h4 id="5-7-2-捕获异常"><a href="#5-7-2-捕获异常" class="headerlink" title="5.7.2 捕获异常"></a>5.7.2 捕获异常</h4><div class="hljs code-wrapper"><pre><code class="hljs stylus">try{<span class="hljs-comment">// 写入可能会报错的代码</span>}<span class="hljs-function"><span class="hljs-title">catch</span><span class="hljs-params">(异常类型 变量)</span></span>{<span class="hljs-comment">// 针对异常进行处理的代码</span>}</code></pre></div><p>（反射还有很多内容，略）</p><h3 id="5-8-继承的设计技巧"><a href="#5-8-继承的设计技巧" class="headerlink" title="5.8 继承的设计技巧"></a>5.8 继承的设计技巧</h3><ol><li>将公共操作和实例域放在父类</li><li>不要使用受保护的域</li><li>使用继承实现”is-a”关系</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>覆盖方法时，不要改变预期的行为</li><li>使用多态，而非类型信息</li><li>不要过多得使用反射</li></ol><h2 id="第6章-接口、lambda表达式与内部类"><a href="#第6章-接口、lambda表达式与内部类" class="headerlink" title="第6章 接口、lambda表达式与内部类"></a>第6章 接口、lambda表达式与内部类</h2><h3 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h3><h4 id="6-1-1-接口概念"><a href="#6-1-1-接口概念" class="headerlink" title="6.1.1 接口概念"></a>6.1.1 接口概念</h4><p>在Java程序设计语言中，<strong>接口（interface）不是类</strong>，而是对类的一组需求描述（类是对编写者的角度来看的，而接口是使用者的角度，对于使用者来说并不需要关注接口的具体实现 ~ 简单说接口就是一堆打包好了的方法）</p><p>接口通过关键字<code>interface</code>实现，比如Comparable接口：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span></span><span class="hljs-class"></span>{<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object other)</span></span>;}</code></pre></div><p><strong>对象所属的类必须实现了接口的方法</strong>，即在上面的例子中，任何实现Comparable接口的类都需要包含compareTo方法，并且这个方法的参数必须是一个Object对象，返回一个整型数值。</p><h4 id="6-1-2-接口的特性"><a href="#6-1-2-接口的特性" class="headerlink" title="6.1.2 接口的特性"></a>6.1.2 接口的特性</h4><p>接口的特性：</p><ul><li>接口不是类，不能new</li><li>虽然不能构造接口的对象，但能声明接口的变量</li><li>接口变量必须引用实现了接口的类对象</li></ul><h4 id="6-1-3-接口与抽象类"><a href="#6-1-3-接口与抽象类" class="headerlink" title="6.1.3 接口与抽象类"></a>6.1.3 接口与抽象类</h4><p>抽象类很难</p><p>抽象类有个问题：每个类只能继承自一个类（Java的类不允许多重继承）</p><p>而接口可以提供多重继承的大多数好处，又能避免多重继承的复杂性和低效性。</p><h4 id="6-1-4-静态方法"><a href="#6-1-4-静态方法" class="headerlink" title="6.1.4 静态方法"></a>6.1.4 静态方法</h4><p>静态方法是一种不能向对象实施操作的方法。例如，Math类的pow方法就是一个静态方法。</p><p>静态方法通常放在类里面，而不是放在接口里。</p><h4 id="6-1-5-默认方法"><a href="#6-1-5-默认方法" class="headerlink" title="6.1.5 默认方法"></a>6.1.5 默认方法</h4><p><code>default</code>可以为接口方法提供一个默认实现：</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;</span><span class="hljs-class"></span>{    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T other)</span> </span>{<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}}</code></pre></div><p>一般没啥用，因为这个接口的每个实际实现都要覆盖这个方法</p><h4 id="6-1-6-解决默认方法冲突"><a href="#6-1-6-解决默认方法冲突" class="headerlink" title="6.1.6 解决默认方法冲突"></a>6.1.6 解决默认方法冲突</h4><p>如果先在一个接口中将一个方法定义为默认方法，然后又在父类或另一个接口中定义了同样的方法，那么会这样：</p><ol><li>父类优先。如果父类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li><li>接口重复。如果一个超接口（接口的父？）提供了一个默认方法，另一个接口提供论一个同盟而且参数类型相同的方法，那么必须覆盖这个方法来解决冲突。</li></ol><h3 id="6-2-接口示例"><a href="#6-2-接口示例" class="headerlink" title="6.2 接口示例"></a>6.2 接口示例</h3><h4 id="6-2-1-接口与回调"><a href="#6-2-1-接口与回调" class="headerlink" title="6.2.1 接口与回调"></a>6.2.1 接口与回调</h4><p><strong>回调（callback）</strong>是一种常见的程序设计模式，可以指定事件发生时采取的动作（比如点击某个按钮就弹出页面）</p><h4 id="6-2-2-Comparator接口"><a href="#6-2-2-Comparator接口" class="headerlink" title="6.2.2 Comparator接口"></a>6.2.2 Comparator接口</h4><p>略</p><h4 id="6-2-3-对象克隆"><a href="#6-2-3-对象克隆" class="headerlink" title="6.2.3 对象克隆"></a>6.2.3 对象克隆</h4><p>Cloneable接口（略）</p><h3 id="6-3-lambda表达式"><a href="#6-3-lambda表达式" class="headerlink" title="6.3 lambda表达式"></a>6.3 lambda表达式</h3><h4 id="6-3-1-为什么引入lambda表达式"><a href="#6-3-1-为什么引入lambda表达式" class="headerlink" title="6.3.1 为什么引入lambda表达式"></a>6.3.1 为什么引入lambda表达式</h4><p>如果要将代码块作为参数传递到某个对象，还是比较麻烦的（因为只有String类型比较符合，所以处理起来麻烦）</p><h4 id="6-3-2-lambda表达式的语法"><a href="#6-3-2-lambda表达式的语法" class="headerlink" title="6.3.2 lambda表达式的语法"></a>6.3.2 lambda表达式的语法</h4><p>lambda表达式就是一个代码块，以及写上代码的变量规范</p><div class="hljs code-wrapper"><pre><code class="hljs java">(String first, String second) -&gt; first.length() - second.length()</code></pre></div><p>lambda表达式形式：<kbd>参数,箭头(-&gt;),表达式</kbd>，即使没有参数也要提供空括号</p><h4 id="6-3-3-函数式接口"><a href="#6-3-3-函数式接口" class="headerlink" title="6.3.3 函数式接口"></a>6.3.3 函数式接口</h4><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口（functional interface）。</p><h4 id="6-3-4-方法引用"><a href="#6-3-4-方法引用" class="headerlink" title="6.3.4 方法引用"></a>6.3.4 方法引用</h4><p>利用方法引用可以实现现成的方法可以完成你想要传递到其他代码的某个动作</p><p>例如希望出现定时器事件就打印这个事件对象，可以调用：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Timer t = <span class="hljs-keyword">new</span> Timer(<span class="hljs-number">1000</span>, event -&gt; System.out.println(event));</code></pre></div><p>上面这个例子本来参数是(1000,event)的，加上了lambda表达式就调用完这个方法后打印一遍event</p><p>通过方法引用，可以直接把println方法传递到Timer构造器这样就更方便了，具体实现：</p><div class="hljs code-wrapper"><pre><code class="hljs java">Timer t = <span class="hljs-keyword">new</span> Timer(<span class="hljs-number">1000</span>,System.out::println)</code></pre></div><p>表达式<code>System.out::println</code>是一个方法引用（method reference），它等价于lambda表达式<code>x -&gt; System.out.println(x)</code></p><h4 id="6-3-5-构造器引用"><a href="#6-3-5-构造器引用" class="headerlink" title="6.3.5 构造器引用"></a>6.3.5 构造器引用</h4><p>构造器引用与方法引用很类似，只不过方法名为new</p><h4 id="6-3-6-变量作用域"><a href="#6-3-6-变量作用域" class="headerlink" title="6.3.6 变量作用域"></a>6.3.6 变量作用域</h4><p>略</p><h4 id="6-3-7-处理lambda表达式"><a href="#6-3-7-处理lambda表达式" class="headerlink" title="6.3.7 处理lambda表达式"></a>6.3.7 处理lambda表达式</h4><p>略</p><h4 id="6-3-7-处理lambda表达式-1"><a href="#6-3-7-处理lambda表达式-1" class="headerlink" title="6.3.7 处理lambda表达式"></a>6.3.7 处理lambda表达式</h4><h2 id="6-4-内部类"><a href="#6-4-内部类" class="headerlink" title="6.4 内部类"></a>6.4 内部类</h2><p><strong>内部类（inner class）</strong>是定义在另一个类中的类，使用内部类的主要原因有三点：</p><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</li><li>内部类可以对同一个包中的其他类隐藏起来</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷。</li></ul><h4 id="6-4-6-匿名内部类"><a href="#6-4-6-匿名内部类" class="headerlink" title="6.4.6 匿名内部类"></a>6.4.6 匿名内部类</h4><p>将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了。这种类被称为<strong>匿名内部类（anonymous inner class）</strong></p><h4 id="6-4-7-静态内部类"><a href="#6-4-7-静态内部类" class="headerlink" title="6.4.7 静态内部类"></a>6.4.7 静态内部类</h4><p>使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为static，以便取消产生的引用。</p><h3 id="6-5-代理"><a href="#6-5-代理" class="headerlink" title="6.5 代理"></a>6.5 代理</h3><p>利用<strong>代理（proxy）</strong>可以在运行时创建一个实现了一组给定接口的新类</p><p>（用得很少，因为这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用）</p><hr><p><strong>完结撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</strong></p><blockquote><p>这里只是基础部分，后面还有Java并发比较重要，不过我觉得Java并发还是单独一篇来写吧，另外，这本书的案例相对来说还是没那么贴合没有开发经验的小白。个人建议没有做过后端开发的读者可以看完《Java核心技术 卷I》后看看 <a href="https://how2j.cn，这个网站以游戏作为案例通俗易懂地讲解了Java的各个部分。如果《Java核心技术" target="_blank" rel="noopener">https://how2j.cn，这个网站以游戏作为案例通俗易懂地讲解了Java的各个部分。如果《Java核心技术</a> 卷I》里有什么看不懂的，去这里看看也许会恍然大悟。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仅阅读了Java基础部分，完结撒花&lt;em&gt;★,°&lt;/em&gt;:.☆(￣▽￣)/$:&lt;em&gt;.°★&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="开发" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《ClickHouse原理解析与应用实践》阅读笔记</title>
    <link href="http://example.com/2021/11/10/%E3%80%8AClickHouse%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/11/10/%E3%80%8AClickHouse%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-10T03:20:33.000Z</published>
    <updated>2021-11-24T08:12:09.988Z</updated>
    
    <content type="html"><![CDATA[<p>ClickHouse好秀啊</p><a id="more"></a><h2 id="第2章-ClickHouse架构概述"><a href="#第2章-ClickHouse架构概述" class="headerlink" title="第2章 ClickHouse架构概述"></a>第2章 ClickHouse架构概述</h2><h3 id="2-1-ClickHouse的核心特性"><a href="#2-1-ClickHouse的核心特性" class="headerlink" title="2.1 ClickHouse的核心特性"></a>2.1 ClickHouse的核心特性</h3><h4 id="2-1-2-列式存储与数据压缩"><a href="#2-1-2-列式存储与数据压缩" class="headerlink" title="2.1.2 列式存储与数据压缩"></a>2.1.2 列式存储与数据压缩</h4><p>行式存储：逐行扫描</p><p>列式存储：逐列扫描</p><h4 id="2-1-3-向量化执行引擎"><a href="#2-1-3-向量化执行引擎" class="headerlink" title="2.1.3 向量化执行引擎"></a>2.1.3 向量化执行引擎</h4><p>向量化执行引擎：一项消除程序循环的优化<br>（原理上类似增加空间复杂度减少时间复杂度）</p><p>通过CPU的SIMD指令（Single Instruction Multiple Data,SIMD）即用单条指令操作多条数据，从而通过数据并行以提高性能，它的原理是在CPU寄存器层面实现数据的并行操作。</p><blockquote><p>ClickHouse目前用SSE4.2指令集实现向量化执行</p></blockquote><h4 id="2-1-4-关系模型与SQL查询"><a href="#2-1-4-关系模型与SQL查询" class="headerlink" title="2.1.4 关系模型与SQL查询"></a>2.1.4 关系模型与SQL查询</h4><p>相比HBase和Redis这类NoSQL数据库，ClickHouse使用关系模型描述并提供了传统数据库的概念（数据库、表、视图、函数等）。此外ClickHouse完全使用SQL作为查询语言。</p><h4 id="2-1-5-表引擎"><a href="#2-1-5-表引擎" class="headerlink" title="2.1.5 表引擎"></a>2.1.5 表引擎</h4><p>ClickHouse共拥有合并树、内存、文件、接口和其他等6大类20多种的表引擎。</p><h4 id="2-1-7-多主架构"><a href="#2-1-7-多主架构" class="headerlink" title="2.1.7 多主架构"></a>2.1.7 多主架构</h4><p>不同于HDFS、Spark、ElasticSearch这类采用主从架构（Master-Slave）的分布式系统，ClickHouse采用多主架构（Multi-Master）。</p><h4 id="2-1-8-在线查询"><a href="#2-1-8-在线查询" class="headerlink" title="2.1.8 在线查询"></a>2.1.8 在线查询</h4><p>在线查询（好像就是即席查询，指用户临时写的查询语句并且需要立刻得到返回结果）</p><p>ClickHouse在在线查询方面很快（相比Hive、Spark SQL），而且开源（Vertica性能很好，但是价格很高）</p><h4 id="2-1-9-数据分片与分布式查询"><a href="#2-1-9-数据分片与分布式查询" class="headerlink" title="2.1.9 数据分片与分布式查询"></a>2.1.9 数据分片与分布式查询</h4><ul><li><p>数据分片</p><p>分片是一种大数据处理下的分治思想，ClickHouse支持数据分片。</p><p>一个集群由1到多个分片组成，每个分片对应ClickHouse的1个服务节点（故数据分片数量取决于ClickHouse服务节点数）</p></li></ul><ul><li><p>分布式查询</p><p>ClickHouse提供本地表（Local Tabel）和分布式表（Distributed Table）。</p><p>本地表等同于一份数据分片</p><p>分布式表不存储数据，它是本地表的代理访问，类似分库中间件，能够代理访问多个数据分片，从而实现分布式查询。ClickHouse</p></li></ul><h3 id="2-2-ClickHouse的架构设计"><a href="#2-2-ClickHouse的架构设计" class="headerlink" title="2.2 ClickHouse的架构设计"></a>2.2 ClickHouse的架构设计</h3><h4 id="2-2-1-Column和Field"><a href="#2-2-1-Column和Field" class="headerlink" title="2.2.1 Column和Field"></a>2.2.1 Column和Field</h4><p>ClickHouse按列存储数据，内存中一列数据由一个Column对象表示；Column采用泛化的设计模式。</p><p>ClickHouse都会以整列的方式操作数据，除非需要操作具体单个的数值（也就是单列中的一行数据），则需要使用Field对象，Field对象代表一个单值；Field采用聚合的设计模式，内部聚合了Null、UInt64、String、Array等13种数据类型及相应的处理逻辑。</p><h4 id="2-2-2-DataType"><a href="#2-2-2-DataType" class="headerlink" title="2.2.2 DataType"></a>2.2.2 DataType</h4><p>ClickHouse数据的序列化和反序列化工作由DataType负责。IDataType采用泛华的设计模式，支持二进制、文本、json、xml、csv、protobuf等多种格式。</p><h4 id="2-2-3-Block和Block流"><a href="#2-2-3-Block和Block流" class="headerlink" title="2.2.3 Block和Block流"></a>2.2.3 Block和Block流</h4><p>Column和Filed组成了数据的基本映射单元，但对应实际操作中缺少了必要补充信息，所以ClickHouse设计了Block。</p><p>Block对象本质是由数据对象、数据类型和列名称组成的三元组，即（Column，DataType，列名称字符串）。</p><p>Column提供数据读取能力，DataType负责正反序列化，所以Block在这些对象的基础上实现了进一步的抽象和封装，使得仅通过Block对象就能完成一系列的数据操作（Block并没有直接聚合Column和DataType对象，而是间接引用）。</p><p>Block流有两个顶层接口，分别是IBlockInputStream和IBlockOutputStream，每个顶层接口又有很多类方法。</p><div class="hljs code-wrapper"><pre class="mermaid">graph LRA[Block流] --&gt;B(IBlockInputStream)    A --&gt; C(IBlockOutputStream)    B --&gt; D(DDL操作)    B --&gt; E(关系运算)    B --&gt; F(表引擎)    C --&gt; G(表引擎)</pre></div><h4 id="2-2-4-Table"><a href="#2-2-4-Table" class="headerlink" title="2.2.4 Table"></a>2.2.4 Table</h4><p>数据表的底层设计中并没有所谓的Table对象，它直接使用<code>IStorage接口</code>指代数据表。</p><p>IStorage定义了DDL（如ALTER、RENAME、OPTIMIZE、DROP等）、read、write方法，它们分别负责数据的定义、查询、写入。</p><p>对Table发起的一次操作通常都会经历这样的过程：接收AST查询语句（抽象语法树，简称AST），根据AST返回指定列的数据，之后再将数据交由Interpreter做进一步处理。</p><h4 id="2-2-5-Parser和Interpreter"><a href="#2-2-5-Parser和Interpreter" class="headerlink" title="2.2.5 Parser和Interpreter"></a>2.2.5 Parser和Interpreter</h4><p>Parser负责创建AST对象（将SQL以递归下降的方法发解析成AST语法树）；Interpreter负责解释AST，并进一步创建查询的执行管道（起到串联查询过程的作用，会根据解释器的雷系聚合它所需要的资源）。</p><h4 id="2-2-6-Functions和Aggregate-Functions"><a href="#2-2-6-Functions和Aggregate-Functions" class="headerlink" title="2.2.6 Functions和Aggregate Functions"></a>2.2.6 Functions和Aggregate Functions</h4><p>ClickHouse主要提供两类函数：普通函数（无状态）和聚合函数（有状态）。</p><p>普通函数由IFunctions定义，聚合函数由IAggregateFunctions接口定义，并支持序列化和反序列化。</p><h4 id="2-2-7-Cluster和Replication"><a href="#2-2-7-Cluster和Replication" class="headerlink" title="2.2.7 Cluster和Replication"></a>2.2.7 Cluster和Replication</h4><p>ClickHouse的集群由分片（Shard）组成，而每个分片又通过副本（Replica）组成，其具有以下特性：</p><ol><li>ClickHouse的1个节点只能拥有1个分片</li><li>分片只是一个逻辑概念，其物理承载还是由副本承担。</li></ol><h2 id="第3章-安装与部署（略）"><a href="#第3章-安装与部署（略）" class="headerlink" title="第3章 安装与部署（略）"></a>第3章 安装与部署（略）</h2><h2 id="第4章-数据定义"><a href="#第4章-数据定义" class="headerlink" title="第4章 数据定义"></a>第4章 数据定义</h2><h3 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h3><ul><li>基础类型</li></ul><table><thead><tr><th>基础类型</th><th>具体类型</th></tr></thead><tbody><tr><td>数值类型</td><td>Int、Float、Decimal</td></tr><tr><td>字符串类型</td><td>String、FixedString、UUID</td></tr><tr><td>时间类型</td><td>DateTime、DateTime64、Date</td></tr></tbody></table><ul><li><p>复合类型</p><ol><li>Array</li><li>Tuple</li><li>Enum</li><li>Nested</li></ol></li><li><p>特殊类型</p><ol><li>Nullable</li><li>Domain</li></ol></li></ul><h3 id="4-2-如何定义数据表"><a href="#4-2-如何定义数据表" class="headerlink" title="4.2 如何定义数据表"></a>4.2 如何定义数据表</h3><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> db_name [<span class="hljs-keyword">ENGINE</span> = Oridinary]</code></pre></div><p>ENGINE处的参数表示数据库所使用的引擎，一共有五种：</p><ul><li>Oridinary：默认引擎，大部分情况都用这个</li><li>Dictionary：字典引擎</li><li>Memory：内存引擎</li><li>Lazy：日志引擎</li><li>MySQL：MySQL引擎</li></ul><h3 id="4-5-分布式DDL执行"><a href="#4-5-分布式DDL执行" class="headerlink" title="4.5 分布式DDL执行"></a>4.5 分布式DDL执行</h3><p>普通DDL语句转化为分布式DDL语句，只需加上<code>ON CLUSTER cluster_name</code>声明即可，如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1 <span class="hljs-keyword">ON</span> CLUSTER ch_cluster (<span class="hljs-keyword">id</span> <span class="hljs-keyword">String</span>,    <span class="hljs-keyword">url</span> <span class="hljs-keyword">String</span>,    EventTime <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">ENGINE</span> = MergeTree()<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(EventTime)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><p> 该语句会对ch_cluster集群内所有节点广播这条DDL语句</p><h2 id="第5章-数据字典"><a href="#第5章-数据字典" class="headerlink" title="第5章 数据字典"></a>第5章 数据字典</h2><p>数据字典是ClickHouse提供的一种存储介质，它以（键值，属性映射）的形式定义数据。</p><p>数据字典被<strong>加载到内存</strong>，支持动态更新，因而数据字典非常适合保存常量或者经常使用的维度表数据，以避免不必要的JOIN查询。</p><div class="hljs code-wrapper"><pre class="mermaid">graph LRA[数据字典] --&gt;B(内置字典 _ ClickHouse默认自带的字典)    A --&gt; C(外部扩展字典 _ 用户自定义配置实现的字典)</pre></div><p>字典中的数据只能通过<strong>字典函数</strong>访问（有一种例外情况，就是使用特殊的字典表引擎）</p><ul><li>7种类型字典的特点总结</li></ul><table><thead><tr><th>名称</th><th>存储结构</th><th>字典键类型</th><th>支持的数据来源</th></tr></thead><tbody><tr><td>flat</td><td>数组</td><td>UInt64</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>hashed</td><td>散列</td><td>UInt64</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>range_hashed</td><td>散列并按时间排序</td><td>UInt64和时间</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>complex_key_hashed</td><td>散列</td><td>复合型Key</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>ip_trie</td><td>层次结构</td><td>复合型Key（单个String）</td><td>Local file、 Executable file、 HTTP、DBMS</td></tr><tr><td>cache</td><td>固定大小数组</td><td>UInt64</td><td>Executable file、HTTP、 ClickHouse、MySQL</td></tr><tr><td>complex_key_cache</td><td>固定大小数组</td><td>复合型Key</td><td>Executable file、HTTP、 ClickHouse、MySQL</td></tr></tbody></table><h2 id="第6章-MergeTree原理解析"><a href="#第6章-MergeTree原理解析" class="headerlink" title="第6章 MergeTree原理解析"></a>第6章 MergeTree原理解析</h2><p>表引擎是ClickHouse的一大特色，表引擎决定了一张表的特性，比如数据以何种形式被存储以及如何被加载。</p><p>合并树（MergeTree）是ClickHouse中最常用的表引擎，因为只有MergeTree系列（MergeTree的变种表引擎有很多）的表引擎才支持<strong>主键索引</strong>、<strong>数据分区</strong>、<strong>数据副本</strong>、<strong>数据采样</strong>这些特性，同时也只有此系列表引擎支持ALTER相关操作。</p><h3 id="6-1-MergeTree的创建方式与存储结构"><a href="#6-1-MergeTree的创建方式与存储结构" class="headerlink" title="6.1 MergeTree的创建方式与存储结构"></a>6.1 MergeTree的创建方式与存储结构</h3><ul><li><p>MergeTree创建方式</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [<span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [db_name.]table_name (name1 [<span class="hljs-keyword">type</span>] [<span class="hljs-keyword">DEFAULT</span>|<span class="hljs-keyword">MATERIALIZED</span>|<span class="hljs-keyword">ALIAS</span> expr],    name2 [<span class="hljs-keyword">type</span>] [<span class="hljs-keyword">DEFAULT</span>|<span class="hljs-keyword">MATERIALIZED</span>|<span class="hljs-keyword">ALIAS</span> expr],    <span class="hljs-comment">--省略 ...</span>) <span class="hljs-keyword">ENGINE</span> = MergeTree()  <span class="hljs-comment">--选择合并树表引擎</span>[<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> expr]<span class="hljs-comment">--选填，分区键</span>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> expr]<span class="hljs-comment">--必填，排序键</span>[PRIMARY <span class="hljs-keyword">KEY</span> expr]<span class="hljs-comment">--选题，主键</span>[<span class="hljs-keyword">SAMPLE</span> <span class="hljs-keyword">BY</span> expr]<span class="hljs-comment">--选题，抽样表达式</span>[<span class="hljs-keyword">SETTINGS</span> <span class="hljs-keyword">name</span> = <span class="hljs-keyword">value</span>,省略...]<span class="hljs-comment">--index_granularity[选填]，索引粒度，默认8192（每隔8192行生成一条索引）;index_granularity[选填]，每一批写书数据的体量大小，默认10M；enable_mixed_granularity_parts[选填]，设置是否开启自适应索引间隔，默认开启；merge_mixed_with_ttl_timeout[选填]；storage_policy[选填]</span></code></pre></div></li></ul><ul><li><p>MergeTree存储结构</p><blockquote><div class="hljs code-wrapper"><pre><code class="hljs sql">table_name│├─partition_1<span class="hljs-comment">-- 分区目录</span>│    ├─ checksums.txt<span class="hljs-comment">-- 检验文件，二进制格式存储</span>│    ├─ colums.txt<span class="hljs-comment">-- 列文件，明文格式存储，保存该分区下的字段信息</span>│    ├─ count.txt<span class="hljs-comment">-- 计数文件，明文格式存储，记录该分区下数据的总行数</span>│    ├─ primary.idx<span class="hljs-comment">-- 一级索引文件，二进制格式存储，用于存放稀疏索引</span>│    ├─ [Column].bin<span class="hljs-comment">-- 数据文件，压缩格式存储（默认LZ4压缩格式）</span>│    ├─ [Column].mrk<span class="hljs-comment">-- 列字段标记文件，二进制格式存储，保存了.bin文件的数据偏移量</span>│    ├─ [Column].mrk2<span class="hljs-comment">-- 如果使用了适应性大小的间隔索引，作用和原理与.mrk文件相同</span>│    ├─ partition.dat<span class="hljs-comment">-- 使用了分区才会生成，保存当前分区表达式最终生成的值</span>│    ├─ minmax_[Column].idx<span class="hljs-comment">-- 使用了分区才会生成，记录当前分区原始字段最大值和最小值</span>│    ├─ skp_idx _[Column].idx<span class="hljs-comment">-- 使用了二级索引才会生成</span>│    ├─ skp_idx _[Column].mrk<span class="hljs-comment">-- 使用了二级索引才会生成</span>│    └─ partition_2│ └─ partition_n</code></pre></div></blockquote></li></ul><h3 id="6-2-数据分区"><a href="#6-2-数据分区" class="headerlink" title="6.2 数据分区"></a>6.2 数据分区</h3><h4 id="6-2-1-数据的分区规则"><a href="#6-2-1-数据的分区规则" class="headerlink" title="6.2.1 数据的分区规则"></a>6.2.1 数据的分区规则</h4><ul><li>ID在不同分区类型下的示例</li></ul><table><thead><tr><th>类型</th><th>样例数据</th><th>分区表达式</th><th>分区ID</th></tr></thead><tbody><tr><td>整型</td><td>18，19，20</td><td>PARTITION BY Age</td><td>分区1：18；分区2：19；分区3：20</td></tr><tr><td>日期</td><td>2021-05-01，2021-05-2</td><td>PARTITION BY EventTime</td><td>分区1：20210501；分区2：20210502</td></tr><tr><td>其他</td><td>‘<a href="http://www.nauu.com’" target="_blank" rel="noopener">www.nauu.com’</a></td><td>PARTITION BY URL</td><td>分区1：15b31467</td></tr></tbody></table><h4 id="6-2-2-分区目录的命名规则"><a href="#6-2-2-分区目录的命名规则" class="headerlink" title="6.2.2 分区目录的命名规则"></a>6.2.2 分区目录的命名规则</h4><p>分区目录 = 分区ID（PartitionID）+MaxBlockNum+MinBlockNum+Level</p><p>例如分区目录是202105_1_1_0</p><blockquote><p>MaxBlockNum和MinBlockNum是最大数据块编号和最小数据块编号（跟数据压缩的数据压缩块无关）</p></blockquote><h4 id="6-2-3-分区目录的合并过程"><a href="#6-2-3-分区目录的合并过程" class="headerlink" title="6.2.3 分区目录的合并过程"></a>6.2.3 分区目录的合并过程</h4><p>MinBlockNum：取同一分区内所有目录中最小的MinBlockNum值</p><p>MaxBlockNum：取同一分区内所有目录中最小的MaxBlockNum值</p><p>Level：取同一分区内最大Level值并加1</p><h3 id="6-3-一级索引"><a href="#6-3-一级索引" class="headerlink" title="6.3 一级索引"></a>6.3 一级索引</h3><h4 id="6-3-1-稀疏索引"><a href="#6-3-1-稀疏索引" class="headerlink" title="6.3.1 稀疏索引"></a>6.3.1 稀疏索引</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109165101.png" width="50%"> </p><h4 id="6-3-2-索引粒度"><a href="#6-3-2-索引粒度" class="headerlink" title="6.3.2 索引粒度"></a>6.3.2 索引粒度</h4><p>ClickHouse中索引粒度默认为8192，数据以index_granularity的粒度（默认8192）被标记成多个小的区间，其中每个区间最多8192行数据。</p><h4 id="6-3-3-索引数据的生成规则"><a href="#6-3-3-索引数据的生成规则" class="headerlink" title="6.3.3 索引数据的生成规则"></a>6.3.3 索引数据的生成规则</h4><p>由于是稀疏索引，所以MergeTree需要间隔 index_granularity 行数据才会生成一条索引记录。</p><h4 id="6-3-4-索引的查询过程"><a href="#6-3-4-索引的查询过程" class="headerlink" title="6.3.4 索引的查询过程"></a>6.3.4 索引的查询过程</h4><p>根据索引粒度生成多个MarkRange，两个相邻的MarkRange相距步长为1，所有MarkRange（整个数据片段）的最大数值区间为[0,+inf]</p><p>索引查询过程分为3个步骤：</p><ol><li><p>生成查询条件区间。例如：</p><p>WHERE ID = ‘A003’ → [‘A003’ , ‘A003’]</p><p>WHERE ID &gt; ‘A003’ → [‘A003’ ,  +inf]</p></li><li><p>递归交集判断：以递归的形式，依次对MarkRange的数值区间与条件区间做交集判断，从最大的区间[0 , +inf]开始：</p><ul><li>如果不存在交集，则直接通过剪枝算法优化此整段MarkRange</li><li>如果存在交集，且MarkRange不可再分解（步长小于8），则记录MarkRange并返回</li></ul></li><li><p>合并MarkRange区间：将最终匹配的MarkRange聚在一起，合并它们的范围。</p></li></ol><h3 id="6-4-二级索引"><a href="#6-4-二级索引" class="headerlink" title="6.4 二级索引"></a>6.4 二级索引</h3><p>二级索引又称为跳数索引，默认关闭，开启命令为：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> allow_experimental_data_skipping_indices = <span class="hljs-number">1</span></code></pre></div><h3 id="6-5-数据存储"><a href="#6-5-数据存储" class="headerlink" title="6.5 数据存储"></a>6.5 数据存储</h3><h4 id="6-5-1-各列独立存储"><a href="#6-5-1-各列独立存储" class="headerlink" title="6.5.1 各列独立存储"></a>6.5.1 各列独立存储</h4><p>每个字段都有一个对应的.bin文件，这些.bin文件承载着物理存储。</p><p>存储的具体实现L：数据经过压缩后按照ORDER BY的声明排序，最后数据以压缩数据块的形式被组织写入.bin文件中</p><h4 id="6-5-2-压缩数据块"><a href="#6-5-2-压缩数据块" class="headerlink" title="6.5.2 压缩数据块"></a>6.5.2 压缩数据块</h4><p>JavaEnable.bin</p><blockquote><blockquote><p>压缩数据块0</p><p>hear stat(65536, 12000)</p></blockquote><blockquote><p>压缩数据块1</p><p>hear stat(65536, 14660)</p></blockquote><p>…</p></blockquote><p>MergeTree在数据具体的写入过程中，会按照索引粒度（默认8192行），按批次获取数据并进行处理。如果把一批数据的未压缩大小设为size，则整个写入过程遵循以下规则：</p><ol><li>单个批次数据 size &lt; 64KB：继续获取下一个批数据，直至累积到 size &gt;= 64 KB，生成下一个压缩数据块</li><li>单个批次数据  64 KB &lt;= size &lt;= 1 MB​：直接生成下一个压缩数据块</li><li>单个批次数据  size &gt;= 1 MB​：先按照1MB大小截断并生成下一个数据块，剩余数据继续依照上述规则执行。</li></ol><h3 id="6-6-数据标记"><a href="#6-6-数据标记" class="headerlink" title="6.6 数据标记"></a>6.6 数据标记</h3><p>下面用一个类比来说明数据标记是什么及其作用</p><blockquote><p>MergeTree表：书</p><p>primary.idx（一级索引）：章节目录</p><p>.bin（数据文件）：书中的内容</p><p>.mrk（数据标记）：章节与内容之间的联系（数据标记记录两个信息：1、页码；2、某段内容起始位置）</p></blockquote><h3 id="6-7-对于分区、索引、标记和压缩数据的协同总结"><a href="#6-7-对于分区、索引、标记和压缩数据的协同总结" class="headerlink" title="6.7 对于分区、索引、标记和压缩数据的协同总结"></a>6.7 对于分区、索引、标记和压缩数据的协同总结</h3><h4 id="6-7-1-写入过程"><a href="#6-7-1-写入过程" class="headerlink" title="6.7.1 写入过程"></a>6.7.1 写入过程</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109214943.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h4 id="6-7-2-查询过程"><a href="#6-7-2-查询过程" class="headerlink" title="6.7.2 查询过程"></a>6.7.2 查询过程</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215057.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h4 id="6-7-3-数据标记与压缩数据块的对应关系"><a href="#6-7-3-数据标记与压缩数据块的对应关系" class="headerlink" title="6.7.3 数据标记与压缩数据块的对应关系"></a>6.7.3 数据标记与压缩数据块的对应关系</h4><ol><li><p>多对一</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215201.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>一对一</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215215.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>一对多</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215238.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li></ol><h2 id="第9章-数据查询"><a href="#第9章-数据查询" class="headerlink" title="第9章 数据查询"></a>第9章 数据查询</h2><h3 id="9-3-SAMPLE语句"><a href="#9-3-SAMPLE语句" class="headerlink" title="9.3 SAMPLE语句"></a>9.3 SAMPLE语句</h3><p>SAMPLE子句能够实现数据采样的功能，使查询返回采样数而不是全部数据，从而减少查询负载。SAMPLE子句的采样机制是一种<strong>幂等</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="幂等性：指多次操作,结果是一致。 数学表达式为： f(x) = f(f(x))">[1]</span></a></sup>设计，所以相同的采样规则能返回相同的数据，这项特性适用于那些可以接受近似查询结果的场景。</p><p>SAMPLE子句只能用于MergeTree系列引擎的数据表，并且要求在<code>CREATE TABLE</code>时声明<code>SAMPLE BY</code>抽样表达式，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> hits_t1 (    <span class="hljs-keyword">ID</span> UInt64,    EventTime <span class="hljs-built_in">DATE</span>,    UserID UInt64) <span class="hljs-keyword">ENGINE</span> = MergeTree()<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(EventTime)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (<span class="hljs-keyword">ID</span>,intHash32(UserID))<span class="hljs-comment">-- SAMPLE Key声明的表达式必须也包含在主键的声明中</span><span class="hljs-keyword">SAMPLE</span> <span class="hljs-keyword">BY</span> intHash32(UserID)</code></pre></div><p><code>SAMPLE BY intHash32(UserID)</code>表示该表内的数据，按照<code>intHash32(UserID)</code>分布后的结果采样查询。</p><blockquote><p>声明 SAMPLE Key的注意事项：</p><ol><li>SAMPLE BY 所声明的表达式必须同时包含在主键的声明内；</li><li>SAMPLE Key 必须是int类型（如果不是，建表时不会报错但会在查询时得到异常）。</li></ol></blockquote><ul><li><p>SAMPLE factor</p><p>factor范围在[0,1]，当factor是0或1的时候等同于不采样</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ID</span> <span class="hljs-keyword">FROM</span> hits_t1 <span class="hljs-keyword">SAMPLE</span> <span class="hljs-number">0.1</span></code></pre></div><p>近似取10%的数据</p></li><li><p>SAMPLE rows</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>() <span class="hljs-keyword">FROM</span> hits_t1 <span class="hljs-keyword">SAMPLE</span> <span class="hljs-number">10000</span></code></pre></div><p>近似采样10000行的数据</p></li><li><p>SAMPLE factor OFFSET n</p><p>OFFSET 表示偏移量</p></li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>() <span class="hljs-keyword">FROM</span> hits_t1 <span class="hljs-keyword">SAMPLE</span> <span class="hljs-number">0.5</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0.4</span></code></pre></div><p>  从二分之一处按0.4的系数采样（若出现了溢出则自动截断）</p><h3 id="9-4-ARRAY-JOIN子句"><a href="#9-4-ARRAY-JOIN子句" class="headerlink" title="9.4 ARRAY JOIN子句"></a>9.4 ARRAY JOIN子句</h3><p>ARRAY JOIN 允许在表的内部，与数组或嵌套类型的字段进行JOIN操作，从而将一行数组展开为多行。（类似Hive里的<code>LATERNAL VIEW EXPLODE</code>函数）</p><p>例如在表query_t1中：</p><table><thead><tr><th>id</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>[1,2,3]</td></tr><tr><td>2</td><td>[3,4]</td></tr><tr><td>3</td><td>[ ]</td></tr></tbody></table><h4 id="9-4-1-INNER-ARRAY-JOIN"><a href="#9-4-1-INNER-ARRAY-JOIN" class="headerlink" title="9.4.1 INNER ARRAY JOIN"></a>9.4.1 INNER ARRAY JOIN</h4><ul><li>demo</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span> <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span></code></pre></div><p>得到结果：</p><table><thead><tr><th>id</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>1</td><td>3</td></tr><tr><td>2</td><td>3</td></tr><tr><td>2</td><td>4</td></tr></tbody></table><p>排除掉了空行</p><blockquote><p>跟Hive的数组行转列很像，Hive中是这样写的：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,v <span class="hljs-keyword">FROM</span> LATERNAL <span class="hljs-keyword">VIEW</span> <span class="hljs-keyword">EXPLODE</span>(<span class="hljs-keyword">value</span>,<span class="hljs-string">','</span>) table_tmp <span class="hljs-keyword">AS</span> v</code></pre></div></blockquote><ul><li>添加别名</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span>,v <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> v</code></pre></div><p>得到结果：</p><table><thead><tr><th>id</th><th>value</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>[1,2,3]</td><td>1</td></tr><tr><td>1</td><td>[1,2,3]</td><td>2</td></tr><tr><td>1</td><td>[1,2,3]</td><td>3</td></tr><tr><td>2</td><td>[3,4]</td><td>3</td></tr><tr><td>2</td><td>[3,4]</td><td>4</td></tr></tbody></table><h4 id="9-4-2-LEFT-ARRAY-JOIN"><a href="#9-4-2-LEFT-ARRAY-JOIN" class="headerlink" title="9.4.2 LEFT ARRAY JOIN"></a>9.4.2 LEFT ARRAY JOIN</h4><ul><li><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span>,v <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> v</code></pre></div></li></ul><p>得到结果：</p><table><thead><tr><th>id</th><th>value</th><th>v</th></tr></thead><tbody><tr><td>1</td><td>[1,2,3]</td><td>1</td></tr><tr><td>1</td><td>[1,2,3]</td><td>2</td></tr><tr><td>1</td><td>[1,2,3]</td><td>3</td></tr><tr><td>2</td><td>[3,4]</td><td>3</td></tr><tr><td>2</td><td>[3,4]</td><td>4</td></tr><tr><td>3</td><td>[ ]</td><td>0</td></tr></tbody></table><p>改为LEFT查询以后，在INNER JOIN 中被排除的空数组出现了在返回的结果集中。</p><blockquote><p>当同时对多个数组字段进行ARRAY JOIN 操作时，查询的计算逻辑是按行合并而不是产生笛卡尔积，例如</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span>,v,arrayMap(x -&gt; x * <span class="hljs-number">2</span>,<span class="hljs-keyword">value</span>) <span class="hljs-keyword">AS</span> mapv,v_1 <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> v,mapv <span class="hljs-keyword">AS</span> v_1</code></pre></div><p>得到结果：</p><table><thead><tr><th>id</th><th>value</th><th>v</th><th>mapv</th><th>v_1</th></tr></thead><tbody><tr><td>1</td><td>[1,2,3]</td><td>1</td><td>[2,4,6]</td><td>2</td></tr><tr><td>1</td><td>[1,2,3]</td><td>2</td><td>[2,4,6]</td><td>4</td></tr><tr><td>1</td><td>[1,2,3]</td><td>3</td><td>[2,4,6]</td><td>6</td></tr><tr><td>2</td><td>[3,4]</td><td>3</td><td>[6,8]</td><td>6</td></tr><tr><td>2</td><td>[3,4]</td><td>4</td><td>[6,8]</td><td>8</td></tr><tr><td>3</td><td>[ ]</td><td>0</td><td>[ ]</td><td>0</td></tr></tbody></table></blockquote><h3 id="9-5-JOIN子句"><a href="#9-5-JOIN子句" class="headerlink" title="9.5 JOIN子句"></a>9.5 JOIN子句</h3><p>ClickHouse的JOIN语法包含<strong>连接精度</strong>和<strong>连接类型</strong>两部分：连接精度+连接类型+JOIN</p><p>连接精度：ALL / ANY / ASOF (默认ALL)</p><p>连接类型：</p><ol><li>外连接：LEFT / RIGHT / FULL(OUTER)</li><li>内连接：INNER</li><li>外连接：CROSS</li></ol><h4 id="9-5-1-连接精度"><a href="#9-5-1-连接精度" class="headerlink" title="9.5.1 连接精度"></a>9.5.1 连接精度</h4><p>ALL：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中全部连接数据。</p><p>ANY：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中<strong>第一行</strong>连接数据。</p><p>ASOF：ASOF是一种模糊连接，它允许在连接键之后追加定义一个模糊连接的匹配条件 asof_column（感觉有点玄学，插个眼，mark）</p><h4 id="9-5-2-连接类型"><a href="#9-5-2-连接类型" class="headerlink" title="9.5.2 连接类型"></a>9.5.2 连接类型</h4><p>跟MySQL一样</p><h4 id="9-5-3-多表连接"><a href="#9-5-3-多表连接" class="headerlink" title="9.5.3 多表连接"></a>9.5.3 多表连接</h4><p>跟MySQL一样</p><h4 id="9-5-4-注意事项"><a href="#9-5-4-注意事项" class="headerlink" title="9.5.4 注意事项"></a>9.5.4 注意事项</h4><ol><li><p>关于性能</p><p>首先，应该遵循<strong>左大又小</strong>的原则，即将数据量小的表放在右侧（跟MySQL或Hive的小表JOIN大表不太一样），因为ClickHouse中所有连接方式，右表都会被全部加载到内存中与左表进行比较。</p><p>其次，<strong>JOIN查询目前没有缓存的支持</strong>，这意味着每一次JOIN查询，即便是连续执行的相同SQL，也都会生成一次全新的执行计划。故如果大量使用JOIN查询，则需要进一步考虑借助上次应用侧的缓存服务或使用JOIN表引擎来改善性能。</p><p>最后，如果是<strong>在大量维度属性不全的查询场景中，建议使用字典代替JOIN查询</strong>。因为在进行多表的连接查询时，查询会转换成两两连接的形式，这种“滚雪球”式的查询很可能带来性能问题。</p></li><li><p>关于空值策略与简写形式</p><p>ClickHouse中连接查询的空值（未被连接的数据）是由默认值填充的，这跟其他常见的数据库的策略不同（由Null填充）。ClickHouse中连接查询的空值策略是通过<code>join_use_nulls</code>参数指定的，默认为0，默认充填0（当该参数为1时，空值由Null填充）。</p><p>此外，JOIN Key支持简化写法，当数据表的连接字段名相同时，可以用<code>USING</code>语法简写，例如下面两条语句的效果是等同的：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.id,a.name,b.rate <span class="hljs-keyword">FROM</span> join_tb1 a<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> join_tb2 b <span class="hljs-keyword">ON</span> a.id = b.id<span class="hljs-comment">-- USING简写</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,rate <span class="hljs-keyword">FROM</span> join_tb1<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> join_tb2 <span class="hljs-keyword">USING</span> <span class="hljs-keyword">id</span></code></pre></div></li></ol><h3 id="9-6-WHERE与PREWHERE子句"><a href="#9-6-WHERE与PREWHERE子句" class="headerlink" title="9.6 WHERE与PREWHERE子句"></a>9.6 WHERE与PREWHERE子句</h3><p>WHERE子句基于条件表达式来实现数据过滤（这个跟其他数据库一样），如果过滤条件恰好是主键字段，则能够借助索引进一步加速查询，所以WHERE子句是查询语句能否启用索引的判断依据（前提是表引擎支持索引特性）。</p><p>PREWHERE目前只能用于MergeTree系列的表引擎，它是WHERE的一种优化，结果相同。它的不同之处在于：使用PREWHERE时，首先只会读取PREWHERE指定的列字段数据，用于数据过滤的条件判断，待数据过滤之后再读取SELECT声明的列字段以补全其余属性。所以再一些场合中PREWHERE相比WHERE处理的数据量更少（处理的数据行数可能没变，但是数据大小变小了），性能更高。</p><p>PREWHERE优化默认打开，会在条件合适的情况下将WHERE替换为PREWHERE，其参数设置语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> optimize_move_to_prewhere = <span class="hljs-number">1</span> <span class="hljs-comment">--参数为0时强制关闭</span></code></pre></div><h3 id="9-7-GROUP-BY子句"><a href="#9-7-GROUP-BY子句" class="headerlink" title="9.7 GROUP BY子句"></a>9.7 GROUP BY子句</h3><p>GROUP BY后声明的字段通常称为<strong>聚合键</strong>或Key，在ClickHouse中的聚合查询中 SELECT 后只声明了聚合函数，则可以省略GROUP BY关键字，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(a1),<span class="hljs-keyword">SUM</span>(a2) <span class="hljs-keyword">FROM</span> t1</code></pre></div><p>SELECT的字段只能是聚合键、聚合函数，否则会报错。</p><p>除了上述特性外，聚合查询还能配合<code>WITH ROLLUP</code>、<code>WITH CUBE</code>、<code>WITH TOTALS</code>三种修饰符获取额外的汇总信息。</p><h4 id="9-7-1-WITH-ROLLUP"><a href="#9-7-1-WITH-ROLLUP" class="headerlink" title="9.7.1 WITH ROLLUP"></a>9.7.1 WITH ROLLUP</h4><p>ROLLUP能够按照聚合键从右向左上卷，基于聚合函数依次生成分组小计和总计。如果聚合键为n​，则最终会生成小计的个数为n+1​。</p><h4 id="9-7-2-WITH-ROLLUP"><a href="#9-7-2-WITH-ROLLUP" class="headerlink" title="9.7.2 WITH ROLLUP"></a>9.7.2 WITH ROLLUP</h4><p>CUBE会像立方体模型一样，基于聚合键之间所有的组合生成小计信息。如果聚合键为n，则最终会生成小计的个数为2的n​次方。</p><h4 id="9-7-3-WITH-TOTALS"><a href="#9-7-3-WITH-TOTALS" class="headerlink" title="9.7.3 WITH TOTALS"></a>9.7.3 WITH TOTALS</h4><p>TOTALS会基于聚合函数对所有数据进行总计，例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a1,<span class="hljs-keyword">SUM</span>(a2),<span class="hljs-keyword">COUNT</span>(a3) <span class="hljs-keyword">FROM</span> t1<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a1 <span class="hljs-keyword">WITH</span> TOTALS</code></pre></div><p>其结果会额外显示累计总和的结果。</p><h3 id="9-10-LIMIT-BY子句"><a href="#9-10-LIMIT-BY子句" class="headerlink" title="9.10 LIMIT BY子句"></a>9.10 LIMIT BY子句</h3><p>LIMIT BY子句运行于ORDER BY 之后和LIMIT之前，最多返回<strong>前n​个字段</strong>的数据，其常规语法如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">LIMIT n BY 字段</code></pre></div><h2 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h2><h3 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h3><p>用Nx表示一个节点（服务器），例如N1,N2</p><p>副本和分片有时候一样，有时候不一样，区分方法：</p><p>如果N1的Y和N2的Y数据相同，则它们互为副本（N1Y = N2Y），否则互为分片（N1Y != N2Y）</p><h3 id="10-2-数据副本"><a href="#10-2-数据副本" class="headerlink" title="10.2 数据副本"></a>10.2 数据副本</h3><p>MegreTree表引擎前缀加了Replicated才有应用副本的能力（还有另一种副本的实现方式），例如ReplicatedMergeTree、ReplicatedReplacingMergeTree、ReplicatedSummingMergeTree，这类表引擎称为复制表系列引擎。</p><p>ReplicatedMergeTree在MergeTree的基础上加入了分布式协同的能力，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110102012.png" srcset="/img/loading.gif" lazyload="" width="70%"></p><p>在MergeTree中，一个数据分区由开始创建到全部完成，会经历两类存储区域：</p><ol><li>内存：数据首先会被写入内存缓冲区</li><li>本地磁盘：数据接着会被写入tmp临时目录分区，待全部完成后再将临时目录重新命名为正式分区</li></ol><ul><li>ReplicatedMergeTree在上述基础上增加了Zookeeper的部分，它会进一步在Zookeeper内创建一系列的监听节点，并以此实现多个实例之间的通信。在整个通信过程中，Zookeeper并不会涉及数据表的传输。</li></ul><h3 id="10-3-ReplicatedMergeTree原理解析"><a href="#10-3-ReplicatedMergeTree原理解析" class="headerlink" title="10.3 ReplicatedMergeTree原理解析"></a>10.3 ReplicatedMergeTree原理解析</h3><p>ReplicatedMergeTree的核心逻辑中，大量运用了Zookeeper的能力，以实现ReplicatedMergeTree副本实例之间的协同，包括主副本选举、副本状态感知、操作日志分发、任务队列和BlockID去重判断等。</p><p>副本协同的核心流程主要有<strong>INSERT</strong>、<strong>MERGE</strong>、<strong>MUTATION</strong>、<strong>ALTER</strong>，分别对应了数据写入、分区合并、数据修改、元数据修改。（其他查询不支持分布式执行，包括SELECT、CREATE、DROP、RENAME、ATTACH）</p><p>拟定一个用ReplicatedMergeTree实现一张拥有1分片、1副本的数据表的演示场景，其完整过程如下：</p><ul><li><p>INSERT的核心执行流程</p><ol><li>创建第一个副本实例</li><li>创建第二个副本实例</li><li>向第一个副本实例写入数据</li><li>由第一个副本实例推送Log日志</li><li>第二个副本实例拉取Log日志</li><li>第二个副本实例向其他副本发起下载请求</li><li>第一个副本实例响应数据下载</li><li>第二个实例下载数据并完成本地写入</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104346.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>MERGE的核心执行流程</p><ol><li>创建远程连接，尝试与主副本通信</li><li>主副本接收通信</li><li>由主副本制定MERGE计划并推送Log日志</li><li>各副本分别拉取Log日志</li><li>各个副本分别在本地执行MERGE</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104410.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>MUTATION的核心执行流程</p><ol><li>推送MUTATION日志</li><li>所有副本实例各自监听MUTATION日志</li><li>由主副本实例响应MUTATION日志并推送Log日志</li><li>各个副本实例分别拉取Log日志</li><li>各个副本实例分别在本地执行MUTATION</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104432.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>ALTER的核心执行流程</p><ol><li>修改共享元数据</li><li>监听共享元数据变更并各自执行本地修改</li><li>确认所有副本完成修改</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104609.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li></ul><h3 id="10-4-数据分片"><a href="#10-4-数据分片" class="headerlink" title="10.4 数据分片"></a>10.4 数据分片</h3><p>通过引入副本可以有效降低数据丢失的风险（多份存储），并提升查询的性能（分摊查询、读写分离），但是仍没有解决数据表容量的问题。每个副本保存了数据表全量的数据，所以在业务庞大的场景中，依靠副本并不能解决单表的性能瓶颈，所以需要将数据水平切分，也就分片（shard）。</p><p>数据表A分布在N个ClickHouse服务节点，且这些数据彼此之间没有重复数据，则称为数据表A有N个分片。为了进一步考虑数据在写入时，如何被均匀地写至各个分片，以及查询时路由到每个分片并组成结果集，所以ClickHouse的数据分片需要结合Distributed表引擎一同使用，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110330.png" srcset="/img/loading.gif" lazyload="" width="60%"></p><p>Distributed表引擎自身不存储任何数据，它能够作为分布式表的一层透明代理，在集群内部自动开展数据的写入、分发、查询、路由等工作。</p><p>接下来以创建test_1_local的过程为例子，解释分布式DDL的核心执行流程</p><ul><li><p>分布式DDL的核心执行流程</p><ol><li>推送DDL日志</li><li>拉取日志并执行</li><li>确认执行进度</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110947.png" srcset="/img/loading.gif" lazyload="" width="60%"></p></li></ul><h3 id="10-5-Distributed原理解析"><a href="#10-5-Distributed原理解析" class="headerlink" title="10.5 Distributed原理解析"></a>10.5 Distributed原理解析</h3><p>Distributed表引擎是作为数据分片的透明代理，能自动路由数据至集群中的各个节点，所以Distributed表引擎和其他数据表一起协同工作，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110112518.png" srcset="/img/loading.gif" lazyload="" width="60%"></p><ul><li>本地表：通常以 _local 为后缀进行命名。本地表是承载数据的载体，可以使用非Distributed的任意表引擎，一张本地表对应了一个数据分片</li><li>分布式表：通常以 _all 为后缀进行命名。分布式表只能用Distributed表引擎，它与本地表形成一对多的映射关系，日后将通过分布式表代理操作多张本地表<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>幂等性：指多次操作,结果是一致。 数学表达式为： f(x) = f(f(x))<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ClickHouse好秀啊&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>牛客SQL二刷</title>
    <link href="http://example.com/2021/10/04/%E7%89%9B%E5%AE%A2SQL%E4%BA%8C%E5%88%B7/"/>
    <id>http://example.com/2021/10/04/%E7%89%9B%E5%AE%A2SQL%E4%BA%8C%E5%88%B7/</id>
    <published>2021-10-04T07:04:37.000Z</published>
    <updated>2021-11-24T09:36:19.535Z</updated>
    
    <content type="html"><![CDATA[<p>二刷牛客80道SQL题</p><a id="more"></a><p><a href="https://www.nowcoder.com/activity/oj?tab=1" target="_blank" rel="noopener">牛客SQL题</a></p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> hire_date == ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(hire_date) <span class="hljs-keyword">FROM</span> employees )</code></pre></div><p>或</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> hire_date <span class="hljs-keyword">DESC</span><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span></code></pre></div><p>错误写法：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,<span class="hljs-keyword">MAX</span>(hire_date),first_name,last_name,gender,hire_date <span class="hljs-keyword">FROM</span> employees</code></pre></div><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> hire_date <span class="hljs-keyword">DESC</span><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">2</span>,<span class="hljs-number">1</span></code></pre></div><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.emp_no,t1.salary,t1.from_date,t1.to_date,t2.dept_no <span class="hljs-keyword">FROM</span> salaries t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_manager t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">WHERE</span> t2.dept_no <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.emp_no</code></pre></div><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.last_name,t1.first_name,t2.dept_no <span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">WHERE</span> t2.dept_no <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span></code></pre></div><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.last_name,t1.first_name,t2.dept_no <span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no</code></pre></div><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,<span class="hljs-keyword">COUNT</span>(emp_no) <span class="hljs-keyword">AS</span> t <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> emp_no<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(emp_no) &gt; <span class="hljs-number">15</span></code></pre></div><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> salary <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> emp_no <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> dept_manager)</code></pre></div><h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.emp_no,t2.emp_no <span class="hljs-keyword">FROM</span> dept_emp t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_manager t2<span class="hljs-keyword">ON</span> t1.dept_no = t2.dept_no <span class="hljs-keyword">WHERE</span> t1.emp_no &lt;&gt; t2.emp_no</code></pre></div><h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.dept_no,t1.emp_no,t2.salary<span class="hljs-keyword">FROM</span> dept_emp t1<span class="hljs-keyword">JOIN</span> salaries t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">WHERE</span> (dept_no,salary) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> dept_no,<span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> salary     <span class="hljs-keyword">FROM</span> dept_emp t1    <span class="hljs-keyword">JOIN</span> salaries t2    <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_no)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.dept_no</code></pre></div><h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> emp_no % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> last_name &lt;&gt; <span class="hljs-string">'Mary'</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> hire_date <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="16"><a href="#16" class="headerlink" title="16"></a>16</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.title,<span class="hljs-keyword">AVG</span>(t2.salary) <span class="hljs-keyword">FROM</span> titles t1<span class="hljs-keyword">JOIN</span> salaries t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.title<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">AVG</span>(t2.salary)</code></pre></div><h4 id="17"><a href="#17" class="headerlink" title="17"></a>17</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,salary <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>,<span class="hljs-number">1</span></code></pre></div><h4 id="18"><a href="#18" class="headerlink" title="18"></a>18</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.emp_no,t2.salary,t1.last_name,t1.first_name <span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">JOIN</span> salaries t2<span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">WHERE</span> salary <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> salary <span class="hljs-keyword">FROM</span> salaries    <span class="hljs-keyword">WHERE</span> salary &lt; (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> salary <span class="hljs-keyword">FROM</span> salaries))</code></pre></div><h4 id="19"><a href="#19" class="headerlink" title="19"></a>19</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name,first_name,dept_name <span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments t3 <span class="hljs-keyword">ON</span> t2.dept_no = t3.dept_no</code></pre></div><h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,(EndSalary- StartSalary) <span class="hljs-keyword">AS</span> growth <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> t1.emp_no,t2.salary <span class="hljs-keyword">AS</span> EndSalary,t3.salary <span class="hljs-keyword">AS</span> StartSalary    <span class="hljs-keyword">FROM</span> salaries t1    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-keyword">SELECT</span> emp_no,salary <span class="hljs-keyword">FROM</span> salaries        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span>=<span class="hljs-string">'9999-01-01'</span>    ) t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-keyword">SELECT</span> salaries.emp_no,salary <span class="hljs-keyword">FROM</span> salaries        <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> employees <span class="hljs-keyword">ON</span> salaries.emp_no = salaries.emp_no        <span class="hljs-keyword">WHERE</span> from_date = hire_date        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> salaries.emp_no    ) t3 <span class="hljs-keyword">ON</span> t2.emp_no = t3.emp_no    <span class="hljs-keyword">WHERE</span> t1.emp_no <span class="hljs-keyword">IN</span> (        <span class="hljs-comment">-- 查询在职员工编号</span>        <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> salaries        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span>=<span class="hljs-string">'9999-01-01'</span>    )    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.emp_no) t<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (EndSalary- StartSalary)</code></pre></div><p>错误写法（这种没考虑到降薪的情况）：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,(MaxSalary- MinSalary) <span class="hljs-keyword">AS</span> growth <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> emp_no,<span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> MaxSalary,<span class="hljs-keyword">MIN</span>(salary)  <span class="hljs-keyword">AS</span> MinSalary    <span class="hljs-keyword">FROM</span> salaries    <span class="hljs-keyword">WHERE</span> emp_no <span class="hljs-keyword">IN</span> (        <span class="hljs-comment">-- 查询在职员工编号</span>        <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> salaries        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span>=<span class="hljs-string">'9999-01-01'</span>    )    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> emp_no) t<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (MaxSalary- MinSalary)</code></pre></div><h4 id="22"><a href="#22" class="headerlink" title="22"></a>22</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t3.dept_no,t3.dept_name,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> salaries t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments t3 <span class="hljs-keyword">ON</span> t2.dept_no = t3.dept_no<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t3.dept_no<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t3.dept_no</code></pre></div><h4 id="23"><a href="#23" class="headerlink" title="23"></a>23</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> emp_no,salary,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">FROM</span> salaries</code></pre></div><h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t3.dept_no,t1.emp_no,t2.salary <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees    <span class="hljs-keyword">WHERE</span> emp_no <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> dept_manager    )) t1 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> salaries) t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> dept_emp) t3 <span class="hljs-keyword">ON</span> t2.emp_no = t3.emp_no<span class="hljs-keyword">WHERE</span> t3.dept_no <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span></code></pre></div><h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.emp_no,t4.emp_no,t1.salary,t4.salary<span class="hljs-keyword">FROM</span> salaries t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_manager t3 <span class="hljs-keyword">ON</span> t2.dept_no = t3.dept_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> salaries t4 <span class="hljs-keyword">ON</span> t3.emp_no = t4.emp_no<span class="hljs-keyword">WHERE</span> t1.salary &gt; t4.salary</code></pre></div><h4 id="26"><a href="#26" class="headerlink" title="26"></a>26</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.dept_no,t3.dept_name,t2.title,<span class="hljs-keyword">COUNT</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">FROM</span> dept_emp t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> titles t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> departments t3 <span class="hljs-keyword">ON</span> t1.dept_no = t3.dept_no<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.dept_no,t3.dept_name,t2.title<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.dept_no</code></pre></div><h4 id="28"><a href="#28" class="headerlink" title="28"></a>28</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t3.name,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> film t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> film_category t2 <span class="hljs-keyword">ON</span> t1.film_id = t2.film_id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">category</span> t3 <span class="hljs-keyword">ON</span> t2.category_id = t3.category_id<span class="hljs-keyword">WHERE</span> t1.description <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%robot%'</span> <span class="hljs-keyword">AND</span> t2.category_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> category_id <span class="hljs-keyword">FROM</span> film_category    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> category_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">5</span>)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t3.name</code></pre></div><h4 id="29"><a href="#29" class="headerlink" title="29"></a>29</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.film_id,t1.title <span class="hljs-keyword">FROM</span> film t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> film_category t2 <span class="hljs-keyword">ON</span> t1.film_id = t2.film_id<span class="hljs-keyword">WHERE</span> t2.category_id <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span></code></pre></div><h4 id="30"><a href="#30" class="headerlink" title="30"></a>30</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.title,t1.description <span class="hljs-keyword">FROM</span> film t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> film_category t2 <span class="hljs-keyword">ON</span> t1.film_id = t2.film_id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">category</span> t3 <span class="hljs-keyword">ON</span> t2.category_id = t3.category_id<span class="hljs-keyword">WHERE</span> t3.name = <span class="hljs-string">'Action'</span></code></pre></div><h4 id="32"><a href="#32" class="headerlink" title="32"></a>32</h4><ul><li>sqlite</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> last_name||<span class="hljs-string">' '</span>||first_name <span class="hljs-keyword">AS</span> <span class="hljs-keyword">Name</span> <span class="hljs-keyword">FROM</span> employees</code></pre></div><ul><li>MySQL</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONCAT</span>(last_name,<span class="hljs-string">' '</span>,first_name) <span class="hljs-keyword">FROM</span> employees</code></pre></div><h4 id="33"><a href="#33" class="headerlink" title="33"></a>33</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> actor(    actor_id <span class="hljs-built_in">smallint</span>(<span class="hljs-number">5</span>) PRIMARY <span class="hljs-keyword">KEY</span>,    first_name <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    last_name <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    last_update <span class="hljs-built_in">date</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>)</code></pre></div><h4 id="34"><a href="#34" class="headerlink" title="34"></a>34</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> actor<span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">'PENELOPE'</span>,<span class="hljs-string">'GUINESS'</span>,<span class="hljs-string">'2006-02-15 12:34:33'</span>),      (<span class="hljs-number">2</span>,<span class="hljs-string">'NICK'</span>,<span class="hljs-string">'WAHLBERG'</span>,<span class="hljs-string">'2006-02-15 12:34:33'</span>)</code></pre></div><h4 id="35"><a href="#35" class="headerlink" title="35"></a>35</h4><ul><li>MySQL</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">IGNORE</span> <span class="hljs-keyword">INTO</span> actor <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'3'</span>,<span class="hljs-string">'ED'</span>,<span class="hljs-string">'CHASE'</span>,<span class="hljs-string">'2006-02-15 12:34:33'</span>)</code></pre></div><ul><li>sqlite</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">IGNORE</span> <span class="hljs-keyword">INTO</span> actor <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'3'</span>,<span class="hljs-string">'ED'</span>,<span class="hljs-string">'CHASE'</span>,<span class="hljs-string">'2006-02-15 12:34:33'</span>)</code></pre></div><h4 id="36"><a href="#36" class="headerlink" title="36"></a>36</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> actor_name(    first_name <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    last_name <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> actor_name<span class="hljs-keyword">SELECT</span> first_name,last_name <span class="hljs-keyword">FROM</span> actor</code></pre></div><h4 id="37"><a href="#37" class="headerlink" title="37"></a>37</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> actor <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> uniq_idx_firstname(first_name);<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> actor <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> idx_lastname(last_name);</code></pre></div><h4 id="38"><a href="#38" class="headerlink" title="38"></a>38</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> actor_name_view <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">AS</span> first_name_v,last_name <span class="hljs-keyword">AS</span> last_name_v <span class="hljs-keyword">FROM</span> actor</code></pre></div><h4 id="39"><a href="#39" class="headerlink" title="39"></a>39</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> salaries <span class="hljs-keyword">FORCE</span> <span class="hljs-keyword">INDEX</span> (idx_emp_no) <span class="hljs-keyword">WHERE</span> emp_no = <span class="hljs-number">10005</span></code></pre></div><h4 id="40"><a href="#40" class="headerlink" title="40"></a>40</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> actor <span class="hljs-keyword">ADD</span> create_date datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'2020-10-01 00:00:00'</span></code></pre></div><h4 id="41"><a href="#41" class="headerlink" title="41"></a>41</h4><p>（这个不是我写的）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> audit_log<span class="hljs-keyword">after</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> employees_test<span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-keyword">row</span><span class="hljs-keyword">begin</span>    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">audit</span> <span class="hljs-keyword">values</span>(new.id,new.name);<span class="hljs-keyword">end</span></code></pre></div><h4 id="42"><a href="#42" class="headerlink" title="42"></a>42</h4><ul><li>MySQL</li></ul><p><strong>MySQL中不允许在子查询的同时删除表数据（不能一边查一边把查的表删了）</strong>，所以可以把得出的表重命名（因为那样就不是原表了）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> titles_test<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MIN</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">id</span>,emp_no <span class="hljs-keyword">FROM</span> titles_test        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> emp_no    ) t)</code></pre></div><p>sqlite也能这样写</p><h4 id="43"><a href="#43" class="headerlink" title="43"></a>43</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> titles_test <span class="hljs-keyword">SET</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-literal">null</span>,from_date =  <span class="hljs-string">'2001-01-01'</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="44"><a href="#44" class="headerlink" title="44"></a>44</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> titles_test <span class="hljs-keyword">SET</span> emp_no = <span class="hljs-keyword">REPLACE</span>(emp_no,<span class="hljs-number">10001</span>,<span class="hljs-number">10005</span>) <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">5</span></code></pre></div><h4 id="45"><a href="#45" class="headerlink" title="45"></a>45</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> titles_test <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> titles_2017</code></pre></div><h4 id="46"><a href="#46" class="headerlink" title="46"></a>46</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">audit</span><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (emp_no)<span class="hljs-keyword">REFERENCES</span> employees_test(<span class="hljs-keyword">id</span>)</code></pre></div><h4 id="48"><a href="#48" class="headerlink" title="48"></a>48</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> salaries <span class="hljs-keyword">JOIN</span> emp_bonus <span class="hljs-keyword">ON</span> emp_bonus.emp_no = salaries.emp_no<span class="hljs-keyword">SET</span> salary=salary*<span class="hljs-number">1.1</span><span class="hljs-keyword">WHERE</span> salaries.to_date=<span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="50"><a href="#50" class="headerlink" title="50"></a>50</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONCAT</span>(last_name,<span class="hljs-string">"'"</span>,first_name) <span class="hljs-keyword">FROM</span> employees</code></pre></div><h4 id="51"><a href="#51" class="headerlink" title="51"></a>51</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">LENGTH</span>(<span class="hljs-string">"10,A,B"</span>) - <span class="hljs-keyword">LENGTH</span>(<span class="hljs-keyword">REPLACE</span>(<span class="hljs-string">"10,A,B"</span>,<span class="hljs-string">','</span>,<span class="hljs-string">''</span>))</code></pre></div><h4 id="52"><a href="#52" class="headerlink" title="52"></a>52</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">SUBSTR</span>(first_name,<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">--从倒数第二开始，获取两个字符</span></code></pre></div><h4 id="53"><a href="#53" class="headerlink" title="53"></a>53</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> dept_no,<span class="hljs-keyword">GROUP_CONCAT</span>(emp_no SEPARATOR <span class="hljs-string">','</span>) <span class="hljs-keyword">FROM</span> dept_emp<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_no</code></pre></div><h4 id="54"><a href="#54" class="headerlink" title="54"></a>54</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(salary) <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span> <span class="hljs-keyword">AND</span> salary <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">AS</span> salary <span class="hljs-keyword">FROM</span> salaries    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span>    <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MIN</span>(salary) <span class="hljs-keyword">AS</span> salary <span class="hljs-keyword">FROM</span> salaries    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span>)</code></pre></div><h4 id="55"><a href="#55" class="headerlink" title="55"></a>55</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">5</span>,<span class="hljs-number">5</span></code></pre></div><h4 id="57"><a href="#57" class="headerlink" title="57"></a>57</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (    <span class="hljs-keyword">SELECT</span> emp_no <span class="hljs-keyword">FROM</span> dept_emp <span class="hljs-keyword">WHERE</span> dept_emp.emp_no = employees.emp_no)</code></pre></div><p>也可以写成</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> emp_no = (    <span class="hljs-keyword">SELECT</span> employees.emp_no <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept_emp    <span class="hljs-keyword">ON</span> dept_emp.emp_no = employees.emp_no    <span class="hljs-keyword">WHERE</span> dept_emp.emp_no <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>)</code></pre></div><h4 id="59"><a href="#59" class="headerlink" title="59"></a>59</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.emp_no,first_name,last_name,btype,salary,    <span class="hljs-keyword">IF</span>(btype=<span class="hljs-number">1</span>,salary*<span class="hljs-number">0.1</span>,<span class="hljs-keyword">IF</span>(btype=<span class="hljs-number">2</span>,salary*<span class="hljs-number">0.2</span>,salary*<span class="hljs-number">0.3</span>)) <span class="hljs-keyword">AS</span> bonu<span class="hljs-keyword">FROM</span> employees t1<span class="hljs-keyword">JOIN</span> emp_bonus t2 <span class="hljs-keyword">ON</span> t1.emp_no = t2.emp_no<span class="hljs-keyword">JOIN</span> salaries t3 <span class="hljs-keyword">ON</span> t1.emp_no = t3.emp_no<span class="hljs-keyword">WHERE</span> t3.to_date = <span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="60"><a href="#60" class="headerlink" title="60"></a>60</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> emp_no,salary,<span class="hljs-keyword">SUM</span>(salary) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> emp_no) <span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="61"><a href="#61" class="headerlink" title="61"></a>61</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> first_name <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> first_name,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name) <span class="hljs-keyword">AS</span> rn <span class="hljs-keyword">FROM</span> employees    ) t     <span class="hljs-keyword">WHERE</span> rn%<span class="hljs-number">2</span> = <span class="hljs-number">1</span>)</code></pre></div><h4 id="62"><a href="#62" class="headerlink" title="62"></a>62</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">FROM</span> grade<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">number</span><span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">3</span></code></pre></div><h4 id="63"><a href="#63" class="headerlink" title="63"></a>63</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-built_in">number</span>,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">FROM</span> passing_number</code></pre></div><h4 id="64"><a href="#64" class="headerlink" title="64"></a>64</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> person.id,person.name,task.content <span class="hljs-keyword">FROM</span> person<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> task <span class="hljs-keyword">ON</span> task.person_id = person.id</code></pre></div><h4 id="65"><a href="#65" class="headerlink" title="65"></a>65</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">type</span>)/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">type</span>=<span class="hljs-string">'no_completed'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">type</span>    <span class="hljs-keyword">FROM</span> email    <span class="hljs-keyword">WHERE</span> send_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>        <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">1</span>    )    <span class="hljs-keyword">AND</span> receive_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>        <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">1</span>    )) t<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div><h4 id="66"><a href="#66" class="headerlink" title="66"></a>66</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><h4 id="67"><a href="#67" class="headerlink" title="67"></a>67</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.name,t3.name,<span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> t2 <span class="hljs-keyword">ON</span> t1.user_id = t2.id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> t3 <span class="hljs-keyword">ON</span> t1.client_id = t3.id<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t2.name</code></pre></div><h4 id="68"><a href="#68" class="headerlink" title="68"></a>68</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">SUM</span>(tag)/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">3</span>) <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> t1.user_id,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">MIN</span>(t2.date) <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span> tag <span class="hljs-keyword">FROM</span> login t1    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> login t2    <span class="hljs-keyword">ON</span> t1.user_id = t2.user_id <span class="hljs-keyword">AND</span> t1.date = (t2.date - <span class="hljs-number">1</span>)    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.user_id) t</code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_id) / (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_id) <span class="hljs-keyword">FROM</span> login),<span class="hljs-number">3</span>)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">DATE_ADD</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>),<span class="hljs-built_in">INTERVAL</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)</code></pre></div><h4 id="69"><a href="#69" class="headerlink" title="69"></a>69</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> t1.date,<span class="hljs-keyword">IF</span>(cnt <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,cnt) <span class="hljs-keyword">FROM</span> login t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) t0    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) t2<span class="hljs-keyword">ON</span> t1.date = t2.date</code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment"># SELECT date,COUNT(*) FROM login</span><span class="hljs-comment"># WHERE (user_id,date) IN (</span><span class="hljs-comment">#     SELECT user_id,MIN(date) FROM login GROUP BY user_id</span><span class="hljs-comment"># )</span><span class="hljs-comment"># GROUP BY date</span><span class="hljs-comment">## 计数为 0 的日期没有现实(新写法基于这种写法改了下)</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">SUM</span>(    <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span>     <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">END</span>)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div><h4 id="70"><a href="#70" class="headerlink" title="70"></a>70</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> t5.date,<span class="hljs-keyword">IF</span>(p <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,p) <span class="hljs-keyword">FROM</span> login t5<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> t3.date,<span class="hljs-keyword">ROUND</span>(t4.num/t3.num,<span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> p     <span class="hljs-keyword">FROM</span> (        <span class="hljs-comment">-- 计算当天新用户数</span>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> (            <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        ) t1        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>    ) t3    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-comment">-- 计算新用户次日留存数</span>        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">DATE</span>(t2.date<span class="hljs-number">-1</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login t1        <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (            <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        ) t2 <span class="hljs-keyword">ON</span> t1.user_id = t2.user_id <span class="hljs-keyword">AND</span> t1.date = t2.date        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t2.date     ) t4    <span class="hljs-keyword">ON</span> t3.date = t4.date) t6 <span class="hljs-keyword">ON</span> t5.date = t6.date</code></pre></div><h4 id="71"><a href="#71" class="headerlink" title="71"></a>71</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.name,t1.date,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> passing_number t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> t2 <span class="hljs-keyword">ON</span> t1.user_id = t2.id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">name</span></code></pre></div><h4 id="72"><a href="#72" class="headerlink" title="72"></a>72</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">AVG</span>(score),<span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> AvgScore <span class="hljs-keyword">FROM</span> grade<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> AvgScore <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="73"><a href="#73" class="headerlink" title="73"></a>73</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.id,t1.job,t1.score <span class="hljs-keyword">FROM</span> grade t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">AVG</span>(score) <span class="hljs-keyword">AS</span> score <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) t2<span class="hljs-keyword">ON</span> t1.job = t2.job<span class="hljs-keyword">WHERE</span> t1.score &gt; t2.score<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.id</code></pre></div><h4 id="74"><a href="#74" class="headerlink" title="74"></a>74</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,score <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> t1.id,<span class="hljs-keyword">name</span>,score,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> language_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rn    <span class="hljs-keyword">FROM</span> grade t1    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-string">`language`</span> t2    <span class="hljs-keyword">ON</span> t1.language_id = t2.id) t<span class="hljs-keyword">WHERE</span> rn &lt;=<span class="hljs-number">2</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">name</span>,score <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="75"><a href="#75" class="headerlink" title="75"></a>75</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     job,    <span class="hljs-keyword">IF</span>(cnt%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(cnt/<span class="hljs-number">2</span>),<span class="hljs-keyword">ROUND</span>(cnt/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-string">`start`</span>,    <span class="hljs-keyword">IF</span>(cnt%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(cnt/<span class="hljs-number">2</span>),<span class="hljs-keyword">ROUND</span>(cnt/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-string">`end`</span><span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) t<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> job</code></pre></div><h4 id="76"><a href="#76" class="headerlink" title="76"></a>76</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,rn2 <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>         t1.job,        t1.id,        t1.score,        t2.cnt,        ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score) <span class="hljs-keyword">AS</span> rn1,        ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rn2    <span class="hljs-keyword">FROM</span> grade t1    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) t2    <span class="hljs-keyword">ON</span> t1.job = t2.job) t<span class="hljs-keyword">WHERE</span> rn1 &gt;= cnt/<span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> rn2 &gt;= cnt/<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,t_rank <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> grade) c<span class="hljs-keyword">WHERE</span> (job,t_rank) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> job,<span class="hljs-keyword">ROUND</span>(t_rank,<span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a    <span class="hljs-keyword">UNION</span>    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a    <span class="hljs-keyword">UNION</span>    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job        ) a    ) b    <span class="hljs-keyword">WHERE</span> t_rank &lt;&gt; <span class="hljs-string">'NULL'</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><h4 id="77"><a href="#77" class="headerlink" title="77"></a>77</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><h4 id="78"><a href="#78" class="headerlink" title="78"></a>78</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id) a<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">num</span> &gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-comment">-- #写法二：</span><span class="hljs-comment">-- SELECT DISTINCT user_id FROM order_info</span><span class="hljs-comment">-- WHERE user_id IN (</span><span class="hljs-comment">--     SELECT user_id FROM order_info</span><span class="hljs-comment">--     WHERE status = 'completed' </span><span class="hljs-comment">--     AND product_name IN ('C++','Java','Python')</span><span class="hljs-comment">--     AND date &gt; '2025-10-15'</span><span class="hljs-comment">--     GROUP BY user_id</span><span class="hljs-comment">--     HAVING COUNT(*) &gt;= 2</span><span class="hljs-comment">-- )</span><span class="hljs-comment">-- ORDER BY user_id</span></code></pre></div><h4 id="79"><a href="#79" class="headerlink" title="79"></a>79</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,user_id,product_name,<span class="hljs-keyword">status</span>,client_id,<span class="hljs-built_in">date</span><span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>) t<span class="hljs-keyword">WHERE</span> cnt &gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span>    )<span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span></code></pre></div><h4 id="80"><a href="#80" class="headerlink" title="80"></a>80</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>),<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><h4 id="81"><a href="#81" class="headerlink" title="81"></a>81</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     user_id,    <span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">CASE</span> rn <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">END</span>)),    <span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">CASE</span> rn <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">END</span>)),    <span class="hljs-keyword">COUNT</span>(*)<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>         user_id,        <span class="hljs-built_in">date</span>,        ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> rn    <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    <span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)) t<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> order_info.user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(order_info.date)),b.date,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,user_id,<span class="hljs-built_in">date</span>,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    ) a    <span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">2</span>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id) b <span class="hljs-keyword">ON</span> order_info.user_id = b.user_id<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> order_info.product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> order_info.date &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> order_info.user_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_info.user_id</code></pre></div><h4 id="82"><a href="#82" class="headerlink" title="82"></a>82</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     t1.id,    is_group_buy,    <span class="hljs-keyword">IF</span>(is_group_buy = <span class="hljs-string">'NO'</span>,t2.name,<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>) t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">client</span>) t2<span class="hljs-keyword">ON</span> t1.client_id = t2.id<span class="hljs-keyword">WHERE</span> cnt &gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> order_info.id,order_info.is_group_buy,client.name <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> order_info.client_id = client.id<span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-12'</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;=<span class="hljs-number">2</span>)<span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-12'</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_info.id</code></pre></div><h4 id="83"><a href="#83" class="headerlink" title="83"></a>83</h4><ul><li>新的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">name</span> <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">'GroupBuy'</span>,<span class="hljs-keyword">name</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">source</span>,    cnt <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span>             *,            <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> client_id) <span class="hljs-keyword">AS</span> cnt,            <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id) <span class="hljs-keyword">AS</span> user_num        <span class="hljs-keyword">FROM</span> order_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>        <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)        <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>        ) t0     <span class="hljs-keyword">WHERE</span> user_num &gt;= <span class="hljs-number">2</span>) t1<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">client</span>) t2<span class="hljs-keyword">ON</span> t1.client_id = t2.id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t1.client_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">name</span> <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>,<span class="hljs-string">'GroupBuy'</span>,<span class="hljs-keyword">name</span>)</code></pre></div><ul><li>旧的写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">IFNULL</span>(client.name,<span class="hljs-string">'GroupBuy'</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">source</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>        <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)        <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span>    )    <span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    ) a<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> a.client_id = client.id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client.name<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">source</span></code></pre></div><h4 id="84"><a href="#84" class="headerlink" title="84"></a>84</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> resume_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">SUBSTR</span>(<span class="hljs-built_in">date</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) = <span class="hljs-string">'2025'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span></code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> resume_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(<span class="hljs-built_in">date</span>) = <span class="hljs-string">'2025'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="85"><a href="#85" class="headerlink" title="85"></a>85</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span> resume_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">SUBSTR</span>(<span class="hljs-built_in">date</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) = <span class="hljs-string">'2025'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="86"><a href="#86" class="headerlink" title="86"></a>86</h4><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t1.job,t1.mon,t1.cnt,t2.mon,t2.cnt<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> resume_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2025</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span>) t1,(    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> resume_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2026</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span>) t2<span class="hljs-keyword">WHERE</span> t1.job =t2.job<span class="hljs-keyword">AND</span> <span class="hljs-keyword">SUBSTR</span>(t1.mon,<span class="hljs-number">-2</span>) = <span class="hljs-keyword">SUBSTR</span>(t2.mon,<span class="hljs-number">-2</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t1.mon <span class="hljs-keyword">DESC</span>,job <span class="hljs-keyword">DESC</span></code></pre></div><h4 id="87"><a href="#87" class="headerlink" title="87"></a>87</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> grade,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">FROM</span> class_grade</code></pre></div><h4 id="86-1"><a href="#86-1" class="headerlink" title="86"></a>86</h4><ul><li>新写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> grade <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>          grade,        <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">AS</span> rn1,        <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rn2,        (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> class_grade) t<span class="hljs-keyword">WHERE</span> t.rn1 &gt;= cnt/<span class="hljs-number">2</span><span class="hljs-keyword">AND</span> t.rn2 &gt;= cnt/<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade</code></pre></div><ul><li>旧写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> grade <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>  grade,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">AS</span> rs1,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs2    <span class="hljs-keyword">FROM</span> class_grade    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  grade) t<span class="hljs-keyword">WHERE</span> t.rs1 &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade)/<span class="hljs-number">2</span><span class="hljs-keyword">AND</span> t.rs2 &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade)/<span class="hljs-number">2</span></code></pre></div><h4 id="89"><a href="#89" class="headerlink" title="89"></a>89</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>,grade_sum <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>,<span class="hljs-keyword">SUM</span>(grade_num) <span class="hljs-keyword">AS</span> grade_sum <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>    <span class="hljs-keyword">JOIN</span> grade_info    <span class="hljs-keyword">ON</span> user.id = grade_info.user_id    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">name</span>) t<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade_sum <span class="hljs-keyword">DESC</span><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>,<span class="hljs-number">1</span></code></pre></div><h4 id="90"><a href="#90" class="headerlink" title="90"></a>90</h4><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.id,user.name,grade_sum<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade_sum <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(grade_num) <span class="hljs-keyword">AS</span> grade_sum <span class="hljs-keyword">FROM</span> grade_info        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) t1) t2<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = b.user_id<span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.id</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二刷牛客80道SQL题&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据仓库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
      <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Hive同步业务库MySQL表方案</title>
    <link href="http://example.com/2021/10/04/Hive%E5%90%8C%E6%AD%A5%E4%B8%9A%E5%8A%A1%E5%BA%93MySQL%E8%A1%A8%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2021/10/04/Hive%E5%90%8C%E6%AD%A5%E4%B8%9A%E5%8A%A1%E5%BA%93MySQL%E8%A1%A8%E6%96%B9%E6%A1%88/</id>
    <published>2021-10-04T06:58:41.000Z</published>
    <updated>2021-11-24T09:36:39.025Z</updated>
    
    <content type="html"><![CDATA[<p>一些常见的Hive同步业务库MySQL（MySQL数据导入到Hive表）的操作</p><a id="more"></a><p>Hive表数据同步（数据采集）业务库MySQL表的步骤：</p><ol><li>找到MySQL表，查看表结构或建表语句</li><li>创建Hive表</li><li>创建调度作业</li><li>触发调度调度，核对数据</li></ol><p>具体来看看常见的<strong>全量同步</strong>和<strong>增量同步</strong>两种方式</p><h2 id="全量同步采集"><a href="#全量同步采集" class="headerlink" title="全量同步采集"></a>全量同步采集</h2><p>我们以天表为例（也有小时表，但都一样的）</p><ol><li><p>找到mysql建表语句</p><p>我们假设建表语句如下，这里只有三个字段</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`mysql_store_gmv`</span> (  <span class="hljs-string">`dt`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">25</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日期'</span>,  <span class="hljs-string">`store_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'店铺ID'</span>,   <span class="hljs-string">`gmv`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'该店铺当天成交金额总和'</span>  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4090</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'店铺gmv'</span></code></pre></div></li><li><p>创建Hive表</p><p>Hive表的创建与MySQL有点不一样，具体创建语句如下（推荐在MySQL建表语句的基础上做一些删减）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`hive_store_gmv`</span> (  <span class="hljs-string">`dt`</span> <span class="hljs-keyword">string</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日期'</span>,  <span class="hljs-string">`store_id`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'店铺ID'</span>,   <span class="hljs-string">`gmv`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'该店铺当天成交金额总和'</span>) <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'店铺gmv'</span></code></pre></div><p>很明显，这里删掉了MySQL字段的一些默认信息，并且去除了主键和选择的存储引擎</p><blockquote><p>MySQL建表语句改成Hive建表的一些常见处理：（在MySQL建表语句的基础上修改）</p><ol><li>删除DEFAULT NULL</li><li>删除自增id</li><li>删除主键</li><li>int(11)或int(10)改成int</li><li>varchar 改成string</li><li>datetime改成string</li><li>删除选择存储引擎和编码等信息</li><li>……</li></ol></blockquote></li><li><p>创建调度作业</p><p>这里的话如果有比较完善的数据平台会相对简单点</p><p>注意点：</p><ol><li><p>不能<code>SELECT * FROM tablename</code>（因为随着业务的发展，表很可能会增加字段）</p><p>正确的方式是该把需要同步的字段写出来，例如同步上表需要写成：</p><p><code>SELECT dt,store_id,gmv FROM mysql_store_gmv</code></p></li><li><p>需要加上不在当天重复调度的WHERE条件</p><p>这里需要考虑两个点，一个是对某天重复调度，所以需要考虑到触发作业后删除当天得到的数据；另一个就是非当天调度，比如在2021年9月12日这天跑过一次了，但是可能会2021年9月13日再触发一次这个同步作业</p></li></ol><p>所以我们需要写出这样，调度作业触发后执行以下SQL：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除(删除Hive表的当天分区数据)</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> hive_store_gmv <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PARTITION</span> (dt=<span class="hljs-keyword">CURDATE</span>());<span class="hljs-comment">-- 查询</span><span class="hljs-keyword">SELECT</span> dt,store_id,gmv <span class="hljs-keyword">FROM</span> mysql_store_gmv<span class="hljs-keyword">WHERE</span> dt &lt;= <span class="hljs-keyword">CURDATE</span>()<span class="hljs-comment">-- 插入（插入到Hive表的当天分区）</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hive_store_gmv <span class="hljs-keyword">PARTITION</span> (dt=<span class="hljs-keyword">CURDATE</span>())(dt,    store_id,    gmv)<span class="hljs-keyword">VALUES</span>($<span class="hljs-number">0</span>,$<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>)<span class="hljs-comment">--三个字段</span></code></pre></div></li></ol><h2 id="增量同步采集"><a href="#增量同步采集" class="headerlink" title="增量同步采集"></a>增量同步采集</h2><p>增量同步基本上与全量同步处理方法一样有第二步和第三步</p><p>增量同步一般建议创建dt分区（日期作为分区）</p><p>增量同步需删除当天数据</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除</span><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> hive_store_gmv <span class="hljs-keyword">WHERE</span> dt = <span class="hljs-keyword">CURDATE</span>()<span class="hljs-comment">--删除当天数据</span><span class="hljs-comment">-- 查询</span><span class="hljs-keyword">SELECT</span> dt,store_id,gmv <span class="hljs-keyword">FROM</span> mysql_store_gmv<span class="hljs-keyword">WHERE</span> dt = <span class="hljs-keyword">CURDATE</span>()<span class="hljs-comment">-- 插入（插入到Hive表的当天分区）</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hive_store_gmv <span class="hljs-keyword">PARTITION</span> (dt=<span class="hljs-keyword">CURDATE</span>())(dt,    store_id,    gmv)<span class="hljs-keyword">VALUES</span>($<span class="hljs-number">0</span>,$<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>)<span class="hljs-comment">--三个字段</span></code></pre></div><h2 id="Hive表导入到MySQL表"><a href="#Hive表导入到MySQL表" class="headerlink" title="Hive表导入到MySQL表"></a>Hive表导入到MySQL表</h2><p>Hive表数据导入（数据采集）业务库MySQL表的步骤：(就Hive表和MySQL表反过来呗)</p><ol><li>找到Hive表，查看表结构或建表语句</li><li>创建MySQL表</li><li>创建调度作业</li><li>触发调度调度，核对数据</li></ol><h3 id="无自增id"><a href="#无自增id" class="headerlink" title="无自增id"></a>无自增id</h3><p>就跟采集那样，但是反过来</p><h3 id="有自增id"><a href="#有自增id" class="headerlink" title="有自增id"></a>有自增id</h3><p>如果MySQL有自增id，那Hive表里是不用管的（hive插入的时候不用插入id这个字段）</p><p>如果Hive表结构是这样的</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`mysql_store_gmv`</span> (  <span class="hljs-string">`dt`</span> <span class="hljs-keyword">string</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日期'</span>,  <span class="hljs-string">`store_id`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'店铺ID'</span>,   <span class="hljs-string">`gmv`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'该店铺当天成交金额总和'</span>) <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'店铺gmv'</span></code></pre></div><p>而MySQL又需要自增id，则MySQL建表语句是这样的（相比上面的例子，这里增加了id这个字段，注意后面的参数是<kbd>AUTO_INCREMENT</kbd>）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`mysql_store_gmv`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`dt`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">25</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'日期'</span>,  <span class="hljs-string">`store_id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'店铺ID'</span>,   <span class="hljs-string">`gmv`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'该店铺当天成交金额总和'</span>  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4090</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">'店铺gmv'</span></code></pre></div><p>Hive表插入到MySQL的语句如下（忽略id）：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hive_store_gmv <span class="hljs-keyword">PARTITION</span> (dt=<span class="hljs-keyword">CURDATE</span>()) (dt,    store_id,    gmv)<span class="hljs-keyword">VALUES</span>($<span class="hljs-number">0</span>,$<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>)<span class="hljs-comment">--三个字段</span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些常见的Hive同步业务库MySQL（MySQL数据导入到Hive表）的操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据仓库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
      <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>我心里有B树</title>
    <link href="http://example.com/2021/08/28/%E6%88%91%E5%BF%83%E9%87%8C%E6%9C%89B%E6%A0%91/"/>
    <id>http://example.com/2021/08/28/%E6%88%91%E5%BF%83%E9%87%8C%E6%9C%89B%E6%A0%91/</id>
    <published>2021-08-28T06:07:07.000Z</published>
    <updated>2021-11-24T08:48:38.654Z</updated>
    
    <content type="html"><![CDATA[<p>介绍数据结构里的各种树</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>数据结构里，树是最考验也是最锻炼逻辑思维的。但是对我这种心里没B树的人来说，看到啥二叉树、二叉排序树、平衡二叉树、B树、B+树、B*树就一脸懵逼。在这里将逐一介绍各种树及其用途，从此成为心里有B树的人。</p><h2 id="树的一些概念"><a href="#树的一些概念" class="headerlink" title="树的一些概念"></a>树的一些概念</h2><ul><li><p>结点</p><p><strong>结点</strong>是数据结构中的基础，是构成复杂数据结构的基本组成单位。（有些也写作“节点”）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828144643.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>结点的度</p><p>度表示每个结点拥有的<strong>子树个数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828144703.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>结点关系</p><ul><li>孩子结点：结点子树的根结点为该结点的<strong>孩子结点</strong>，例如上图B为A的孩子结点(也称作”子结点”或”子节点”)。</li><li>双亲结点：相应该结点称为孩子结点的<strong>双亲结点</strong>，例如上图A为B的双亲结点</li><li>兄弟结点： 同一个双亲结点的孩子结点之间互称<strong>兄弟结点</strong>，结点B与结点C互为兄弟结点。</li></ul></li><li><p>结点层次</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828145422.png" srcset="/img/loading.gif" lazyload="" alt=""></p></li><li><p>树的高度（深度）</p><p>就是树的最大层数，例如上面的树高度为4</p></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828145911.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>这是一颗普通的二叉树，普通的二叉树具有如下特点：</p><p>1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。<br>2）左子树和右子树是有顺序的，次序不能任意颠倒。<br>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p><h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>二叉排序树又称为二叉查找树、二叉搜索树</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828145903.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>二叉排序树的特点：左边比根节点小，右边比根节点大</p><p>但问题来了，有些情况例如：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828150219.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>这其实也是个二叉排序树（确实左边节点的都比根节点小）</p><p>这种二叉排序树就退化成链表了</p><p>这个时候树的高度就很大了，树的高度很大并不利于一些查找，所以需要平衡树，在插入的时候同时调整这棵树，让他的节点尽可能均匀分布。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是平衡树的一种，来看它的树结构</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828150642.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>显然红黑树在努力的保证树的平衡性，这么做的主要目的是降低树的高度，因为树的查找性能取决于树的高度，因而通常二叉树越是平衡则查找性能越高。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>红黑树这种结构已经让树的高度很低了，那有没有办法让树的高度更低呢？</p><p>注意，红黑树还是<strong>二叉树</strong>的一种，它的每个节点的度不能大于2，即每个节点最多有2个子节点。</p><p>这个时候出现不讲武德的了：<strong>B树</strong>，它通常用在<strong>文件系统索引</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828151557.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>为什么说它不讲武德呢，因为这个已经不是二叉树了（也是搜索树的一种，但不是二叉树了）。上图这是一个３路的B树，它的每个节点最多可以拥有３个孩子节点。</p><p>B树设计成多路的目的主要是进一步降低树的高度。虽说树的高度越低越好，但是如果无限所路的B树就退化成有序数组了：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828151930.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>那按照之前这么说，树的高度越低查找性能越好，那有序数组查找性能岂不是最好？</p><p>注意，B树通常用在文件系统和数据库的索引，而这些索引一般是存在硬盘上的，在写入到硬盘之前需要加载到内存上，如果数据量太大，并不一定能一次性加载到内存中。所以，用有序数组来当索引其实并不合适，因为可能会撑爆内存。</p><p>这时候B树的多路存储的优越性就体现出来了，可以从根节点开始每次只加载B树的一个节点到内存，然后一步步往下找。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828152556.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p><strong>在内存中，红黑树比B树效率更高；但在磁盘操作中，B树更优</strong></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是以B树为基础的，它的<strong>数据都在叶子结点</strong>，同时叶子结点之间还加了指针形成列表。(如图，跟B树一样都是利用分治思想，但B+树的最下面一层的叶子结点就存着所有的数据了)</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828152811.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>B+树通常较多用在<strong>数据库索引</strong>，因为select数据通常并不只select一条，通常会select很多条。如果是多条，B树需要做局部的中序遍历，可能需要跨层访问。而B+树由于所有数据都在叶子结点，所以不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。</p><p>例如从7找到19，B+树只需要在叶子结点中就能找到。而如果是B树，而可能要跑到上层根结点搜索。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210828153200.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>B+树的查找和树的高度有关，复杂度是$O( log(n) )$，如果用hash存储索引，平均时间复杂度是$O(1)$，但hash存储索引比B+树存储索引更优越仅仅局限于 select的数据为一条的时候，由于在数据库中通常是查询多条数据，所以数据库的索引较多用B+树而不是hash。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/vROSLrWv0gbKMi1rJT6eWA" target="_blank" rel="noopener">为什么MySQL数据库要用B+树存储索引？</a></p><p><a href="https://www.jianshu.com/p/bf73c8d50dc2" target="_blank" rel="noopener">深入学习二叉树(一) 二叉树基础</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍数据结构里的各种树&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>SQL类型题总结</title>
    <link href="http://example.com/2021/08/15/SQL%E7%B1%BB%E5%9E%8B%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/08/15/SQL%E7%B1%BB%E5%9E%8B%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2021-08-14T18:48:13.000Z</published>
    <updated>2021-11-24T08:32:22.517Z</updated>
    
    <content type="html"><![CDATA[<p> 两万字牛客、leetcode的SQL题型总结</p><a id="more"></a><blockquote><p><strong>阅读提示：</strong></p><p>为了SQL语句的简洁和便于阅读，每道题中的子查询在下一步骤中可能用表别名表示而不全写出来</p><p>例如：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 子查询（表别名命名为a）</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> a <span class="hljs-comment">--这里的a表示上面的子查询，在SQL中这样是不可运行的，这里只是为了方便阅读</span><span class="hljs-comment">-- 正确写法（鉴于易读性，中间步骤通常不这样写，会写成像上面那样，只有最后的完整SQL语句才这样写出）</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> t) a</code></pre></div></blockquote><h2 id="累计求和"><a href="#累计求和" class="headerlink" title="累计求和"></a>累计求和</h2><h4 id="SQL60-统计salary的累计和running-total（较难）"><a href="#SQL60-统计salary的累计和running-total（较难）" class="headerlink" title="SQL60 统计salary的累计和running_total（较难）"></a><a href="https://www.nowcoder.com/practice/58824cd644ea47d7b2b670c506a159a6?tpId=82&amp;&amp;tqId=29828&amp;rp=1&amp;ru=/ta/sql&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL60</strong> <strong>统计salary的累计和running_total</strong></a>（较难）</h4><blockquote><p>描述</p><p>按照salary的累计和running_total，其中running_total为前N个当前( to_date = ‘9999-01-01’)员工的salary累计和，其他以此类推。 具体结果如下Demo展示。。<br>CREATE TABLE <code>salaries</code> ( <code>emp_no</code> int(11) NOT NULL,<br><code>salary</code> int(11) NOT NULL,<br><code>from_date</code> date NOT NULL,<br><code>to_date</code> date NOT NULL,<br>PRIMARY KEY (<code>emp_no</code>,<code>from_date</code>));<br>输出格式:</p><table><thead><tr><th align="left">emp_no</th><th align="left">salary</th><th align="left">running_total</th></tr></thead><tbody><tr><td align="left">10001</td><td align="left">88958</td><td align="left">88958</td></tr><tr><td align="left">10002</td><td align="left">72527</td><td align="left">161485</td></tr><tr><td align="left">10003</td><td align="left">43311</td><td align="left">204796</td></tr><tr><td align="left">10004</td><td align="left">74057</td><td align="left">278853</td></tr></tbody></table></blockquote><p>根据题目描述，简单得说就是给定一个表，两个字段（emp_no，salary），按照emp_no进行排序，生成一个名为running_total的字段，该字段是salary的累计和。（WHERE s2.to_date = ‘9999-01-01’这个条件是牛客的奇葩条件，不过他这么说我们就这么写吧）</p><ul><li>方法一</li></ul><p>最朴素的解法就是来个自连接，原表简写为<code>s1</code>，再来一个表并命名为<code>s2</code>，并对<code>s2</code>的salary字段进行求和，这里有个关键的条件是<code>s2.emp_no &lt;= s1.emp_no</code>，这样就可以把范围限定在所在行从而实现累计求和了，SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 方法一（用另一个表来限定求和范围）</span><span class="hljs-keyword">SELECT</span> s1.emp_no, s1.salary,(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(s2.salary)<span class="hljs-keyword">FROM</span> salaries <span class="hljs-keyword">AS</span> s2<span class="hljs-keyword">WHERE</span> s2.emp_no &lt;= s1.emp_no<span class="hljs-keyword">AND</span> s2.to_date = <span class="hljs-string">'9999-01-01'</span>) <span class="hljs-keyword">AS</span> running_total<span class="hljs-keyword">FROM</span> salaries <span class="hljs-keyword">AS</span> s1<span class="hljs-keyword">WHERE</span> s1.to_date = <span class="hljs-string">'9999-01-01'</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> s1.emp_no</code></pre></div><ul><li>方法二</li></ul><p>上面这种方法比较原始，SQL也提供了开窗函数（或称作窗口函数）来实现这样的功能，<code>SUM+OVER</code>可以达到开窗函数的功能，SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 方法二（开窗函数）</span><span class="hljs-keyword">SELECT</span> emp_no,salary,<span class="hljs-keyword">SUM</span>(salary) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> emp_no) <span class="hljs-keyword">AS</span> running_total<span class="hljs-keyword">FROM</span> salaries<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">to_date</span> = <span class="hljs-string">'9999-01-01'</span></code></pre></div><h4 id="SQL71-牛客每个人最近的登录日期-六-（较难）"><a href="#SQL71-牛客每个人最近的登录日期-六-（较难）" class="headerlink" title="SQL71 牛客每个人最近的登录日期(六)（较难）"></a><a href="https://www.nowcoder.com/practice/572a027e52804c058e1f8b0c5e8a65b4?tpId=82&amp;&amp;tqId=35089&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL71</strong> <strong>牛客每个人最近的登录日期(六)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客每个用户查询刷题信息，包括: 用户的名字，以及截止到某天，累计总共通过了多少题。 不存在没有登录却刷题的情况，但是存在登录了没刷题的情况，不会存在刷题表里面，有提交代码没有通过的情况，但是会记录在刷题表里，只不过通过数目是0。<br>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903934415_A5E822A1E15CEBC7E16183ECD9D7CC7A" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网<br>。。。<br>第5行表示user_id为3的用户在2020-10-13使用了客户端id为2的设备登录了牛客网</p><p>有一个刷题（passing_number)表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903944909_9C60ECB78BE56145269BDFA74F1074D3" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12通过了4个题目。<br>。。。<br>第3行表示user_id为1的用户在2020-10-13提交了代码但是没有通过任何题目。<br>第4行表示user_id为4的用户在2020-10-13通过了2个题目</p><p>还有一个用户(user)表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903952301_4763AF7B377AF42CB5A87C53B965DC45" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>请你写出一个sql语句查询刷题信息，包括: 用户的名字，以及截止到某天，累计总共通过了多少题，并且查询结果先按照日期升序排序，再按照姓名升序排序，有登录却没有刷题的哪一天的数据不需要输出，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20201015/557336_1602736313104_6BE4C7264FB9F7CED1DD6A6D44652D6C" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>fh在2020-10-12为止，总共通过了4道题，输出为4<br>wangchao在2020-10-12为止，总共通过了1道题，总计为1<br>tm在2020-10-12为止只登陆了没有刷题，故没有显示出来<br>tm在2020-10-13为止刷了题，但是却没有通过任何题目，总计为0<br>wangchao在2020-10-13通过2道，但是加上前面2020-10-12通过1道，故在2020-10-13为止总共通过了3道题，总计为3</p></blockquote><p>还是排序，但是这里需要先分区再排序</p><ol><li><p>分组排序</p><p><code>SELECT user_id,date,SUM(number) OVER(PARTITION BY user_id ORDER BY user_id,date) FROM passing_number</code></p><p>这样基本上就完成的差不多了</p></li><li><p><code>JOIN</code>连接，将 user_id 替换成 user_name</p></li><li><p><code>ORDER BY</code>排序</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.name,<span class="hljs-built_in">date</span>,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> passing_number<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ON</span> passing_number.user_id = user.id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>,user.name</code></pre></div><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><h4 id="SQL73-考试分数-二-（中等）"><a href="#SQL73-考试分数-二-（中等）" class="headerlink" title="SQL73 考试分数(二)（中等）"></a><a href="https://www.nowcoder.com/practice/f456dedf88a64f169aadd648491a27c1?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL73</strong> <strong>考试分数(二)</strong></a>（中等）</h4><blockquote><p>描述</p><p>牛客每次考试完，都会有一个成绩表(grade)，如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434140530/A40EBCABDBC68539EE224EE1DC2A7FE7" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示用户id为1的用户选择了C++岗位并且考了11001分</p><p>。。。</p><p>第8行表示用户id为8的用户选择了前端岗位并且考了9999分</p><p>请你写一个sql语句查询用户分数大于其所在工作(job)分数的平均分的所有grade的属性，并且以id的升序排序，如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434164748/393D7F7211F18AF58DCC405ABAAB04DD" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>(注意: sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5，sqlite四舍五入的函数为round)</p></blockquote><ol><li><p>先求出每个岗位的平均分</p><blockquote><p>– 子查询（平均分）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">AVG</span>(score) <span class="hljs-keyword">AS</span> score <span class="hljs-keyword">FROM</span> grade<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job</code></pre></div></blockquote></li><li><p>表连接</p><p><code>JOIN</code>连接两个表之后，相当于把两个表拼接，那么子查询就相当于是一个字段了</p></li><li><p>WHERE 条件过滤</p><p><code>a.score &gt; b.score</code></p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,a.job,a.score <span class="hljs-keyword">FROM</span> grade a<span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">AVG</span>(score) <span class="hljs-keyword">AS</span> score <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) b<span class="hljs-keyword">ON</span> a.job = b.job<span class="hljs-keyword">WHERE</span> a.score &gt; b.score<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><h4 id="SQL86-实习广场投递简历分析-三-（困难）"><a href="#SQL86-实习广场投递简历分析-三-（困难）" class="headerlink" title="SQL86 实习广场投递简历分析(三)（困难）"></a><a href="https://www.nowcoder.com/practice/83f84aa5c32b4cf5a75558d02dd7743c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL86</strong> <strong>实习广场投递简历分析(三)</strong></a>（困难）</h4><blockquote><p>描述</p><p>在牛客实习广场有很多公司开放职位给同学们投递，同学投递完就会把简历信息存到数据库里。</p><p>现在有简历信息表(resume_info)，部分信息简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210305/301499_1614930662852/E587507D0FC15C77027A0B0E39B12F10" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示，在2025年1月2号，C++岗位收到了53封简历</p><p>。。。</p><p>最后1行表示，在2027年2月6号，C++岗位收到了231封简历</p><p>请你写出SQL语句查询在2025年投递简历的每个岗位，每一个月内收到简历的数目，和对应的2026年的同一个月同岗位，收到简历的数目，最后的结果先按first_year_mon月份降序，再按job降序排序显示，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210305/301499_1614931927046/10AF6822A92E37CE34B3EFFF8522E033" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>第1行表示Python岗位在2025年2月收到了93份简历，在对应的2026年2月收到了846份简历</p><p>。。。</p><p>最后1行表示C++岗位在2025年1月收到了107份简历，在对应的2026年1月收到了470份简历</p></blockquote><p>这道题难度说是困难，但其实很简单。</p><ol><li><p>首先看字段，像不像是两个<code>(job,date,cnt)</code>字段的表进行连接。得到只有左边三个字段很容易的，所以我们先查询得到这部分：</p><blockquote><p>– 子查询</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span> resume_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2025</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span></code></pre></div></blockquote><p>​        那么要得到2026年的数据，只需要把上面的WHERE条件中的2025改成2026即可。</p></li><li><p>我们将上面两个子表（2025年数据和2026年数据）分别命名为a、b，然后进行连接</p><blockquote><p>– 表连接</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.job,a.mon,a.cnt,b.mon,b.cnt<span class="hljs-keyword">FROM</span> a, b<span class="hljs-keyword">WHERE</span> a.job =b.job<span class="hljs-keyword">AND</span> <span class="hljs-keyword">SUBSTR</span>(a.mon,<span class="hljs-number">-2</span>) = <span class="hljs-keyword">SUBSTR</span>(b.mon,<span class="hljs-number">-2</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.mon <span class="hljs-keyword">DESC</span>,job <span class="hljs-keyword">DESC</span></code></pre></div></blockquote><p>这里表连接有两个连接词，一个是<code>job</code>，另一个是<code>mon的后面两个字符串</code>(即月份)，因为2025年和2026年不同，所以需要把年份去掉，即只取月份。这里用<code>SUBSTR()</code>函数实现（该函数仅用于字符串类型），<code>SUBSTR(mon,-2)</code>表示取mon字段的最后两个字符。</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.job,a.mon,a.cnt,b.mon,b.cnt<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> resume_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2025</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span>) a,(    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y-%m'</span>) <span class="hljs-keyword">AS</span> mon,<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">num</span>) <span class="hljs-keyword">AS</span> cnt    <span class="hljs-keyword">FROM</span> resume_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">DATE_FORMAT</span>(<span class="hljs-built_in">date</span>,<span class="hljs-string">'%Y'</span>) = <span class="hljs-number">2026</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job,mon    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> mon <span class="hljs-keyword">DESC</span>,cnt <span class="hljs-keyword">DESC</span>) b<span class="hljs-keyword">WHERE</span> a.job =b.job<span class="hljs-keyword">AND</span> <span class="hljs-keyword">SUBSTR</span>(a.mon,<span class="hljs-number">-2</span>) = <span class="hljs-keyword">SUBSTR</span>(b.mon,<span class="hljs-number">-2</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.mon <span class="hljs-keyword">DESC</span>,job <span class="hljs-keyword">DESC</span></code></pre></div><h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><h4 id="SQL75-考试分数-四-（较难）"><a href="#SQL75-考试分数-四-（较难）" class="headerlink" title="SQL75 考试分数(四)（较难）"></a><a href="https://www.nowcoder.com/practice/502fb6e2b1ad4e56aa2e0dd90c6edf3c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL75</strong> <strong>考试分数(四)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每次考试完，都会有一个成绩表(grade)，如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434754935/ECC08FF796C5751177B2300798551D67" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示用户id为1的用户选择了C++岗位并且考了11001分</p><p>。。。</p><p>第8行表示用户id为8的用户选择了B语言岗位并且考了9999分</p><p>请你写一个sql语句查询各个岗位分数升序排列之后的中位数位置的范围，并且按job升序排序，结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434773205/02F13D43D70927AC143B7ADE08DC301F" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解释:</p><p>第1行表示C++岗位的中位数位置范围为[2,2]，也就是2。因为C++岗位总共3个人，是奇数，所以中位数位置为2是正确的(即位置为2的10000是中位数)</p><p>第2行表示Java岗位的中位数位置范围为[1,2]。因为Java岗位总共2个人，是偶数，所以要知道中位数，需要知道2个位置的数字，而因为只有2个人，所以中位数位置为[1,2]是正确的(即需要知道位置为1的12000与位置为2的13000才能计算出中位数为12500)</p><p>第3行表示前端岗位的中位数位置范围为[2,2]，也就是2。因为B语言岗位总共3个人，是奇数，所以中位数位置为2是正确的(即位置为2的11000是中位数)</p><p>(注意: sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5，sqlite四舍五入的函数为round，sqlite不支持floor函数，支持cast(x as integer) 函数，不支持if函数，支持case when …then …else ..end函数)</p></blockquote><p>中位数！！！咋一看以为这是排序题，然后发现并不需要排序</p><p>思路：</p><ol><li><p>GROUP BY + COUNT(*)统计各个岗位的数量</p><p><code>SELECT job,COUNT(*) AS num FROM grade  GROUP BY job</code></p><p>将查询结果命名为子表a</p></li><li><p>用<code>IF(expr1,a,b)</code>将岗位数分为单数、双数两种情况处理</p><p>其中，当岗位数为单数时，start和end相同，其中位数都是(这里岗位数命名为num) num/2并向上取整【例如，5的中位数是5/2并向上取整，即3】</p><p>当岗位数为双数时，其中位数start是num/2，end是num/2+1【例如，6的两个中位数分别是6/2即3，以及6/2+1即4】</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)) ,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)) <span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) a<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> job</code></pre></div><h4 id="SQL76-考试分数-五"><a href="#SQL76-考试分数-五" class="headerlink" title="SQL76 考试分数(五)"></a><a href="#NIUKE_SQL76">SQL76 考试分数(五)</a></h4><h3 id="正序-逆序"><a href="#正序-逆序" class="headerlink" title="正序+逆序"></a>正序+逆序</h3><h4 id="SQL88-最差是第几名-二-（较难）"><a href="#SQL88-最差是第几名-二-（较难）" class="headerlink" title="SQL88 最差是第几名(二)（较难）"></a><a href="https://www.nowcoder.com/practice/165d88474d434597bcd2af8bf72b24f1?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL88</strong> <strong>最差是第几名(二)</strong></a>（较难）</h4><blockquote><p>描述</p><p>TM小哥和FH小妹在牛客大学若干年后成立了牛客SQL班，班的每个人的综合成绩用A,B,C,D,E表示，90分以上都是A，80<del>90分都是B，60</del>70分为C，50~60为D，E为50分以下</p><p>因为每个名次最多1个人，比如有2个A，那么必定有1个A是第1名，有1个A是第2名(综合成绩同分也会按照某一门的成绩分先后)。</p><p>每次SQL考试完之后，老师会将班级成绩表展示给同学看。</p><p>现在有班级成绩表(class_grade)如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210310/301499_1615348808889/89751765A8ABF251A21CBC1F35C7E2D8" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示成绩为A的学生有2个</p><p>…….</p><p>最后1行表示成绩为D的学生有2个</p><p>老师想知道学生们综合成绩的中位数是什么档位，请你写SQL帮忙查询一下，如果只有1个中位数，输出1个，如果有2个中位数，按grade升序输出，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210310/301499_1615348944255/9CE3BEF4C093F1FBE8525594E5882325" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>总体学生成绩排序如下:A, A, B, B, B, B, C, C, C, C, D, D，总共12个数，取中间的2个，取6，7为:B,</p></blockquote><p>思路：</p><p>因为中位数可能有两个（累计和为单数和双数两种情况），故可以采用另一种思路，<strong>正逆序累计和都大于等于综合的一半</strong>。</p><p>生成两个累计和，一个正序一个逆序，当正序和逆序都大于等于总和的一半时，即为中位数，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210810013846.png" srcset="/img/loading.gif" lazyload="" alt=""></p><ol><li><p>生成正逆序累计和</p><blockquote><p>– 子查询（正逆序累计和）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  grade,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">AS</span> rs1,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs2<span class="hljs-keyword">FROM</span> class_grade<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  grade</code></pre></div></blockquote></li><li><p>外层嵌套，加上过滤条件</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> grade <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>  grade,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade) <span class="hljs-keyword">AS</span> rs1,<span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs2    <span class="hljs-keyword">FROM</span> class_grade    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>  grade) t<span class="hljs-keyword">WHERE</span> t.rs1 &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade)/<span class="hljs-number">2</span><span class="hljs-keyword">AND</span> t.rs2 &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(<span class="hljs-built_in">number</span>) <span class="hljs-keyword">FROM</span> class_grade)/<span class="hljs-number">2</span></code></pre></div><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h4 id="SQL51-查找字符串-10-A-B-中逗号-出现的次数cnt（中等）"><a href="#SQL51-查找字符串-10-A-B-中逗号-出现的次数cnt（中等）" class="headerlink" title="SQL51 查找字符串 10,A,B 中逗号,出现的次数cnt（中等）"></a><a href="https://www.nowcoder.com/practice/e3870bd5d6744109a902db43c105bd50?tpId=82&amp;&amp;tqId=29819&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL51</strong> <strong>查找字符串 10,A,B 中逗号,出现的次数cnt</strong></a>（中等）</h4><blockquote><p>描述</p><p>查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。</p><p>示例1</p><p>输入：</p><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">"10,A,B"</span></code></pre></div><p>输出：</p><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-number">2.0000</span></code></pre></div></blockquote><p>思路：用<code>REPLACE()</code>函数替换需要处理的字符串，将逗号替换为空，用<code>length()</code>函数统计原字符串长度以及处理后的字符串长度，相减得到个数</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> (<span class="hljs-keyword">length</span>(<span class="hljs-string">'10,A,B'</span>) - <span class="hljs-keyword">length</span>(<span class="hljs-keyword">REPLACE</span>(<span class="hljs-string">'10,A,B'</span>,<span class="hljs-string">","</span>,<span class="hljs-string">""</span>))) <span class="hljs-keyword">AS</span> cnt</code></pre></div><blockquote><p>拓展：此题不需要取整，如果需要取整的话可以用<code>ROUND()</code>函数</p></blockquote><h4 id="SQL52-获取Employees中的first-name（中等）"><a href="#SQL52-获取Employees中的first-name（中等）" class="headerlink" title="SQL52 获取Employees中的first_name（中等）"></a><a href="https://www.nowcoder.com/practice/74d90728827e44e2864cce8b26882105?tpId=82&amp;&amp;tqId=29820&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL52</strong> <strong>获取Employees中的first_name</strong></a>（中等）</h4><p>（我觉得题名该写成<strong>SQL52</strong> <strong>获取Employees中的first_name并按照first_name后两个字符串排序</strong>）</p><blockquote><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列<br>CREATE TABLE <code>employees</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>birth_date</code> date NOT NULL,<br><code>first_name</code> varchar(14) NOT NULL,<br><code>last_name</code> varchar(16) NOT NULL,<br><code>gender</code> char(1) NOT NULL,<br><code>hire_date</code> date NOT NULL,<br>PRIMARY KEY (<code>emp_no</code>));<br>输出格式：</p><table><thead><tr><th align="left">first_name</th></tr></thead><tbody><tr><td align="left">Chirstian</td></tr><tr><td align="left">Tzvetan</td></tr><tr><td align="left">Bezalel</td></tr><tr><td align="left">Duangkaew</td></tr></tbody></table></blockquote><p>这个是很常规的<code>select 字段名 from tablename order by</code>型题，但是这里重在<strong>按照字段的最后两个字母排序</strong>。<code>SUBSTR()</code>函数可以获取字符串的部分字符，所以这里可以用<code>SUBSTR(first_name,-2)</code>，表示获取first_name字符串的最后两个字符，于是SQL实现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">SUBSTR</span>(first_name,<span class="hljs-number">-2</span>)</code></pre></div><blockquote><p>拓展</p><p>1、substr函数格式  (字符截取函数) </p><div class="hljs code-wrapper"><pre><code class="hljs sql">　　<span class="hljs-comment">-- 格式1 </span>　　substr(stringname, a, b);　　<span class="hljs-comment">-- 格式2</span>　　substr(stringname, a) ;</code></pre></div><p>解析：</p><p>格式1：<br> 1、string 需要截取的字符串<br>  2、a 截取字符串的开始位置（注：当a等于0或1时，都是从第一位开始截取）<br> 3、b 要截取的字符串的长度</p><p>格式2：<br> 1、string 需要截取的字符串<br> 2、a 可以理解为从第a个字符开始截取后面所有的字符串。</p></blockquote><p>此外，也可以用<code>RIGHT()</code>函数，这题将SUBSRT函数换成``RIGHT(first_name,2)<code>也可以达到同样的效果，表示从右开始数截取两个字符（所以</code>LEFT(first_name,2)<code>函数就表示从左开始截取first_name字段的2个字符）。限于认知水平，本人觉得</code>RIGHT()<code>和</code>LEFT()`很鸡肋。</p><h4 id="SQL83-牛客的课程订单分析-七-（较难）"><a href="#SQL83-牛客的课程订单分析-七-（较难）" class="headerlink" title="SQL83 牛客的课程订单分析(七)（较难）"></a><a href="https://www.nowcoder.com/practice/d6f4a37f966145da8900ba9edcc4c068?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL83</strong> <strong>牛客的课程订单分析(七)</strong></a>（较难）</h4><blockquote><p>描述</p><p>有很多同学在牛客购买课程来学习，购买会产生订单存到数据库里。</p><p>有一个订单信息表(order_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614323798769/031537881B33EBB979D8E6E63131CE63" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为557336的用户在2025-10-10的时候使用了client_id为1的客户端下了C++课程的<strong>非拼团**</strong>(is_group_buy<strong><strong>为</strong></strong>N<strong><strong>o</strong></strong>)**订单，但是状态为没有购买成功。</p><p>第2行表示user_id为230173543的用户在2025-10-12的时候使用了client_id为2的客户端下了Python课程的非拼团<strong>(is_group_buy**</strong>为<strong><strong>N</strong></strong>o<strong>**)</strong>订单，状态为购买成功。</p><p>。。。</p><p>最后1行表示user_id为557336的用户在2025-10-25的时候使用了下了C++课程的拼团<strong>(is_group_buy**</strong>为<strong>**Yes)</strong>订单，拼团不统计客户端，所以<strong>client_id</strong>所以为<strong>0</strong>，状态为购买成功。</p><p>有一个客户端表(client)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614323833226/E5783422025D1F46BE7EF16FEE660647" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>请你写出一个sql语句查询在2025-10-15以后，同一个用户下单2个以及2个以上状态为购买成功的C++课程或Java课程或Python课程的来源信息，第一列是显示的是客户端名字，如果是拼团订单则显示GroupBuy，第二列显示这个客户端(或者是拼团订单)有多少订单，最后结果按照第一列(source)升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614323840965/A1722B1F53A15FC02282C10E33E90645" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>id为4，6的订单满足以上条件，且因为4是通过IOS下单的非拼团订单，则记: IOS 1</p><p>，6是通过PC下单的非拼团订单，则记: PC 1;</p><p>id为5，7的订单满足以上条件，且因为5与7都是拼团订单，则记: GroupBuy 2;</p><p>最后按照source升序排序。</p></blockquote><p>思路：</p><ol><li><p>先获得符合条件的数据作为子表，还是依赖WHERE 条件实现过滤，整体思路是：</p><p>`SELECT * FROM order_info WHERE user_id IN (    )</p><div class="hljs code-wrapper"><pre><code>`</code></pre></div><p>然后将条件补充完整，如下：</p><blockquote><p>– 子查询</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span>)<span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span></code></pre></div></blockquote></li><li><p>上述已经是一个符合条件的数据，所以接下来只需要进行<code>GROUP BY</code>分组查询即可</p><p>这里注意要用LEFT/RIGHT JOIN连接，并且将NULL替换成’GroupBuy’</p><blockquote><p>– 分组查询</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">IFNULL</span>(client.name,<span class="hljs-string">'GroupBuy'</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">source</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span>  a <span class="hljs-comment">-- 上述的子查询表</span><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> a.client_id = client.id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client.name<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">source</span></code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">IFNULL</span>(client.name,<span class="hljs-string">'GroupBuy'</span>) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">source</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt<span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> order_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>        <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)        <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">2</span>    )    <span class="hljs-keyword">AND</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    ) a<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> a.client_id = client.id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client.name<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">source</span></code></pre></div><h2 id="字段拼接"><a href="#字段拼接" class="headerlink" title="字段拼接"></a>字段拼接</h2><h4 id="将employees表中的所有员工的last-name和first-name通过引号连接起来（中等）"><a href="#将employees表中的所有员工的last-name和first-name通过引号连接起来（中等）" class="headerlink" title="将employees表中的所有员工的last_name和first_name通过引号连接起来（中等）"></a><a href="https://www.nowcoder.com/practice/810bf4ee3ac64949b08983aa66ec7bee?tpId=82&amp;&amp;tqId=29818&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>将employees表中的所有员工的last_name和first_name通过引号连接起来</strong></a>（中等）</h4><blockquote><p>描述</p><p>将employees表中的所有员工的last_name和first_name通过(‘)连接起来。(sqlite不支持concat，请用||实现，mysql支持concat)<br>CREATE TABLE <code>employees</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>birth_date</code> date NOT NULL,<br><code>first_name</code> varchar(14) NOT NULL,<br><code>last_name</code> varchar(16) NOT NULL,<br><code>gender</code> char(1) NOT NULL,<br><code>hire_date</code> date NOT NULL,<br>PRIMARY KEY (<code>emp_no</code>));<br>输出格式:</p><table><thead><tr><th align="left">name</th></tr></thead><tbody><tr><td align="left">Facello’Georgi</td></tr><tr><td align="left">Simmel’Bezalel</td></tr><tr><td align="left">Bamford’Parto</td></tr></tbody></table></blockquote><p><code>CONCAT( )</code>函数可以实现两个字段拼接，例如<code>CONCAT(a,b)</code>可以将字段a和字段b拼接成一个字段，如果拼接三个字段则<code>CONCAT(a,b,c)</code>，因而该题SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CONCAT</span>(last_name,<span class="hljs-string">"'"</span>,first_name) <span class="hljs-keyword">FROM</span> employees</code></pre></div><h4 id="SQL53-按照dept-no进行汇总（中等）"><a href="#SQL53-按照dept-no进行汇总（中等）" class="headerlink" title="SQL53 按照dept_no进行汇总（中等）"></a><a href="https://www.nowcoder.com/practice/6e86365af15e49d8abe2c3d4b5126e87?tpId=82&amp;tqId=29813&amp;rp=1&amp;ru=%2Factivity%2Foj&amp;qru=%2Fta%2Fsql%2Fquestion-ranking" target="_blank" rel="noopener"><strong>SQL53</strong> <strong>按照dept_no进行汇总</strong></a>（中等）</h4><blockquote><p>描述</p><p>按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees<br>CREATE TABLE <code>dept_emp</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>dept_no</code> char(4) NOT NULL,<br><code>from_date</code> date NOT NULL,<br><code>to_date</code> date NOT NULL,<br>PRIMARY KEY (<code>emp_no</code>,<code>dept_no</code>));<br>输出格式:</p><table><thead><tr><th align="left">dept_no</th><th align="left">employees</th></tr></thead><tbody><tr><td align="left">d001</td><td align="left">10001,10002</td></tr><tr><td align="left">d002</td><td align="left">10006</td></tr><tr><td align="left">d003</td><td align="left">10005</td></tr><tr><td align="left">d004</td><td align="left">10003,10004</td></tr></tbody></table></blockquote><p><code>CONCAT()</code>函数可以拼接两个或多个字段，所以这里的思路是对每个dept_no分组，然后拼接。</p><p>但CONCAT并不是聚合函数，在GROUP BY操作之后用CONCAT并不会将字段拼接（只会显示第一个），所以这里需要用聚合函数<code>GROUP_CONCAT</code>，正确SQL实现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> dept_no,<span class="hljs-keyword">GROUP_CONCAT</span>(emp_no) employees<span class="hljs-keyword">FROM</span> dept_emp <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> dept_no</code></pre></div><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h4 id="SQL61-对于employees表中，给出奇数行的first-name（较难）"><a href="#SQL61-对于employees表中，给出奇数行的first-name（较难）" class="headerlink" title="SQL61 对于employees表中，给出奇数行的first_name（较难）"></a><a href="https://www.nowcoder.com/practice/e3cf1171f6cc426bac85fd4ffa786594?tpId=82&amp;&amp;tqId=29829&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL61</strong> <strong>对于employees表中，给出奇数行的first_name</strong></a>（较难）</h4><p>（我觉得题名该写成<strong>SQL61</strong> <strong>对于employees表中，first_name的行号由升序排序，给出结果数据顺序与原表相同的奇数行的first_name</strong>）</p><blockquote><p>描述</p><p>对于employees表中，输出first_name排名(按first_name升序排序)为奇数的first_name<br>CREATE TABLE <code>employees</code> (<br><code>emp_no</code> int(11) NOT NULL,<br><code>birth_date</code> date NOT NULL,<br><code>first_name</code> varchar(14) NOT NULL,<br><code>last_name</code> varchar(16) NOT NULL,<br><code>gender</code> char(1) NOT NULL,<br><code>hire_date</code> date NOT NULL,</p><p>PRIMARY KEY (<code>emp_no</code>));</p><p>如，输入为：</p><p>INSERT INTO employees VALUES(10001,’1953-09-02’,’Georgi’,’Facello’,’M’,’1986-06-26’);<br>INSERT INTO employees VALUES(10002,’1964-06-02’,’Bezalel’,’Simmel’,’F’,’1985-11-21’);<br>INSERT INTO employees VALUES(10005,’1955-01-21’,’Kyoichi’,’Maliniak’,’M’,’1989-09-12’);<br>INSERT INTO employees VALUES(10006,’1953-04-20’,’Anneke’,’Preusig’,’F’,’1989-06-02’);</p><p>输出格式:</p><table><thead><tr><th align="left">first_name</th></tr></thead><tbody><tr><td align="left">Georgi</td></tr><tr><td align="left">Anneke</td></tr></tbody></table><p>因为Georgi按first_name排名为3，Anneke按first_name排名为1，所以会输出这2个，且输出时不需排序。</p></blockquote><p>先不看题目描述的最后一行（因为Georgi按first_name排名为3，Anneke按first_name排名为1，所以会输出这2个，且输出时不需排序。）</p><p>这种情况用开窗函数<code>ROW_NUMBER() OVER(ORDER BY 排序字段名)</code>先得到一个有序号的字段，然后将这个表作为子查询结果（因为最终结果不要ROW_NUMBER() OVER( )得到的这个字段），只保留first_name这个字段，并且加上WHERE条件筛选出奇数行，SQL语句如下（由里到外看）：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> ( <span class="hljs-keyword">SELECT</span> first_name,ROW_NUMBER() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name) <span class="hljs-keyword">AS</span> rs    <span class="hljs-keyword">FROM</span> employees) a <span class="hljs-keyword">WHERE</span> rs % <span class="hljs-number">2</span> = <span class="hljs-number">1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name</code></pre></div><p>OK，如果没有题目的最后一行描述，那么已经大功告成了，但是事情并没有那么简单。</p><p>当加上最后一行的题目描述，我们需要结果是原来插入的那个顺序输出，所以不能是开窗函数排序后的结果那样输出。</p><ul><li>方法一（套娃）</li></ul><p>思路：因为排序需要用原表的顺序，所以总体思路是最后还是FROM 原表，也就是<code>FROM employees</code></p><p>在上述的基础上，我们将筛选得到的first_name字段用在WHERE语句上再嵌套一层，用<code>WHERE 字段名 IN</code>的方法实现，SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> employees<span class="hljs-keyword">WHERE</span> first_name <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> first_name <span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> first_name,ROW_NUMBER() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name) <span class="hljs-keyword">AS</span> rs        <span class="hljs-keyword">FROM</span> employees    ) a     <span class="hljs-keyword">WHERE</span> rs % <span class="hljs-number">2</span> = <span class="hljs-number">1</span>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name)</code></pre></div><p>简单粗暴哈哈哈</p><ul><li><p>方法二（表连接）</p><p><a href="https://blog.nowcoder.net/n/ec78e0fb848b46f4b7d431775ca41b9b?f=comment" target="_blank" rel="noopener">牛客用户：77栗子松糕</a></p><p>本质上都一样（都是from原表），只是这里将子查询作为一个表来与原表连接了</p></li></ul><h4 id="SQL63-刷题通过的题目排名（中等）"><a href="#SQL63-刷题通过的题目排名（中等）" class="headerlink" title="SQL63 刷题通过的题目排名（中等）"></a><a href="https://www.nowcoder.com/practice/cd2e10a588dc4c1db0407d0bf63394f3?tpId=82&amp;&amp;tqId=35080&amp;rp=1&amp;ru=/ta/sql&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL63</strong> <strong>刷题通过的题目排名</strong></a>（中等）</h4><blockquote><p>描述</p><p>在牛客刷题有一个通过题目个数的(passing_number)表，id是主键，简化如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200813/557336_1597308916086_6B7E692D15E9D27D855F76C56E00D52A" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示id为1的用户通过了4个题目;…..第6行表示id为6的用户通过了4个题目;请你根据上表，输出通过的题目的排名，通过题目个数相同的，排名相同，此时按照id升序排列，数据如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20201105/557336_1604558013211_15EB7DEE744C7810B57ED3EF3D65D7FE" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>id为5的用户通过了5个排名第1，id为1和id为6的都通过了2个，并列第2</p></blockquote><p>这题与普通的排序题类似，不一样的是这里的排名有重复的，所以不能用<code>row_number()</code>函数，需要用<code>dense_rank()</code>函数，直接<code>DENSE_RANK() OVER(ORDER BY number DESC)</code>将number降序排序（即number值大的排序序号较小），SQL实现如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-built_in">number</span>,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> t_rank <span class="hljs-keyword">FROM</span> passing_number<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> t_rank,<span class="hljs-keyword">id</span></code></pre></div><blockquote><p>拓展</p><p><a href="https://www.cnblogs.com/qiuting/p/7880500.html" target="_blank" rel="noopener">row_number()、rank()、dense_rank() 的区别</a></p><p><strong>row_numbe</strong>r的用途非常广泛，排序最好用它，它会为查询出来的每一行记录生成一个序号，依次排序且不会重复，注意使用row_number函数时必须要用over子句选择对某一列进行排序才能生成序号。</p><p><strong>rank</strong>函数用于返回结果集的分区内每行的排名，行的排名是相关行之前的排名数加一。简单来说rank函数就是对查询出来的记录进行排名，与row_number函数不同的是，rank函数考虑到了over子句中排序字段值相同的情况，如果使用rank函数来生成序号，over子句中排序字段值相同的序号是一样的，后面字段值不相同的序号将跳过相同的排名号排下一个，也就是相关行之前的排名数加一，可以理解为根据当前的记录数生成序号，后面的记录依此类推。</p><p><strong>dense_rank</strong>函数的功能与rank函数类似，dense_rank函数在生成序号时是连续的，而rank函数生成的序号有可能不连续。dense_rank函数出现相同排名时，将不跳过相同排名号，rank值紧接上一次的rank值。在各个分组内，rank()是跳跃排序，有两个第一名时接下来就是第三名，dense_rank()是连续排序，有两个第一名时仍然跟着第二名。</p></blockquote><h4 id="SQL74-考试分数-三-（较难）"><a href="#SQL74-考试分数-三-（较难）" class="headerlink" title="SQL74 考试分数(三)（较难）"></a><a href="https://www.nowcoder.com/practice/b83f8b0e7e934d95a56c24f047260d91?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL74</strong> <strong>考试分数(三)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每次举办企业笔试的时候，企业一般都会有不同的语言岗位，比如C++工程师，JAVA工程师，Python工程师，每个用户笔试完有不同的分数，现在有一个分数(grade)表简化如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652427039_07E19104EBD63DA9EDB41F5DD4489F99" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示用户id为1的选择了language_id为1岗位的最后考试完的分数为12000，<br>….<br>第7行表示用户id为7的选择了language_id为2岗位的最后考试完的分数为11000，</p><p>不同的语言岗位(language)表简化如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652437695_C8AFE1A16BE6BBA7929B73D79DE0E398" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>请你找出每个岗位分数排名前2名的用户，得到的结果先按照language的name升序排序，再按照积分降序排序，最后按照grade的id升序排序，得到结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652444918_D40D8F8B37A92E9E7A15A5231F7D3822" srcset="/img/loading.gif" lazyload="" alt="img"></p></blockquote><p>思路：</p><ol><li><p>因为要筛选出前两名，所以还是用排序。从案例中来看，重复的也算入了前两名内，所以这里用于生成排序序号的函数应该用<code>DENSE_RANK()</code>（相同排名会生成相同排名号，连续；<code>RANK()</code>也是相同排名会生成相同排名号，但不连续）</p><blockquote><p>– 子查询（分组排序）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,language_id,score,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> language_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> grade</code></pre></div></blockquote></li><li><p>表连接，WHERE过滤等</p></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.id,c.name,a.score <span class="hljs-keyword">FROM</span> grade a<span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,language_id,score,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> language_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs    <span class="hljs-keyword">FROM</span> grade) b<span class="hljs-keyword">ON</span> a.id = b.id<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">language</span> c<span class="hljs-keyword">ON</span> a.language_id = c.id<span class="hljs-keyword">WHERE</span> b.rs &lt;= <span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> c.name,a.score <span class="hljs-keyword">DESC</span>,a.id</code></pre></div><h4 id="SQL76-考试分数-五-（困难）"><a href="#SQL76-考试分数-五-（困难）" class="headerlink" title="SQL76 考试分数(五)（困难）"></a><a href="https://www.nowcoder.com/practice/b626ff9e2ad04789954c2132c74c0512?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL76</strong> <strong>考试分数(五)</strong></a>（困难）</h4><p><span id="NIUKE_SQL76">锚点：中位数</span></p><blockquote><p>描述</p><p>牛客每次考试完，都会有一个成绩表(grade)，如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612434987195/17DF5669D7379DF505A49E7E33701DDF" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示用户id为1的用户选择了C++岗位并且考了11001分</p><p>。。。</p><p>第8行表示用户id为8的用户选择了B语言岗位并且考了9999分</p><p>请你写一个sql语句查询各个岗位分数的中位数位置上的所有grade信息，并且按id升序排序，结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210204/557336_1612435020053/E4B68B27A8EAB1FDC2576B68F209167D" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解释：</p><p>第1行表示C++岗位的中位数位置上的为用户id为2，分数为10000，在C++岗位里面排名是第2</p><p>第2，3行表示Java岗位的中位数位置上的为用户id为4,5，分数为12000,13000，在Java岗位里面排名是第2,1</p><p>第4行表示B语言岗位的中位数位置上的为用户id为7，分数为11000，在前端岗位里面排名是第2</p><p>(注意: sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5，sqlite四舍五入的函数为round，sqlite不支持floor函数，支持cast(x as integer) 函数，不支持if函数，支持case when …then …else ..end函数，sqlite不支持自定义变量)</p></blockquote><p>方法：无限套娃~~</p><ol><li><p>是这题<a href="[考试分数(四"><strong>SQL75</strong> <strong>考试分数(四)</strong></a>_牛客题霸_牛客网 (nowcoder.com)](<a href="https://www.nowcoder.com/practice/502fb6e2b1ad4e56aa2e0dd90c6edf3c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1))的进阶版本（这题要给出score是中位数的所有数据），还是先分组查询，但与（四）题不同的是，这里需要把中位数号合并，以下分别是单数、双数（双数有两个中位数）的情况，将其合并成(job,t_rank)两个字段的数据" target="_blank" rel="noopener">https://www.nowcoder.com/practice/502fb6e2b1ad4e56aa2e0dd90c6edf3c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1))的进阶版本（这题要给出score是中位数的所有数据），还是先分组查询，但与（四）题不同的是，这里需要把中位数号合并，以下分别是单数、双数（双数有两个中位数）的情况，将其合并成(job,t_rank)两个字段的数据</a></p><blockquote><p>– 子查询（获取(job,t_rank)）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank<span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) a<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank<span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job) a<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank<span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a</code></pre></div></blockquote><p>（备注：<code>UNION</code>后面不能接<code>ORDER BY</code>）</p></li><li><p>去重，WHERE过滤</p><p>上面的子查询得到的数据里，还有null和重复的数据。所以外层再嵌套一个</p><blockquote><p>– 子查询（去重并过滤）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> job,<span class="hljs-keyword">ROUND</span>(t_rank,<span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> (<span class="hljs-comment">-- 此前的三个子查询a</span> ) b <span class="hljs-keyword">WHERE</span> t_rank &lt;&gt; <span class="hljs-string">'NULL'</span></code></pre></div></blockquote></li><li><p>现在得到准确的(job,t_rank)格式了，那么对原表也用一次<code>ROW_NUMBER()</code>分组排序生成一个序号。都有(job,t_rank)，那么剩下就是老套的<code>WHERE 字段 IN</code>大法了</p><blockquote><p>– 子查询（再次套娃）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,t_rank <span class="hljs-keyword">FROM</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> t_rank <span class="hljs-keyword">FROM</span> grade) c<span class="hljs-keyword">WHERE</span> (job,t_rank) <span class="hljs-keyword">IN</span> (<span class="hljs-comment">-- 此前的子查询结果</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,t_rank <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,job,score,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> job <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> grade) c<span class="hljs-keyword">WHERE</span> (job,t_rank) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> job,<span class="hljs-keyword">ROUND</span>(t_rank,<span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span>,<span class="hljs-keyword">CEILING</span>(<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>),<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a    <span class="hljs-keyword">UNION</span>    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job    ) a    <span class="hljs-keyword">UNION</span>    <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">num</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,<span class="hljs-keyword">num</span>/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>) <span class="hljs-keyword">AS</span> t_rank    <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> job,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> grade        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> job        ) a    ) b    <span class="hljs-keyword">WHERE</span> t_rank &lt;&gt; <span class="hljs-string">'NULL'</span>)<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span></code></pre></div><h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><h3 id="连续数字"><a href="#连续数字" class="headerlink" title="连续数字"></a>连续数字</h3><h4 id="180-连续出现的数字（中等）"><a href="#180-连续出现的数字（中等）" class="headerlink" title="180. 连续出现的数字（中等）"></a><a href="https://leetcode-cn.com/problems/consecutive-numbers/" target="_blank" rel="noopener"><strong>180. 连续出现的数字</strong></a>（中等）</h4><blockquote><p>表：Logs</p><p>+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| id          | int     |<br>| num         | varchar |<br>+————-+———+<br>id 是这个表的主键。</p><p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p><p>返回的结果表中的数据可以按 任意顺序 排列。</p><p>查询结果格式如下面的例子所示：</p><p>Logs 表：<br>+—-+—–+<br>| Id | Num |<br>+—-+—–+<br>| 1  | 1   |<br>| 2  | 1   |<br>| 3  | 1   |<br>| 4  | 2   |<br>| 5  | 1   |<br>| 6  | 2   |<br>| 7  | 2   |<br>+—-+—–+</p><p>Result 表：<br>+—————–+<br>| ConsecutiveNums |<br>+—————–+<br>| 1               |<br>+—————–+<br>1 是唯一连续出现至少三次的数字。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/consecutive-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/consecutive-numbers</a><br>著作权归领扣网络所有。</p></blockquote><p>这里因为id是连续的，所以可以利用id来作为判断是否连续的重要依据。</p><p>以第一行的id为基准，将第二行数据的id减1，第二行数据的id减2，这样三行数据的id都相同了</p><p>之后再以id为连接键进行表连接，当连接后的表里同一行的num都相同时，即该num是一个出现了连续三次的num</p><p>SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> a.num <span class="hljs-keyword">AS</span> ConsecutiveNums <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">logs</span> a<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span><span class="hljs-number">-1</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">logs</span>) b <span class="hljs-keyword">ON</span> a.id = b.id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span><span class="hljs-number">-2</span> <span class="hljs-keyword">AS</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">logs</span>) c <span class="hljs-keyword">ON</span> a.id = c.id<span class="hljs-keyword">WHERE</span> a.num = b.num<span class="hljs-keyword">AND</span> a.num = c.num</code></pre></div><h3 id="连续登录"><a href="#连续登录" class="headerlink" title="连续登录"></a>连续登录</h3><h4 id="连续登陆7天以上的用户-（困难）"><a href="#连续登陆7天以上的用户-（困难）" class="headerlink" title="连续登陆7天以上的用户 （困难）"></a><a href="https://www.cnblogs.com/ikww/p/12012831.html" target="_blank" rel="noopener"><strong>连续登陆7天以上的用户</strong> </a>（困难）</h4><blockquote><p>描述</p><p>表order，表结构如下：（分别是用户id和登录时间）</p><table><thead><tr><th>user_id</th><th>date</th></tr></thead><tbody><tr><td>int</td><td>datetime</td></tr></tbody></table><p>求连续登录七天的用户ID</p></blockquote><p>思路：</p><ol><li>按用户及日期去重</li><li>按用户为分区，以时间排序</li><li>将步骤2得到的序号与步骤1的时间相减</li><li>将步骤三得到的新字段以用户和差值分组并筛选单个分组大于7的用户id</li></ol><p>SQL实现：</p><ol><li><p>GROUP BY 分组并 DISTINCT 去重（因为每个用户每天的数据可能有很多）</p><blockquote><p>– 子查询（t1）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-string">`date`</span></code></pre></div></blockquote></li><li><p>PARTITION BY 用户 ORDER BY 时间</p><blockquote><p>– 子查询（t2）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">`date`</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> t1</code></pre></div></blockquote></li><li><p>相减</p><p>经过前面两个步骤操作后，对同一个用户，如果是连续登录的，那么他的<code>日期</code>和<code>rs</code>这两个字段应该都是以步长为1的等差数列。所以对连续登录的用户，将这个两个字段相减，会得到多行相同的数值，接下来先进行相减的操作：</p><blockquote><p>– 子查询（t3）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,(t2.<span class="hljs-string">`date`</span> - t2.rs) <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">FROM</span> t2</code></pre></div></blockquote></li><li><p>分组筛选</p><blockquote><p>– 最终步骤</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> t3<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id,d<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">7</span></code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> user_id,(t2.<span class="hljs-string">`date`</span> - t2.rs) <span class="hljs-keyword">AS</span> d <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> *,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">`date`</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id,<span class="hljs-string">`date`</span>)) t2) t3<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id,d<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*) &gt;= <span class="hljs-number">7</span></code></pre></div><h2 id="比例"><a href="#比例" class="headerlink" title="比例"></a>比例</h2><h4 id="SQL65-异常的邮件概率（较难）"><a href="#SQL65-异常的邮件概率（较难）" class="headerlink" title="SQL65 异常的邮件概率（较难）"></a><a href="https://www.nowcoder.com/practice/d6dd656483b545159d3aa89b4c26004e?tpId=82&amp;&amp;tqId=35083&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL65</strong> <strong>异常的邮件概率</strong></a>（较难）</h4><p>（题目很长，你忍一下）简单来说就统计每天正常用户对正常用户发送邮件失败的比例</p><blockquote><p>描述</p><p>现在有一个需求，让你统计正常用户发送给正常用户邮件失败的概率:<br>有一个邮件(email)表，id为主键， type是枚举类型，枚举成员为(completed，no_completed)，completed代表邮件发送是成功的，no_completed代表邮件是发送失败的。简况如下:<br><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652115615_43081841018939871F6352EF230E6D8E" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示为id为2的用户在2020-01-11成功发送了一封邮件给了id为3的用户;<br>…<br>第3行表示为id为1的用户在2020-01-11<strong>没有成功</strong>发送一封邮件给了id为4的用户;<br>…<br>第6行表示为id为4的用户在2020-01-12成功发送了一封邮件给了id为1的用户;</p><p>下面是一个用户(user)表，id为主键，is_blacklist为0代表为正常用户，is_blacklist为1代表为黑名单用户，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652932880_7440E658C1F32DF28A6F4360EAB2D9BB" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示id为1的是正常用户;<br>第2行表示id为2的不是正常用户，是黑名单用户，如果发送大量邮件或者出现各种情况就会容易发送邮件失败的用户<br>。。。<br>第4行表示id为4的是正常用户</p><p>现在让你写一个sql查询，每一个日期里面，正常用户发送给正常用户邮件失败的概率是多少，结果保留到小数点后面3位(3位之后的四舍五入)，并且按照日期升序排序，上面例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652145337_6DF0297941EF626E9F6560F28F60E2C7" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>结果表示:</p><p>2020-01-11失败的概率为0.500，因为email的第1条数据，发送的用户id为2是黑名单用户，所以不计入统计，正常用户发正常用户总共2次，但是失败了1次，所以概率是0.500;</p><p>2020-01-12没有失败的情况，所以概率为0.000.<br>(注意: sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5，sqlite四舍五入的函数为round)</p></blockquote><p>因为题目要求的是每天的比例，所以显然需要用到<code>GROUP BY</code>函数对日期(date)进行分组，但是题目有一个<strong>正常用户对正常用户</strong>，因而我们先取出正常用户这部分。</p><p>通过<code>SELECT id FROM user WHERE is_blacklist = 0</code>筛选出正常用户id，那么还是用<code>WHERE 字段名 IN</code>的方法来实现筛选出 id正常的发送用户和 id正常的接受用户，两个条件用<code>AND</code>连接，写成</p><blockquote><p>–  子查询（筛选出用户 id是正常的数据）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> email <span class="hljs-keyword">WHERE</span> send_id <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">0</span>)<span class="hljs-keyword">AND</span> receive_id <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">0</span>)</code></pre></div></blockquote><p>为了方便描述，我们将上面这个子查询得到的表给个别名a，在表a里所有的用户id都是正常id了。那么接下来只需要统计type字段中no_completed占的比例即可，那么在使用表a的情况下，统计no_completed占用比例可以这样写：</p><p><code>SUM(IF(type = 'no_completed',1,0))/COUNT(*)</code></p><p>上面里层的<code>IF()</code>语句中，如果type 等于’no_completed’则返回数值1，否则返回数值0</p><p>外层嵌套一个<code>SUM()/COUNT(*)</code>就可以实现统计发送失败的比例了（因为发送失败返回了1，所以用<code>SUM( )</code> ）</p><p>因为题目要求保留三位小数，所以外层还得套一个<code>ROUND(value,3)</code>函数，即：</p><p><code>ROUND(SUM(IF(type = 'no_completed',1,0))/COUNT(*),3)</code></p><p>那么，SQL逻辑为</p><blockquote><p>– SQL查询逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">type</span> = <span class="hljs-string">'no_completed'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">3</span>) <span class="hljs-keyword">FROM</span>  a<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote><p>这里表a是用户id全为正常的一个子表，把这个子表的SQL语句拼接上去就完成了，完整SQL语句如下：</p><p>（注意，子表即子查询结果需要命名否则会报错，下面将子表命名为a）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-string">`date`</span>,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">SUM</span>(<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">type</span> = <span class="hljs-string">'no_completed'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">3</span>) <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> email     <span class="hljs-keyword">WHERE</span> send_id <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`user`</span>        <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">0</span>    )    <span class="hljs-keyword">AND</span> receive_id <span class="hljs-keyword">IN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">`user`</span>        <span class="hljs-keyword">WHERE</span> is_blacklist = <span class="hljs-number">0</span>    )) a<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div><blockquote><p>拓展</p><p>在表名或字段名两边加上<kbd>`</kbd> 是用来防止占用特殊字符串</p><p>例如 <code>date</code>就防止date字段跟date函数冲突（加上了就明确表示date是字段而不是函数也不是特殊符号）</p></blockquote><h4 id="262-行程和用户（困难）"><a href="#262-行程和用户（困难）" class="headerlink" title="262. 行程和用户（困难）"></a><a href="https://leetcode-cn.com/problems/trips-and-users/" target="_blank" rel="noopener"><strong>262. 行程和用户</strong></a>（困难）</h4><blockquote><p>SQL架构</p><p>表：<code>Trips</code></p><div class="hljs code-wrapper"><pre><code class="hljs gherkin">+-------------+----------+|<span class="hljs-string"> Column Name </span>|<span class="hljs-string"> Type     </span>|+-------------+----------+|<span class="hljs-string"> Id          </span>|<span class="hljs-string"> int      </span>||<span class="hljs-string"> Client_Id   </span>|<span class="hljs-string"> int      </span>||<span class="hljs-string"> Driver_Id   </span>|<span class="hljs-string"> int      </span>||<span class="hljs-string"> City_Id     </span>|<span class="hljs-string"> int      </span>||<span class="hljs-string"> Status      </span>|<span class="hljs-string"> enum     </span>||<span class="hljs-string"> Request_at  </span>|<span class="hljs-string"> date     </span>|<span class="hljs-string">     </span><span class="hljs-string">+-------------+----------+</span><span class="hljs-string">Id 是这张表的主键。</span><span class="hljs-string">这张表中存所有出租车的行程信息。每段行程有唯一 Id ，其中 Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。</span><span class="hljs-string">Status 是一个表示行程状态的枚举类型，枚举成员为(‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’) 。</span></code></pre></div><p>表：<code>Users</code></p><div class="hljs code-wrapper"><pre><code class="hljs crystal">+-------------+----------+| Column Name | Type     |+-------------+----------+| Users_Id    | int      || Banned      | <span class="hljs-class"><span class="hljs-keyword">enum</span>     |</span>| Role        | <span class="hljs-class"><span class="hljs-keyword">enum</span>     |</span>+-------------+----------+Users_Id 是这张表的主键。这张表中存所有用户，每个用户都有一个唯一的 Users_Id ，Role 是一个表示用户身份的枚举类型，枚举成员为 (‘client’, ‘driver’, ‘partner’) 。Banned 是一个表示用户是否被禁止的枚举类型，枚举成员为 (‘Yes’, ‘No’) 。</code></pre></div><p>写一段 SQL 语句查出 <code>"2013-10-01"</code> 至 <code>"2013-10-03"</code> 期间非禁止用户（<strong>乘客和司机都必须未被禁止</strong>）的取消率。非禁止用户即 Banned 为 No 的用户，禁止用户即 Banned 为 Yes 的用户。</p><p><strong>取消率</strong> 的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)。</p><p>返回结果表中的数据可以按任意顺序组织。其中取消率 <code>Cancellation Rate</code> 需要四舍五入保留 <strong>两位小数</strong> 。</p><p>查询结果格式如下例所示：</p><div class="hljs code-wrapper"><pre><code class="hljs sql">Trips 表：+<span class="hljs-comment">----+-----------+-----------+---------+---------------------+------------+</span>| Id | Client_Id | Driver_Id | City_Id | Status              | Request_at |+<span class="hljs-comment">----+-----------+-----------+---------+---------------------+------------+</span>| 1  | 1         | 10        | 1       | completed           | 2013-10-01 || 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 || 3  | 3         | 12        | 6       | completed           | 2013-10-01 || 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 || 5  | 1         | 10        | 1       | completed           | 2013-10-02 || 6  | 2         | 11        | 6       | completed           | 2013-10-02 || 7  | 3         | 12        | 6       | completed           | 2013-10-02 || 8  | 2         | 12        | 12      | completed           | 2013-10-03 || 9  | 3         | 10        | 12      | completed           | 2013-10-03 || 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |+<span class="hljs-comment">----+-----------+-----------+---------+---------------------+------------+</span>Users 表：+<span class="hljs-comment">----------+--------+--------+</span>| Users_Id | Banned | Role   |+<span class="hljs-comment">----------+--------+--------+</span>| 1        | No     | client || 2        | Yes    | client || 3        | No     | client || 4        | No     | client || 10       | No     | driver || 11       | No     | driver || 12       | No     | driver || 13       | No     | driver |+<span class="hljs-comment">----------+--------+--------+</span>Result 表：+<span class="hljs-comment">------------+-------------------+</span>| Day        | Cancellation Rate |+<span class="hljs-comment">------------+-------------------+</span>| 2013-10-01 | 0.33              || 2013-10-02 | 0.00              || 2013-10-03 | 0.50              |+<span class="hljs-comment">------------+-------------------+</span>2013-10-01：  - 共有 4 条请求，其中 2 条取消。  - 然而，Id=2 的请求是由禁止用户（User_Id=2）发出的，所以计算时应当忽略它。  - 因此，总共有 3 条非禁止请求参与计算，其中 1 条取消。  - 取消率为 (1 / 3) = 0.332013-10-02：  - 共有 3 条请求，其中 0 条取消。  - 然而，Id=6 的请求是由禁止用户发出的，所以计算时应当忽略它。  - 因此，总共有 2 条非禁止请求参与计算，其中 0 条取消。  - 取消率为 (0 / 2) = 0.002013-10-03：  - 共有 3 条请求，其中 1 条取消。  - 然而，Id=8 的请求是由禁止用户发出的，所以计算时应当忽略它。  - 因此，总共有 2 条非禁止请求参与计算，其中 1 条取消。  - 取消率为 (1 / 2) = 0.50</code></pre></div></blockquote><p>简单来说就是去除掉禁止用户后，看取消率</p><p>那么，思路是先去除禁止用户，然后进行表连接并将取消操作转换为数值，最后求出比例即可</p><ol><li><p>去除禁止用户</p><blockquote><p>– 子查询（子表t1）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Trips<span class="hljs-keyword">WHERE</span> Client_Id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> Users_Id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Users</span><span class="hljs-keyword">WHERE</span> Banned = <span class="hljs-string">'Yes'</span>)<span class="hljs-keyword">AND</span> Driver_Id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> Users_Id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Users</span><span class="hljs-keyword">WHERE</span> Banned = <span class="hljs-string">'Yes'</span>)</code></pre></div></blockquote><p>经过上述操作后，得到的数据是Trips表去除用户后的数据</p><p>上述子查询操作得到的结果给个表别名 t1，为了方便阅读，之后把子查询简单得用t1表示（如果想要SQL运行得补充完整）</p></li><li><p>将取消操作转换为数值</p><blockquote><p>– 取消操作转换为数值（子表t2）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  Request_at,<span class="hljs-keyword">IF</span>(<span class="hljs-keyword">Status</span> = <span class="hljs-string">'cancelled_by_client'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> status1, <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">Status</span> = <span class="hljs-string">'cancelled_by_driver'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> status2<span class="hljs-keyword">FROM</span> t1<span class="hljs-keyword">WHERE</span> request_at <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">'2013-10-01'</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">'2013-10-03'</span></code></pre></div></blockquote><p>这里把<strong>被用户取消</strong>和<strong>被司机取消</strong>的操作都转换为数值1，其他的换成0</p><p>WHERE条件放在外层也行，但是放在内层先过滤掉则速度会更快</p></li><li><p>计算比例</p><p>因为取消操作都换成1了，即每一条数据如果有取消操作，则在 status1 和 status2 这两个字段中有且只有一个1</p><p>那么相加再除以总行数即可</p><blockquote><p>– 查询逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.Request_at,<span class="hljs-keyword">ROUND</span>( ( <span class="hljs-keyword">SUM</span>(t2.status1)+<span class="hljs-keyword">SUM</span>(t2.status2) )/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">2</span>)<span class="hljs-keyword">FROM</span> t2<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Request_at</code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t2.Request_at <span class="hljs-keyword">AS</span> <span class="hljs-keyword">Day</span>,<span class="hljs-keyword">ROUND</span>( ( <span class="hljs-keyword">SUM</span>(t2.status1)+<span class="hljs-keyword">SUM</span>(t2.status2) )/<span class="hljs-keyword">COUNT</span>(*),<span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">`Cancellation Rate`</span><span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>  Request_at,            <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">Status</span> = <span class="hljs-string">'cancelled_by_client'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> status1,             <span class="hljs-keyword">IF</span>(<span class="hljs-keyword">Status</span> = <span class="hljs-string">'cancelled_by_driver'</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-keyword">AS</span> status2    <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Trips        <span class="hljs-keyword">WHERE</span> Client_Id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (            <span class="hljs-keyword">SELECT</span> Users_Id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Users</span>            <span class="hljs-keyword">WHERE</span> Banned = <span class="hljs-string">'Yes'</span>        )        <span class="hljs-keyword">AND</span> Driver_Id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (            <span class="hljs-keyword">SELECT</span> Users_Id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">Users</span>            <span class="hljs-keyword">WHERE</span> Banned = <span class="hljs-string">'Yes'</span>        )    ) t1    <span class="hljs-keyword">WHERE</span> request_at <span class="hljs-keyword">BETWEEN</span> <span class="hljs-string">'2013-10-01'</span> <span class="hljs-keyword">AND</span> <span class="hljs-string">'2013-10-03'</span>) t2<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Request_at</code></pre></div><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><h4 id="SQL66-牛客每个人最近的登录日期-一-（简单）"><a href="#SQL66-牛客每个人最近的登录日期-一-（简单）" class="headerlink" title="SQL66 牛客每个人最近的登录日期(一)（简单）"></a><a href="https://www.nowcoder.com/practice/ca274ebe6eac40ab9c33ced3f2223bb2?tpId=82&amp;&amp;tqId=35084&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener"><strong>SQL66</strong> <strong>牛客每个人最近的登录日期(一)</strong></a>（简单）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客每个用户最近登录是哪一天。</p><p>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652540640_64D4B3DE58C69D6263B209D2B1AB6393" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网<br>。。。<br>第4行表示user_id为3的用户在2020-10-13使用了客户端id为2的设备登录了牛客网</p><p>请你写出一个sql语句查询每个用户最近一天登录的日子，并且按照user_id升序排序，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20201026/557336_1603700593855_F4BBCB1D5E81A508C2A06167DCF2F5ED" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>user_id为2的最近的登录日期在2020-10-13<br>user_id为3的最近的登录日期也是2020-10-13</p></blockquote><p>思路：因为是按用户分的，显然是<code>GROUP BY user_id</code>。在SQL中，可以用<code>MAX()</code>函数来取距离现在最近的时间（反之，用<code>MIN()</code>函数则可以取到最早之前的时间）。该题SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><h4 id="SQL67-牛客每个人最近的登录日期-二-（较难）"><a href="#SQL67-牛客每个人最近的登录日期-二-（较难）" class="headerlink" title="SQL67 牛客每个人最近的登录日期(二)（较难）"></a><a href="https://www.nowcoder.com/practice/7cc3c814329546e89e71bb45c805c9ad?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL67</strong> <strong>牛客每个人最近的登录日期(二)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客每个用户最近登录是哪一天，用的是什么设备.</p><p>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210106/557336_1609907092884/B7BB8B84A2534ED56DAB6420C6D02C42" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网<br>。。。<br>第4行表示user_id为3的用户在2020-10-13使用了客户端id为2的设备登录了牛客网</p><p>还有一个用户(user)表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652611050_C098FF7CF52D3DC2ECE5019F4E7A5E88" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>还有一个客户端(client)表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200817/557336_1597652618264_F2C14AA3F53E74C2FE5A266283E56241" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>请你写出一个sql语句查询每个用户最近一天登录的日子，用户的名字，以及用户用的设备的名字，并且查询结果按照user的name升序排序，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210106/557336_1609907127708/7B7FC5B3933D957E9FD6C914ACE1D91A" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>fh最近的登录日期在2020-10-13，而且是使用ios登录的<br>wangchao最近的登录日期也是2020-10-13，而且是使用ios登录的</p></blockquote><p>就这，还较难？跟上一题不是很像嘛？就加一个表连接把字段换一下不就完事？</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.name, client.name, <span class="hljs-keyword">MAX</span>(login.date)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ON</span> user.id = login.user_id<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> client.id = login.client_id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user.name<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.name</code></pre></div><p>我啪地一下，很快呀↑它就给我报答案错误了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210808180239.png" srcset="/img/loading.gif" lazyload="" alt=""></p><blockquote><p><strong>考点：group by 子句常见错误：</strong><br><strong>select 子句中只能存在以下三种元素：常数、聚合函数、group by子句指定列(聚合键)</strong></p></blockquote><p>也就是用了<code>GROUP BY</code>，那么选择的字段里就只能有这三种类型：</p><ol><li>常数字段</li><li>聚合函数作用的字段</li><li>group by子句指定列(聚合键)</li></ol><p>看看上面有user.name, client.name, MAX(login.date)这三个字段，其中user.name是聚合键，MAX(login.date)使用了聚合函数，都没问题。而client.name既不是常数也没有聚合函数，更不是聚合键，所以不能带上这个字段。</p><p>看正确解法思路：既然没办法GROUP BY 后SELECT这么多字段，而且用户id和时间还是准确的（看上图运行结果，只是不符合GROUP BY后SELECT的字段才错误，也就是只有客户端是错误的），所以我们先拿到准去的 用户id 和 时间date</p><blockquote><p>– 子查询</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id, <span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div></blockquote><p>然后将三个表连接</p><blockquote><p>– 三个表连接</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.name,client.name,login.date<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ON</span> login.user_id = user.id<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> login.client_id = client.id</code></pre></div></blockquote><p>三个表连接后考虑用WHERE来过滤得到符合条件的结果，要筛选出最近登录，只需要用<code>WHERE 字段名 IN</code>即可实现</p><p>因为这里是需要用户id和时间date两个字段来判断，所以写出来是<code>WHERE (user_id,date) IN (  子查询  )</code></p><p>（注意：因为WHERE IN 后面的不是一个子表，所以不需要也不可以给这里子查询加上表别名）</p><p>完整的SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.name,client.name,login.date<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">ON</span> login.user_id = user.id<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">client</span> <span class="hljs-keyword">ON</span> login.client_id = client.id<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> user_id, <span class="hljs-keyword">MAX</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    )<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.name</code></pre></div><h4 id="SQL68-牛客每个人最近的登录日期-三-（较难）"><a href="#SQL68-牛客每个人最近的登录日期-三-（较难）" class="headerlink" title="SQL68 牛客每个人最近的登录日期(三)（较难）"></a><a href="https://www.nowcoder.com/practice/16d41af206cd4066a06a3a0aa585ad3d?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL68</strong> <strong>牛客每个人最近的登录日期(三)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客新登录用户的次日成功的留存率，<br>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20201026/557336_1603701796116_54BBC7EED94F0CAAFEC8DB042BBBCD01" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备第一次新登录了牛客网<br>。。。</p><p>第4行表示user_id为3的用户在2020-10-12使用了客户端id为2的设备登录了牛客网</p><p>。。。</p><p>最后1行表示user_id为1的用户在2020-10-14使用了客户端id为2的设备登录了牛客网</p><p>请你写出一个sql语句查询新登录用户次日成功的留存率，即第1天登陆之后，第2天再次登陆的概率,保存小数点后面3位(3位之后的四舍五入)，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903513290_CD24AA22EB7078641AEAF29B146D26FD" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:</p><p>user_id为1的用户在2020-10-12第一次新登录了，在2020-10-13又登录了，算是成功的留存</p><p>user_id为2的用户在2020-10-12第一次新登录了，在2020-10-13又登录了，算是成功的留存</p><p>user_id为3的用户在2020-10-12第一次新登录了，在2020-10-13没登录了，算是失败的留存</p><p>user_id为4的用户在2020-10-13第一次新登录了，在2020-10-14没登录了，算是失败的留存</p><p>固次日成功的留存率为 2/4=0.5</p><p>(sqlite里查找某一天的后一天的用法是:date(yyyy-mm-dd, ‘+1 day’)，四舍五入的函数为round，sqlite 1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5</p><p>mysql里查找某一天的后一天的用法是:DATE_ADD(yyyy-mm-dd,INTERVAL 1 DAY)，四舍五入的函数为round)</p></blockquote><ol><li><p>先取出新用户第二天的登录数据</p><blockquote><p>– 所有用户的第二天登录数据</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div></blockquote><p>这里有一个问题，因为如果是字符串类型的时间，例如<code>2020-10-12</code>对其用了<code>MIN( )</code>函数后，会变成<code>20201012</code>，为了的后续操作，我们需要对其套上<code>DATE()</code>函数使其变回<code>2020-10-12</code>这种日期格式。</p></li><li><p>再用子查询（老套路，还是<code>WHERE 字段名 IN</code>）</p><blockquote><p>– WHERE IN大法</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id) </code></pre></div></blockquote></li><li><p>查询用户数</p><p>接下来获取用户数，需要用<code>DISTINCT</code>（字段前加上这个可以去重）</p><blockquote><p>– 用户数</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_id) <span class="hljs-keyword">FROM</span> login</code></pre></div></blockquote></li><li><p>相除，并且用<code>ROUND(value,3)</code>保留三位小数</p></li></ol><p>最终SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">COUNT</span>(*)/( <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_id) <span class="hljs-keyword">FROM</span> login),<span class="hljs-number">3</span>)<span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login     <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)</code></pre></div><h4 id="SQL69-牛客每个人最近的登录日期-四-（较难）"><a href="#SQL69-牛客每个人最近的登录日期-四-（较难）" class="headerlink" title="SQL69 牛客每个人最近的登录日期(四)（较难）"></a><a href="https://www.nowcoder.com/practice/e524dc7450234395aa21c75303a42b0a?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL69</strong> <strong>牛客每个人最近的登录日期(四)</strong></a>（较难）</h4><blockquote><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>牛客每天有很多人登录，请你统计一下牛客每个日期登录新用户个数，<br>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903671918_2C3C4BF94A59FB9AEEA6FEA89DEE17C9" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网，因为是第1次登录，所以是新用户<br>。。。<br>第4行表示user_id为2的用户在2020-10-13使用了客户端id为2的设备登录了牛客网，因为是第2次登录，所以是老用户<br>。。<br>最后1行表示user_id为4的用户在2020-10-15使用了客户端id为1的设备登录了牛客网，因为是第2次登录，所以是老用户</p><p>请你写出一个sql语句查询每个日期登录新用户个数，并且查询结果按照日期升序排序，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903683115_47DE8F52D6F847E788BB9EF6279481C4" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>2020-10-12，有3个新用户(user_id为2，3，1)登录<br>2020-10-13，没有新用户登录<br>2020-10-14，有1个新用户(user_id为4)登录<br>2020-10-15，没有新用户登录</p></blockquote><p>这不比上一道题更简单吗？先筛选出(新用户id,日期date)，然后WHERE IN，再GROUP BY分组COUNT统计行数，我啪地一声很快…</p><blockquote><p>– 错误写法</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote><p>…就错了（这种情况没有得出新用户是0的情况，如图）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210809015523.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>不慌，那就在上面这基础上改一下，毕竟天下没有白写的bug</p><p>这里是因为用WHERE IN过滤了才会导致有些日期没有了，所以要保证都有思路上还是直接FROM 原表并且不做任何过滤。这种没有的情况，与其最近的则是NULL。那么，为了填补日期，我们考虑用表连接来完成（将没有的日期先补成NULL），这种显然可以通过<code>LEFT JOIN</code>或<code>RIGHT JOIN</code>完成。这里将原表写在左边，所以使用<code>LEFT JOIN</code>（LEFT JOIN ：以左表为基准，右表没有的行数返回NULL）</p><p>为了SQL语句简介，先将上面的错误查询当作表a，并将a表中的COUNT(<em>)给个别名，这里写出`COUNT(</em>) AS num`</p><blockquote><p>– 表连接（填补缺少的日期）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> login.date,a.num <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> a <span class="hljs-keyword">ON</span> login.date = a.date<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote><p>这种情况下，a.num会是NULL值，因而需要将NULL替换成0，使用<code>IFNULL(a.num,0)</code>即可完成，并将a表写入，最后SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> login.date,<span class="hljs-keyword">IFNULL</span>(a.num,<span class="hljs-number">0</span>) <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login    <span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>) <span class="hljs-keyword">FROM</span> login    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    )    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) a <span class="hljs-keyword">ON</span> login.date = a.date<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div><h4 id="SQL70-牛客每个人最近的登录日期-五-（困难）"><a href="#SQL70-牛客每个人最近的登录日期-五-（困难）" class="headerlink" title="SQL70 牛客每个人最近的登录日期(五)（困难）"></a><a href="https://www.nowcoder.com/practice/ea0c56cd700344b590182aad03cc61b8?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL70</strong> <strong>牛客每个人最近的登录日期(五)</strong></a>（困难）</h4><blockquote><p>描述</p><p>牛客每天有很多人登录，请你统计一下牛客每个日期新用户的次日留存率。<br>有一个登录(login)记录表，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903752757_A02F3DF1419BC2D3D4EE9B2B4557053B" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为2的用户在2020-10-12使用了客户端id为1的设备登录了牛客网，因为是第1次登录，所以是新用户<br>。。。<br>第4行表示user_id为2的用户在2020-10-13使用了客户端id为2的设备登录了牛客网，因为是第2次登录，所以是老用户<br>。。<br>最后1行表示user_id为4的用户在2020-10-15使用了客户端id为1的设备登录了牛客网，因为是第2次登录，所以是老用户</p><p>请你写出一个sql语句查询每个日期新用户的次日留存率，结果保留小数点后面3位数(3位之后的四舍五入)，并且查询结果按照日期升序排序，上面的例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20200820/557336_1597903761838_F734DB69B9941F0DF86776922B0CF347" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>查询结果表明:<br>2020-10-12登录了3个(user_id为2，3，1)新用户，2020-10-13，只有2个(id为2,1)登录，故2020-10-12新用户次日留存率为2/3=0.667;<br>2020-10-13没有新用户登录，输出0.000;<br>2020-10-14登录了1个(user_id为4)新用户，2020-10-15，user_id为4的用户登录，故2020-10-14新用户次日留存率为1/1=1.000;</p><p>2020-10-15没有新用户登录，输出0.000;</p><p>(注意:sqlite里查找某一天的后一天的用法是:date(yyyy-mm-dd, ‘+1 day’)，sqlite里1/2得到的不是0.5，得到的是0，只有1*1.0/2才会得到0.5)</p></blockquote><p>如果前面日期的题都掌握了，其实这道题很容易。老套路，SQL语句从里到外看，无限套娃。</p><ol><li><p>首先是计算每天的次日用户数</p><blockquote><p>– 子查询（次日留存用户数）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">DATE</span>(<span class="hljs-built_in">date</span><span class="hljs-number">-1</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote><p>这里<code>MIN(date)+1</code>来作为留存筛选条件，然后在SELECT处将日期减回去</p></li><li><p>每天的注册用户数</p><blockquote><p>– 子查询（注册用户数）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.date,(b.num/a.num) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) eee    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span></code></pre></div></blockquote></li><li><p>将子查询（次日留存用户数）与子查询（注册用户数）连接相处，得到结果</p><blockquote><p>– 子查询（ 得到每天的留存率）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.date,(b.num/a.num) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> (     <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> (         <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login             <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id     ) eee     <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span> ) a <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (     <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">DATE</span>(<span class="hljs-built_in">date</span><span class="hljs-number">-1</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login     <span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (         <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login         <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id     )     <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>     <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span> ) b <span class="hljs-keyword">ON</span> a.date = b.date <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a.date <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.date</code></pre></div></blockquote><p>到这一步已经得到结果了，但是仍然出现了<strong>SQL69</strong> <strong>牛客每个人最近的登录日期(四)</strong>里最开始的那种情况：留存率为0的日期没有显示出来。</p></li><li><p>再套娃</p><p>再以原表作为基表，LEFT JOIN 操作一次</p></li></ol><p>最终SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> login.date,<span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">IFNULL</span>(c.p,<span class="hljs-number">0</span>),<span class="hljs-number">3</span>) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> login<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> a.date,(b.num/a.num) <span class="hljs-keyword">AS</span> p <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> (            <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> login                <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        ) eee        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>    ) a    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">DATE</span>(<span class="hljs-built_in">date</span><span class="hljs-number">-1</span>) <span class="hljs-keyword">AS</span> <span class="hljs-built_in">date</span>,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">FROM</span> login        <span class="hljs-keyword">WHERE</span> (user_id,<span class="hljs-built_in">date</span>) <span class="hljs-keyword">IN</span> (            <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>)+<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> login            <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id        )        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>    ) b    <span class="hljs-keyword">ON</span> a.date = b.date    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a.date    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> a.date) c<span class="hljs-keyword">ON</span> login.date = c.date</code></pre></div><h4 id="SQL80-牛客的课程订单分析-四-（较难）"><a href="#SQL80-牛客的课程订单分析-四-（较难）" class="headerlink" title="SQL80 牛客的课程订单分析(四)（较难）"></a><a href="https://www.nowcoder.com/practice/c93d2079282f4943a3771ca6fd081c23?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL80</strong> <strong>牛客的课程订单分析(四)</strong></a>（较难）</h4><blockquote><p>描述</p><p>有很多同学在牛客购买课程来学习，购买会产生订单存到数据库里。</p><p>有一个订单信息表(order_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614310851199/05757BC2D70D6C85A451733582C84202" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为557336的用户在2025-10-10的时候使用了client_id为1的客户端下了C++课程的订单，但是状态为没有购买成功。</p><p>第2行表示user_id为230173543的用户在2025-10-12的时候使用了client_id为2的客户端下了Python课程的订单，状态为购买成功。</p><p>。。。</p><p>最后1行表示user_id为557336的用户在2025-10-25的时候使用了client_id为1的客户端下了Python课程的订单，状态为购买成功。</p><p>请你写出一个sql语句查询在2025-10-15以后，如果有一个用户下单2个以及2个以上状态为购买成功的C++课程或Java课程或Python课程，那么输出这个用户的user_id，以及满足前面条件的第一次购买成功的C++课程或Java课程或Python课程的日期first_buy_date，以及购买成功的C++课程或Java课程或Python课程的次数cnt，并且输出结果按照user_id升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614310860082/0CDA2587932AE43AF2BB6299FA683419" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>id为4，6的订单满足以上条件，输出57，id为4的订单为第一次购买成功，输出first_buy_date为2025-10-23，总共成功购买了2次;</p><p>id为5，7，8的订单满足以上条件，输出557336，id为5的订单为第一次购买成功，输出first_buy_date为2025-10-23，总共成功购买了3次;</p></blockquote><p>因为是分用户，所以还是需要<code>GROUP BY</code>操作，SELECE后面的字段可以有MIN(date),COUNT(*) ，这样SELECT之后的字段就没有出现（group by指定列，聚合函数，常熟）以外的字段了</p><blockquote><p>– 逻辑框架</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>),<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div></blockquote><p>之后补充题目要求条件，完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">MIN</span>(<span class="hljs-built_in">date</span>),<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> =<span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*)&gt;=<span class="hljs-number">2</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div><h4 id="SQL81-牛客的课程订单分析-五-（困难）"><a href="#SQL81-牛客的课程订单分析-五-（困难）" class="headerlink" title="SQL81 牛客的课程订单分析(五)（困难）"></a><a href="https://www.nowcoder.com/practice/348afda488554ceb922efd2f3effc427?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL81</strong> <strong>牛客的课程订单分析(五)</strong></a>（困难）</h4><blockquote><p>描述</p><p>有很多同学在牛客购买课程来学习，购买会产生订单存到数据库里。</p><p>有一个订单信息表(order_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614320881447/390E1A747B9D2D6DF976278C6AE5D0DB" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示user_id为557336的用户在2025-10-10的时候使用了client_id为1的客户端下了C++课程的订单，但是状态为没有购买成功。</p><p>第2行表示user_id为230173543的用户在2025-10-12的时候使用了client_id为2的客户端下了Python课程的订单，状态为购买成功。</p><p>。。。</p><p>最后1行表示user_id为557336的用户在2025-10-26的时候使用了client_id为1的客户端下了Python课程的订单，状态为购买成功。</p><p>请你写出一个sql语句查询在2025-10-15以后，如果有一个用户下单2个以及2个以上状态为购买成功的C++课程或Java课程或Python课程，那么输出这个用户的user_id，以及满足前面条件的第一次购买成功的C++课程或Java课程或Python课程的日期first_buy_date，以及满足前面条件的第二次购买成功的C++课程或Java课程或Python课程的日期second_buy_date，以及购买成功的C++课程或Java课程或Python课程的次数cnt，并且输出结果按照user_id升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210226/310548_1614320891682/E781EA8A3E13F91AD1409831A1854DE3" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解析:</p><p>id为4，6的订单满足以上条件，输出57，id为4的订单为第一次购买成功，输出first_buy_date为2025-10-23，id为6的订单为第二次购买，输出second_buy_date为2025-10-24，总共成功购买了2次;</p><p>id为5，7，8的订单满足以上条件，输出557336，id为5的订单为第一次购买成功，输出first_buy_date为2025-10-23，id为7的订单为第二次购买，输出second_buy_date为2025-10-25，总共成功购买了3次;</p></blockquote><ol><li><p>先取出(user_id,second_buy_date)作为一个子表</p><blockquote><p>– 子查询（第二次下单时间）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,user_id,<span class="hljs-built_in">date</span>,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>) a<span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">2</span>  <span class="hljs-comment">--第二次下单</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id</code></pre></div></blockquote></li><li><p>表连接</p><p>将上面的子查询得到的结果给个表别名b，为了简单描述下面我用b来代替上面的子查询</p><p>因为用户id是唯一且共同的，因而可以作为连接键将两个表（子表b与原表）连接</p><blockquote><p>– 表连接</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>  order_info.user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(order_info.date)),<span class="hljs-comment">--第一次下单</span>b.date,<span class="hljs-comment">--第二次下单</span><span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">JOIN</span> b <span class="hljs-keyword">ON</span> order_info.user_id = b.user_id</code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> order_info.user_id,<span class="hljs-built_in">DATE</span>(<span class="hljs-keyword">MIN</span>(order_info.date)),b.date,<span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> order_info<span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-built_in">date</span> <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,user_id,<span class="hljs-built_in">date</span>,ROW_NUMBER() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">date</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> order_info    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span>    <span class="hljs-keyword">AND</span> product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)    <span class="hljs-keyword">AND</span> <span class="hljs-built_in">date</span> &gt; <span class="hljs-string">'2025-10-15'</span>    ) a    <span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">2</span>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id) b <span class="hljs-keyword">ON</span> order_info.user_id = b.user_id<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">status</span> = <span class="hljs-string">'completed'</span><span class="hljs-keyword">AND</span> order_info.product_name <span class="hljs-keyword">IN</span> (<span class="hljs-string">'C++'</span>,<span class="hljs-string">'Java'</span>,<span class="hljs-string">'Python'</span>)<span class="hljs-keyword">AND</span> order_info.date &gt; <span class="hljs-string">'2025-10-15'</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> order_info.user_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_info.user_id</code></pre></div><h4 id="SQL90-获得积分最多的人-二-（较难）"><a href="#SQL90-获得积分最多的人-二-（较难）" class="headerlink" title="SQL90 获得积分最多的人(二)（较难）"></a><a href="https://www.nowcoder.com/practice/b6248d075d2d4213948b2e768080dc92?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL90</strong> <strong>获得积分最多的人(二)</strong></a>（较难）</h4><blockquote><p>描述</p><p>牛客每天有很多用户刷题，发帖，点赞，点踩等等，这些都会记录相应的积分。</p><p>有一个用户表(user)，简况如下：</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616896023720/B9EE61A3CF7F34EF411FE1A9C6B86FBC" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>还有一个积分表(grade_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616900022314/5A84E57F33739CFEC87F578CD60DB6A3" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示，user_id为1的用户积分增加了3分。</p><p>第2行表示，user_id为2的用户积分增加了3分。</p><p>第3行表示，user_id为1的用户积分又增加了1分。</p><p>…….</p><p>最后1行表示，user_id为3的用户积分增加了1分。</p><p>请你写一个SQL查找积分增加最高的用户的id(可能有多个)，名字，以及他的总积分是多少，查询结果按照id升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616900118014/B64703D5542E7DE36EC9394C05E69FBF" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解释:</p><p>user_id为1和3的2个人，积分都为4，都要输出</p></blockquote><ol><li><p>因为是分组求和，所以还是先<code>GROUP BY</code>+<code>SUM()</code>一顿操作。</p><p>此外，为了筛选出grade之和最多的，这里通过排序来实现，所以在上述分组求和的基础上再嵌套一层SELECT语句</p><blockquote><p>– 子查询（子表b）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade_sum <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs <span class="hljs-keyword">FROM</span> ( <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(grade_num) <span class="hljs-keyword">AS</span> grade_sum <span class="hljs-keyword">FROM</span> grade_info <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id) a</code></pre></div></blockquote></li><li><p>上述查询结果中已经有了需要的直接或间接数据，所以只需要再做表连接和WHERE过滤操作即可。</p><p>取排序最高的，即rs=1，SQL逻辑如下：</p><blockquote><p>– 查询逻辑</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.id,user.name,grade_sum<span class="hljs-keyword">FROM</span> b<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = b.user_id<span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.id</code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user.id,user.name,grade_sum<span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade_sum <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rs     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(grade_num) <span class="hljs-keyword">AS</span> grade_sum <span class="hljs-keyword">FROM</span> grade_info        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) a    ) b<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = b.user_id<span class="hljs-keyword">WHERE</span> rs = <span class="hljs-number">1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user.id</code></pre></div><h4 id="SQL91-获得积分最多的人-三-（困难）"><a href="#SQL91-获得积分最多的人-三-（困难）" class="headerlink" title="SQL91 获得积分最多的人(三)（困难）"></a><a href="https://www.nowcoder.com/practice/d2b7e2a305a7499fb310dc82a43820e8?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1" target="_blank" rel="noopener"><strong>SQL91</strong> <strong>获得积分最多的人(三)</strong></a>（困难）</h4><blockquote><p>描述</p><p>牛客每天有很多用户刷题，发帖，点赞，点踩等等，这些都会记录相应的积分。</p><p>有一个用户表(user)，简况如下：</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616896023720/B9EE61A3CF7F34EF411FE1A9C6B86FBC" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>还有一个积分表(grade_info)，简况如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616905385537/13C8EB67E494299F9396F462A8D0728D" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>第1行表示，user_id为1的用户积分增加了3分。</p><p>第2行表示，user_id为2的用户积分增加了3分。</p><p>第3行表示，user_id为1的用户积分减少了1分。</p><p>…….</p><p>最后1行表示，user_id为3的用户积分减少了1分。</p><p>请你写一个SQL查找积分最高的用户的id，名字，以及他的总积分是多少(可能有多个)，查询结果按照id升序排序，以上例子查询结果如下:</p><p><img src="https://uploadfiles.nowcoder.com/images/20210328/301499_1616905506009/26B900CFF8FB6BE2B2077D494CA1F237" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>解释:</p><p>user_id为1和3的先加了3分，但是后面又减了1分，他们2个是2分，</p><p>其他3个都是3分，所以输出其他三个的数据</p></blockquote><p>这道题是牛客最后一道题，但是挺简单的。</p><p>先来看这道题与众不同的是，有加（add）和减（reduce）两种操作，但是记录的数值都是正数，所以显然不能直接用<code>SUM()</code>，所以在用SUM之前我们先将其转换一下：</p><ol><li><p>把type = ‘reduce’的grade_num变成负数</p><blockquote><p>– grade_num数值的转换（子表a）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id,grade_num <span class="hljs-keyword">AS</span> g <span class="hljs-keyword">FROM</span> grade_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">'add'</span><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><span class="hljs-keyword">SELECT</span> user_id,(-grade_num) <span class="hljs-keyword">AS</span> g <span class="hljs-keyword">FROM</span> grade_info<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">'reduce'</span></code></pre></div></blockquote><p>将type字段是’add’的数据正常取出，将type字段是’reduce’给其grade_num加个负号</p><p>注意：这里一定要用<code>UNION ALL</code>而不能用UNION（UNION会去重，而UNION ALL不去重）</p><p>这样两个查询结果就上下拼接起来了（上面部分是grade_num为正数的行，下面部分是grade_num为负数的行，而它们都有相同的字段名）</p></li><li><p>求和排序</p><p>因为还是要求和并且取最高的，所以按老套路求和之后再套上一层SELECT</p><blockquote><p>– 求和排序（子表c）</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> g_sum <span class="hljs-keyword">DESC</span>) rs <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(g) <span class="hljs-keyword">AS</span> g_sum    <span class="hljs-keyword">FROM</span>  a    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id) b</code></pre></div></blockquote></li><li><p>表连接</p><p>最后user_id这些换成name，所以需要做表连接；并且WHERE条件过滤掉 rs = 1以外的数据</p><blockquote><p>– 表连接</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,g_sum <span class="hljs-keyword">FROM</span>  c<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = c.user_id<span class="hljs-keyword">WHERE</span> c.rs = <span class="hljs-number">1</span></code></pre></div></blockquote></li></ol><p>完整SQL语句如下：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,g_sum <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span> *,<span class="hljs-keyword">DENSE_RANK</span>() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> g_sum <span class="hljs-keyword">DESC</span>) rs     <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,<span class="hljs-keyword">SUM</span>(g) <span class="hljs-keyword">AS</span> g_sum        <span class="hljs-keyword">FROM</span> (        <span class="hljs-keyword">SELECT</span> user_id,grade_num <span class="hljs-keyword">AS</span> g <span class="hljs-keyword">FROM</span> grade_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">'add'</span>        <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>        <span class="hljs-keyword">SELECT</span> user_id,(-grade_num) <span class="hljs-keyword">AS</span> g <span class="hljs-keyword">FROM</span> grade_info        <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">'reduce'</span>        ) a        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id    ) b    ) c<span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">user</span><span class="hljs-keyword">ON</span> user.id = c.user_id<span class="hljs-keyword">WHERE</span> c.rs = <span class="hljs-number">1</span></code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 两万字牛客、leetcode的SQL题型总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>维度建模</title>
    <link href="http://example.com/2021/08/02/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1/"/>
    <id>http://example.com/2021/08/02/%E7%BB%B4%E5%BA%A6%E5%BB%BA%E6%A8%A1/</id>
    <published>2021-08-02T15:11:32.000Z</published>
    <updated>2021-11-24T08:48:06.243Z</updated>
    
    <content type="html"><![CDATA[<p>数仓模型里最常见的建模方法：维度建模</p><a id="more"></a><h2 id="数据模型相关概念"><a href="#数据模型相关概念" class="headerlink" title="数据模型相关概念"></a>数据模型相关概念</h2><p><strong>01. 基本概念</strong></p><p>维度建模，是数据仓库大师Ralph Kimball提出的，是数据仓库工程领域最流行的数仓建模经典。</p><p>维度建模以分析决策的需求出发构建模型，构建的数据模型为分析需求服务，因此它重点解决用户如何更快速完成分析需求，同时还有较好的大规模复杂查询的响应性能。它是面向分析的，为了提高查询性能可以增加数据冗余，反规范化的设计技术。</p><p>数据模型是指用数据来表达分析、决策的模型，而建立数据模型的方法有很多，维度建模就是众多方法的其中之一。</p><p><strong>1.1 事实表</strong></p><p>事实表产生于业务过程，存储了业务活动或事件提炼出来的性能度量。从最低的粒度级别来看，事实表行对应一个度量事件。</p><p>事实表根据粒度的角色划分不同，可分为事务事实表、周期快照事实表、累积快照事实表。</p><p>（1）<strong>事务事实表</strong>，用于承载事务数据，通常粒度比较低，它是面向事务的，其粒度是每一行对应一个事务，它是最细粒度的事实表，例如产品交易事务事实、ATM交易事务事实。</p><p>（2）<strong>周期快照事实表</strong>，按照一定的时间周期间隔(每天，每月)来捕捉业务活动的执行情况，一旦装入事实表就不会再去更新，它是事务事实表的补充。用来记录有规律的、固定时间间隔的业务累计数据，通常粒度比较高，例如账户月平均余额事实表。</p><p>（3）<strong>累积快照事实表</strong>，用来记录具有时间跨度的业务处理过程的整个过程的信息，每个生命周期一行，通常这类事实表比较少见。</p><p><em>注意：**这里需要值得注意的是，在事实表的设计时，一定要注意一个事实表只能有一个粒度，不能将不同粒度的事实建立在同一张事实表中。</em></p><p><strong>1.2 维度表</strong>  </p><p>维度表，一致性维度，业务过程的发生或分析角度，我们主要关注下退化维度和缓慢变化维。</p><p>（1）<strong>退化维度</strong>（DegenerateDimension）</p><p>在维度类型中，有一种重要的维度称作为退化维度，亦维度退化一说。这种维度指的是直接把一些简单的维度放在事实表中。退化维度是维度建模领域中的一个非常重要的概念，它对理解维度建模有着非常重要的作用，退化维度一般在分析中可以用来做分组使用。</p><p>（2）<strong>缓慢变化维</strong>（Slowly Changing Dimensions）</p><p>维度的属性并不是始终不变的，它会随着时间的流逝发生缓慢的变化，这种随时间发生变化的维度我们一般称之为缓慢变化维（SCD）。</p><p>SCD常用的三种处理方式：</p><p>① <strong>TYPE1</strong> 直接覆盖原值</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210815050950.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>② <strong>TYPE2</strong> 增加维度行</p><p>   <em>在为维度成员增加新行时，需为其分配新的主代理键。<strong>并且，至少需要在维度行再增加三列：</strong>有效日期、截止日期、行标识。**这个地方可联想拉链表设计。</em></p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210815051025.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>③ <strong>TYPE3</strong> 增加属性列 </p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210815051109.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>④ 混合方式</p><p>可根据实际业务场景，混合或选择使用以上三种方式，以快速方便而又准确的分析历史变化情况。</p><p><strong>1.3 粒度</strong></p><p>用于确定某一事实表中的行表示什么，是业务最小活动单元或不同维度组合，即业务细节程度。</p><p><strong>1.4 维度建模流程</strong></p><p>维度建模步骤：选择业务过程-&gt;声明粒度-&gt;确定维度-&gt;确定事实。旨在重点解决数据粒度、维度设计和事实表设计问题。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210815051204.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>声明粒度，为业务最小活动单元或不同维度组合。以共同粒度从多个组织业务过程合并度量的事实表称为合并事实表，需要注意的是，来自多个业务过程的事实合并到合并事实表时，它们必须具有同样等级的粒度。</p><p>以上四个步骤是维度建模的所有步骤，仅仅确定模型中的事实表和维度表。</p><p>而数据整个流向具体步骤如下：</p><ul><li>将详细的原子数据加载到维度结构中</li><li>围绕业务流程构建维度模型</li><li>确保每个事实表都有一个关联的日期维度表</li><li>确保单个事实表中的所有事实具有相同的粒度或详细程度</li><li>解析事实表中的多对多关系</li><li>解析维度表中的多对一关系</li><li>在维度表中存储报表标签和筛选值</li><li>确保维度表使用代理键</li><li>创建一致的维度以在整个企业中集成数据</li><li>提供DW/BI解决方案</li><li>支持业务用户的决策</li></ul><p>数据仓库建模方法论可分为：<strong>维度建模</strong>、范式建模、Data Vault模型、Anchor模型</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801225303.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>其中数仓最为常用的是<strong>维度建模</strong>，而维度建模建立的模型主要有三种：（1）<strong>星型模型</strong>、（2）<strong>雪花模型</strong>、（3）<strong>星座模型</strong></p><h2 id="维度建模的三种数据模型"><a href="#维度建模的三种数据模型" class="headerlink" title="维度建模的三种数据模型"></a>维度建模的三种数据模型</h2><h3 id="星型模型"><a href="#星型模型" class="headerlink" title="星型模型"></a>星型模型</h3><p>星型模型主要由维表和事实表构成，<strong>以事实表为中心</strong>，所有维度直接关联在事实表上，呈星型分布。</p><p><img src="C:%5CUsers%5CCAIWEI%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210815051258507.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>图来源于Kimball《The Data Warehouse Toolkits -3rd Edition》</p><h3 id="雪花模型"><a href="#雪花模型" class="headerlink" title="雪花模型"></a>雪花模型</h3><p>雪花模型，在星型模型的基础上，维度表上又关联了其他维度表。</p><p>雪花模型的维护成本较高，性能方面也较差，尤其是基于hadoop体系构建数仓，减少join就是减少shuffle，性能差距会很大。</p><ul><li><p><strong>区分星型模型与雪花模型</strong></p><p>与星型模型的区别：主要在维度，标准的星型模型维度只有一层，而雪花模型的维度会涉及多级，如图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801230325.png" srcset="/img/loading.gif" lazyload="" alt="星型模型与雪花模型"></p><ul><li><strong>星型模型和雪花模型的优劣对比</strong></li></ul><table><thead><tr><th align="left">属性</th><th align="left">星型模型</th><th align="left">雪花模型</th></tr></thead><tbody><tr><td align="left">数据总量</td><td align="left">多</td><td align="left">少</td></tr><tr><td align="left">可读性</td><td align="left">容易</td><td align="left">差</td></tr><tr><td align="left">表个数</td><td align="left">少</td><td align="left">多</td></tr><tr><td align="left">查询速度</td><td align="left">快</td><td align="left">慢</td></tr><tr><td align="left">冗余度</td><td align="left">高</td><td align="left">低</td></tr><tr><td align="left">对实时表的情况</td><td align="left">增加宽度</td><td align="left">字段比较少，冗余底</td></tr><tr><td align="left">扩展性</td><td align="left">差</td><td align="left">好</td></tr></tbody></table><ul><li><p>应用场景</p><p><strong>星型模型</strong>的设计方式主要带来的好处是能够提升查询效率，因为生成的事实表已经经过预处理，主要的数据都在事实表里面，所以只要扫描实时表就能够进行大量的查询，而不必进行大量的join，其次维表数据一般比较少，在join可直接放入内存进行join以提升效率，除此之外，星型模型的事实表可读性比较好，不用关联多个表就能获取大部分核心信息，设计维护相对比较简答。</p><p><strong>雪花模型</strong>的设计方式是比较符合数据库范式（比较靠近3NF，但无法完全遵守，因为完全遵循3NF的性能成本太高）的理念，设计方式比较正规，数据冗余少，但在查询的时候可能需要join多张表从而导致查询效率下降，此外规范化操作在后期维护比较复杂。</p></li></ul><h3 id="星座模型"><a href="#星座模型" class="headerlink" title="星座模型"></a>星座模型</h3><p>星座模型，是对星型模型的扩展延伸，多张事实表共享维度表。数仓模型建设后期，大部分维度建模都是星座模型。</p><p>星座模型与前两种的区别是<strong>事实表的数量</strong>，星座模型有多个事实表。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801234858.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><ul><li><p>星座不星座？</p><p>这个只跟数据和需求有关系，跟设计没关系，不用选择。</p><p>（需要星座模型的时候就得是星座模型，不需要的时候就不会是星座模型，所以不用选）</p></li><li><p>星型还是雪花？</p><p>取决于<strong>性能优先</strong>还是<strong>灵活优先</strong></p><p>如果性能优先，则选择星型模型；如果灵活优先则选择雪花模型。</p><p>在实际开发中，不会只选择一种，会根据情况组合甚至并存（一层维度和多层维度都保留）。但整体来看会更倾向于<strong>星型模型</strong>，尤其是Hadoop体系中，减少Join操作可减少Shuffle，性能差距很大（关系型库数据可以依靠强大的主键索引）。</p></li></ul><p>总结：</p><p>数据仓库大多数时候是比较适合使用<strong>星型模型构建底层数据Hive表</strong>，通过大量的冗余来提升查询效率，星型模型对OLAP的分析引擎支持比较友好，这一点在Kylin中比较能体现。而雪花模型在关系型数据库中如MySQL，Oracle中非常常见，尤其像电商的数据库表。在数据仓库中雪花模型的应用场景比较少，但也不是没有，所以在具体设计的时候，可以考虑是不是能结合两者的优点参与设计，以此达到设计的最优化目的。</p><h2 id="事实表的维度建模"><a href="#事实表的维度建模" class="headerlink" title="事实表的维度建模"></a>事实表的维度建模</h2><p>维度建模的中心是事实表（星型模型、雪花模型、星座模型都是以<strong>事实表</strong>为中心）,因而事实表是维度建模的核心表和基本表。它存储了业务过程中的各种度量和事实，而这些度量和事实正是下游数据使用人员所要关心和分析的对象。</p><p>接下来将探讨以下三种事实表：</p><ul><li>事务事实表</li><li>快照事实表</li><li>累计快照事实表</li></ul><h3 id="事务事实表"><a href="#事务事实表" class="headerlink" title="事务事实表"></a>事务事实表</h3><p>事务事实表是维度建模事实表中最为常见、使用最为广泛的事实表。</p><p>事务事实表通常用于记录业务过程的事件，而且是原子粒度的事件。事务事实表中的数据在事务事件发生之后，数据的粒度通常是每个事务一条记录。一旦事务被提交，事实表数据被插入，数据就不再进行更改。</p><p>我们通过事务事实表存储单次业务事件 / 行为的细节，以及存储与事件相关的维度细节，用户即可以单独或者聚合分析业务事件和行为。</p><p>事务事实表的粒度确定是事务事实表设计过程中的关键步骤，一般都会包含可加的度量和事实。理解概念的最佳途径无疑是实际的例子，因此下面将结合超市零售业务以及维度建模的四个环节来说明事务事实表。</p><p><strong>（1）选择业务过程</strong></p><p>在超市的零售示例中，业务用户做的事情是更好的理解POS系统记录顾客购买的情况，那么很容易确定业务过程就是POS系统记录的顾客购买情况，即在什么时候、什么商品、哪个收银台、销售了哪些产品等。</p><p><strong>（2）定义粒度</strong></p><p>顾客单次购买行为的体现是一张购物小票，但是事务事实表应该选择最原子粒度的事件，所以小票的子项（在业务上的动作即为收银员每次扫描的商品条码）应该是超市零售事务事实表的粒度。</p><p><strong>（3）确定维度</strong></p><p>小票子项的粒度确定后，销售日期、销售商品、销售收银台、销售门店等维度很容易被确定了。另一个不太容易考虑到的是维度是促销行为，但是通过和业务人员交流或者查看报表表头等也能够发现此维度。</p><p><strong>（4）确定事实</strong></p><p>维度设计的最后一步，是确定哪些事实和度量应该在事实表中出现。对于本例，商品销售数量、销售价格和销售金额很容易确定下来。但是实际上，商品的成本价是确定的，因此可以很容易地确定商品的销售毛利：（商品实际销售价格－商品成本价） 销售数量，基于下游使用便利这一因素，也应该将此放人事务事实表中。</p><p>基于毛利润也可以计算出毛利率，那么毛利率这种比例应该放入事务事实表吗？在事实表的设计中，一个常见的原则是只存放比例的分子和分母，因此比例的计算是和业务强，业务逻辑可能非常的复杂，所以一般不加入事实表中。</p><p>至此，我们也完成了超市零售事务的事实表和维度表的设计，超市零售事务事实表以及相关的维度表如图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zWSuIP8rdu1xpCsHSKOlS1xSo5WWsufMriaqfAVNwTl564heVN3dTOV7F4huibx5YKlrRqHWaZScjoXiakZscZuGw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="快照事实表"><a href="#快照事实表" class="headerlink" title="快照事实表"></a>快照事实表</h3><p>在实际的业务活动中，除了关心单次的业务事件和行为外，很多时候还关心业务的状态（当前状态、历史状态）。以超市零售业务为例，管理人员和分析人员除了关心销售情况，还会关心商品的库存情况，例如哪些商品的库存情况，例如哪些商品库存告罄需要补货、哪些积压需要促销，而这正是 <strong>快照事实表（也叫周期快照事实表）</strong>所要解决发范畴。</p><p>所谓周期快照事实表，是指间隔一定的周期对业务的状态进行一次拍照并记录下来的事实表。最常见的例子是销售库存、银行账户余额等。</p><p>与事务事实表的稀疏性不同（这里的稀疏性是相对的），周期快照事实表通常被认为是稠密的。因此事务事实表只有事务发生才会记录，但是周期快照则必须捕获当前每个实体的状态。</p><p>比如，某个商品如果某天没有销售，那么这个商品不会存在于当天的事务事实表中的，但是为了记录其库存情况，即使没有销售行为，也必须再周期快照事实表中对其进行拍照。</p><p>周期快照事实表的周期通常需要和业务方共同确定，最常见的周期是天、周和月等。</p><p>周期快照事实表中的事实一般是半可加的，如某个商品的库存可以跨商品、仓库等相加，但是明显在时间上相加是没有意义的。</p><p>下面就以超市的库存业务为例来介绍周期快照事实表的设计过程。</p><p><strong>（1）选择业务过程</strong></p><p>本例是为了更好地理解超市的库存情况，因此业务过程就是商品的库存情况，即在什么时候、什么商品、哪个仓库的库存量如何。</p><p><strong>（2）定义粒度</strong></p><p>这里的粒度主要指库存的周期，商品的粒度很容易确定（注意这里是 SKU 级别）。选择库存的周期需要考虑到数据量膨胀情况。</p><p>考虑如下例子，某个超市有 万个商品（即SKU）， 其有 100 家连锁店，那么每天对其库存拍照将有 100<em>10000=100 万行记录，那么一年将有 365</em>1000000=3.65亿条记录。当然随着目前存储的日益廉价，这些都不是问题，但是设计人员需要考虑到这些因素。</p><p><strong>（3）确认维度</strong></p><p>对于超市零售库存，相应的维度为周期（天 周、月等） 商品、仓库（总仓、分仓或者门店等）。</p><p><strong>（4）确定事实</strong></p><p>这里的事实很容易确定，即库存量。但是仅仅记录现存库存是不够充分的，因为业务上通常会和其他事实协同来度量库存的变化趋势、快慢等，所以还可对周期快照事实表的事实进行增强 。</p><p>基于上述设计的周期快照事实表及相关维度如图所示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zWSuIP8rdu1xpCsHSKOlS1xSo5WWsufMadt0wGdd7IGAib4NT8SuUMC4fggBpjbBMRZnVgw4kK8e6KMOCr9uK5Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="累计快照事实表"><a href="#累计快照事实表" class="headerlink" title="累计快照事实表"></a>累计快照事实表</h3><p>事实表的第三种类型是累计快照事实表，相比前两者，累计快照事实表没那么常见，但是对于某些业务场景来说非常有价值。</p><p><strong>累计快照事实表非常适用于具有工作流或者流水线形式业务的分**</strong>析**，这些业务通常涉及多个时间节点或者有主要的里程碑事件，而累计快照事实表正是从全流程角度对其业务状态的拍照。</p><p>考虑车险理赔业务，一次车险的理赔通常包括客户报案、保险公司立案、客户提交理赔材料、理赔审批通过和付款等关键步骤，而累积快照事实表正是从全流程角度对每个车险理赔单的拍照，拍照内容即是其关键步骤的各个状态，便于业务人员一目了然地分析各个理赔单的状态、步骤间的耗时等。</p><p>下面以车险理赔业务为例来介绍累计周期快照事实表。</p><p><strong>（1）选择业务过程</strong></p><p>本例是为了更好地理解保险公司的车险理赔业务，因此业务过程就是车险理赔，即在什么时候、 哪个理赔申请所处的状态如何。</p><p><strong>（2）定义粒度</strong></p><p>累计周期快照事实表的粒度一般很容易确定，就是业务的某个实体，这里即为保险理赔申请。</p><p><strong>（3）确定维度</strong></p><p>对于累计周期快照事实表，相关的维度包含快照周期（天、周、月 和年等）、理赔申请人、受理 、审核人、网点 电话或者实体）等。</p><p><strong>（4）确定事实</strong></p><p>这里的事实包括索赔金额、审批金额、打款金额、处理时长等。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zWSuIP8rdu1xpCsHSKOlS1xSo5WWsufMzATAjpktT6dZD89zaX1GZ9sryv7uaTQ4RIhULj4DX12RXbuTetudAA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="维度建模其他概念"><a href="#维度建模其他概念" class="headerlink" title="维度建模其他概念"></a>维度建模其他概念</h2><h3 id="1-角色扮演维度"><a href="#1-角色扮演维度" class="headerlink" title="1 角色扮演维度"></a>1 角色扮演维度</h3><p> 单个维度可以被事实表多次引用，每个引用连接逻辑上存在差异的角色维度。例如，事实表可以有多个日期，每个日期通过外键引用不同的日期维度，原则上每个外键表示不同的日期维度视图，这样引用具有不同的含义。这些不同的维度视图具有唯一的代理键列名,被称为角色，相关维度被称为<strong>角色扮演维度</strong>。</p><p>当一个事实表多次引用一个维度表时会用到角色扮演维度。例如，一个销售订单有一个是订单日期，还有一个请求交付日期，这时就需要引用日期维度表两次。</p><p>我们期望在每个事实表中设置日期维度，因为总是希望按照时间来分析业务情况。在事务型事实表中，主要的日期列是事务日期，例如，订单日期。有时会发现其它日期也可能与每个事实关联，例如，订单事务的请求交付日期。每个日期应该成为事实表的外键。</p><p><a href="https://cloud.tencent.com/developer/article/1012222" target="_blank" rel="noopener">HAWQ取代传统数仓实践（八）——维度表技术之角色扮演维度</a></p><h3 id="2-多对多关系和双向筛选器"><a href="#2-多对多关系和双向筛选器" class="headerlink" title="2 多对多关系和双向筛选器"></a>2 多对多关系和双向筛选器</h3><p>许多数据建模决策是性能和功能之间的权衡；使用迭代设计，你通常会找到解决问题的更好方法。有几种不同的方法可以设计多对多关系。传统的方法是使用桥接表，该桥接表包含将两个表关联在一起的所有键组合。在下面的示例中，“客户”和“产品”维度表通常有一个从关系的“一方”到“多方”的单向过滤器。如果要求根据购买产品的选定客户筛选产品，我们可以使用“销售”事实表作为桥接表，并将产品和销售之间的关系更改为使用双向筛选器。</p><p>根据关系的基数，使用双向过滤器可能会导致性能损失。如果我们只有100种产品，销售记录不到100万，这可能不是什么大事。如果我们有1万种产品和1亿份销售记录，这种关系可能会大大减慢速度(“除非必须这样做，否则不要这样做”)。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210802010318.png" srcset="/img/loading.gif" lazyload="" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数仓模型里最常见的建模方法：维度建模&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据仓库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
      <category term="数仓入门" scheme="http://example.com/tags/%E6%95%B0%E4%BB%93%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>数仓命名规范</title>
    <link href="http://example.com/2021/08/02/%E6%95%B0%E4%BB%93%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>http://example.com/2021/08/02/%E6%95%B0%E4%BB%93%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</id>
    <published>2021-08-02T13:18:37.000Z</published>
    <updated>2021-11-24T08:44:47.748Z</updated>
    
    <content type="html"><![CDATA[<p>数据仓库命名规范</p><a id="more"></a><p>这里分为<strong>表命名规范</strong>、<strong>字段命名规范</strong>、<strong>指标命名规范</strong>、<strong>作业命名规范</strong>，通常涉及表命名规范</p><h2 id="表命名规范"><a href="#表命名规范" class="headerlink" title="表命名规范"></a>表命名规范</h2><p>不同分层的表命名规范不一样（以下命名规范包括了库名），abc为补充的三个参数，具体见后面</p><ul><li><p>ODS层</p><p>即贴源层，由业务方直接导入，不会经过数据清洗转化。操作数据层定位于业务明细数据保留区，负责保留数据接入时点后历史变更数据，数据原则上全量保留。</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">项目名<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_ods</span>.</span></span>ods_系统名称(默认为空)_源表名_abc</code></pre></div></li><li><p>DW层</p><p>由ODS层数据经过清洗转化而成。这一层整合后的业务过程明细数据，负责各业务场景整合、数据结构化、规范化，常用公共维度冗余加工，以及明细业务标签信息加工。另外，在该层也会做一部分的数据聚合，将相同主题的数据汇集到一张表中，提高数据的可用性。</p><ul><li><p>dim层（维表）</p><div class="hljs code-wrapper"><pre><code class="hljs reasonml">项目名<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_dw</span>.</span></span>dim_项目名_业务描述_abc</code></pre></div></li><li><p>dwv（业务明细）</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">项目名_dw.dwv_项目名<span class="hljs-literal">_</span>一级主题域<span class="hljs-literal">_</span>二级主题域<span class="hljs-literal">_</span>业务描述_abc</code></pre></div></li><li><p>dwm（周期汇总）</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">项目名_dw.dws_项目名<span class="hljs-literal">_</span>数据粒度<span class="hljs-literal">_</span>业务描述<span class="hljs-literal">_</span>统计范围cycle[N]_abc</code></pre></div><p>例如：</p><p><code>projectname_dw.dwm_projectname_store_activity_byr_currcy_order_cycle7_sdt</code>说明：projectname是项目名，其数据粒度为店铺（store）+活动（activity）+买家（byr）+币种（currcy）;业务描述为下单（order）；统计的时间范围为近7天。</p></li><li><p>dws层（数据汇总服务）</p><div class="hljs code-wrapper"><pre><code class="hljs haxe">项目名_dw.dws_项目名<span class="hljs-literal">_</span>数据粒度<span class="hljs-literal">_</span>业务描述_abc</code></pre></div></li></ul></li></ul><blockquote><p><strong>abc 说明</strong></p><p>a：表示数据粒度类别: <strong>f</strong> 表示明细数据，<strong>s</strong>表示汇总数据。</p><p>b：表示数据更新周期: <strong>d</strong>表示天(t+1)产出; <strong>h</strong>表示小时产出; <strong>mi</strong>表示分钟产出; <strong>c</strong>表示全量产出; <strong>w</strong>表示周产出; <strong>m</strong>表示月产出，<strong>y</strong>表示月产出。</p><p>c：表示数据存储形态: <strong>t</strong>表示表; <strong>v</strong>表示视图。</p><p>abc会有多种不同的组合，比如 fct 表示dw层的全量表，fdt 表示dw层的增量表(天表)</p></blockquote><ul><li><p>作业命名规范</p><ul><li><p>数据采集作业（后缀import）</p><p>一般是采集变成ods层数据</p><div class="hljs code-wrapper"><pre><code class="hljs elm">项目名_ods.ods_系统名称_源表名_abc_<span class="hljs-keyword">import</span></code></pre></div><p>如：projectname_ods.ods_projectname_orders_fct_import</p></li><li><p>数据导出作业（后缀export）</p><p>同采集作业，但后缀改成export</p><p>projectname_store_method_h_export </p></li><li><p>数据查询作业</p><p>与产出目标表同名</p></li></ul></li></ul><h2 id="字段命名规范"><a href="#字段命名规范" class="headerlink" title="字段命名规范"></a>字段命名规范</h2><ul><li><p>度量词汇</p><p>次数：cnt</p><p>金额：amt</p><p>时长：dr</p><p>比例：rate</p><p>百分比：pct</p><p>环比：p2p</p></li></ul><ul><li><p>统计词汇</p><p>订单金额：order_amt</p><p>商品数：prod_cnt</p><p>用户数：uid_cnt</p><p>订单数：order_cnt</p><p>曝光次数：pv</p><p>点击次数：click_cnt</p><p>买家数：byr_cnt</p><p>卖家数：sel_cnt</p><p>店铺数：store_cnt</p></li></ul><ul><li><p>约定名词词汇</p><p>gmv：成交金额</p><p>cmv：取消金额</p><p>pmv：营业额</p><p>cancel：取消</p><p>consumer：顾客（有消费记录）</p><p>user：用户</p><p>member：会员</p><p>coins：购物金</p><p>sent：发送</p><p>used：使用</p><p>unuse：待使用/未使用（不含已过期）</p><p>source：来源</p><p>promotion：优惠</p></li></ul><ul><li><p>日期修饰词汇</p><p>日：d</p><p>小时：h</p><p>分钟：mi</p><p>周：w</p><p>月：m</p><p>季度：q</p><p>年：y</p><p>七日：7d</p></li></ul><ul><li><p>聚合词汇</p><p>total：历史累计</p><p>avg：平均</p><p>std：截止到当前统计日期</p></li></ul><ul><li><p>业务场景词汇</p><p>order：下单</p><p>pay：支付</p><p>refund：退款</p><p>return_goods：退货  </p><p>subs：订阅</p><p>reg：注册</p><p>login：登录  </p><p>visit：访问</p><p>add_chart：购物车</p><p>site：站点</p></li></ul><h2 id="指标命名规范"><a href="#指标命名规范" class="headerlink" title="指标命名规范"></a>指标命名规范</h2><p>1、指标统一：数据指标的内容及对应的命名、属性需要保持唯一性，无歧义。</p><p>2、指标统一目前只针对单一业务，暂不考虑跨业务间场景</p><p>3、指标统一命名：修饰语（业务场景限定条件）+对象+方法+时间范围 如cancel_order_cnt_1d</p><p>修饰语（业务场景限定条件）：cancel 取消；</p><p>统计对象：order 订单；</p><p>统计方法：cnt 记数，对订单进行去重统计；</p><p>统计周期：1d近一天的。</p><p>4、原子、派生指标之间的定义和关系</p><p>​    原子指标：基于某一业务事件行为下的度量，是业务定义中不可再拆分的指标，具有明确业务含义的名词 ，如支付金额。</p><p>​    派生指标: 由原子指标＋多个修饰词（可选）＋时间周期。可以理解为对原子指标业务统计范围的圈定。如原子指标：支付金额，最近一天海外买家支付金额则为派生指标（最近一天为时间周期，海外为修饰词 买家作为维度，而不作为修饰词）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据仓库命名规范&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据仓库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
      <category term="数仓入门" scheme="http://example.com/tags/%E6%95%B0%E4%BB%93%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>数仓主题域划分</title>
    <link href="http://example.com/2021/08/01/%E6%95%B0%E4%BB%93%E4%B8%BB%E9%A2%98%E5%9F%9F%E5%88%92%E5%88%86/"/>
    <id>http://example.com/2021/08/01/%E6%95%B0%E4%BB%93%E4%B8%BB%E9%A2%98%E5%9F%9F%E5%88%92%E5%88%86/</id>
    <published>2021-08-01T11:55:07.000Z</published>
    <updated>2021-11-24T08:44:57.642Z</updated>
    
    <content type="html"><![CDATA[<p>数据仓库主体域划分一直是个难题</p><a id="more"></a><p>因为数据仓库是面向主题的，所以主题域的划分显得很重要，因为主题域的确定也意味着数据的目的是干什么的。有关于主题划分的文章较少，阿里大数据之路这本书也没有单独的章节来讲主题域的划分，因为这个是需要对业务场景来说的，而且就算确定的业务场景也没有说百分百该如何划分，我还见过一群在互联网大数据领域有着多年工作经验的数仓专家们讨论某个表该划分到哪个主题域。所以，以下内容仅代表我在数仓主题域的一些拙见。</p><h2 id="什么是数据仓库主题域？"><a href="#什么是数据仓库主题域？" class="headerlink" title="什么是数据仓库主题域？"></a>什么是数据仓库主题域？</h2><p>主题域通常是联系较为紧密的数据主题的集合。可以根据业务的关注点，将这些数据主题划分到不同的主题域。主题域的确定必须由最终用户和数据仓库的设计人员共同完成。</p><h2 id="划分主题域方法"><a href="#划分主题域方法" class="headerlink" title="划分主题域方法"></a>划分主题域方法</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><p>在业务调研之后，可以进行主题域的划分。划分主题域，需要分析各个业务模块中有哪些业务活动。通常我们按照以下方法划分主题域，可以按照用户企业的部门划分，也可以按照业务过程或者业务板块中的功能模块划分。</p><ul><li>按照系统划分：业务系统有几种，就划分为几类</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801204402.png" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li>按业务划分：比如业务系统中有商品、交易、物流等过程，那这里的每一个过程就划分到一个主体域里。相对来说按业务划分主题域较常用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801215033.png" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li>按部门规划：比如公司内的生产、供应链、研发、销售等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801204847.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="数据中台常用方法"><a href="#数据中台常用方法" class="headerlink" title="数据中台常用方法"></a>数据中台常用方法</h3><p>目前较多大型互联网公司都有建设数据中台，这种模式下较多按业务划分。这种除了具有一级主题域以外，每个一级主题域还有二级主题域。具体架构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801214947.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>具体表现例子：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801215726.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>当然，在实际的业务中每个一级域下的二级域也不会就这么两三个。</p><h2 id="主题域的核心"><a href="#主题域的核心" class="headerlink" title="主题域的核心"></a>主题域的核心</h2><p>为保障整个体系的生命力，主题域需要抽象提炼，并长期维护更新，但不轻易变动。划分数据域时，需满足以下两点：</p><ul><li>能涵盖当前所有的业务需求。</li><li>能在新业务进入时，无影响地被包含进已有的主题域中和扩展新的主题域。</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="一次能划分好主题域吗"><a href="#一次能划分好主题域吗" class="headerlink" title="一次能划分好主题域吗"></a>一次能划分好主题域吗</h3><p>首先，主题域是无法一次划分完整的，一般是一次先建立几个明确的主题，在大多数数据仓库的设计过程中都有一个主题域的选择过程。业务是一直发展的，因此设计之初不要想着一次把所有主题全部划分完整。我们可以遵循上面说的划分主题域的两个要点，后续采用迭代的方式补充。</p><h3 id="划分为几个主题域合适"><a href="#划分为几个主题域合适" class="headerlink" title="划分为几个主题域合适"></a>划分为几个主题域合适</h3><p>主题域的个数由业务复杂度决定，但建议一级主题域在10个以内。</p><h3 id="感觉可以划分到多个主题域？"><a href="#感觉可以划分到多个主题域？" class="headerlink" title="感觉可以划分到多个主题域？"></a>感觉可以划分到多个主题域？</h3><p>表只能属于一个一级主题域，在一些比较模糊中的报表中，例如如果有一级数据域：商品域、订阅域，那商品中的订阅该划分到商品域还是订阅域？</p><p>这种比较容易让人接受的是以<strong>数据内容</strong>来划分域。不同的人有不同的看法，但是数据团队一定要制定统一的规范。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据仓库主体域划分一直是个难题&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据仓库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
      <category term="数仓入门" scheme="http://example.com/tags/%E6%95%B0%E4%BB%93%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>数仓基础概念</title>
    <link href="http://example.com/2021/07/30/%E6%95%B0%E4%BB%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2021/07/30/%E6%95%B0%E4%BB%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-07-30T10:56:25.000Z</published>
    <updated>2021-11-24T09:37:11.695Z</updated>
    
    <content type="html"><![CDATA[<p>了解数据仓库</p><a id="more"></a><h2 id="1-数据仓库的定义"><a href="#1-数据仓库的定义" class="headerlink" title="1. 数据仓库的定义"></a>1. 数据仓库的定义</h2><p><strong>问：什么是数据仓库?</strong></p><p>数据仓库面向主题（整个处理流程）、具有集成（数据整合）、随时间相对稳定、反映历史变化。</p><h2 id="2-事实表与维度表"><a href="#2-事实表与维度表" class="headerlink" title="2. 事实表与维度表"></a>2. 事实表与维度表</h2><p>维表是观察该事物的角度（维度），事实表是要关注的内容（结果）</p><ul><li><p>维度表的特点</p><p><strong>维度表的冗余很大</strong>，主要是维度一般不大（相对事实表来说），而维度表的冗余度可以使事实表节省很多空间。</p></li><li><p>事实表的特点</p><p>事实表一般都很大，如果以普通方式查询的话，得到结果所需要的时间很长。所以一般需要进行一些特殊处理（比如预生成处理）</p><p>事实表一般没有主键，维度表的主键一般都是整型（目的是节约事实表存储空间）</p></li></ul><h2 id="3-多维数据建模"><a href="#3-多维数据建模" class="headerlink" title="3. 多维数据建模"></a>3. 多维数据建模</h2><h3 id="3-1-星型模型"><a href="#3-1-星型模型" class="headerlink" title="3.1 星型模型"></a>3.1 星型模型</h3><p>星型模型主要由维表和事实表构成，<strong>以事实表为中心</strong>，所有维度直接关联在事实表上，呈星型分布。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/1OYP1AZw0W1UwPYvStthXYOIVIJMRPHg8cs4Mkghw3E3KRLbgSgMAT1PHibFQ5noseRpicmylmKp3gKPc0LMAyDg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload="" alt="图片"></p><p>图来源于Kimball《The Data Warehouse Toolkits -3rd Edition》</p><h3 id="3-2-雪花模型"><a href="#3-2-雪花模型" class="headerlink" title="3.2 雪花模型"></a>3.2 雪花模型</h3><p>雪花模型，在星型模型的基础上，维度表上又关联了其他维度表。</p><p>雪花模型的维护成本较高，性能方面也较差，尤其是基于hadoop体系构建数仓，减少join就是减少shuffle，性能差距会很大。</p><ul><li><p><strong>区分星型模型与雪花模型</strong></p><p>与星型模型的区别：主要在维度，标准的星型模型维度只有一层，而雪花模型的维度会涉及多级，如图：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801230325.png" srcset="/img/loading.gif" lazyload="" alt="星型模型与雪花模型"></p><ul><li><strong>星型模型和雪花模型的优劣对比</strong></li></ul><table><thead><tr><th align="left">属性</th><th align="left">星型模型</th><th align="left">雪花模型</th></tr></thead><tbody><tr><td align="left">数据总量</td><td align="left">多</td><td align="left">少</td></tr><tr><td align="left">可读性</td><td align="left">容易</td><td align="left">差</td></tr><tr><td align="left">表个数</td><td align="left">少</td><td align="left">多</td></tr><tr><td align="left">查询速度</td><td align="left">快</td><td align="left">慢</td></tr><tr><td align="left">冗余度</td><td align="left">高</td><td align="left">低</td></tr><tr><td align="left">对实时表的情况</td><td align="left">增加宽度</td><td align="left">字段比较少，冗余底</td></tr><tr><td align="left">扩展性</td><td align="left">差</td><td align="left">好</td></tr></tbody></table><ul><li><p>应用场景</p><p><strong>星型模型</strong>的设计方式主要带来的好处是能够提升查询效率，因为生成的事实表已经经过预处理，主要的数据都在事实表里面，所以只要扫描实时表就能够进行大量的查询，而不必进行大量的join，其次维表数据一般比较少，在join可直接放入内存进行join以提升效率，除此之外，星型模型的事实表可读性比较好，不用关联多个表就能获取大部分核心信息，设计维护相对比较简答。</p><p><strong>雪花模型</strong>的设计方式是比较符合数据库范式（比较靠近3NF，但无法完全遵守，因为完全遵循3NF的性能成本太高）的理念，设计方式比较正规，数据冗余少，但在查询的时候可能需要join多张表从而导致查询效率下降，此外规范化操作在后期维护比较复杂。</p></li></ul><h3 id="3-3-星座模型"><a href="#3-3-星座模型" class="headerlink" title="3.3 星座模型"></a>3.3 星座模型</h3><p>星座模型，是对星型模型的扩展延伸，多张事实表共享维度表。数仓模型建设后期，大部分维度建模都是星座模型。</p><p>星座模型与前两种的区别是<strong>事实表的数量</strong>，星座模型有多个事实表。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210801234858.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h2 id="4-数据仓库和数据库的区别？"><a href="#4-数据仓库和数据库的区别？" class="headerlink" title="4.数据仓库和数据库的区别？"></a>4.数据仓库和数据库的区别？</h2><ul><li><p>数据库是面向事务的，数据由日常业务产生，常更新</p><p>数据仓库是面向主题的，数据来源于数据库或文件，经过一定的规则转换得到，用于分析决策</p></li><li><p>数据库一般是存储<strong>当前</strong>数据的</p><p>数据仓库一般存储的是<strong>历史</strong>数据</p></li><li><p>数据库的设计一般要符合三范式，有最大精确度和最小冗余度，有利于数据的插入</p><p>数据仓库的设计一般是按照数仓建模规范，有一定的冗余，有利于查询</p></li></ul><h2 id="5-数据仓库建模5步法"><a href="#5-数据仓库建模5步法" class="headerlink" title="5.数据仓库建模5步法"></a>5.数据仓库建模5步法</h2><ol><li><p>确定主题（目标是什么）</p><p>即确定数据分析或前端展示的主题（例如：某年某月某地区的啤酒销售情况）。</p><p>主要体现出某一方面的分析角度（维度）和统计数值型数据（指标）之间的关系。</p><p>确定主题时要综合考虑。</p></li><li><p>确定数据指标（度量单位）</p><p>确定主题后，要考虑分析的数据指标（例如年销售额等）。数据指标是要统计的指标，必须事先选择恰当。（如果条件允许，则依托一套元数据管理会做得更好）</p></li><li><p>确定事实数据粒度（最小研究单位）</p><p>确定数据指标之后，需要考虑该指标的汇总情况和不同维度下指标的聚合情况。例如在业务系统中数据最小记录到秒，而在数仓建设需求中，时间可能只需要精确到天就可以了。</p></li><li><p>确定维度（分析的角度）</p><p>维度是分析的各个角度，例如：我们希望按照时间、地区、产品进行分析，那么这里的时间、地区、产品就是维度。基于不同的维度，可以看到各种数据指标的汇总情况，也可以基于所有维度进行交叉分析（这里的所有维度是指模型中列入的维度）。</p></li><li><p>创建事实表（结果表）</p><p>在确定好实时数据和维度后，将考虑加载事实表。业务系统中的一条条订单、交易数据就是将要简历的事实表的原始数据（原始表）。通常是将原始表与维度表进行关联，生成事实表。</p></li></ol><h2 id="6-数仓专业术语"><a href="#6-数仓专业术语" class="headerlink" title="6. 数仓专业术语"></a>6. 数仓专业术语</h2><h3 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h3><p>ETL（Extract-Transform-Load）是指将业务系统中的数据进行<strong>抽取、转换、加载</strong>到数据仓库的过程，目的是将企业中分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析的依据。</p><h3 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h3><p>联机分析处理（Online analytical processing，OLAP），从数据仓库中抽取详细数据的一个子集并经过必要的聚集，存储到OLAP存储器中供前端分析工具读取。</p><h3 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h3><p>联机(在线)事务处理(On-Line Transaction Processing，OLTP)，主要是执行日常的事务处理，比如数据库记录的增删改查。OLTP的特点一般有：实时性要求高，数据量不大，高并发，并且要求满足ACID原则。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解数据仓库&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据仓库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
    
      <category term="数仓入门" scheme="http://example.com/tags/%E6%95%B0%E4%BB%93%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>大数据技术的演变：计算框架</title>
    <link href="http://example.com/2021/06/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E5%8F%98%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2021/06/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E5%8F%98%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6/</id>
    <published>2021-06-07T10:02:18.000Z</published>
    <updated>2021-11-24T08:37:03.309Z</updated>
    
    <content type="html"><![CDATA[<p>从计算框架的角度来看大数据技术18年来的变化</p><a id="more"></a><h2 id="开篇语"><a href="#开篇语" class="headerlink" title="开篇语"></a>开篇语</h2><p>大数据技术最早源自于Google，主要是因为Google需要面对的数据量太大了（2003年的时候Google就已经有几百亿的搜索量了）。为了省去重复造轮子节省劳动成本，Google内部以及工业界都亟须一套工具来处理大规模的数据。</p><p>接下来，将从大数据计算框架的演变来观看大数据技术的前世今生。</p><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/hadoop-logo.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>2003 年，Google工程师Jeffrey Dean等人的论文《MapReduce: Simplified Data Processing on Large Clusters》的发表标志着大数据技术的来临。</p><p>MapReduce是Hadoop的计算框架（Hadoop1.x主要由用于存储的分布式文件系统<code>HDFS</code>和计算框架<code>MapReduce</code>组成），MapReduce的逻辑较为简单（思想是较简单，但操作就复杂了），其思想为分而治之，主要分为<code>Map</code>和<code>Reduce</code>两个阶段。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/s5KOH2nhNXTZ6wl.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>而Hadoop 1.x中的存储则由HDFS（分布式文件系统）完成</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210411110426377.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>为了统一管理分布式系统中的资源，Hadoop 2.x版本中增加了一个重要模块——<code>yarn</code>。yarn是一个资源管理器，其作用是在Hadoop集群（Hadoop任务）中分配资源（内存、CPU等），故Hadoop 2.x版本的架构是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210411110708380.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>此外，伴随着Hadoop诞生的还有HBase（分布式数据库）、Hive（数据仓库工具，提供类似SQL的接口）、Sqoop（数据同步工具）、Ooize（作业调度系统）</p><p>在这里逐一介绍一个各个组件的作业：</p><ul><li><p>Hive</p><p>Hive主要解决<strong>“存储和计算问题”</strong>（海量数据的三大问题为：“传输问题，存储问题，计算问题”）</p><p>Hive存储的数据是在HDFS上的，但它可以将分布式的数据文件映射为一张表，并提供类SQL的查询功能（简称Hive-SQL，也简称HQL）。</p><p>Hive的本质是<strong>“将SQL转换成MapReduce程序”</strong>（MapReduce写起来很麻烦，现在几乎没人写了，想象一下写汇编语言）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210411112518503.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><ul><li><p>HBase</p><p>HBase是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统</p><p>（注意一个是文件系统，一个是数据库。可以说HBase跟HDFS没什么关系，只是文件系统是通过HDFS来支持的）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210411113038717.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><ul><li><p>Sqoop</p><p>Sqoop可将多种数据库的数据导入到HDFS中，也可以在HDFS上的数据导出到数据库。</p><p>在大数据应用的业务场景中，数据通常来源于多个不同的数据库，比如<code>MySQL</code>、<code>Ti-DB</code>、<code>Redis</code>，而每种数据库的存储格式又是不一样的，所以在使用时需要对这些数据进行一个规范化操作。与Sqoop类似的数据同步框架有阿里开发的<code>DataX</code>，为了便于理解，在此只讲解DataX架构图。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012050.png" srcset="/img/loading.gif" lazyload="" alt="DataX数据同步原理图"></p><p>上图中左侧可以看出，多种数据源之间转换是较为复杂的；DataX将源自MySQL、Oracle的数据转换为统一的格式，再将该格式转换为目标格式（如上图右侧部分）。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/2dZ9A1eXsmghtSR.png" srcset="/img/loading.gif" lazyload="" alt="DataX工作流程图"></p></li><li><p>Ooize</p><p>Ooize是一个调度系统。Linux系统也有自带的调度系统<code>crontab</code>，crontab可以实现定时触发某个程序（任务）。但是仅仅定时触发某个程序是远远无法满足业务需求的，因为在实际的大数据业务场景中，还会涉及有<code>依赖项</code>的作业，举个栗子：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012147.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>定时作业启动后分别得到作业1和作业2，而实际应用中我们需要当作业1和作业2都有数据之后触发作业3（这种情况称作业1和作业2是作业3的上游依赖项），那么这种情况crontab是很难完成的，因而需要Ooize。</p></li><li><p>Flume</p><p>Flume是一个<code>高可用</code>的分布式的海量日志采集、聚合和传输的系统。对于数据库来说，日志代表着操作，故日志采集系统一定要有高可用性（High Availability）。</p></li><li><p>Zookeeper</p><p>ZooKeeper是一个分布式的应用程序协调服务。因为大数据框架中各种组件多，Zookeeper的作用即是保证<code>事务一致性</code>。</p></li></ul><p>还有许多形形色色的大数据组件，但是这里仅仅讲解一些目前（2021年）较常用的大数据框架及组件（其中MapReduce也已经被淘汰了，但是作为大数据时代三驾马车之一，其影响较大，故还是需要学习一下）</p><p>Hadoop时代的大数据框架架构大概如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012322.png" srcset="/img/loading.gif" lazyload="" alt="Hadoop时代大数据架构"></p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012351.png" srcset="/img/loading.gif" lazyload="" width="30%"></p><p><strong>MapReduce存在的问题</strong></p><p>MapReduce作为最早的大数据计算框架，有着规范的批处理流程，但是太慢了，谷歌在十几年前尝试着优化，但是花费了五年时间效率也仅仅提升了百分之几，在性能方面已几乎达到了瓶颈；此外，由于MapReduce只提供Map和Reduce两种操作，故完成一项大数据相关任务往往需要多个MapReduce子任务，多个子MapReduce需要一个接一个执行从而形成一条链路，而链路中只要有一个MapReduce出错或者失败就会影响整个任务，这种情况使得大数据在业务场景中的应用受到很大的限制。</p><p>企业需要相对较快且对较高开发效率且稳定的大数据处理技术，而Spark恰巧满足了这种需求。</p><p><strong>新一代大数据计算框架</strong></p><p>Spark是一个基于内存计算技术的大数据计算框架，其<code>微批处理</code>（即把不同时间段的数据当作多个小块数据来处理）可以实现准实时计算。Spark的核心功能是RDD（弹性分布式数据集，即RDD只记录每一份数据集分别在哪台服务器节点等配置信息从而使得RDD像是一个分布式的数据集），RDD有着map、reduce在内的数十种操作，相比MapReduce，Spark在针对业务场景中简单易用。</p><p>大多数情况下，Spark的速度是Hadoop的数倍甚至上百倍（Spark的启动引擎较慢，所以在处理小规模的数据时比MapReduce、Hive快得不多甚至更慢）。从运行逻辑斯蒂回归算法在Spark 和 Hadoop 所需时间对比（x轴是迭代次数）：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606104325.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>此外，Hadoop这种需要多次读写入硬盘的模式并不适合机器学习算法这类需要迭代的计算（读写硬盘会需要较长的时间），而Spark直接在内存中计算故并不会有这类问题，在2013年之后国内的一线互联网公司基本上都采用Spark了。</p><p>此外Spark也提供了Spark ML（机器学习），Spark SQL（类似SQL的操作接口），Spark Streaming（实时处理）等模块</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012531.png" srcset="/img/loading.gif" lazyload="" alt="Spark模块"></p><p>Spark即支持<code>批处理</code>又支持<code>流处理</code>，此外在架构设计上的优越注定会在性能、业务适应等多方面完爆MapReduce（事实上，MapReduce早就被国内外的一线互联网公司淘汰了，有兴趣的读者可以看看Google Brain资深工程师蔡元楠老师的<a href="https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/article/90081%3Futm_term%3DzeusL8H4I%26utm_source%3Dzhihu%26utm_medium%3Djikeshijian%26utm_campaign%3D167-presell%26utm_content%3D0417bannerlink">为什么MapReduce会被硅谷一线公司淘汰？</a>）</p><p>在Spark中执行流程是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012557.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p>其中<code>DataFrame</code>和<code>Dataset</code>是Spark的两种数据类型（SQL、DataFrame、Dataset都是RDD的上层接口），可以用Scala、Java、python、R编写（其中Dataset是不支持Python和R语言的，并且性能以及功能支持上这几门编程语言在Spark的性能上依次递减，即Spark对Scala支持最好，对R支持最差，Java编写的Spark代码运行速度是Python的10倍左右）</p><p>此时，大数据技术在常见的业务应用中的架构图是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012654.jpg" srcset="/img/loading.gif" lazyload="" alt="批处理与流处理在业务中的应用"></p><ul><li><p>kafka</p><p>这里说一下<code>Kafka</code>，一种<code>高吞吐量</code>的分布式发布订阅消息系统（MQ系统），其在众多消息系统中一枝独秀（高吞吐量，想象一下排队，人数一定的情况下是不是进得快出得快体验更佳）。Kafka在数据的实时计算中有着重要的作用。</p></li></ul><h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012840.png" srcset="/img/loading.gif" lazyload="" width="30%"></p><p>Spark中的实时计算模块是Spark Streaming（现在Spark在流处理方面都用<code>Structured Streaming</code>了），严格来说，这只是准实时（近实时）计算，其延迟是在<code>1分钟</code>以内。Spark微批处理的思想使得其有相比MapReduce有较快的速度，因而在批处理（离线计算）和流处理（实时计算）方面都有着良好的效果，但是这种设计也限制了Spark在实时处理方面的发展。而在一些业务场景中需要更快速的处理数据（例如金融、支付等），经过多年的发展，Flink在众多实时计算框架中脱颖而出（最早的实时计算框架Storm也很少见了）。</p><p>Flink在官网上是这样写的： Stateful Computations over Data Streams（数据流上的有状态计算），显然Flink中最重要的一个概念是<code>State</code>(状态)，这种设计天然符合无边界数据的处理（无边界数据是指持续增长的数据）。Flink的设计思想使得Flink可以达到实时计算要求，延迟在<code>毫秒级</code>（即1秒钟以内）。到2021年的今天，Flink已经被应用在国内的众多知名互联网公司。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606012939.png" srcset="/img/loading.gif" lazyload="" alt="Flink执行流程"></p><p>Flink有着与Spark相似的一些概念，例如也有Flink ML（机器学习）、Dataset、Datastream（像不像Spark Streaming）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013021.png" srcset="/img/loading.gif" lazyload="" alt="Flink模块"></p><h2 id="Beam"><a href="#Beam" class="headerlink" title="Beam"></a>Beam</h2><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013115.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>在业务场景中，批处理与流处理混用是很常见的，批处理与流处理统一框架Beam应运而生。在此前，批处理和流处理往往需要两套计算框架，例如本文Spark部分的最后一张图中，Hadoop（这里的Hadoop通常是指MapReduce）与Spark Streaming并存（现在大部分公司是Spark+Flink了。尽管Flink号称批流统一，但相比微批处理，实时计算是被认为不稳定的）。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013517.jpeg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>那么这种情况下往往需要对离线和实时作业都进行相应的开发，这个过程会涉及数据平台、数据服务、数据仓库、运维等多个开发团队，消耗的人力成本是巨大的。基于Beam开发的数据处理程序可以执行在已经支持的任意分布式计算引擎上（目前Spark、Flink、Dataflow、samza、twister2都已经支持，对storm的支持在开发中），如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013249.png" srcset="/img/loading.gif" lazyload="" width="50%"></p><p><strong>Beam不是计算框架</strong>，但仍然出现在这一篇文章里，因为Beam与计算框架密切相关。Beam最重要的是编程模型思想，Beam中有着大量的抽象封装，例如<strong>PCollection</strong>（PCollection 是无序且没有固定边界的）、PValue、Transform。Beam的设计思想相对较为复杂，但绝不是多余的（试想RDD相比MapReduce也较为复杂，但如果不这样设计怎么满足得了各种复杂的业务需求呢）。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20210606013341.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>大数据框架及组件自2003年出现以来就不断迭代变化，经历了从批处理（Hadoop）到微批处理（Spark），再到流处理（Flink）。</p><p>在2003年，大数据框架首选肯定是Hadoop（因为当时也只有Hadoop）。</p><p>但是，在2009年Spark开源后（尤其是已经在业界论证了Spark性能在Hadoop之上时），面临着继续使用Hadoop和使用Spark的两种选择。作为一个新人，当然是只是需要花少量时间在Hadoop上，而主要学习Spark。</p><p>但对于已有成熟的大数据业务及应用的互联网公司开发人员，如果继续使用Hadoop则意味着需要忍受在开发维护上麻烦较多且性能不佳，如果选择使用Spark则意味着需要进行大规模的技术栈迁移（想象一下既要工作又要学习新技术）。</p><p>而到了2014年Flink出现的时候呢？还是面临着类似的选择。</p><p>但如果一开始就有 Beam ，或许就不必有这个烦恼了。（但目前国内外互联网公司和社区的情况来看，Apache Beam已经扑街了）</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>大数据框架经过18年的演变有着较大的变化，对于大数据技术从业者来说，仍然需要不断学习充电。那么，当面临新的一代大数据框架，你会怎么做呢？</p><p>“拥抱变化”——Jack马（作者：我信你个鬼，我选择躺平）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从计算框架的角度来看大数据技术18年来的变化&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hadoop" scheme="http://example.com/tags/Hadoop/"/>
    
      <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
      <category term="Flink" scheme="http://example.com/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>深度学习图像采样总结</title>
    <link href="http://example.com/2021/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-22T06:24:23.000Z</published>
    <updated>2021-11-24T08:43:57.195Z</updated>
    
    <content type="html"><![CDATA[<p>就硬卷…</p><a id="more"></a><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>深度学习是机器学习和人工智能研究的最新且最热门的趋势之一。深度学习方法为计算机视觉带来了革命性的进步，新的深度学习理论和技术正在不断诞生，在计算机视觉领域超越传统的机器学习甚至是现有的深度学习方法。近年来，有关深度学习方面的研究成果爆炸式地增长，由于其发展迅猛，导致了它的进展很难被新的研究者入手并跟进。此外，深度学习已有的方法数量上过于庞大，种类上过于繁多，虽然有大量的深度学习综述为研究者提供现有的研究发展情况，但是其往往是全面地介绍整个深度学习方法。因而，本文将着重于计算机视觉领域，从深度学习方法中的图像采样对深度学习展开叙述。</p><h2 id="1-序言"><a href="#1-序言" class="headerlink" title="1.序言"></a>1.序言</h2><p>深度学习（DeepLearning，DL）被认为是机器学习（Machine Learning ，ML）子领域，其采用多层次的非线性信息处理和抽象，用于有监督、无监督、半监督、自监督、弱监督等的特征学习、表示、分类、回归和模式识别等[1-01]。在 2000 年时深度学习的方法被用于人工神经网络（ANN），随着层数的加深，人工神经网络的被单独提出深层神经网络（DNN）这一分支。在2012年 ImageNet大规模视觉识别挑战赛上卷积神经网络AlexNet获得冠军，并且误判率令人惊艳[1-02]，从此卷积神经网络受到众多研究者的瞩目，并促使了深度学习的快速发展，目前计算机视觉（CV）领域多使用卷积神经网络，并且神经网络深度逐渐加深[1-03]。在自然语言处理（NLP）领域，由于循环神经网络（RNN）结构使得其较适合处理文本分析等场景从而受到众多研究者的欢迎。生成对抗网络以零和博弈的思想依赖生成模型和判别模型使得在图像生成方面效果良好。此外，较为常用的深度学习方法还有自编码器[1-04]、胶囊网络[1-05]、属于循环神经网络的长短记忆网络[1-06]、增强神经网络、深度信念网络、 深度朗伯网络、循环支持向量机等[1-07]。</p><p>对于图像分类、处理任务，神经网络中一大部分操作是采样，尤其是卷积神经网络。而神经网络的采样操作中较为常见的为卷积和池化，另外还有反卷积、反池化等多种多样的采样操作。各种采样的目的与原理都不尽相同，正是这些不一样的采样构成了神经网络结构中重要的部分。</p><h2 id="2-上采样与下采样"><a href="#2-上采样与下采样" class="headerlink" title="2.上采样与下采样"></a>2.上采样与下采样</h2><h3 id="上采样"><a href="#上采样" class="headerlink" title="上采样"></a>上采样</h3><p>在计算机视觉领域，输入图像通过卷积核提取特征后，输出的尺寸可能会变小，虽然在图像分类的是没有需要将图像再次恢复到原来的尺寸，但是图像的语义分割等却是需要恢复图像尺寸以便进行进一步计算。这种扩大图像尺寸，实现图像从小分辨率提升到大分辨率的映射操作，叫做上采样(Upsample)。 目前常见的上采样有插值法、反卷积、反池化，此外深度学习中的上采样方法还有 ： 扩张（空洞）卷积（dilated conv） 、PixelShuffle 、 DUpsampling 、 Meta-Upscale 、 CAPAFE等。</p><p>其中插值的方法，即在原图像已有的像素点之间插入新的像素点。目前已有的插值方法包括：双线内插法、 三次内插法 、反距离加权插值法、克里金插值法、最小曲率法、谢别德法、自然邻点插值法、最近邻点插值法、多元回归法、径向基函数法、线性插值三角网法、移动平均法、局部多项式法、 距离倒数乘方法 、 自然邻点插值法 、 拉格朗日插值法、牛顿均差插值法、分段线性插值、分段三次Hermite插值、三次样条插值[2-01~10]……插值的在超分辨率图像重建等方面有重要的应用。</p><p>反卷积和反池化等则常在卷积神经网络中出现。</p><h3 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h3><p> 下采样（subsampled）也称为降采样downsampled），其采样层是使用池化的相关技术来实现，目的是降低维度并保留有效特征，可在一定程度避免过拟合。</p><p>池化属于降采用的一种，池化除了降低维度，其目的还有保持旋转、平移、伸缩不变形，增大感受野等。采样有最大值采样，平均值采样，求和区域采样和随机区域采样等；池化也类似地有最大值池化，平均值池化，随机池化，求和区域池化等。</p><p>降采样原理：对一个尺寸大小为M * N地图像 ，对其进行 s倍下采样，即得到$\frac{M * N}{s^2}$分辨率地图像，其中$s$是$M$,$N$的公约数。具体对于特征图，则是把原始图像像素点为$s*s$的区域的变成一个像素，这个像素点的值就是该区域内所有像素的均值：$p_k=\sum_{i \in win(k)}I_i/s^2$</p><p>降采样的作用主要有：</p><ol><li><p>保持平移、旋转等的不变性；</p></li><li><p>降维的同时保留主要特征，减少计算量，防止过拟合，提高模型泛化能力。 </p></li></ol><p>卷积神经网络中常见的降采样通过是池化层实现，目前常见的池化层有：最大池化层，平均池化层等。池化目的是对输入的特征图（Feature Map）进行降维以减少参数并且保留有效的特征，以减少之后的运算量。</p> <center><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/paper/深度学习图像采样综述(1.jpg" srcset="/img/loading.gif" lazyload="" width="600"></center> <h2 id="3-卷积神经网络中的图像采样"><a href="#3-卷积神经网络中的图像采样" class="headerlink" title="3.卷积神经网络中的图像采样"></a>3.卷积神经网络中的图像采样</h2><p>近几年来随着深度学习的迅速发展，卷积神经网络在计算机视觉领域理论与应用快速发展。2012年AlexNet[3-01]在ImageNet 大规模图像分类挑战赛的成绩让众多研究者看到神经网络在计算机视觉上的历史性突破，由此掀起了卷积神经网络的研究热潮，深度学习也从学术界到业界逐渐被大众熟知。之后，新的神经网络不断出现，著名的有牛津大学视觉几何组在2014年提出的VGGNet [3-02]、由谷歌研究人员提出的GoogleNet [3-03] ；2016年由何凯明等人提出的ResNet [3-04] 使神经网络超过上百层且效果更佳，并衍生出了ResNeXt、DenseNet 、NPN、SENet等；在2018年CVPR会议，张婷等人延续IGCV 1提出了IGCV 2 和IGCV 3 [3-05]。如今卷积神经网络在图像分类、语义分割、目标检测、目标追踪、行为识别等领域都有了可观的应用成果[3-06]。</p><p>典型的卷积神经网络一般包括输入层、输出层以及诸多的隐藏层，其中隐藏层一般由卷积层、池化层、全连接层、等构成，其中卷积以及池化其本质是图像采用。卷积神经网络最具有特色的结构便是卷积核，由于卷积才使得卷积神经网络在处理图像上相对于循环神经网络等效果较好。卷积和池化是提取特征和降维的过程，特征图经过数层的卷积运算最终得到的是较为高级的特征，因而，如何利用有限的计算资源提取出更多有效的高级特征便是深度学习在计算机视觉领域研究内至关重要的研究。</p><p>卷积神经网络中的图像采样主要表现在卷积以及池化，卷积主要目的在于提取特征，而池化的目的在于降维减少计算量。输入层读入规则化的图像，每一层的每个神经元将前一层的一组小的局部感受野并权值共享。神经元抽取边缘、角点等基本的视觉特征，经过一层层的采样逐渐转变为高级视觉特征。卷积神经网络通过卷积操作获得特征图，每个位置，来自不同特征图的单元得到各自不同类型的特征。一个卷积层中可能包含多个不同权值的特征图，这使得被保留的图像具备更丰富的特征。卷积层后边会连接池化层进行降采样操作，一方面可以降低图像的分辨率，减少参数量，另一方面可以获得平移和形变的鲁棒性。卷积层和池化层的交替分布，使得特征图的数目逐步增多，而且分辨率逐渐降低，最终完成分类。</p><h3 id="3-1-卷积自编码器"><a href="#3-1-卷积自编码器" class="headerlink" title="3.1 卷积自编码器"></a>3.1 卷积自编码器</h3><p>无监督学习方法的主要目的是从未标记的数据中提取一般有用的特征，检测和去除输入冗余，并在稳健和有区别的表示中仅保留数据的基本方面。卷积自编码器是一种结合了卷积和池化操作的无监督学习方法，其通过特征提取、堆栈，实现深层的神经网络[3.1-1]。 </p><center><img src="http://deeplearning.stanford.edu/wiki/images/f/f9/Autoencoder636.png" srcset="/img/loading.gif" lazyload="" width="300"></center><center>图 卷积自编码器</center><p>假设有k个卷积核，每个卷积核由参数$w^k$和$b^k$组成，用和$h^k$表示卷积层，则<br>$$<br>h^k=σ(x∗w^k+b^k)<br>$$<br>将得到的$h^k$进行特征重构，可以得到下式：<br>$$<br>y=σ(h^k∗w^k+c)<br>$$</p><p>将输入的样本和最终利用特征重构得出来的结果进行欧几里得距离比较，通过BP算法进行优化，就可以得到一个完整的卷积自编码器（CAE）:<br>$$<br>E=\frac{1}{2n}∑(x_i−y_i)^2<br>$$</p><h3 id="3-2-经典卷积神经网络"><a href="#3-2-经典卷积神经网络" class="headerlink" title="3.2 经典卷积神经网络"></a>3.2 经典卷积神经网络</h3><h4 id="3-2-1-LeNet"><a href="#3-2-1-LeNet" class="headerlink" title="3.2.1 LeNet"></a>3.2.1 LeNet</h4><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/image-20200408004128834.png" srcset="/img/loading.gif" lazyload="" alt="image-20200408004128834"></p><p>从最早的卷积神经网络LetNet-5的结构图中可看出其具有两个卷积层和两个池化层（图中表示为降采样层），输入32 * 32 *3的图像，第一个卷积层将三个通道的RGB图按照卷积计算的规则提取低级特征得到6个28 * 28的特征图，第一个池化层对3 * 32 *32 的图像经过卷积运算后得到的的特征图进行采样，得到 6个14 * 14 的特征图。 这是神经网络中最早利用图像局部相关性的原理而对图像抽样，以达到减少数据处理量并保留有用信息。第二个池化层通过降采样将16个10 * 10的特征图转变为16个5 * 5的特征图。不难看出，LetNet-5的计算量都是经过降采样减少的，而图像特征则是经过卷积提取的。</p><h5 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h5><p>卷积操作通过卷积核（Convolution Kernel ）实现，卷积核并非在深度学习中最早提出，早在边缘检测等研究例如Sobel 算子等滤波算子就已出现，当时被称为Filter[3.2.1-1]。卷积核具有的一局部性，即它只关注局部特征，局部的程度取决于卷积核的大小，其意义在于比较图像邻近像素的相似性，而图像相邻像素通常有一定的关联，故卷积这种采样方式很适合用于深度学习中对图像的处理。</p><p>时域卷积对应频域相乘，故原图像与卷积核的卷积，其实是对频域信息的选择。例如，图像中的边缘和轮廓属于是高频信息，图像中某区域强度的综合考量属于低频信息。</p><p>信号与图像处理中的一维信号的卷积：<br>$$<br>y[n]=x[n]*h[n]= \sum_k x[k]h[n-k]<br>$$<br>其中 $x[n]$是输入信号 $h[n]$是单位响应。于是输出信号 $y[n]$就是输入信号 $x[n]$的延迟响应的叠加。这也就是一维卷积本质：加权叠加/积分。</p><p>那么对于二维信号，比如图像，卷积的公式为：<br>$$<br>y[m,n]=x[m,n]<em>h[m,n]=\sum_j \sum_i x[i,j]h[m-i,n-j]<br>$$<br>若卷积核大小是3</em>3，则卷积核如图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143230026.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p> 输入图像到输出图像的变化如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143341925.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>二维卷积也有加权叠加/积分的作用,其中卷积核进行了水平和竖直方向的翻转。</p><p>kernel size（卷积核大小） =3 ,stride（步长）=1 的反卷积计算过程：<br>$$<br>\vec{w}=[w_1 \quad w_2 \quad w_3]^T \quad<br>\vec{x}=[x_1 \quad x_2 \quad x_3 \quad x_4]^T \<br>\vec{w}*^T \vec{x}=<br>\left[<br> \begin{matrix}</p><p> w_1 \quad w_2 \quad w_3 \quad 0 \quad 0 \quad 0\<br> 0 \quad w_1 \quad w_2 \quad w_3 \quad 0 \quad 0 \<br> 0 \quad 0 \quad w_1 \quad w_2 \quad w_3 \quad 0  \<br> 0 \quad 0 \quad 0 \quad w_1 \quad w_2 \quad w_3  \</p><p> \end{matrix}<br>  \right]</p><p>  \left[<br> \begin{matrix}<br> 0\<br> x_1 \x_2 \x_3 \x_4 \<br> 0<br>   \end{matrix}<br>  \right]</p><p>  =</p><p>  \left[<br> \begin{matrix}</p><p> w_2 x_1+w_3x_2 \<br>  w_1x_1+w_2x_2+w_3x_3 \<br> w_1x_2+w_2x_3+ w_3x_4  \<br> w_1x_3+w_2x_4 \</p><p> \end{matrix}<br>  \right]<br>$$</p><h5 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h5><p>池化层又成为降采样层或（下）欠采样层，其与卷积都是卷积神经网络中不可缺少的一部分，较早的卷积神经网络例如AlexNet通常会是卷积层后会紧跟一个池化层。池化的主要功能是对特征进行降维，减少参数量以降低计算量，避免过拟合，最大池化和平均池化是最为常见的两种池化方式。最大池化保留了图像纹理特征,平均池化保留了图像的整体数据特征，池化都达到了降维的作用。</p><p>以最大池化为例，其过程如图所示：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/fsafsa13213.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>和卷积层类似，池化层也有<strong>窗口</strong>和<strong>步长</strong>的概念，其中<strong>步长</strong>在里面的作用也是完全相同的，就是窗口每次移动的像素个数。</p><h4 id="3-2-2-AlexNet"><a href="#3-2-2-AlexNet" class="headerlink" title="3.2.2 AlexNet"></a>3.2.2 AlexNet</h4><p> <img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143517475.png" srcset="/img/loading.gif" lazyload="" alt=""> </p><p>AlexNet是2012年 ImageNet大规模视觉识别挑战赛（ ILSVRC ）的冠军，正是它的出现让沉寂14年的卷积神经网络受到瞩目，因而促使了深度学习快速的快速发展。</p><p>因为显存的关系，AlexNet在两个GPU上训练，输入的是227 * 227 * 3的RGB图像。对于单个GPU，图像是经过卷积运算之后为55 * 55 *3，该神经网络总过对特征图经过三次最大池化（降采样）分别得到27 * 27 *96 ，13 * 13 * 256，6 * 6 * 256 。<br>相较于LeNet，AlexNet采用了分组卷积，其分布式计算使得图像特征得以分散在不同的计算设备上计算；另外其卷积步长不再完全为1，这种步长大于1的卷积被称之为跨步卷积。</p><h5 id="分组卷积（-Group-convolution-）"><a href="#分组卷积（-Group-convolution-）" class="headerlink" title="分组卷积（ Group convolution ）"></a>分组卷积（ Group convolution ）</h5><p>由于计算资源有限，AlexNet使用两个GPU训练模型，故卷积操作在两个GPU处理，特征图也在两个GPU上处理，最后把两个GPU的计算结果融合。</p><p>此后许多轻量级的SOTA网络（State Of The Art， 指在该项研究中当前最先进的网络结构）都用到了分组卷积，以完成多个计算设备使用有限的算力。</p><h5 id="跨步卷积（Strided-Convolution）"><a href="#跨步卷积（Strided-Convolution）" class="headerlink" title="跨步卷积（Strided Convolution）"></a>跨步卷积（Strided Convolution）</h5><p>相比LeNet-5，AlexNet的卷积操作开始出现充填(padding)和步长(stride)，此后的卷积神经网络中跨步卷积成了常见的卷积操作。</p><p>kernel size（卷积核大小） =3 ,stride（步长）&gt;1 的反卷积计算过程：<br>$$<br>\vec{w}=[w_1 \quad w_2 \quad w_3]^T \quad\vec{x}=[x_1 \quad x_2 \quad x_3 \quad x_4]^T \\vec{w}*^T \vec{x}=\left[ \begin{matrix}  w_1 \quad w_2 \quad w_3 \quad 0 \quad 0 \quad 0\ \0 \quad w_1 \quad w_2 \quad w_3 \quad 0 \quad   \end{matrix}  \right]    \left[ \begin{matrix}0\ x_1 \x_2 \x_3 \x_4 \0   \end{matrix}  \right]    =    \left[ \begin{matrix}  w_2 x_1+w_3x_2 \  w_1x_2+w_2x_3+w_3x_4 \      \end{matrix}  \right]<br>$$</p><p>当卷积stride（步长）&gt;1时可起到降采样的作用。</p><h4 id="3-2-3-ZFNet"><a href="#3-2-3-ZFNet" class="headerlink" title="3.2.3 ZFNet"></a>3.2.3 ZFNet</h4><h5 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h5><p>反卷积（Deconvolution） 的概念首次出现在Zeiler在2010年发表的论文中[3.2.3-1]，而Zeiler在2011年发表的论文中反卷积作为术语正式使用[3.2.3-2]。ZFNet沿袭AlexNet的网络架构，并提出了有关优化性能的一些关键想法 ， 展示了将滤波器和权重可视化的正确方法 ， 反卷积可视化训练过程中特征的演化及发现潜在的问题[3.2.3-3]。随后反卷积在神经网络可视化上的成功应用的案例逐渐增多，例如场景分割、生成模型等的工作也逐渐采用反卷积。反卷积也有很多其他的叫法，比如：Transposed Convolution，Fractional Strided Convolution等。</p><p> 反卷积是上采样的一种，由于其是通过转置卷积核来达到去除卷积的目的，因而也称为转置卷积(transpose convolution)或者分数步长卷积(convolution with fractional strides)或者后向卷积(backwards strided convolution)，其名称具有一定的争议性。 反卷积并非正向卷积的完全逆向，从目前的实现方法上看我们可以将其视作一种较特殊的正向卷积。反卷积按照一定的比例在图像边缘补0来扩大图像的尺寸，再旋转卷积核，最后进行正向卷积。</p><p>反卷积的数学表达：</p><ul><li>输入大小$ i \times i$的图像，卷积核大小为$ k \times k $，由图像边缘充填(padding) $p$ , 步长(strides) $s$ ，由卷积计算公式$o = \frac{i+2p-k}{s}+1$得到输出图像大小为$o \times o$</li><li>输入$ i \times i$的图像特征转变为列向量$X$，输出$ o \times o$的图像特征展开成列向量$Y$ .</li><li>若是正向卷积，则由$Y=CX$得到稀疏矩阵$C$；若是反向卷积，则由$Y=C^T X$ 得到$ C $</li></ul><p>当卷积 stride &gt;1(步长大于1)时，可以实现降采样；类似的，反卷积也可以实现升采样。</p><p>kernel size（卷积核大小） =3 ,stride（步长）=1的反卷积计算过程：<br>$$<br>\vec{w}=[w_1 \quad w_2 \quad w_3]^T \quad<br>\vec{x}=[x_1 \quad x_2 \quad x_3 \quad x_4]^T \<br>\vec{w}*^T \vec{x}=<br>\left[<br> \begin{matrix}</p><p> w_1 \quad 0\quad 0\quad 0 \<br> w_2 \quad w_1\quad 0\quad 0 \<br> w_3 \quad w_2 \quad w_1 \quad 0  \<br> 0 \quad  w_3 \quad w_2 \quad w_1  \<br> 0 \quad  0 \quad w_3 \quad w_2 \<br> 0 \quad  0 \quad 0 \quad w_3 \</p><p> \end{matrix}<br>  \right]</p><p>  \left[<br> \begin{matrix}<br> x_1 \x_2 \x_3 \x_4<br>   \end{matrix}<br>  \right]</p><p>  =</p><p>  \left[<br> \begin{matrix}</p><p> w_1 x_1 \<br>  w_3x_1+w_1x_2 \<br> w_3x_2+w_2x_3+ w_1x_3  \<br> w_3x_2+w_2x_3+ w_1x_4  \<br> w_3x_3+w_2x_4  \<br> w_3x_4 \</p><p> \end{matrix}<br>  \right]<br>$$<br>kernel size（卷积核大小） =3 ,stride（步长）&gt;1 的反卷积计算过程：<br>$$<br>\vec{w}=[w_1 \quad w_2 \quad w_3]^T \quad<br>\vec{x}=[x_1 \quad x_2 \quad x_3]^T \<br>\vec{w}*^T \vec{x}=<br>\left[<br> \begin{matrix}</p><p> w_1 \quad 0 \<br> w_2 \quad 0 \<br> w_3 \quad w_1  \<br> 0 \quad  w_2  \<br> 0 \quad  w_3  \<br> 0 \quad  0 \</p><p> \end{matrix}<br>  \right]</p><p>  \left[<br> \begin{matrix}<br> x_1 \x_2<br>   \end{matrix}<br>  \right]</p><p>  =</p><p>  \left[<br> \begin{matrix}</p><p> w_1 x_1 \<br> w_2 x_1 \<br> w_3x_1+w_1x_2  \<br> w_2x_2  \<br> w_3x_2  \<br> 0  \</p><p> \end{matrix}<br>  \right]<br>$$</p><h5 id="反池化"><a href="#反池化" class="headerlink" title="反池化"></a>反池化</h5><p>反池化是上采样的一种，ZFNet作者在论文中首次使用反池化。反池化是池化的逆操作，因为经过池化之后部分信息已丢失，因而想要以池化后的信息恢复到全部信息，则存只能通过补位来实现最大程度上的信息完整。</p><p>池化有两种：最大池化和平均池化，其反池化也需要与其对应。反池化无法直接实现，ZFNet作者在训练神经网络的过程中记录每个池化操作z*z的区域内输入最大值的位置，反池化时，将最大值返回其对应的位置，其余位置的数值补为0，由此近似得实现了反池化。 </p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143601820.png" srcset="/img/loading.gif" lazyload="" alt=""> </p><p> <img src="https://img-blog.csdnimg.cn/20200220230126232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d3cGppYXlvdQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload="" alt="在这里插入图片描述"> </p><h4 id="3-2-4-VGGNet"><a href="#3-2-4-VGGNet" class="headerlink" title="3.2.4 VGGNet"></a>3.2.4 VGGNet</h4><p>VGGNet为此前卷积神经网络的加深网络，VGGNet的层数更深，大量的卷积层更利于图像从低级特征提取到高级特征。VGGNet-19 训练输出的图像大小为 224 * 224 *3，经过第一次卷积之后的图像特征大小为 224 *224 * 64。VGGNet-19 一共有五个池化层，池化后的特征图大小分别是 112 * 112 * 65，56 * 56 * 128，28 * 28 *256，14 * 14 * 512，7 * 7 * 512.</p><p>VGGNet中每个最大池化层后的滤波器数量都增加一倍，因而加强了缩小空间尺寸并保持深度增长。在此前，如AlexNet的卷积大小为11*11，而在VGGNet中，卷积核大小都较小，至此已充分证明卷积核两个3 * 3jchang的卷积采样效果会比一个5 * 5的卷积核好，且计算量也相对较小，故此后的神经网络中除了一些特定的应用场景所需否则都一般采用较小的卷积核。</p><h4 id="3-2-5-GoogLeNet"><a href="#3-2-5-GoogLeNet" class="headerlink" title="3.2.5 GoogLeNet"></a>3.2.5 GoogLeNet</h4><h4 id="V1"><a href="#V1" class="headerlink" title="V1"></a>V1</h4><p>GoogLeNet是 ImageNet 2014比赛分类的冠军，其错误率低至6.656%，相比此前的卷积神经网络，其大大增加了卷积神经网络的深度。 GoogLeNet Incepetion V1相比AlexNet的卷积神经网络更深，但是计算量却更少，准确率确远高于AlexNet。GoogLeNet参数少是相比其他神经网络计算量更小的直接原因，造成参数少的原因除了模型精心设计因而参数复用率高以外，另外用全局平均池化层代替了以往的网络结构中最后的全连接。</p><h4 id="V2"><a href="#V2" class="headerlink" title="V2"></a>V2</h4><h4 id="V3"><a href="#V3" class="headerlink" title="V3"></a>V3</h4><h4 id="3-2-6-ResNet"><a href="#3-2-6-ResNet" class="headerlink" title="3.2.6 ResNet"></a>3.2.6 ResNet</h4><p>ResNet（残差网络）在网络架构上参照了Inception V1，其快捷连接(shortcut connection)降低了池化层的重要性，以ResNet-34为例，从网络结构中可以清楚地看到只有第一次卷积以及倒数第二层池化层，此外便全是卷积层。通过恒等映射的方式解决神经网络准确率饱和退化的问题，因而这种网络结构可以达到远超过此前的深层次，并且除了输入输出的邻近层外都可以采用卷积核逐步提取图像特征，由此可以在保证增加层数并使用卷积将图像从低级特征逐步提取到高级特征，在不考虑降维的情况下无需在中间加入池化层。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/shendu153135.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>ResNet中当输入输出尺寸发生增加时，会考虑两个策略：（a）快捷连接仍然使用自身映射，对于维度的增加用零来填补空缺。此策略不会引入额外的参数；（b）投影捷径被用来匹配尺寸（由1×1的卷积完成）。对于这两种选项，当快捷连接在两个不同大小的特征图谱上出现时，用步长(stride)等于2来处理。在工程实现中常常采用了第二种解决方式，并且对于下采样操作(subsample)是通过1x1的池化来完成的。</p><p>ResNet最为重要的是恒等映射的思想，其后大量著名的神经网络借鉴或以其为模板，衍生出了：用不同长度子路径组合选择合适的子路径集合提高模型表达能力的FractalNet[3.6.2-1]； 以ResNetv2为基础增大残差块中的卷积核数量以此学习到更多有用信息的WideResNet[3.6.2-2]；每个分支都用相同的拓扑结构，通过变量基数达到控制组的数量目的的ResNeXt[3.6.2-3]；每一层和前面所有层相连并构建结构窄的网络，学习少量特征图以降低了冗余性的 DenseNet[3.6.2-4] ； 使用残差连接复用特征并大量抛弃最大池化避免高频高幅的DarkNet-53[3.6.2-5] ； 采用空洞卷积而非降采样的方法扩大感受野的 Dilated ResNet[3.6.2-6] 。</p><h4 id="3-2-7-Dilated-ResNet（空洞卷积神经网络）"><a href="#3-2-7-Dilated-ResNet（空洞卷积神经网络）" class="headerlink" title="3.2.7 Dilated ResNet（空洞卷积神经网络）"></a>3.2.7 Dilated ResNet（空洞卷积神经网络）</h4><p>空洞卷积（Dilated Convolution）也被称为扩展卷积或者膨胀卷积，是在2016年由 普林斯顿大学的 Fisher Yu 等人在其参考残差网络构建的空洞卷积神经网络中的一种上采样方法[3.2.7-1] 。扩张卷积是在标准卷积核中注入空洞，以此增加模型的感受野（reception field）。相比常规的卷积操作，扩张卷积增多了一个卷积核的点的间隔数量dilation rate这个参数，常规的卷积操作dilatation rate为1。<br>感受野的大小在目标检测和图像分割尤其重要，而感受野需要依靠下采样，然而图像经过下采样会导致小目标不容易被检测到；虽然多层特征图提取目标在此方面有一定程度的应对效果，，但是前面的特征图语义信息不够因而并不合适 ；<br>如果没有下采样，神经网络的计算量会增大，另外会因为没有逐渐将低级特征提取到高级特征导致效果不佳，感受野也不会有变化。而空洞卷积可以不牺牲特征图尺寸增大感受野[3-02]。空洞卷积的目的是扩大感受野，实际上并没有扩大特征图，因而并不能当作上采样方法。 </p><h4 id="3-2-8-YOLO2"><a href="#3-2-8-YOLO2" class="headerlink" title="3.2.8 YOLO2"></a>3.2.8 YOLO2</h4><p>yolo2是继2015年Joseph Redmon等人提出yolo [3.28-1 ] 之后在2017提出的一种改进 [3-04] 。yolo在工业界应用广泛，大量目标检测的落地都依赖yolo实现。其中在yolo2中提到穿透层(passthrough layer)。</p><p>穿透层的本质是特征重排，26 * 26 * 512的特征图按行和列隔点采样，得到4个13 * 13 * 512的特征图并按通道顺序串联，得到13 * 13 * 2048的特征图.还有就是，穿透层不学习参数，其直接将前面的层的特征重排拼接到后面的层，故网络越在前面的层，感受野越小，因而有利于小目标的检测。</p><h4 id="SENet"><a href="#SENet" class="headerlink" title="SENet"></a>SENet</h4><p>SENet考虑特征通道之间的关系，其显式地建模特征通道之间的相互依赖关系。其采用了一种全新的特征重标定策略。 SENet通过学习的方式获取到每个特征通道的重要程度，再依照此重要程度提升有用的特征并且抑制对当前任务用处不大的特征，以此达到更高效并准确的完成图像分类。 </p><h3 id="3-3-全卷积神经网络"><a href="#3-3-全卷积神经网络" class="headerlink" title="3.3 全卷积神经网络"></a>3.3 全卷积神经网络</h3><p>全卷积神经网络是在2015年由UC Berkeley的Jonathan Long等提出的用于图像语义分割的一种卷积神经网络[3.3-1]。</p><p>普通的卷积神经网络结构适用于图像级别的分类和回归任务，因为其最后得到输入图像的分类的概率。特征图（feature map）在经过最后的卷积操作之后会经过若干个全连接层计算，被映射成为固定长度的特征向量以此完成分类。如AlexNet为完成ImageNet大规模图像分类挑战赛中一千种图像分类故而最后输出一个1000维的向量表示输入图像属于每一类的概率。<br>全卷积神经网络（FCN）对图像进行像素级的分类，其适用于语义级别的图像分割问题。相比经典的CNN在最后使用全连接层得到固定长度的特征向量进行分类不同，FCN可接受任意尺寸的输入图像，采用反卷积对最后一个卷基层的特征图（feature map）进行上采样，使它恢复到输入图像相同的尺寸，从而可以对每一个像素都产生一个预测，同时保留了原始输入图像中的空间信息，最后奇偶在上采样的特征图进行像素的分类。FCN从抽象的特征中恢复出每个像素所属的类别，即从图像级别的分类进一步延伸到像素级别的分类。<br>FCN将传统CNN中的全连接层转化成一个个的卷积层。在传统的CNN结构中，前5层是卷积层，第6层和第7层分别是一个长度为4096的一维向量，第8层是长度为1000的一维向量，分别对应1000个类别的概率。FCN将这3层表示为卷积层，卷积核的大小(通道数，宽，高)分别为（4096,7,7）、（4096,1,1）、（1000,1,1）。所有的层都是卷积层，故称为全卷积神经网络，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20190728153423546.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>其网络结构如下：</p><p>  <img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122143755317.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h3 id="3-4-图卷积神经网络"><a href="#3-4-图卷积神经网络" class="headerlink" title="3.4 图卷积神经网络"></a>3.4 图卷积神经网络</h3><p>图(Graph)是一种由若干个结点(Node)及连接两个结点的边(Edge)所构成的图形，用于刻画不同结点之间的关系。下面是一个生动的例子，图片来自论文[14]:</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122144623327.png" srcset="/img/loading.gif" lazyload="" alt="图像与图（示例）"></p><p>最早的图神经网络起源于Franco博士的论文[2], 它的理论基础是<strong>不动点</strong>理论。给定一张图 GG，每个结点都有其自己的特征(feature), 本文中用xvxv表示结点v的特征；连接两个结点的边也有自己的特征，本文中用x(v,u)x(v,u)表示结点v与结点u之间边的特征；GNN的学习目标是获得每个结点的图感知的隐藏状态 hvhv(state embedding)，这就意味着：对于每个节点，它的隐藏状态包含了来自邻居节点的信息。那么，如何让每个结点都感知到图上其他的结点呢？GNN通过<strong>迭代式更新</strong>所有结点的隐藏状态来实现，在t+1t+1时刻，结点vv的隐藏状态按照如下方式更新：</p><p>ht+1v=f(xv,xco[v],htne[v],xne[v]),𝐡𝑣t+1=𝑓(𝐱𝑣,𝐱𝑐𝑜[𝑣],𝐡𝑛t𝑒[𝑣],𝐱𝑛𝑒[𝑣]),</p><p>上面这个公式中的 ff 就是隐藏状态的<strong>状态更新</strong>函数，在论文中也被称为<strong>局部转移函数</strong>(local transaction function)。公式中的xco[v]𝐱𝑐𝑜[𝑣]指的是与结点vv相邻的边的特征，xne[v]𝐱𝑛𝑒[𝑣]指的是结点vv的邻居结点的特征，htne[v]𝐡𝑛t𝑒[𝑣]则指邻居结点在tt时刻的隐藏状态。注意 ff 是对所有结点都成立的，是一个全局共享的函数。那么怎么把它跟深度学习结合在一起呢？聪明的读者应该想到了，那就是利用神经网络(Neural Network)来拟合这个复杂函数 ff。值得一提的是，虽然看起来 ff 的输入是不定长参数，但在 ff 内部我们可以先将不定长的参数通过一定操作变成一个固定的参数，比如说用所有隐藏状态的加和来代表所有隐藏状态。我们举个例子来说明一下：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/imsafma134.jpg" srcset="/img/loading.gif" lazyload="" width="40%"></p><p>假设结点55为中心结点，其隐藏状态的更新函数如图所示。这个更新公式表达的思想自然又贴切：不断地利用当前时刻邻居结点的隐藏状态作为部分输入来生成下一时刻中心结点的隐藏状态，直到每个结点的隐藏状态变化幅度很小，整个图的信息流动趋于平稳。至此，每个结点都“知晓”了其邻居的信息。状态更新公式仅描述了如何获取每个结点的隐藏状态，除它以外，我们还需要另外一个函数 gg 来描述如何适应下游任务。举个例子，给定一个社交网络，一个可能的下游任务是判断各个结点是否为水军账号。</p><p>ov=g(hv,xv)𝐨𝑣=𝑔(𝐡𝑣,𝐱𝑣)</p><p>在原论文中，gg 又被称为<strong>局部输出函数</strong>(local output function)，与 f类似，g 也可以由一个神经网络来表达，它也是一个全局共享的函数。那么，整个流程可以用下面这张图表达：</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/sadasd315164.jpg" srcset="/img/loading.gif" lazyload="" alt=""></p><p>仔细观察两个时刻之间的连线，它与图的连线密切相关。比如说在 T1T1 时刻，结点 1 的状态接受来自结点 3 的上一时刻的隐藏状态，因为结点 1 与结点 3相邻。直到 TnTn 时刻，各个结点隐藏状态收敛，每个结点后面接一个 gg 即可得到该结点的输出 oo。</p><p>对于不同的图来说，收敛的时刻可能不同，因为收敛是通过两个时刻pp-范数的差值是否小于某个阈值 ϵϵ来判定的，比如：</p><p>$$<br>||Ht+1||2−||Ht||2&lt;ϵ<br>$$</p><h3 id="3-5-时序卷积神经网络"><a href="#3-5-时序卷积神经网络" class="headerlink" title="3.5 时序卷积神经网络"></a>3.5 时序卷积神经网络</h3><h4 id="TCN"><a href="#TCN" class="headerlink" title="TCN"></a>TCN</h4><p>卷积核大小的限制使得卷积不能很好的抓取长时的依赖信息，因而对于时序问题的建模较多采用由于循环自回归而对时间序列的表示较好的循环神经网络（RNN）。 但一些特殊的卷积神经网络结构在时序建模上也有良好的表现，比如Goolgle用于语音合成的wavenet，Facebook提出的用于翻译的卷积神经网络特殊的卷积神经网络——时序卷积网络（Temporal convolutional network， TCN）与多种RNN结构相对比，发现在多种任务上TCN都能达到甚至超过RNN模型。 </p><p>TCN相比RNN有并行性、感受野尺寸可以灵活调整、梯度稳定、占用内存更低、相比LSTM更快的特点；与之相对的，这种单向结构的TCN 在迁移学习方面适应能力较弱，并且在实际应用中仍旧受限于卷积神经网络普遍存在的因感受野而带来的某些限制。</p><h4 id="DeepTCN"><a href="#DeepTCN" class="headerlink" title="DeepTCN"></a>DeepTCN</h4><p> DeepTCN是一种基于卷积神经网络的多关联时间序列预测的概率预测模型。该模型可用于估计参数和非参数设置下的概率密度。其构建了基于膨胀因果卷积网的叠加残差块来捕获序列的时间依赖性。与表示学习相结合，能够学习复杂的模式，如季节性、系列内和跨系列的假日效应，并利用这些模式进行更准确的预测，特别是在历史数据稀少或不可用的情况下。</p><p>1.提出了一种基于卷积的预测框架，该框架同时提供了估计概率密度的参数和非参数方法。</p><p>2.该框架能够学习序列间的潜在相关性，能够处理数据稀疏、冷启动等复杂的实际预测情况，具有较高的可扩展性和可扩展性。</p><p>3.大量的实证研究表明，我们的框架优于其他最先进的方法，无论是点预测和概率预测。</p><p>4.与递归结构相比，卷积模型的计算可以完全并行化，从而达到较高的训练效率。与此同时，优化要容易得多。在我们的案例中，训练时间是文献Flunkert等(2017)报道的复发模型的1/8。</p><p>5.该模型非常灵活，可以包括外生协变量，如额外的促销计划或天气预报。</p><h3 id="3-6-卷积神经网络中的其他上采样方法"><a href="#3-6-卷积神经网络中的其他上采样方法" class="headerlink" title="3.6 卷积神经网络中的其他上采样方法"></a>3.6 卷积神经网络中的其他上采样方法</h3><h5 id="3-6-1-PixelShuffle"><a href="#3-6-1-PixelShuffle" class="headerlink" title="3.6.1 PixelShuffle"></a>3.6.1 PixelShuffle</h5><p>PixelShuffle由Redmon等人在CVPR2016中提出的一种上采样方法，其主要关注于亚像素卷积层。首先将一个H x W的低分辨率图像通过三次卷积之后变为通道数为$r^2$的特征图，然后用reshape的方法将 Hx W x r2 的特征图重组为 rH x rW 的高分辨率图像。 经过三次卷积之后输出与原图一样尺寸的r2通道的输出图，扩大的倍数刚刚好等同于通道数。这样可以让网络学习到插值方法，并存在于前三层卷积层参数中[3.6.1-1]。</p><p><img src="https://img-blog.csdnimg.cn/2019080116323060.png" srcset="/img/loading.gif" lazyload="" alt=""> </p><p>PixelShuffle相对超分辨率此前不同的超分辨率的优点在于：不需要通过线性插值来扩大特征图尺寸，以更小的卷积核获得很好的效果；并且用卷积学习比手工设计插值会有更好的拟合效果。</p><h5 id="3-6-2-DUpsampling"><a href="#3-6-2-DUpsampling" class="headerlink" title="3.6.2 DUpsampling"></a>3.6.2 DUpsampling</h5><p>​      DUpsampling是在CVPR2019年提出的一种上采样方法[3.6.2-1]，从网络结构来看和PixelShuffle有相似之处，其通过卷积学习亚像素，并最后重组来获得更大的图像。</p><p>  DUpsampling在对特征图的操作上有所不同，是先通过将单个像素所对应的C个通道reshape成一个1xC的向量，与CxN的矩阵相乘得到1xN的向量，再reshape成为2x2xN/4（2应该指的是放大倍数，即rxrxN/r2）的扩大后的亚像素块,组合成放大后的特征图。<br>  以上这两种算法都是基于数据去训练的，可以获得比线性插值更好的效果，但是与线性插值相比存在的问题是：1、对于不同的放大倍数的图像需要训练不同的网络（因为通道数的改变）；2、不容易进行连续的放大，比如1.1倍，1.2倍这样。说不容易而不是不能是因为可以适当放大输入图像或者对权重和步长进行调整后放缩，但是计算很复杂，效果没有整数倍好，线性插值却很容易办到。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122144815796.png" srcset="/img/loading.gif" lazyload="" alt=""></p><h5 id="3-6-3-Meta-Upscale"><a href="#3-6-3-Meta-Upscale" class="headerlink" title="3.6.3 Meta-Upscale"></a>3.6.3 Meta-Upscale</h5><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122144856779.png" srcset="/img/loading.gif" lazyload="" alt=""> </p><p>   Meta-SR中的Meta-Upscale是在CVPR2019上的Meta-SR: A Magnifification-Arbitrary Network for Super-Resolution一文中提出来的，作者提出了一种可以任意尺度缩放的方法，可以实现较好效果的非整数的放缩。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122144934656.png" srcset="/img/loading.gif" lazyload="" alt="">  </p><p>   FLR 表示由特征学习模块提取的特征，并假定缩放因子是 r。对于 SR 图像上的每个像素（i, j），文中认为它由 ILR 图像上像素（i′,j′）的特征与一组相应卷积滤波器的权重所共同决定。从这一角度看，放大模块可视为从 FLR 到 ISR 的映射函数。<br>$$<br>I^{SR}(i,j)=\Phi(F^{LR}(i^{‘},j^{‘}),W(i,j))<br>$$<br>k * k为设定的与I^SR所相关的一个像素搜索范围。及这个范围内的所有像素都是和最后输出的像素是有关系的，需要对其计算相应的权重并加权计算。HWx（InCxoutC）我的理解是图像最后输出的长x宽x输入的通道数（文中为64）x输出的通道数（文中为3）做为权值生成的输出的通道数。对于一个像素的计算我们需要对64个通道上feature map上的对应9个值加权求和，就可以计算出输出的一个通道值，重复3次就是一个值的3个通道数的值，重复HW次就可以计算出整个输出。<br>   那么知道最后如何计算输出之后，我们关心的是文中提到的是怎么来做对不同的放缩大小的权值计算的以及如何在任意尺度下完成输出像素和LR特征图上的对应。<br>   作者把 Meta-Upscale 模块由三个重要的函数，即 Location Projection、Weight Prediction、Feature Mapping（这个就是上文讲的如何乘以权值得到最后的输出）。<br>   先说下文中的Location Projection，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145040963.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>$$<br>(i^{‘},j^{‘} )=T(i,j)=([\frac{i}{r}],[\frac{j}{r}])<br>$$<br>通过向下取整使得ISR中的每一个值都可以在ILR上找到一个对应的值。如放大1.5倍，那么ILR上的0对应ISR中的0和1（0/1.5&lt;1,1/1.5&lt;1）。</p><p>   而权重预测Weight Prediction在网络中是通过构建了两层全链接层和relu来实现的，输出在上文已经讲过了就不再重复，而文中用于预测的输入是这样获得的，如下式：<br>$$<br>V_{ij}=(\frac{i}{r}-[\frac{i}{r}],\frac{j}{r}-[\frac{j}{r}],\frac{1}{r})<br>$$<br>   总结一下，Meta-SR中的思路有点像RPN，做了一个外部的推荐网络，来推荐放缩的权值及像素的对应关系，在非整数倍放大上起的不错的效果。</p><h5 id="3-6-4-CAPAFE"><a href="#3-6-4-CAPAFE" class="headerlink" title="3.6.4 CAPAFE"></a>3.6.4 CAPAFE</h5><p>​       CAPAFE是出自ICCV2019的一种内容感知并重组特征的上采样方法，结构思路与此前的上采样方法较多的不同之处。</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145107859.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>   CAPAFE的整个网络结构由两部分组成，一部分是核预测模块（Kernel Prediction Module），用于生成用于重组计算的核上的权重。另一部分是内容感知重组模块（Content-aware Reassembly Module），用于将计算到的权重将通道reshape成一个kxk的矩阵作为核与原本输入的特征图上的对应点及以其为中心点的kxk区域做卷积计算，获得输出。<br>   首先我们先关注下核预测模块是如何预测出权重值的，这一部分文中分为三部分：通道压缩器（Channel Compressor）、内容编码（Content Encoder）、核归一化（Kernel Normaliaer）。输入的Feature map通过1x1的卷积核，完成对通道数的压缩，文中提及这一步的原因是为了减少计算量，而且文中说通过实验将通道数压缩在64不会影响效果，文中给的Cm为64。之后通过多层Kenconder x Kenconder的卷积核完成对特征图的计算，输出HxWxσ2xKup2的特征图，这里Kenconder的大小与感受野有关，越大生成的权重与周围的内容的关联性越高。最后将特征图reshape成σHxσWxKup2，之后单独对每一个像素的所有通道用softmax做归一化，为了是最后生成的重组核内权重值和为1。这样权重的预测就完成了。<br>   之后将预测好的权重对每一个像素都拉成kupxkup的卷积核即图中对应的Wl，通过对（i/σ，j/σ）向下映射的方法（floor function）找到每个像素在原来的feature map上对应的点，以其为中心点构建出kupxkup的区域做卷积计算，就可以得到一个像素的输出，重复操作可以获得整个输出。<br>$$<br>X^{‘}<em>{l’}=\sum^{r}</em>{n=-r}\sum^{r}<em>{m=-r}W</em>{l’(n,m)}*X_{(i+n,j+m)}<br>$$<br>   CAPAFE的整个网络内的参数量特别少，只有Content Encoder中的NxKenconder x Kenconderxσ2xKup2的卷积核的参数，同时它的上采样思路也比较不同，当然它无法如Meta-SR那样做连续缩放。</p><h2 id="4-循环神经网络中的图像采样"><a href="#4-循环神经网络中的图像采样" class="headerlink" title="4.循环神经网络中的图像采样"></a>4.循环神经网络中的图像采样</h2><p>循环神经网络(RNN)也被称为递归神经网络，相比卷积神经网络，其有更悠久的发展历史[4-1]。其被大量用于语音识别[4-2]、机器翻译、文本/音乐生成、情感分类、DNA序列分析、视频行为识别、实体名字识别、场景标记[4-3]，可见其同样在视觉任务中有一定作用。</p><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><h4 id="4-1-LSTM采样"><a href="#4-1-LSTM采样" class="headerlink" title="4.1 LSTM采样"></a>4.1 LSTM采样</h4><p>LSTM常用于自然语言处理（NLP），但其作为RNN最为经典的模型同样也可以完成图像分类任务。</p><p>在每个时间步，LSTM 都使用了 softmax 输出了一个在字符集上的概率分布。</p><p>给定每个时间步的分布，有几种方法来获得单个的字符，每个字符获得其相应的嵌入然后传递给 LSTM 作为下一步的输入：</p><ol><li>获得当前时间步最大的值</li><li>从分布中使用 softmax 采样</li><li>获取前 k 个结果，使用 beam 搜索</li></ol><h4 id="评价采样的质量"><a href="#评价采样的质量" class="headerlink" title="评价采样的质量"></a>评价采样的质量</h4><p>最简单的方法：可视化数据！诸如“the”或者“and”这样的词出现得非常频繁，即使就是训练很多的时间。随着训练的继续，样本会越来越像真的英语。</p><p>而更加形式化的性能评估就是测量 <strong>perplexity</strong> 在一个新的测试集合上。Perplexity 是测试集的逆概率，使用词的数目正规化。最小化 perplexity 和最大化概率是一样的，所以一个更低的 perplexity 模型能够更好地描述数据。Perplexity 是一种常用的度量语言模型的测度，其定义如下：<br>$$<br>PP=P(w_1w_2…w_N)^{\frac{-1}{N}}=(\prod_{i=1}^N \frac{1}{(w_i|w_1w_2…w_{i-1})})<br>$$<br>其中的 $$w_1, …, w_N$$ 是训练数据的整个序列；我们将整个这些看成是一个序列。在 bigram 模型中，条件是截断的，$PP==(\prod_{i=1}^N \frac{1}{(P(w_i|w_{i-1})})^{\frac{1}{N}}$</p><p>在实践中，我们没有测试集，所以就不会测量 perplexity，我们训练的字符层的模型。perplexity 通常用在词层的语言模型上。</p><p>相比Bi-LSTM，LSTM的结构很适合社交网络等文本分析等并应用于推荐系统。</p><h3 id="4-2-SRCNN"><a href="#4-2-SRCNN" class="headerlink" title="4.2 SRCNN"></a>4.2 SRCNN</h3><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20211122145141623.png" srcset="/img/loading.gif" lazyload="" alt=""></p><blockquote><p>SRCNN超分辨率重建的流程:</p><p>（1）将低分辨率图像使用两/三次差值放大至目标尺寸，得到图中的输入(input)；</p><p>（2）将低分辨率图像输入到三层的卷积神经网络。例如在论文中，对YCrCb颜色空间中的Y通道重建，网络形式为(conv1+relu1)—(conv2+relu2)—(conv3)。第一层卷积：卷积核大小为9×9($f_1×f_1$)，卷积核数目64($n_1$)，输出64张特征图；第二层卷积：卷积核尺寸1×1($f_2×f_2$)，卷积核数目32($n_2$)，输出32张特征图；第三层卷积：卷积核尺寸5×5($f_3×f_3$)，卷积核数目为1($n_3$)，输出1张特征图即为最终重建高分辨率图像。</p></blockquote><h2 id="5-生成对抗网络中的图像采样"><a href="#5-生成对抗网络中的图像采样" class="headerlink" title="5.生成对抗网络中的图像采样"></a>5.生成对抗网络中的图像采样</h2><p>生成对抗网络（GAN）是在2014年Goodfellow在提出的一种基于概率与统计理论并借鉴博弈思想的深度学习模型[5-1]，目前已经出现C-GAN、Info-GAN、DC-GAN、W-GAN/W-GAN-GP、f-GAN、Big-GAN、EB-GAN、SR-GAN/ESR-GAN等多种变体[5-2]，其在生成图像数据集、 生成人脸照片 、 生成现实照片 、 生成动画角色 、 图像转换 、 文字-图片转化 、 语义图像-图片转化 、 生成正面人像图片 、 生成新体态 、 图片转表情 、 图片编辑 、 图像融合 、 超分辨率 、视频预测、 3D打印等方面已经有了相应的应用[5-3]。</p><h3 id="5-1-GAN"><a href="#5-1-GAN" class="headerlink" title="5.1 GAN"></a>5.1 GAN</h3><p>GAN由服从可以不需要或只需要少量的数据标注即可生成有效的高维数据，其通过生成数据的生成模型和估计样本是训练数据的概率的判别模型之间不断博弈获得高维度的生成数据。</p><p>生成模型的训练程序是将判别模型判断错误的概率最大化，当判别模型将来自生成模型的数据判断正确率接近50%时，即认为判别模型已无法判断生成的数据是否正确。在G和D由多层感知器定义的情况下，整个系统可以用反向传播进行训练。在训练或生成样本期间，不需要任何马尔科夫链或展开的近似推理网络。[1] 。</p><p><img src="https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/md/41a59b4bd87f50222e05277057b34ce.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>GAN的主要灵感来源于博弈论中零和博弈的思想，应用到深度学习神经网络上来说，就是通过生成网络G（Generator）和判别网络D（Discriminator）不断博弈，进而使G学习到数据的分布，如果用到图片生成上，则训练完成后，G可以从一段随机数中生成逼真的图像。G， D的主要功能是：</p><p>● G是一个生成网络，它生成一个随机的噪声z（随机数），通过这个噪声生成图像 。对于给定的输入x和输出y，生成模型学习到其映射关系，其联合分布概率$p(x,y)$,由贝叶斯定理知在已知$p(x)$和$p(x|y)$可得到$p(y|x)$。</p><p>● D是一个判别网络，判别一张图片是不是“真实的”。它的输入参数是x，x代表一张图片，输出D（x）代表x为真实图片的概率，如果为1，就代表100%是真实的图片，而输出为0，就代表不可能是真实的图片</p><p>训练过程中，生成网络G的目标就是尽量生成真实的图片去欺骗判别网络D。而D的目标就是尽量辨别出G生成的假图像和真实的图像。这样，G和D构成了一个动态的“博弈过程”，最终的平衡点即纳什均衡点。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>没啥好看的。。。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1-01] Lecun Y , Bengio Y , Hinton G . Deep learning[J]. nature, 2015, 521(7553):436.</p><p>[1-02] Krizhevsky, A., Sutskever, I. and Hinton, G. (2012) ImageNet Classification with Deep Convolutional Neural Networks. Advances in Neural Information Processing Systems, 25, 1097-1105.</p><p>[1-03]  Khan A, Sohail A, Zahoora U, et al. A survey of the recent architectures of deep convolutional neural networks[J]. arXiv preprint arXiv:1901.06032, 2019. </p><p> [1-04] 袁非牛, 章琳, 史劲亭,等. Theories and Applications of Auto-Encoder Neural Networks: A Literature Survey%自编码神经网络理论及应用综述[J]. 计算机学报, 2019, 042(001):203-230. </p><p>[1-05]  Sabour, Sara, Nicholas Frosst, and Geoffrey E. Hinton. “Dynamic routing between capsules.” <em>Advances in neural information processing systems</em>. 2017. </p><p>[1-06]  Hochreiter, Sepp, and Jürgen Schmidhuber. “Long short-term memory.” <em>Neural computation</em> 9.8 (1997): 1735-1780. </p><p>[1-07] Minar M R , Naher J . Recent Advances in Deep Learning: An Overview[J]. 2018. </p><p>[2-01] Keys, Robert. “Cubic convolution interpolation for digital image processing.” <em>IEEE transactions on acoustics, speech, and signal processing</em> 29.6 (1981): 1153-1160. </p><p>[2-02]  张智邦, 李桂清, 韦国栋,等. 形状插值算法综述[J]. 计算机辅助设计与图形学学报, 2015(08):38-49. </p><p>[2-03] Chen, Shenchang Eric, and Lance Williams. “View interpolation for image synthesis.” <em>Proceedings of the 20th annual conference on Computer graphics and interactive techniques</em>. 1993. </p><p>[2-04] Carey, W. Knox, Daniel B. Chuang, and Sheila S. Hemami. “Regularity-preserving image interpolation.” <em>IEEE transactions on image processing</em> 8.9 (1999): 1293-1297. </p><p>[2-05] Lehmann, Thomas Martin, Claudia Gonner, and Klaus Spitzer. “Survey: Interpolation methods in medical image processing.” <em>IEEE transactions on medical imaging</em> 18.11 (1999): 1049-1075. </p><p>[2-06] Hou, Hsieh, and H. Andrews. “Cubic splines for image interpolation and digital filtering.” <em>IEEE Transactions on acoustics, speech, and signal processing</em> 26.6 (1978): 508-517. </p><p>[2-07] Thévenaz, Philippe, Thierry Blu, and Michael Unser. “Image interpolation and resampling.” <em>Handbook of medical imaging, processing and analysis</em> 1.1 (2000): 393-420. </p><p>[2-08]  Dodgson, Neil A. “Quadratic interpolation for image resampling.” <em>IEEE transactions on image processing</em> 6.9 (1997): 1322-1326. </p><p>[2-09]  Hwang, Jung Woo, and Hwang Soo Lee. “Adaptive image interpolation based on local gradient features.” <em>IEEE signal processing letters</em> 11.3 (2004): 359-362. </p><p>[2-10]   Dong, Weisheng, et al. “Sparse representation based image interpolation with nonlocal autoregressive modeling.” <em>IEEE Transactions on Image Processing</em> 22.4 (2013): 1382-1394. </p><p>[3-01]  Krizhevsky A, Sutskever I, Hinton G E. Imagenet classification with deep convolutional neural networks[C]//Advances in neural information processing systems. 2012: 1097-1105. </p><p>[ ]:AlexNet</p><p>[3-02]  Simonyan K, Zisserman A. Very deep convolutional networks for large-scale image recognition[J]. arXiv preprint arXiv:1409.1556, 2014. </p><p>[ ]:VGG</p><p>[3-03]  Szegedy C, Liu W, Jia Y, et al. Going deeper with convolutions[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2015: 1-9. </p><p>[ ]:GoogLetNet</p><p>[3-04] He K , Zhang X , Ren S , et al. Deep Residual Learning for Image Recognition[C]// IEEE Conference on Computer Vision &amp; Pattern Recognition. IEEE Computer Society, 2016.</p><p>[3-05]  Sun, Ke, et al. “Igcv3: Interleaved low-rank group convolutions for efficient deep neural networks.” <em>arXiv preprint arXiv:1806.00178</em> (2018). </p><p>[3-06] 陈超, 齐峰. 卷积神经网络的发展及其在计算机视觉领域中的应用综述[J]. 计算机科学, 2019, 46(03):69-79. </p><p>[3.1-1]  Masci, Jonathan, et al. “Stacked convolutional auto-encoders for hierarchical feature extraction.” <em>International conference on artificial neural networks</em>. Springer, Berlin, Heidelberg, 2011. </p><p>[3.2.1-1]  Vincent, O. Rebecca, and Olusegun Folorunso. “A descriptive algorithm for sobel image edge detection.” <em>Proceedings of Informing Science &amp; IT Education Conference (InSITE)</em>. Vol. 40. California: Informing Science Institute, 2009. </p><p>[3.2.3-1]  Zeiler, Matthew D., et al. “Deconvolutional networks.” <em>2010 IEEE Computer Society Conference on computer vision and pattern recognition</em>. IEEE, 2010. </p><p>[3.2.3-2]  Zeiler, Matthew D., Graham W. Taylor, and Rob Fergus. “Adaptive deconvolutional networks for mid and high level feature learning.” <em>2011 International Conference on Computer Vision</em>. IEEE, 2011. </p><p>[3.2.3-3]  Zeiler, Matthew D., and Rob Fergus. “Visualizing and understanding convolutional networks.” <em>European conference on computer vision</em>. Springer, Cham, 2014. </p><p>[3.2.6-1]  Larsson, Gustav, Michael Maire, and Gregory Shakhnarovich. “Fractalnet: Ultra-deep neural networks without residuals.” <em>arXiv preprint arXiv:1605.07648</em> (2016). </p><p>[3.2.6-2]  <a href="https://arxiv.org/abs/1605.07146" target="_blank" rel="noopener">Zagoruyko, Sergey, and Nikos Komodakis. “Wide residual networks.” <em>arXiv preprint arXiv:1605.07146</em> (2016).</a></p><p>[3.2.6-3] Xie, Saining, et al. “Aggregated residual transformations for deep neural networks.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2017. </p><p>[3.2.6-4]  Huang, Gao, et al. “Densely connected convolutional networks.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2017. </p><p>[3.2.6-5] Redmon, Joseph, and Ali Farhadi. “Yolov3: An incremental improvement.” <em>arXiv preprint arXiv:1804.02767</em> (2018). </p><p>[3-07] [Yu, Fisher, Vladlen Koltun, and Thomas Funkhouser. “Dilated residual networks.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2017. ](</p><p>[3.2.7-1] Yu, Fisher, Koltun, Vladlen. Multi-Scale Context Aggregation by Dilated Convolutions[J]. </p><p>[3.2.7 -2] Understanding the Effective Receptive Field in Deep Convolutional Neural Networks，Wenjie Luo, Yujia Li, Raquel Urtasun, Richard Zemel </p><p>[3.2.8-1]  Redmon, Joseph, et al. “You only look once: Unified, real-time object detection.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2016. </p><p>[3.2.8-2]  Redmon, Joseph, and Ali Farhadi. “YOLO9000: better, faster, stronger.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2017. </p><p>[3.3-1]  Long, Jonathan, Evan Shelhamer, and Trevor Darrell. “Fully convolutional networks for semantic segmentation.” <em>Proceedings of the IEEE conference on computer vision and pattern recognition</em>. 2015. </p><p> Lecun Y , Bottou L . Gradient-based learning applied to document recognition[J]. Proceedings of the IEEE, 1998, 86(11):P.2278-2324. </p><p>[3.6.1-1]  Shi W , Caballero J , Ferenc Huszár, et al. Real-time single image and video super-resolution using an efficient sub-pixel convolutional neural network[J]. 2016. </p><p>[3.6.2-1]  Tian, Zhi, et al. “Decoders matter for semantic segmentation: Data-dependent decoding enables flexible feature aggregation.” <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em>. 2019. </p><p> [3.6.4-3]  Hu, Xuecai, et al. “Meta-SR: a magnification-arbitrary network for super-resolution.” <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em>. 2019. </p><p> [3.6.4-1]  Wang, Jiaqi, et al. “CARAFE: Content-Aware ReAssembly of FEatures.” <em>Proceedings of the IEEE International Conference on Computer Vision</em>. 2019. </p><p>[4-1]  Salehinejad, Hojjat, et al. “Recent advances in recurrent neural networks.” <em>arXiv preprint arXiv:1801.01078</em> (2017). </p><p>[4-2] Deng, Li, Geoffrey Hinton, and Brian Kingsbury. “New types of deep neural network learning for speech recognition and related applications: An overview.” <em>2013 IEEE International Conference on Acoustics, Speech and Signal Processing</em>. IEEE, 2013. </p><p> [4-3]  Byeon, Wonmin, et al. “Scene labeling with lstm recurrent neural networks.” <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em>. 2015. </p><p>[5-1]  Goodfellow I J , Pouget-Abadie J , Mirza M , et al. Generative Adversarial Networks[J]. Advances in Neural Information Processing Systems, 2014, 3:2672-2680. </p><p>[5-2]   朱秀昌. 生成对抗网络图像处理综述[J]. 南京邮电大学学报:自然科学版, 2019, 39(3):1-12. </p><p>[5-3]  Creswell, Antonia, et al. “Generative adversarial networks: An overview.” <em>IEEE Signal Processing Magazine</em> 35.1 (2018): 53-65. </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就硬卷…&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>win10安装Hadoop以及pyspark</title>
    <link href="http://example.com/2021/05/10/win10%E5%AE%89%E8%A3%85Hadoop%E4%BB%A5%E5%8F%8Apyspark/"/>
    <id>http://example.com/2021/05/10/win10%E5%AE%89%E8%A3%85Hadoop%E4%BB%A5%E5%8F%8Apyspark/</id>
    <published>2021-05-09T16:38:45.000Z</published>
    <updated>2021-11-24T09:38:15.333Z</updated>
    
    <content type="html"><![CDATA[<p>win10安装Hadooop记录（安装过程与在linux环境安装类似）</p><a id="more"></a><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><ul><li>安装</li></ul><p>建议安装版本：Hadoop3.0.0+Spark3.0.0+Hive3.1</p><p><a href="https://blog.csdn.net/qq_42754919/article/details/109402379" target="_blank" rel="noopener">windows安装Spark3.0.0+hadoop+JDK大数据开发平台_我本将心向明月丶的博客-CSDN博客</a></p><p>已编译包下载：</p><p><a href="https://github.com/steveloughran/winutils" target="_blank" rel="noopener">GitHub - steveloughran/winutils: Windows binaries for Hadoop versions (built from the git commit ID used for the ASF relase)</a></p><ul><li>启动命令（注：需要打开cmd输入命令，直接打开文件无法启动）：</li></ul><div class="hljs code-wrapper"><pre><code class="hljs shell">start-all.cmd</code></pre></div><ul><li><p>检测</p><p><strong>出现四个任务管理且不报错，并不一定说明安装成功。测试是否开启成功：输入命令<code>jps</code></strong><br>出现下面四个才能说明安装成功，如果不出现四个说明安装没有成功，可能是上面第四步出现问题，重新配置。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20201031151402658.png#pic_center" srcset="/img/loading.gif" lazyload="" alt=""></p><ul><li><p>打开（Web端）</p><div class="hljs code-wrapper"><pre><code class="hljs shell">http://localhost:9870/</code></pre></div><p>在浏览器地址栏中输入：<a href="http://localhost:8088/" target="_blank" rel="noopener">http://localhost:8088</a>查看集群状态</p></li></ul><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;win10安装Hadooop记录（安装过程与在linux环境安装类似）&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hadoop" scheme="http://example.com/tags/Hadoop/"/>
    
      <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据官方中文文档</title>
    <link href="http://example.com/2021/04/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/04/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</id>
    <published>2021-04-09T02:12:39.000Z</published>
    <updated>2021-11-24T09:38:31.653Z</updated>
    
    <content type="html"><![CDATA[<p>中文学习文档（很详细）</p><a id="more"></a><ul><li><a href="https://www.docs4dev.com/docs/zh/python/3.7.2rc1/all" target="_blank" rel="noopener">Python中文文档</a></li><li><a href="https://www.docs4dev.com/docs/zh/mysql/5.7/reference" target="_blank" rel="noopener">MySql 中文文档</a></li><li><a href="https://www.docs4dev.com/docs/zh/apache-hive/3.1.1/reference/" target="_blank" rel="noopener">Apache Hive 中文手册</a></li><li><a href="https://www.docs4dev.com/docs/zh/apache-hbase/2.1/reference" target="_blank" rel="noopener">Apache HBase 中文文档</a></li><li><a href="https://www.docs4dev.com/docs/zh/flume/1.9.0/reference" target="_blank" rel="noopener">Apache Flume 用户指南</a></li><li><a href="https://www.docs4dev.com/docs/zh/zookeeper/r3.5.6/reference" target="_blank" rel="noopener">ZooKeeper</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中文学习文档（很详细）&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hadoop" scheme="http://example.com/tags/Hadoop/"/>
    
      <category term="Hive" scheme="http://example.com/tags/Hive/"/>
    
      <category term="Spark" scheme="http://example.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>零基础动态规划入门</title>
    <link href="http://example.com/2021/04/04/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/04/04/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</id>
    <published>2021-04-04T04:17:20.000Z</published>
    <updated>2021-11-24T09:38:57.402Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划方法解题</p><a id="more"></a><p>动态规划分为3个部分：</p><ol><li>确定状态</li><li>转移方程</li><li>初始条件和边界情况</li></ol><ul><li><p><strong>确定状态</strong></p><p>即数列每个元素$f[i]$或矩阵每个元素$f[i][j]$代表着什么</p></li><li><p><strong>转移方程</strong></p><p>例如斐波那契数列的转移方程是$F(n) = F(n-1)+F(n-2)$，这个表示的是每个元素的关系</p></li><li><p><strong>初始条件和边界情况</strong></p><p>初始条件，例如$f[0]$等于多少</p><p>边界情况，什么时候停下，$i$的范围是多少</p><p><a href="https://zhuanlan.zhihu.com/p/356804629" target="_blank" rel="noopener">参考：肝了好多天-动态规划十连-超细腻解析</a></p></li></ul><h3 id="斐波那契问题"><a href="#斐波那契问题" class="headerlink" title="斐波那契问题"></a>斐波那契问题</h3><ul><li><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></li></ul><p>$$<br>F(0) = 0,F(1) = 1    \<br>F(n) = F(n-1)+F(n-2),n&gt;1<br>$$</p><p>给定$n$，计算$F(n)$</p><p>从上述问题可知，初始条件为$F(0)=1,F(1)=1$</p><p>方法一（<strong>暴力递归-深度优先搜索</strong>）：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> self.fib(n - <span class="hljs-number">1</span>) + self.fib(n - <span class="hljs-number">2</span>)</code></pre></div><p>不超时算我输，这里暴力递归显然没有利用上此前已计算出来的结果</p><p>方法二（<strong>带记忆的方法</strong>）：</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        f = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<span class="hljs-comment">#初始化一个元素个数为n+1且元素全为0的列表</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>            f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,len(f)):                f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]<span class="hljs-comment">#转移方程</span>            <span class="hljs-keyword">return</span> f[<span class="hljs-number">-1</span>]<span class="hljs-comment">#返回列表最后一个数</span></code></pre></div><p>上述代码中，$f[i]$表示的是数列中第$i$个元素的数值（确定状态），$f(i) = f(i-1) + f(i-2)$（转移方程），$f(0) = f(1) = 1$（初始状态），迭代到第$n$个元素就停止（边界条件）</p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/zhi-xin-hua-shi-pa-lou-ti-zhi-cong-bao-l-lo1t/" target="_blank" rel="noopener">参考：【知信】花式爬楼梯，从暴力爬楼梯，到动态规划爬楼梯</a></p><p>斐波那契问题简单，如果换成具体问题呢？</p><ul><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></li></ul><p>一样先<strong>确定状态</strong>，然后写出<strong>转移方程</strong>，最后是<strong>初始条件和边界情况</strong></p><p>这里$f[i]$的值表示爬楼梯的方法数（确定状态）</p><p>因为每次可以爬1或2步，所以到第$i$格楼梯的爬法（个数）都是由到$i-1$和到$i-2$阶楼梯的爬法相加，因而转移方程为$f(i) = f(i-1) + f(i-2)$</p><p>初始条件$f(0) = f(1) = 1$（爬第一格楼梯和第二个楼梯只有一种方法），从2开始迭代到n+1（第一个元素用来存储第0格楼梯的爬法了，所以是n+1）从而可以确定边界条件</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        f = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)  <span class="hljs-comment">#生成n+1个元素的列表</span>        f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>   <span class="hljs-comment"># 0格楼梯和1格楼梯只需要1步</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):            f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]<span class="hljs-comment">#转移方程</span>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">-1</span>]<span class="hljs-comment">#列表的倒数第一个元素（最后一个元素）</span></code></pre></div><p>这种是每次可以爬一步或两步的，同理，如果可以爬三步的，那转移方程则为$f(i) = f(i-1) + f(i-2) + f(i-3)$</p><p>具体题目看</p><ul><li><a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/" target="_blank" rel="noopener">面试题 08.01. 三步问题</a></li></ul><p>还是像之前那样先<strong>确定状态</strong>，然后写出<strong>转移方程</strong>，最后是<strong>初始条件和边界情况</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">waysToStep</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">3</span>:            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>        <span class="hljs-keyword">else</span>:            dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)            dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>            dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>            dp[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>):                dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>] + dp[i<span class="hljs-number">-3</span>]        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>]%<span class="hljs-number">1000000007</span></code></pre></div><p>上述代码中if部分为特例，else部分显然包括了状态（$f(i)$表示有多少种爬法）；转移方程则变成了$f(i) = f(i-1) + f(i-2) + f(i-3)$，迭代次数为到$n+1$停止（边界条件）</p><ul><li><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></li></ul><p>之前的题都是有几种爬楼梯的方法，这次题目换了一下，增加的条件是每爬一次都有体力消耗，求爬完楼梯最小体力消耗是多少（体力的最低花费）？</p><p>套路：</p><p><strong>确定状态</strong>：这次$f(i)$表示的不是有几种爬法了，因为题目求体力的最低花费，所以此时$f(i)$表示的是爬到第$i$格楼梯体力的最低花费；</p><p><strong>转移方程</strong>：$f(i) = min[ f(i-1)+cost(i),f(i-2)+cost(i-1) ]$，$f(i)$表示爬到第$i$格楼梯体力的最低花费，因为每次可以爬楼梯1或2阶，所以爬到第$i$阶有两种可能：</p><ol><li>爬到第$i-1$阶再爬1步到第$i$阶（耗费体力为$f(i-1)+cost[i]$）</li><li>爬到$i-2$阶再爬2步第$i$阶（耗费体力为$f(i-2)+cost[i-1]$）</li></ol><p>所以，显然两种方式里哪个小，则哪种就是到第$i$阶的体力最低花费，因而得到转移方程</p><p><strong>初始条件和边界情况</strong>：（懒得写了）</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(self, cost: List[int])</span> -&gt; int:</span>                n = len(cost)        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> min(cost)        <span class="hljs-keyword">else</span>:            x = [<span class="hljs-number">0</span>] * n            x[<span class="hljs-number">1</span>] = min(cost[<span class="hljs-number">0</span>],cost[<span class="hljs-number">1</span>])            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,len(x)):                x[i] = min(x[i<span class="hljs-number">-1</span>]+cost[i],x[i<span class="hljs-number">-2</span>]+cost[i<span class="hljs-number">-1</span>])            <span class="hljs-keyword">return</span> x[<span class="hljs-number">-1</span>]</code></pre></div><p>leetcode斐波那契问题合集：</p><p><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></p><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a></p><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指 Offer 10- II. 青蛙跳台阶问题e</a></p><p><a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/" target="_blank" rel="noopener">面试题 08.01. 三步问题</a></p><p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></p><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/" target="_blank" rel="noopener">1137. 第 N 个泰波那契数</a></p><h3 id="从左上角到右下角"><a href="#从左上角到右下角" class="headerlink" title="从左上角到右下角"></a>从左上角到右下角</h3><ul><li><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></li></ul><p>机器人位于 m x n 网格的左上角，每次<strong>只能向下</strong>或者<strong>向右</strong>移动一步。机器人试图达到网格的右下角</p><p>问总共有多少条不同的路径？</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/robot_maze.png" srcset="/img/loading.gif" lazyload="" alt="img"></p><p>还是动态规划，只是一维变二维（即使$f(i)$变$f(i,j)$，莫慌）</p><p>还是像之前那样先<strong>确定状态</strong>，然后写出<strong>转移方程</strong>，最后是<strong>初始条件和边界情况</strong></p><p><strong>确定状态</strong>:$f(i,j)$表示到第$i$行第$j$列的位置有多少种走法</p><p><strong>转移方程</strong>:因为只能向下或向右，所以$f(i,j) = f(i-1,j)+f(i,j-1)$</p><p><strong>初始条件和边界情况</strong>：初始条件为$f(0,0)=1$，注意$0\le i\le m-1$，$0\le j \le n-1$（从零开始数嘛）</p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(self, m: int, n: int)</span> -&gt; int:</span>        f = [ [<span class="hljs-number">0</span>] * n ] * m <span class="hljs-comment">#生成m*n大小的矩阵</span>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,m):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,n):                <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j &gt; <span class="hljs-number">0</span>:                    f[i][j] = f[i<span class="hljs-number">-1</span>][j] + f[i][j<span class="hljs-number">-1</span>]                <span class="hljs-keyword">elif</span> i &gt; <span class="hljs-number">0</span> :                    f[i][j] = f[i<span class="hljs-number">-1</span>][j]                <span class="hljs-keyword">elif</span> j &gt; <span class="hljs-number">0</span> :                    f[i][j] = f[i][j<span class="hljs-number">-1</span>]                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">continue</span>        <span class="hljs-keyword">return</span> f[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划方法解题&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>SQL底层原理及实操记录</title>
    <link href="http://example.com/2021/03/31/SQL%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%93%8D%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/03/31/SQL%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E6%93%8D%E8%AE%B0%E5%BD%95/</id>
    <published>2021-03-31T02:41:16.000Z</published>
    <updated>2021-11-24T09:39:23.195Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL45讲学习笔记,从底层原理上里理解关系型数据库并记录实操（MySQL8.0的一些新特性）</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>MySQL45讲学习笔记,从底层原理上里理解关系型数据库并记录实操（MySQL8.0的一些新特性）</p><h2 id="MySQL底层原理"><a href="#MySQL底层原理" class="headerlink" title="MySQL底层原理"></a>MySQL底层原理</h2><h2 id="MySQL实操记录"><a href="#MySQL实操记录" class="headerlink" title="MySQL实操记录"></a>MySQL实操记录</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>安装MySQL</li><li>安装Navicat（新手建议安装，非必须）</li></ol><p>靠谱参考教程：<a href="https://blog.csdn.net/qq_37350706/article/details/81707862" target="_blank" rel="noopener">https://blog.csdn.net/qq_37350706/article/details/81707862</a></p><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><p>MySQL8.0中的group by有新特性，默认开启参数ONLY_FULL_GROUP_BY，可以通过输入以下命令查看：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @@sql_mode;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210331105532759.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>默认开启参数ONLY_FULL_GROUP_BY，表示开启group by完全模式：即select后面跟的列group by后面也必须有，但是group by后面跟的列，select后面不一定需要出现。</p><p>故会出现以下情况：</p><p>1）报错：</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> anchorinformation <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> AnchorID;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210331105924043.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>2） 成功执行</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> AnchorID <span class="hljs-keyword">from</span> anchorinformation <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> AnchorID;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> AnchorID,ANY_VALUE(anchor) <span class="hljs-keyword">from</span> anchorinformation <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> AnchorID;</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL45讲学习笔记,从底层原理上里理解关系型数据库并记录实操（MySQL8.0的一些新特性）&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL五十题</title>
    <link href="http://example.com/2021/03/30/SQL%E4%BA%94%E5%8D%81%E9%A2%98/"/>
    <id>http://example.com/2021/03/30/SQL%E4%BA%94%E5%8D%81%E9%A2%98/</id>
    <published>2021-03-30T14:38:07.000Z</published>
    <updated>2021-11-24T09:39:48.049Z</updated>
    
    <content type="html"><![CDATA[<p>SQL五十题</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>题目来自<a href="https://cloud.tencent.com/developer/article/1540526" target="_blank" rel="noopener">SQL练习题共50道附答案（MySQL）</a></p><p>此处不是正题，而是建表</p><p>1.学生表  student(s_id,s_name,s_birth,s_sex) </p><p>– 学生编号,学生姓名, 出生年月,学生性别 </p><p>2.课程表  course(c_id,c_name,t_id) </p><p>– 课程编号, 课程名称, 教师编号 </p><p>3.教师表  teacher(t_id,t_name) </p><p>-– 教师编号,教师姓名 </p><p>4.成绩表  score(s_id,c_id,s_score) </p><p>–学生编号,课程编号,分数</p><p>建议安装个Navicat，然后打开命令行，主要是界面看起来清爽（手动滑稽）</p><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/image-20210331011629991.png" srcset="/img/loading.gif" lazyload="" alt=""></p><p>命令如下</p><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--  建立课程表</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`course`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`course`</span>  (  <span class="hljs-string">`c_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'课程编号'</span>,  <span class="hljs-string">`c_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'课程名称'</span>,  <span class="hljs-string">`t_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'教师编号'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`c_id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;<span class="hljs-comment">-- 课程表数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`course`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'语文'</span>, <span class="hljs-string">'02'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`course`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'数学'</span>, <span class="hljs-string">'01'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`course`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'英语'</span>, <span class="hljs-string">'03'</span>);<span class="hljs-comment">-- 分数表</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`score`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`score`</span>  (  <span class="hljs-string">`s_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'学生编号'</span>,  <span class="hljs-string">`c_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'课程编号'</span>,  <span class="hljs-string">`s_score`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>) <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'分数'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`s_id`</span>, <span class="hljs-string">`c_id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;<span class="hljs-comment">-- 分数数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">90</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">99</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">70</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">60</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">80</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'04'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">50</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'04'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">30</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'04'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">20</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'05'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">76</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'05'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">87</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'05'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">95</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'06'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">31</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'06'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">88</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'06'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">34</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'07'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">66</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'07'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">89</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'07'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">98</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'08'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">59</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'08'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">88</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'09'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">67</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'09'</span>, <span class="hljs-string">'03'</span>, <span class="hljs-number">88</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'10'</span>, <span class="hljs-string">'01'</span>, <span class="hljs-number">65</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`score`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'10'</span>, <span class="hljs-string">'02'</span>, <span class="hljs-number">78</span>);<span class="hljs-comment">-- 建立学生表</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`student`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`student`</span>  (  <span class="hljs-string">`s_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'学生编号'</span>,  <span class="hljs-string">`s_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'学生姓名'</span>,  <span class="hljs-string">`s_birth`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'出生年月'</span>,  <span class="hljs-string">`s_sex`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'学生性别'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`s_id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;<span class="hljs-comment">-- 学生数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'斯内克'</span>, <span class="hljs-string">'1990-01-01'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'张益达'</span>, <span class="hljs-string">'1990-12-21'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'张大炮'</span>, <span class="hljs-string">'1990-05-20'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'04'</span>, <span class="hljs-string">'李云龙'</span>, <span class="hljs-string">'1990-08-06'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'05'</span>, <span class="hljs-string">'楚云飞'</span>, <span class="hljs-string">'1991-12-01'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'06'</span>, <span class="hljs-string">'赵日天'</span>, <span class="hljs-string">'1992-03-01'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'07'</span>, <span class="hljs-string">'小甜甜'</span>, <span class="hljs-string">'1989-07-01'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'08'</span>, <span class="hljs-string">'王菊花'</span>, <span class="hljs-string">'1990-01-20'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'09'</span>, <span class="hljs-string">'李慕白'</span>, <span class="hljs-string">'1994-01-20'</span>, <span class="hljs-string">'男'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`student`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'10'</span>, <span class="hljs-string">'东京热'</span>, <span class="hljs-string">'1980-01-20'</span>, <span class="hljs-string">'女'</span>);<span class="hljs-comment">-- 建立老师表</span><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`teacher`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`teacher`</span>  (  <span class="hljs-string">`t_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'教师编号'</span>,  <span class="hljs-string">`t_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'教师姓名'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`t_id`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span> <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8 <span class="hljs-keyword">COLLATE</span> = utf8_general_ci ROW_FORMAT = <span class="hljs-keyword">Compact</span>;<span class="hljs-comment">-- 老师表数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`teacher`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'01'</span>, <span class="hljs-string">'墨白'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`teacher`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'02'</span>, <span class="hljs-string">'默狐'</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`teacher`</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'03'</span>, <span class="hljs-string">'柠檬'</span>);<span class="hljs-keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="hljs-number">1</span>;</code></pre></div><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1、查询”语文”课程比”数学”课程成绩高的学生的信息及课程分数 </p><div class="hljs code-wrapper"><pre><code class="hljs sql"></code></pre></div><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://cloud.tencent.com/developer/article/1540526" target="_blank" rel="noopener">SQL练习题共50道附答案（MySQL）——墨白的Java基地</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL五十题&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据技术" scheme="http://example.com/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL45讲</title>
    <link href="http://example.com/2021/03/29/MySQL45%E8%AE%B2/"/>
    <id>http://example.com/2021/03/29/MySQL45%E8%AE%B2/</id>
    <published>2021-03-28T18:27:14.000Z</published>
    <updated>2021-11-24T09:40:13.969Z</updated>
    
    <content type="html"><![CDATA[<p>《MySQL45》讲转载，侵删</p><a id="more"></a><p>《MySQL45》讲转载，侵删</p><p><a href="https://sao-operation.gitee.io/my-sql45/01.基础架构：一条SQL查询语句是如何执行的？.html" target="_blank" rel="noopener">01.基础架构：一条SQL查询语句是如何执行的？.html        </a><br><a href="https://sao-operation.gitee.io/my-sql45/02.日志系统：一条SQL更新语句是如何执行的？.html" target="_blank" rel="noopener">02.日志系统：一条SQL更新语句是如何执行的？.html        </a><br><a href="https://sao-operation.gitee.io/my-sql45/03.事务隔离：为什么你改了我还看不见？.html" target="_blank" rel="noopener">03.事务隔离：为什么你改了我还看不见？.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/04.深入浅出索引（上）.html" target="_blank" rel="noopener">04.深入浅出索引（上）.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/05.深入浅出索引（下）.html" target="_blank" rel="noopener">05.深入浅出索引（下）.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/06.全局锁和表锁%20：给表加个字段怎么有这么多阻碍？.html" target="_blank" rel="noopener">06.全局锁和表锁 ：给表加个字段怎么有这么多阻碍？.html </a><br><a href="https://sao-operation.gitee.io/my-sql45/07.行锁功过：怎么减少行锁对性能的影响？.html" target="_blank" rel="noopener">07.行锁功过：怎么减少行锁对性能的影响？.html           </a><br><a href="https://sao-operation.gitee.io/my-sql45/08.事务到底是隔离的还是不隔离的？.htmla" target="_blank" rel="noopener">08.事务到底是隔离的还是不隔离的？.htmla                </a><br><a href="https://sao-operation.gitee.io/my-sql45/09.普通索引和唯一索引，应该怎么选择？.html" target="_blank" rel="noopener">09.普通索引和唯一索引，应该怎么选择？.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/10.MySQL为什么有时候会选错索引？.html" target="_blank" rel="noopener">10.MySQL为什么有时候会选错索引？.html                  </a><br><a href="https://sao-operation.gitee.io/my-sql45/11.怎么给字符串字段加索引？.html" target="_blank" rel="noopener">11.怎么给字符串字段加索引？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/12.为什么我的MySQL会" target="_blank" rel="noopener" 抖"一下？.html"="">12.为什么我的MySQL会“抖”一下？.html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/13.为什么表数据删掉一半，表文件大小不变？.html" target="_blank" rel="noopener">13.为什么表数据删掉一半，表文件大小不变？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/14.count(×)这么慢，我该怎么办？.html" target="_blank" rel="noopener">14.count(×)这么慢，我该怎么办？.html                   </a><br><a href="https://sao-operation.gitee.io/my-sql45/15.答疑文章（一）：日志和索引相关问题.html" target="_blank" rel="noopener">15.答疑文章（一）：日志和索引相关问题.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/16." target="_blank" rel="noopener" order_by"是怎么工作的？(1).html"="">16.“order by”是怎么工作的？(1).html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/16." target="_blank" rel="noopener" order_by"是怎么工作的？.html"="">16.“order by”是怎么工作的？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/17.如何正确地显示随机消息？(1).html" target="_blank" rel="noopener">17.如何正确地显示随机消息？(1).html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/17.如何正确地显示随机消息？.html" target="_blank" rel="noopener">17.如何正确地显示随机消息？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/18.为什么这些SQL语句逻辑相同性能却差异巨大？.html" target="_blank" rel="noopener">18.为什么这些SQL语句逻辑相同性能却差异巨大？.html      </a><br><a href="https://sao-operation.gitee.io/my-sql45/18.为什么这些SQL语句逻辑相同，性能却差异巨大？.html" target="_blank" rel="noopener">18.为什么这些SQL语句逻辑相同，性能却差异巨大？.html    </a><br><a href="https://sao-operation.gitee.io/my-sql45/19.为什么我只查一行的语句也执行这么慢？.html" target="_blank" rel="noopener">19.为什么我只查一行的语句也执行这么慢？.html           </a><br><a href="https://sao-operation.gitee.io/my-sql45/19.为什么我只查一行的语句，也执行这么慢？.html" target="_blank" rel="noopener">19.为什么我只查一行的语句，也执行这么慢？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/20.幻读是什么幻读有什么问题？.html" target="_blank" rel="noopener">20.幻读是什么幻读有什么问题？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/21.为什么我只改一行的语句锁这么多？.html" target="_blank" rel="noopener">21.为什么我只改一行的语句锁这么多？.html               </a><br><a href="https://sao-operation.gitee.io/my-sql45/22.MySQL有哪些" target="_blank" rel="noopener" 饮鸩止渴"提高性能的方法？.html"="">22.MySQL有哪些“饮鸩止渴”提高性能的方法？.html          </a><br><a href="https://sao-operation.gitee.io/my-sql45/23.MySQL是怎么保证数据不丢的？.html" target="_blank" rel="noopener">23.MySQL是怎么保证数据不丢的？.html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/24.MySQL是怎么保证主备一致的？.html" target="_blank" rel="noopener">24.MySQL是怎么保证主备一致的？.html                    </a><br><a href="https://sao-operation.gitee.io/my-sql45/25.MySQL是怎么保证高可用的？.html" target="_blank" rel="noopener">25.MySQL是怎么保证高可用的？.html                      </a><br><a href="https://sao-operation.gitee.io/my-sql45/26.备库为什么会延迟好几个小时？.html" target="_blank" rel="noopener">26.备库为什么会延迟好几个小时？.html                   </a><br><a href="https://sao-operation.gitee.io/my-sql45/27.主库出问题了从库怎么办？.html" target="_blank" rel="noopener">27.主库出问题了从库怎么办？.html                       </a><br><a href="https://sao-operation.gitee.io/my-sql45/28.读写分离有哪些坑？.html" target="_blank" rel="noopener">28.读写分离有哪些坑？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/29.如何判断一个数据库是不是出问题了？.html" target="_blank" rel="noopener">29.如何判断一个数据库是不是出问题了？.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/30.答疑文章（二）：用动态的观点看加锁.html" target="_blank" rel="noopener">30.答疑文章（二）：用动态的观点看加锁.html             </a><br><a href="https://sao-operation.gitee.io/my-sql45/31.误删数据后除了跑路还能怎么办？.html" target="_blank" rel="noopener">31.误删数据后除了跑路还能怎么办？.html                 </a><br><a href="https://sao-operation.gitee.io/my-sql45/32.为什么还有kill不掉的语句？.html" target="_blank" rel="noopener">32.为什么还有kill不掉的语句？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/33.我查这么多数据会不会把数据库内存打爆？.html" target="_blank" rel="noopener">33.我查这么多数据会不会把数据库内存打爆？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/34.到底可不可以使用join？.html" target="_blank" rel="noopener">34.到底可不可以使用join？.html                         </a><br><a href="https://sao-operation.gitee.io/my-sql45/35.join语句怎么优化？.html" target="_blank" rel="noopener">35.join语句怎么优化？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/36.为什么临时表可以重名？.html" target="_blank" rel="noopener">36.为什么临时表可以重名？.html                         </a><br><a href="https://sao-operation.gitee.io/my-sql45/37.什么时候会使用内部临时表？.html" target="_blank" rel="noopener">37.什么时候会使用内部临时表？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/38.都说InnoDB好那还要不要使用Memory引擎？.html" target="_blank" rel="noopener">38.都说InnoDB好那还要不要使用Memory引擎？.html         </a><br><a href="https://sao-operation.gitee.io/my-sql45/39.自增主键为什么不是连续的？.html" target="_blank" rel="noopener">39.自增主键为什么不是连续的？.html                     </a><br><a href="https://sao-operation.gitee.io/my-sql45/40.insert语句的锁为什么这么多？.html" target="_blank" rel="noopener">40.insert语句的锁为什么这么多？.html                   </a><br><a href="https://sao-operation.gitee.io/my-sql45/41.怎么最快地复制一张表？.html" target="_blank" rel="noopener">41.怎么最快地复制一张表？.html                         </a><br><a href="https://sao-operation.gitee.io/my-sql45/42.grant之后要跟着flush_privileges吗？.html" target="_blank" rel="noopener">42.grant之后要跟着flush privileges吗？.html            </a><br><a href="https://sao-operation.gitee.io/my-sql45/43.要不要使用分区表？.html" target="_blank" rel="noopener">43.要不要使用分区表？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/44.答疑文章（三）：说一说这些好问题.html" target="_blank" rel="noopener">44.答疑文章（三）：说一说这些好问题.html               </a><br><a href="https://sao-operation.gitee.io/my-sql45/45.自增id用完怎么办？.html" target="_blank" rel="noopener">45.自增id用完怎么办？.html                             </a><br><a href="https://sao-operation.gitee.io/my-sql45/IT视频学习网-www.itspxx.com.url" target="_blank" rel="noopener">IT视频学习网-www.itspxx.com.url                        </a><br><a href="https://sao-operation.gitee.io/my-sql45/开篇词.这一次，让我们一起来搞懂MySQL.html" target="_blank" rel="noopener">开篇词.这一次，让我们一起来搞懂MySQL.html              </a><br><a href="https://sao-operation.gitee.io/my-sql45/文档列表.bat" target="_blank" rel="noopener">文档列表.bat                                           </a><br><a href="https://sao-operation.gitee.io/my-sql45/更多精品教程-itspxx.com.url" target="_blank" rel="noopener">更多精品教程-itspxx.com.url                            </a><br><a href="https://sao-operation.gitee.io/my-sql45/本教程由IT视频学习网提供.url" target="_blank" rel="noopener">本教程由IT视频学习网提供.url                           </a><br><a href="https://sao-operation.gitee.io/my-sql45/直播回顾.林晓斌：我的MySQL心路历程.html" target="_blank" rel="noopener">直播回顾.林晓斌：我的 MySQL 心路历程.html              </a><br><a href="https://sao-operation.gitee.io/my-sql45/结束语.点线网面一起构建MySQL知识网络.html" target="_blank" rel="noopener">结束语.点线网面一起构建MySQL知识网络.html              </a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《MySQL45》讲转载，侵删&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
