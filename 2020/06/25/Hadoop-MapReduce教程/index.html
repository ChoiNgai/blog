

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#3cbdfe">
  <meta name="description" content="此文章转载于Hadoop官方中文文档">
  <meta name="author" content="CAIWEI">
  <meta name="keywords" content="">
  <meta name="description" content="此文章转载于Hadoop官方中文文档">
<meta property="og:type" content="article">
<meta property="og:title" content="Hadoop MapReduce教程">
<meta property="og:url" content="http://example.com/2020/06/25/Hadoop-MapReduce%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="CAIWEI的博客">
<meta property="og:description" content="此文章转载于Hadoop官方中文文档">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-25T13:32:40.000Z">
<meta property="article:modified_time" content="2021-11-24T08:22:30.426Z">
<meta property="article:author" content="CAIWEI">
<meta property="article:tag" content="Hadoop">
<meta name="twitter:card" content="summary_large_image">
  
  <title>Hadoop MapReduce教程 - CAIWEI的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="CAIWEI的博客" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> </strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/0.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Hadoop MapReduce教程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-06-25 21:32" pubdate>
        2020年6月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      30k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      94 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Hadoop MapReduce教程</h1>
            
            <div class="markdown-body">
              <p>此文章转载于<a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html" target="_blank" rel="noopener">Hadoop官方中文文档</a></p>
<a id="more"></a>



<ul>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#目的" target="_blank" rel="noopener">目的</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#先决条件" target="_blank" rel="noopener">先决条件</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#概述" target="_blank" rel="noopener">概述</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#输入与输出" target="_blank" rel="noopener">输入与输出</a></li>
<li>例子：WordCount v1.0<ul>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#源代码" target="_blank" rel="noopener">源代码</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#用法" target="_blank" rel="noopener">用法</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#解释" target="_blank" rel="noopener">解释</a></li>
</ul>
</li>
<li>Map/Reduce - 用户界面<ul>
<li>核心功能描述<ul>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Mapper" target="_blank" rel="noopener">Mapper</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Reducer" target="_blank" rel="noopener">Reducer</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Partitioner" target="_blank" rel="noopener">Partitioner</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Reporter" target="_blank" rel="noopener">Reporter</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#OutputCollector" target="_blank" rel="noopener">OutputCollector</a></li>
</ul>
</li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#作业配置" target="_blank" rel="noopener">作业配置</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#任务的执行和环境" target="_blank" rel="noopener">任务的执行和环境</a></li>
<li>作业的提交与监控<ul>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#作业的控制" target="_blank" rel="noopener">作业的控制</a></li>
</ul>
</li>
<li>作业的输入<ul>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#InputSplit" target="_blank" rel="noopener">InputSplit</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#RecordReader" target="_blank" rel="noopener">RecordReader</a></li>
</ul>
</li>
<li>作业的输出<ul>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#任务的Side-Effect+File" target="_blank" rel="noopener">任务的Side-Effect File</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#RecordWriter" target="_blank" rel="noopener">RecordWriter</a></li>
</ul>
</li>
<li>其他有用的特性<ul>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Counters" target="_blank" rel="noopener">Counters</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#DistributedCache" target="_blank" rel="noopener">DistributedCache</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Tool" target="_blank" rel="noopener">Tool</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#IsolationRunner" target="_blank" rel="noopener">IsolationRunner</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#Profiling" target="_blank" rel="noopener">Profiling</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#调试" target="_blank" rel="noopener">调试</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#JobControl" target="_blank" rel="noopener">JobControl</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#数据压缩" target="_blank" rel="noopener">数据压缩</a></li>
</ul>
</li>
</ul>
</li>
<li>例子：WordCount v2.0<ul>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#源代码-N10DC0" target="_blank" rel="noopener">源代码</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#运行样例" target="_blank" rel="noopener">运行样例</a></li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#程序要点" target="_blank" rel="noopener">程序要点</a></li>
</ul>
</li>
</ul>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>这篇教程从用户的角度出发，全面地介绍了Hadoop Map/Reduce框架的各个方面。</p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>请先确认Hadoop被正确安装、配置和正常运行中。更多信息见：</p>
<ul>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html" target="_blank" rel="noopener">Hadoop快速入门</a>对初次使用者。</li>
<li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html" target="_blank" rel="noopener">Hadoop集群搭建</a>对大规模分布式集群。</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Hadoop Map/Reduce是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上T级别的数据集。</p>
<p>一个Map/Reduce <em>作业（job）</em> 通常会把输入的数据集切分为若干独立的数据块，由 <em>map任务（task）</em>以完全并行的方式处理它们。框架会对map的输出先进行排序， 然后把结果输入给<em>reduce任务</em>。通常作业的输入和输出都会被存储在文件系统中。 整个框架负责任务的调度和监控，以及重新执行已经失败的任务。</p>
<p>通常，Map/Reduce框架和<a href="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">分布式文件系统</a>是运行在一组相同的节点上的，也就是说，计算节点和存储节点通常在一起。这种配置允许框架在那些已经存好数据的节点上高效地调度任务，这可以使整个集群的网络带宽被非常高效地利用。</p>
<p>Map/Reduce框架由一个单独的master JobTracker 和每个集群节点一个slave TaskTracker共同组成。master负责调度构成一个作业的所有任务，这些任务分布在不同的slave上，master监控它们的执行，重新执行已经失败的任务。而slave仅负责执行由master指派的任务。</p>
<p>应用程序至少应该指明输入/输出的位置（路径），并通过实现合适的接口或抽象类提供map和reduce函数。再加上其他作业的参数，就构成了<em>作业配置（job configuration）</em>。然后，Hadoop的 <em>job client</em>提交作业（jar包/可执行程序等）和配置信息给JobTracker，后者负责分发这些软件和配置信息给slave、调度任务并监控它们的执行，同时提供状态和诊断信息给job-client。</p>
<p>虽然Hadoop框架是用JavaTM实现的，但Map/Reduce应用程序则不一定要用 Java来写 。</p>
<ul>
<li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/streaming/package-summary.html" target="_blank" rel="noopener">Hadoop Streaming</a>是一种运行作业的实用工具，它允许用户创建和运行任何可执行程序 （例如：Shell工具）来做为mapper和reducer。</li>
<li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/pipes/package-summary.html" target="_blank" rel="noopener">Hadoop Pipes</a>是一个与<a href="http://www.swig.org/" target="_blank" rel="noopener">SWIG</a>兼容的C++ API （没有基于JNITM技术），它也可用于实现Map/Reduce应用程序。</li>
</ul>
<h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>Map/Reduce框架运转在&lt;key, value&gt; 键值对上，也就是说， 框架把作业的输入看为是一组&lt;key, value&gt; 键值对，同样也产出一组 &lt;key, value&gt; 键值对做为作业的输出，这两组键值对的类型可能不同。</p>
<p>框架需要对key和value的类(classes)进行序列化操作， 因此，这些类需要实现 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/Writable.html" target="_blank" rel="noopener">Writable</a>接口。 另外，为了方便框架执行排序操作，key类必须实现 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/WritableComparable.html" target="_blank" rel="noopener">WritableComparable</a>接口。</p>
<p>一个Map/Reduce 作业的输入和输出类型如下所示：</p>
<p>(input) &lt;k1, v1&gt; -&gt; <strong>map</strong> -&gt; &lt;k2, v2&gt; -&gt; <strong>combine</strong> -&gt; &lt;k2, v2&gt; -&gt; <strong>reduce</strong> -&gt; &lt;k3, v3&gt; (output)</p>
<h2 id="例子：WordCount-v1-0"><a href="#例子：WordCount-v1-0" class="headerlink" title="例子：WordCount v1.0"></a>例子：WordCount v1.0</h2><p>在深入细节之前，让我们先看一个Map/Reduce的应用示例，以便对它们的工作方式有一个初步的认识。</p>
<p>WordCount是一个简单的应用，它可以计算出指定数据集中每一个单词出现的次数。</p>
<p>这个应用适用于 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#Standalone+Operation" target="_blank" rel="noopener">单机模式</a>， <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#SingleNodeSetup" target="_blank" rel="noopener">伪分布式模式</a> 或 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#Fully-Distributed+Operation" target="_blank" rel="noopener">完全分布式模式</a> 三种Hadoop安装方式。</p>
<p><strong>源代码</strong></p>
<div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.myorg;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;
<span class="hljs-keyword">import</span> org.apache.hadoop.conf.*;
<span class="hljs-keyword">import</span> org.apache.hadoop.io.*;
<span class="hljs-keyword">import</span> org.apache.hadoop.mapred.*;
<span class="hljs-keyword">import</span> org.apache.hadoop.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WordCount</span> </span>{

   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Map</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MapReduceBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">LongWritable</span>, <span class="hljs-title">Text</span>, <span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>&gt; </span>{
	 <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> IntWritable one = <span class="hljs-keyword">new</span> IntWritable(<span class="hljs-number">1</span>);
	 <span class="hljs-keyword">private</span> Text word = <span class="hljs-keyword">new</span> Text();

	 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter)</span> <span class="hljs-keyword">throws</span> IOException </span>{
	   String line = value.toString();
	   StringTokenizer tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(line);
	   <span class="hljs-keyword">while</span> (tokenizer.hasMoreTokens()) {
		 word.set(tokenizer.nextToken());
		 output.collect(word, one);
	   }
	 }
   }

   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reduce</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MapReduceBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Reducer</span>&lt;<span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>, <span class="hljs-title">Text</span>, <span class="hljs-title">IntWritable</span>&gt; </span>{
	 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">(Text key, Iterator&lt;IntWritable&gt; values, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter)</span> <span class="hljs-keyword">throws</span> IOException </span>{
	   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
	   <span class="hljs-keyword">while</span> (values.hasNext()) {
		 sum += values.next().get();
	   }
	   output.collect(key, <span class="hljs-keyword">new</span> IntWritable(sum));
	 }
   }

   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
	 JobConf conf = <span class="hljs-keyword">new</span> JobConf(WordCount<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
	 conf.setJobName(<span class="hljs-string">"wordcount"</span>);

	 conf.setOutputKeyClass(Text<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
	 conf.setOutputValueClass(IntWritable<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

	 conf.setMapperClass(Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
	 conf.setCombinerClass(Reduce<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
	 conf.setReducerClass(Reduce<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

	 conf.setInputFormat(TextInputFormat<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
	 conf.setOutputFormat(TextOutputFormat<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

	 FileInputFormat.setInputPaths(conf, <span class="hljs-keyword">new</span> Path(args[<span class="hljs-number">0</span>]));
	 FileOutputFormat.setOutputPath(conf, <span class="hljs-keyword">new</span> Path(args[<span class="hljs-number">1</span>]));

	 JobClient.runJob(conf);
   }
}</code></pre></div>





<p>假设环境变量HADOOP_HOME对应安装时的根目录，HADOOP_VERSION对应Hadoop的当前安装版本，编译WordCount.java来创建jar包，可如下操作：</p>
<p>$ mkdir wordcount_classes<br>$ javac -classpath ${HADOOP_HOME}/hadoop-${HADOOP_VERSION}-core.jar -d wordcount_classes WordCount.java<br>$ jar -cvf /usr/joe/wordcount.jar -C wordcount_classes/ .</p>
<p>假设：</p>
<ul>
<li>/usr/joe/wordcount/input - 是HDFS中的输入路径</li>
<li>/usr/joe/wordcount/output - 是HDFS中的输出路径</li>
</ul>
<p>用示例文本文件做为输入：</p>
<p>$ bin/hadoop dfs -ls /usr/joe/wordcount/input/<br>/usr/joe/wordcount/input/file01<br>/usr/joe/wordcount/input/file02</p>
<p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file01<br>Hello World Bye World</p>
<p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file02<br>Hello Hadoop Goodbye Hadoop</p>
<p>运行应用程序：</p>
<p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount /usr/joe/wordcount/input /usr/joe/wordcount/output</p>
<p>输出是：</p>
<p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>Bye 1<br>Goodbye 1<br>Hadoop 2<br>Hello 2<br>World 2</p>
<p>应用程序能够使用-files选项来指定一个由逗号分隔的路径列表，这些路径是task的当前工作目录。使用选项-libjars可以向map和reduce的classpath中添加jar包。使用-archives选项程序可以传递档案文件做为参数，这些档案文件会被解压并且在task的当前工作目录下会创建一个指向解压生成的目录的符号链接（以压缩包的名字命名）。 有关命令行选项的更多细节请参考 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/commands_manual.html" target="_blank" rel="noopener">Commands manual</a>。</p>
<p>使用-libjars和-files运行wordcount例子：<br>hadoop jar hadoop-examples.jar wordcount -files cachefile.txt -libjars mylib.jar input output</p>
<p>WordCount应用程序非常直截了当。</p>
<p>Mapper(14-26行)中的map方法(18-25行)通过指定的 TextInputFormat(49行)一次处理一行。然后，它通过StringTokenizer 以空格为分隔符将一行切分为若干tokens，之后，输出&lt; <word>, 1&gt; 形式的键值对。</word></p>
<p>对于示例中的第一个输入，map输出是：<br>&lt; Hello, 1&gt;<br>&lt; World, 1&gt;<br>&lt; Bye, 1&gt;<br>&lt; World, 1&gt;</p>
<p>第二个输入，map输出是：<br>&lt; Hello, 1&gt;<br>&lt; Hadoop, 1&gt;<br>&lt; Goodbye, 1&gt;<br>&lt; Hadoop, 1&gt;</p>
<p>关于组成一个指定作业的map数目的确定，以及如何以更精细的方式去控制这些map，我们将在教程的后续部分学习到更多的内容。</p>
<p>WordCount还指定了一个combiner (46行)。因此，每次map运行之后，会对输出按照<em>key</em>进行排序，然后把输出传递给本地的combiner（按照作业的配置与Reducer一样），进行本地聚合。</p>
<p>第一个map的输出是：<br>&lt; Bye, 1&gt;<br>&lt; Hello, 1&gt;<br>&lt; World, 2&gt;</p>
<p>第二个map的输出是：<br>&lt; Goodbye, 1&gt;<br>&lt; Hadoop, 2&gt;<br>&lt; Hello, 1&gt;</p>
<p>Reducer(28-36行)中的reduce方法(29-35行) 仅是将每个key（本例中就是单词）出现的次数求和。</p>
<p>因此这个作业的输出就是：<br>&lt; Bye, 1&gt;<br>&lt; Goodbye, 1&gt;<br>&lt; Hadoop, 2&gt;<br>&lt; Hello, 2&gt;<br>&lt; World, 2&gt;</p>
<p>代码中的run方法中指定了作业的几个方面， 例如：通过命令行传递过来的输入/输出路径、key/value的类型、输入/输出的格式等等JobConf中的配置信息。随后程序调用了JobClient.runJob(55行)来提交作业并且监控它的执行。</p>
<p>我们将在本教程的后续部分学习更多的关于JobConf， JobClient， Tool和其他接口及类(class)。</p>
<h2 id="Map-Reduce-用户界面"><a href="#Map-Reduce-用户界面" class="headerlink" title="Map/Reduce - 用户界面"></a>Map/Reduce - 用户界面</h2><p>这部分文档为用户将会面临的Map/Reduce框架中的各个环节提供了适当的细节。这应该会帮助用户更细粒度地去实现、配置和调优作业。然而，请注意每个类/接口的javadoc文档提供最全面的文档；本文只是想起到指南的作用。</p>
<p>我们会先看看Mapper和Reducer接口。应用程序通常会通过提供map和reduce方法来实现它们。</p>
<p>然后，我们会讨论其他的核心接口，其中包括： JobConf，JobClient，Partitioner， OutputCollector，Reporter， InputFormat，OutputFormat等等。</p>
<p>最后，我们将通过讨论框架中一些有用的功能点（例如：DistributedCache， IsolationRunner等等）来收尾。</p>
<p>应用程序通常会通过提供map和reduce来实现 Mapper和Reducer接口，它们组成作业的核心。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Mapper.html" target="_blank" rel="noopener">Mapper</a>将输入键值对(key/value pair)映射到一组中间格式的键值对集合。</p>
<p>Map是一类将输入记录集转换为中间格式记录集的独立任务。 这种转换的中间格式记录集不需要与输入记录集的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。</p>
<p>Hadoop Map/Reduce框架为每一个InputSplit产生一个map任务，而每个InputSplit是由该作业的InputFormat产生的。</p>
<p>概括地说，对Mapper的实现者需要重写 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConfigurable.html#configure(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener">JobConfigurable.configure(JobConf)</a>方法，这个方法需要传递一个JobConf参数，目的是完成Mapper的初始化工作。然后，框架为这个任务的InputSplit中每个键值对调用一次 [map(WritableComparable, Writable, OutputCollector, Reporter)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Mapper.html#map" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Mapper.html#map</a>(K1, V1, org.apache.hadoop.mapred.OutputCollector, org.apache.hadoop.mapred.Reporter))操作。应用程序可以通过重写<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/Closeable.html#close()" target="_blank" rel="noopener">Closeable.close()</a>方法来执行相应的清理工作。</p>
<p>输出键值对不需要与输入键值对的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。通过调用[ OutputCollector.collect(WritableComparable,Writable)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect</a>(K, V))可以收集输出的键值对。</p>
<p>应用程序可以使用Reporter报告进度，设定应用级别的状态消息，更新Counters（计数器），或者仅是表明自己运行正常。</p>
<p>框架随后会把与一个特定key关联的所有中间过程的值（value）分成组，然后把它们传给Reducer以产出最终的结果。用户可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setOutputKeyComparatorClass(java.lang.Class)" target="_blank" rel="noopener">JobConf.setOutputKeyComparatorClass(Class)</a>来指定具体负责分组的 Comparator。</p>
<p>Mapper的输出被排序后，就被划分给每个Reducer。分块的总数目和一个作业的reduce任务的数目是一样的。用户可以通过实现自定义的 Partitioner来控制哪个key被分配给哪个 Reducer。</p>
<p>用户可选择通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setCombinerClass(java.lang.Class)" target="_blank" rel="noopener"> JobConf.setCombinerClass(Class)</a>指定一个combiner，它负责对中间过程的输出进行本地的聚集，这会有助于降低从Mapper到 Reducer数据传输量。</p>
<p>这些被排好序的中间过程的输出结果保存的格式是(key-len, key, value-len, value)，应用程序可以通过JobConf控制对这些中间结果是否进行压缩以及怎么压缩，使用哪种<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/compress/CompressionCodec.html" target="_blank" rel="noopener"> CompressionCodec</a>。</p>
<p>Map的数目通常是由输入数据的大小决定的，一般就是所有输入文件的总块（block）数。</p>
<p>Map正常的并行规模大致是每个节点（node）大约10到100个map，对于CPU 消耗较小的map任务可以设到300个左右。由于每个任务初始化需要一定的时间，因此，比较合理的情况是map执行的时间至少超过1分钟。</p>
<p>这样，如果你输入10TB的数据，每个块（block）的大小是128MB，你将需要大约82,000个map来完成任务，除非使用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumMapTasks(int)" target="_blank" rel="noopener">setNumMapTasks(int)</a>（注意：这里仅仅是对框架进行了一个提示(hint)，实际决定因素见<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumMapTasks(int)" target="_blank" rel="noopener">这里</a>）将这个数值设置得更高。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html" target="_blank" rel="noopener">Reducer</a>将与一个key关联的一组中间数值集归约（reduce）为一个更小的数值集。</p>
<p>用户可以通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumReduceTasks(int)" target="_blank" rel="noopener"> JobConf.setNumReduceTasks(int)</a>设定一个作业中reduce任务的数目。</p>
<p>概括地说，对Reducer的实现者需要重写 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConfigurable.html#configure(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener">JobConfigurable.configure(JobConf)</a>方法，这个方法需要传递一个JobConf参数，目的是完成Reducer的初始化工作。然后，框架为成组的输入数据中的每个&lt;key, (list of values)&gt;对调用一次 [reduce(WritableComparable, Iterator, OutputCollector, Reporter)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce</a>(K2, java.util.Iterator, org.apache.hadoop.mapred.OutputCollector, org.apache.hadoop.mapred.Reporter))方法。之后，应用程序可以通过重写<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/Closeable.html#close()" target="_blank" rel="noopener">Closeable.close()</a>来执行相应的清理工作。</p>
<p>Reducer有3个主要阶段：shuffle、sort和reduce。</p>
<p>Reducer的输入就是Mapper已经排好序的输出。在这个阶段，框架通过HTTP为每个Reducer获得所有Mapper输出中与之相关的分块。</p>
<p>这个阶段，框架将按照key的值对Reducer的输入进行分组 （因为不同mapper的输出中可能会有相同的key）。</p>
<p>Shuffle和Sort两个阶段是同时进行的；map的输出也是一边被取回一边被合并的。</p>
<p>如果需要中间过程对key的分组规则和reduce前对key的分组规则不同，那么可以通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setOutputValueGroupingComparator(java.lang.Class)" target="_blank" rel="noopener"> JobConf.setOutputValueGroupingComparator(Class)</a>来指定一个Comparator。再加上 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setOutputKeyComparatorClass(java.lang.Class)" target="_blank" rel="noopener">JobConf.setOutputKeyComparatorClass(Class)</a>可用于控制中间过程的key如何被分组，所以结合两者可以实现<em>按值的二次排序</em>。</p>
<p>在这个阶段，框架为已分组的输入数据中的每个 &lt;key, (list of values)&gt;对调用一次 [reduce(WritableComparable, Iterator, OutputCollector, Reporter)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reducer.html#reduce</a>(K2, java.util.Iterator, org.apache.hadoop.mapred.OutputCollector, org.apache.hadoop.mapred.Reporter))方法。</p>
<p>Reduce任务的输出通常是通过调用 [OutputCollector.collect(WritableComparable, Writable)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html#collect</a>(K, V))写入 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/fs/FileSystem.html" target="_blank" rel="noopener">文件系统</a>的。</p>
<p>应用程序可以使用Reporter报告进度，设定应用程序级别的状态消息，更新Counters（计数器），或者仅是表明自己运行正常。</p>
<p>Reducer的输出是<em>没有排序的</em>。</p>
<p>Reduce的数目建议是0.95或1.75乘以 (&lt;<em>no. of nodes</em>&gt; * mapred.tasktracker.reduce.tasks.maximum)。</p>
<p>用0.95，所有reduce可以在maps一完成时就立刻启动，开始传输map的输出结果。用1.75，速度快的节点可以在完成第一轮reduce任务后，可以开始第二轮，这样可以得到比较好的负载均衡的效果。</p>
<p>增加reduce的数目会增加整个框架的开销，但可以改善负载均衡，降低由于执行失败带来的负面影响。</p>
<p>上述比例因子比整体数目稍小一些是为了给框架中的推测性任务（speculative-tasks） 或失败的任务预留一些reduce的资源。</p>
<p>如果没有归约要进行，那么设置reduce任务的数目为<em>零</em>是合法的。</p>
<p>这种情况下，map任务的输出会直接被写入由 [setOutputPath(Path)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path))指定的输出路径。框架在把它们写入FileSystem之前没有对它们进行排序。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Partitioner.html" target="_blank" rel="noopener">Partitioner</a>用于划分键值空间（key space）。</p>
<p>Partitioner负责控制map输出结果key的分割。Key（或者一个key子集）被用于产生分区，通常使用的是Hash函数。分区的数目与一个作业的reduce任务的数目是一样的。因此，它控制将中间过程的key（也就是这条记录）应该发送给m个reduce任务中的哪一个来进行reduce操作。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/lib/HashPartitioner.html" target="_blank" rel="noopener">HashPartitioner</a>是默认的 Partitioner。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html" target="_blank" rel="noopener">Reporter</a>是用于Map/Reduce应用程序报告进度，设定应用级别的状态消息， 更新Counters（计数器）的机制。</p>
<p>Mapper和Reducer的实现可以利用Reporter 来报告进度，或者仅是表明自己运行正常。在那种应用程序需要花很长时间处理个别键值对的场景中，这种机制是很关键的，因为框架可能会以为这个任务超时了，从而将它强行杀死。另一个避免这种情况发生的方式是，将配置参数mapred.task.timeout设置为一个足够高的值（或者干脆设置为零，则没有超时限制了）。</p>
<p>应用程序可以用Reporter来更新Counter（计数器）。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputCollector.html" target="_blank" rel="noopener">OutputCollector</a>是一个Map/Reduce框架提供的用于收集 Mapper或Reducer输出数据的通用机制 （包括中间输出结果和作业的输出结果）。</p>
<p>Hadoop Map/Reduce框架附带了一个包含许多实用型的mapper、reducer和partitioner 的<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/lib/package-summary.html" target="_blank" rel="noopener">类库</a>。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html" target="_blank" rel="noopener">JobConf</a>代表一个Map/Reduce作业的配置。</p>
<p>JobConf是用户向Hadoop框架描述一个Map/Reduce作业如何执行的主要接口。框架会按照JobConf描述的信息忠实地去尝试完成这个作业，然而：</p>
<ul>
<li>一些参数可能会被管理者标记为<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#FinalParams" target="_blank" rel="noopener"> final</a>，这意味它们不能被更改。</li>
<li>一些作业的参数可以被直截了当地进行设置（例如： <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumReduceTasks(int)" target="_blank" rel="noopener">setNumReduceTasks(int)</a>），而另一些参数则与框架或者作业的其他参数之间微妙地相互影响，并且设置起来比较复杂（例如：<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setNumMapTasks(int)" target="_blank" rel="noopener"> setNumMapTasks(int)</a>）。</li>
</ul>
<p>通常，JobConf会指明Mapper、Combiner(如果有的话)、 Partitioner、Reducer、InputFormat和 OutputFormat的具体实现。JobConf还能指定一组输入文件 ([setInputPaths(JobConf, Path…)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path[])) /[addInputPath(JobConf, Path)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path))) 和([setInputPaths(JobConf, String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#setInputPaths</a>(org.apache.hadoop.mapred.JobConf, java.lang.String)) /[addInputPaths(JobConf, String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html#addInputPath</a>(org.apache.hadoop.mapred.JobConf, java.lang.String))) 以及输出文件应该写在哪儿 ([setOutputPath(Path)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputPath</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.fs.Path)))。</p>
<p>JobConf可选择地对作业设置一些高级选项，例如：设置Comparator； 放到DistributedCache上的文件；中间结果或者作业输出结果是否需要压缩以及怎么压缩； 利用用户提供的脚本(<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapDebugScript(java.lang.String)" target="_blank" rel="noopener">setMapDebugScript(String)</a>/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setReduceDebugScript(java.lang.String)" target="_blank" rel="noopener">setReduceDebugScript(String)</a>) 进行调试；作业是否允许<em>预防性（speculative）</em>任务的执行 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapSpeculativeExecution(boolean)" target="_blank" rel="noopener">setMapSpeculativeExecution(boolean)</a>)/(<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setReduceSpeculativeExecution(boolean)" target="_blank" rel="noopener">setReduceSpeculativeExecution(boolean)</a>) ；每个任务最大的尝试次数 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxMapAttempts(int)" target="_blank" rel="noopener">setMaxMapAttempts(int)</a>/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxReduceAttempts(int)" target="_blank" rel="noopener">setMaxReduceAttempts(int)</a>) ；一个作业能容忍的任务失败的百分比 (<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxMapTaskFailuresPercent(int)" target="_blank" rel="noopener">setMaxMapTaskFailuresPercent(int)</a>/<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMaxReduceTaskFailuresPercent(int)" target="_blank" rel="noopener">setMaxReduceTaskFailuresPercent(int)</a>) ；等等。</p>
<p>当然，用户能使用 [set(String, String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#set" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#set</a>(java.lang.String, java.lang.String))/[get(String, String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#get" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/conf/Configuration.html#get</a>(java.lang.String, java.lang.String)) 来设置或者取得应用程序需要的任意参数。然而，DistributedCache的使用是面向大规模只读数据的。</p>
<p>TaskTracker是在一个单独的jvm上以子进程的形式执行 Mapper/Reducer任务（Task）的。</p>
<p>子任务会继承父TaskTracker的环境。用户可以通过JobConf中的 mapred.child.java.opts配置参数来设定子jvm上的附加选项，例如： 通过-Djava.library.path=&lt;&gt; 将一个非标准路径设为运行时的链接用以搜索共享库，等等。如果mapred.child.java.opts包含一个符号<em>@taskid@</em>， 它会被替换成map/reduce的taskid的值。</p>
<p>下面是一个包含多个参数和替换的例子，其中包括：记录jvm GC日志； JVM JMX代理程序以无密码的方式启动，这样它就能连接到jconsole上，从而可以查看子进程的内存和线程，得到线程的dump；还把子jvm的最大堆尺寸设置为512MB， 并为子jvm的java.library.path添加了一个附加路径。</p>
<property>
 <name>mapred.child.java.opts</name>
 <value>
   -Xmx512M -Djava.library.path=/home/mycompany/lib -verbose:gc -Xloggc:/tmp/@taskid@.gc
   -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false
 </value>
</property>

<p>用户或管理员也可以使用mapred.child.ulimit设定运行的子任务的最大虚拟内存。mapred.child.ulimit的值以（KB)为单位，并且必须大于或等于-Xmx参数传给JavaVM的值，否则VM会无法启动。</p>
<p>注意：mapred.child.java.opts只用于设置task tracker启动的子任务。为守护进程设置内存选项请查看 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html#配置Hadoop守护进程的运行环境" target="_blank" rel="noopener">cluster_setup.html</a></p>
<p>${mapred.local.dir}/taskTracker/是task tracker的本地目录， 用于创建本地缓存和job。它可以指定多个目录（跨越多个磁盘），文件会半随机的保存到本地路径下的某个目录。当job启动时，task tracker根据配置文档创建本地job目录，目录结构如以下所示：</p>
<ul>
<li><p>${mapred.local.dir}/taskTracker/archive/ :分布式缓存。这个目录保存本地的分布式缓存。因此本地分布式缓存是在所有task和job间共享的。</p>
</li>
<li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/</p>
</li>
</ul>
<p>  : 本地job目录。</p>
<ul>
<li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/work/: job指定的共享目录。各个任务可以使用这个空间做为暂存空间，用于它们之间共享文件。这个目录通过job.local.dir 参数暴露给用户。这个路径可以通过API <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#getJobLocalDir()" target="_blank" rel="noopener">JobConf.getJobLocalDir()</a>来访问。它也可以被做为系统属性获得。因此，用户（比如运行streaming）可以调用System.getProperty(“job.local.dir”)获得该目录。</p>
</li>
<li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/jars/: 存放jar包的路径，用于存放作业的jar文件和展开的jar。job.jar是应用程序的jar文件，它会被自动分发到各台机器，在task启动前会被自动展开。使用api <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#getJar()" target="_blank" rel="noopener">JobConf.getJar() </a>函数可以得到job.jar的位置。使用JobConf.getJar().getParent()可以访问存放展开的jar包的目录。</p>
</li>
<li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/job.xml： 一个job.xml文件，本地的通用的作业配置文件。</p>
</li>
<li><p>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid</p>
<p>： 每个任务有一个目录</p>
<p>task-id</p>
<p>，它里面有如下的目录结构：</p>
<ul>
<li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/job.xml： 一个job.xml文件，本地化的任务作业配置文件。任务本地化是指为该task设定特定的属性值。这些值会在下面具体说明。</li>
<li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/output 一个存放中间过程的输出文件的目录。它保存了由framwork产生的临时map reduce数据，比如map的输出文件等。</li>
<li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/work： task的当前工作目录。</li>
<li>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/work/tmp： task的临时目录。（用户可以设定属性mapred.child.tmp 来为map和reduce task设定临时目录。缺省值是./tmp。如果这个值不是绝对路径， 它会把task的工作路径加到该路径前面作为task的临时文件路径。如果这个值是绝对路径则直接使用这个值。 如果指定的目录不存在，会自动创建该目录。之后，按照选项 -Djava.io.tmpdir=’临时文件的绝对路径’执行java子任务。 pipes和streaming的临时文件路径是通过环境变量TMPDIR=’the absolute path of the tmp dir’设定的）。 如果mapred.child.tmp有./tmp值，这个目录会被创建。</li>
</ul>
</li>
</ul>
<p>下面的属性是为每个task执行时使用的本地参数，它们保存在本地化的任务作业配置文件里：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mapred.job.id</td>
<td align="center">String</td>
<td align="center">job id</td>
</tr>
<tr>
<td align="center">mapred.jar</td>
<td align="center">String</td>
<td align="center">job目录下job.jar的位置</td>
</tr>
<tr>
<td align="center">job.local.dir</td>
<td align="center">String</td>
<td align="center">job指定的共享存储空间</td>
</tr>
<tr>
<td align="center">mapred.tip.id</td>
<td align="center">String</td>
<td align="center">task id</td>
</tr>
<tr>
<td align="center">mapred.task.id</td>
<td align="center">String</td>
<td align="center">task尝试id</td>
</tr>
<tr>
<td align="center">mapred.task.is.map</td>
<td align="center">boolean</td>
<td align="center">是否是map task</td>
</tr>
<tr>
<td align="center">mapred.task.partition</td>
<td align="center">int</td>
<td align="center">task在job中的id</td>
</tr>
<tr>
<td align="center">map.input.file</td>
<td align="center">String</td>
<td align="center">map读取的文件名</td>
</tr>
<tr>
<td align="center">map.input.start</td>
<td align="center">long</td>
<td align="center">map输入的数据块的起始位置偏移</td>
</tr>
<tr>
<td align="center">map.input.length</td>
<td align="center">long</td>
<td align="center">map输入的数据块的字节数</td>
</tr>
<tr>
<td align="center">mapred.work.output.dir</td>
<td align="center">String</td>
<td align="center">task临时输出目录</td>
</tr>
</tbody></table>
<p>task的标准输出和错误输出流会被读到TaskTracker中，并且记录到 ${HADOOP_LOG_DIR}/userlogs</p>
<p><a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#DistributedCache" target="_blank" rel="noopener">DistributedCache</a> 可用于map或reduce task中分发jar包和本地库。子jvm总是把 <em>当前工作目录</em> 加到 java.library.path 和 LD_LIBRARY_PATH。 因此，可以通过 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/System.html#loadLibrary(java.lang.String)" target="_blank" rel="noopener">System.loadLibrary</a>或 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/System.html#load(java.lang.String)" target="_blank" rel="noopener">System.load</a>装载缓存的库。有关使用分布式缓存加载共享库的细节请参考 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/native_libraries.html#使用DistributedCache+加载本地库" target="_blank" rel="noopener">native_libraries.html</a></p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobClient.html" target="_blank" rel="noopener">JobClient</a>是用户提交的作业与JobTracker交互的主要接口。</p>
<p>JobClient 提供提交作业，追踪进程，访问子任务的日志记录，获得Map/Reduce集群状态信息等功能。</p>
<p>作业提交过程包括：</p>
<ol>
<li>检查作业输入输出样式细节</li>
<li>为作业计算InputSplit值。</li>
<li>如果需要的话，为作业的DistributedCache建立必须的统计信息。</li>
<li>拷贝作业的jar包和配置文件到FileSystem上的Map/Reduce系统目录下。</li>
<li>提交作业到JobTracker并且监控它的状态。</li>
</ol>
<p>作业的历史文件记录到指定目录的”_logs/history/“子目录下。这个指定目录由hadoop.job.history.user.location设定，默认是作业输出的目录。因此默认情况下，文件会存放在mapred.output.dir/_logs/history目录下。用户可以设置hadoop.job.history.user.location为none来停止日志记录。</p>
<p>用户使用下面的命令可以看到在指定目录下的历史日志记录的摘要。<br>$ bin/hadoop job -history output-dir<br>这个命令会打印出作业的细节，以及失败的和被杀死的任务细节。<br>要查看有关作业的更多细节例如成功的任务、每个任务尝试的次数（task attempt）等，可以使用下面的命令<br>$ bin/hadoop job -history all output-dir</p>
<p>用户可以使用 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputLogFilter.html" target="_blank" rel="noopener">OutputLogFilter</a> 从输出目录列表中筛选日志文件。</p>
<p>一般情况，用户利用JobConf创建应用程序并配置作业属性， 然后用 JobClient 提交作业并监视它的进程。</p>
<p>有时候，用一个单独的Map/Reduce作业并不能完成一个复杂的任务，用户也许要链接多个Map/Reduce作业才行。这是容易实现的，因为作业通常输出到分布式文件系统上的，所以可以把这个作业的输出作为下一个作业的输入实现串联。</p>
<p>然而，这也意味着，确保每一作业完成(成功或失败)的责任就直接落在了客户身上。在这种情况下，可以用的控制作业的选项有：</p>
<ul>
<li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobClient.html#runJob(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener">runJob(JobConf)</a>：提交作业，仅当作业完成时返回。</li>
<li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobClient.html#submitJob(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener">submitJob(JobConf)</a>：只提交作业，之后需要你轮询它返回的 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/RunningJob.html" target="_blank" rel="noopener">RunningJob</a>句柄的状态，并根据情况调度。</li>
<li><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setJobEndNotificationURI(java.lang.String)" target="_blank" rel="noopener">JobConf.setJobEndNotificationURI(String)</a>：设置一个作业完成通知，可避免轮询。</li>
</ul>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/InputFormat.html" target="_blank" rel="noopener">InputFormat</a> 为Map/Reduce作业描述输入的细节规范。</p>
<p>Map/Reduce框架根据作业的InputFormat来：</p>
<ol>
<li>检查作业输入的有效性。</li>
<li>把输入文件切分成多个逻辑InputSplit实例， 并把每一实例分别分发给一个 Mapper。</li>
<li>提供RecordReader的实现，这个RecordReader从逻辑InputSplit中获得输入记录， 这些记录将由Mapper处理。</li>
</ol>
<p>基于文件的InputFormat实现（通常是 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileInputFormat.html" target="_blank" rel="noopener">FileInputFormat</a>的子类） 默认行为是按照输入文件的字节大小，把输入数据切分成逻辑分块（<em>logical</em> InputSplit ）。 其中输入文件所在的FileSystem的数据块尺寸是分块大小的上限。下限可以设置mapred.min.split.size 的值。</p>
<p>考虑到边界情况，对于很多应用程序来说，很明显按照文件大小进行逻辑分割是不能满足需求的。 在这种情况下，应用程序需要实现一个RecordReader来处理记录的边界并为每个任务提供一个逻辑分块的面向记录的视图。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/TextInputFormat.html" target="_blank" rel="noopener">TextInputFormat</a> 是默认的InputFormat。</p>
<p>如果一个作业的Inputformat是TextInputFormat， 并且框架检测到输入文件的后缀是<em>.gz*和</em>.lzo*，就会使用对应的CompressionCodec自动解压缩这些文件。 但是需要注意，上述带后缀的压缩文件不会被切分，并且整个压缩文件会分给一个mapper来处理。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/InputSplit.html" target="_blank" rel="noopener">InputSplit</a> 是一个单独的Mapper要处理的数据块。</p>
<p>一般的InputSplit 是字节样式输入，然后由RecordReader处理并转化成记录样式。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileSplit.html" target="_blank" rel="noopener">FileSplit</a> 是默认的InputSplit。 它把 map.input.file 设定为输入文件的路径，输入文件是逻辑分块文件。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/RecordReader.html" target="_blank" rel="noopener">RecordReader</a> 从InputSlit读入&lt;key, value&gt;对。</p>
<p>一般的，RecordReader 把由InputSplit 提供的字节样式的输入文件，转化成由Mapper处理的记录样式的文件。 因此RecordReader负责处理记录的边界情况和把数据表示成keys/values对形式。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/OutputFormat.html" target="_blank" rel="noopener">OutputFormat</a> 描述Map/Reduce作业的输出样式。</p>
<p>Map/Reduce框架根据作业的OutputFormat来：</p>
<ol>
<li>检验作业的输出，例如检查输出路径是否已经存在。</li>
<li>提供一个RecordWriter的实现，用来输出作业结果。 输出文件保存在FileSystem上。</li>
</ol>
<p>TextOutputFormat是默认的 OutputFormat。</p>
<p>在一些应用程序中，子任务需要产生一些side-file，这些文件与作业实际输出结果的文件不同。</p>
<p>在这种情况下，同一个Mapper或者Reducer的两个实例（比如预防性任务）同时打开或者写 FileSystem上的同一文件就会产生冲突。因此应用程序在写文件的时候需要为每次任务尝试（不仅仅是每次任务，每个任务可以尝试执行很多次）选取一个独一无二的文件名(使用attemptid，例如task_200709221812_0001_m_000000_0)。</p>
<p>为了避免冲突，Map/Reduce框架为每次尝试执行任务都建立和维护一个特殊的 ${mapred.output.dir}/<em>temporary/</em>${taskid}子目录，这个目录位于本次尝试执行任务输出结果所在的FileSystem上，可以通过 ${mapred.work.output.dir}来访问这个子目录。 对于成功完成的任务尝试，只有${mapred.output.dir}/<em>temporary/</em>${taskid}下的文件会<em>移动</em>到${mapred.output.dir}。当然，框架会丢弃那些失败的任务尝试的子目录。这种处理过程对于应用程序来说是完全透明的。</p>
<p>在任务执行期间，应用程序在写文件时可以利用这个特性，比如 通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener"> FileOutputFormat.getWorkOutputPath()</a>获得${mapred.work.output.dir}目录， 并在其下创建任意任务执行时所需的side-file，框架在任务尝试成功时会马上移动这些文件，因此不需要在程序内为每次任务尝试选取一个独一无二的名字。</p>
<p>注意：在每次任务尝试执行期间，${mapred.work.output.dir} 的值实际上是 ${mapred.output.dir}/<em>temporary/</em>{$taskid}，这个值是Map/Reduce框架创建的。 所以使用这个特性的方法是，在<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapred.JobConf)" target="_blank" rel="noopener"> FileOutputFormat.getWorkOutputPath() </a>路径下创建side-file即可。</p>
<p>对于只使用map不使用reduce的作业，这个结论也成立。这种情况下，map的输出结果直接生成到HDFS上。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/RecordWriter.html" target="_blank" rel="noopener">RecordWriter</a> 生成&lt;key, value&gt; 对到输出文件。</p>
<p>RecordWriter的实现把作业的输出结果写到 FileSystem。</p>
<h4 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h4><p>Counters 是多个由Map/Reduce框架或者应用程序定义的全局计数器。 每一个Counter可以是任何一种 Enum类型。同一特定Enum类型的Counter可以汇集到一个组，其类型为Counters.Group。</p>
<p>应用程序可以定义任意(Enum类型)的Counters并且可以通过 map 或者 reduce方法中的 [Reporter.incrCounter(Enum, long)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter</a>(java.lang.Enum, long))或者 [Reporter.incrCounter(String, String, long)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/Reporter.html#incrCounter</a>(java.lang.String, java.lang.String, long amount)) 更新。之后框架会汇总这些全局counters。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html" target="_blank" rel="noopener">DistributedCache</a> 可将具体应用相关的、大尺寸的、只读的文件有效地分布放置。</p>
<p>DistributedCache 是Map/Reduce框架提供的功能，能够缓存应用程序所需的文件 （包括文本，档案文件，jar文件等）。</p>
<p>应用程序在JobConf中通过url(hdfs://)指定需要被缓存的文件。 DistributedCache假定由hdfs://格式url指定的文件已经在 FileSystem上了。</p>
<p>Map-Redcue框架在作业所有任务执行之前会把必要的文件拷贝到slave节点上。 它运行高效是因为每个作业的文件只拷贝一次并且为那些没有文档的slave节点缓存文档。</p>
<p>DistributedCache 根据缓存文档修改的时间戳进行追踪。 在作业执行期间，当前应用程序或者外部程序不能修改缓存文件。</p>
<p>distributedCache可以分发简单的只读数据或文本文件，也可以分发复杂类型的文件例如归档文件和jar文件。归档文件(zip,tar,tgz和tar.gz文件)在slave节点上会被<em>解档（un-archived）</em>。 这些文件可以设置<em>执行权限</em>。</p>
<p>用户可以通过设置mapred.cache.{files|archives}来分发文件。 如果要分发多个文件，可以使用逗号分隔文件所在路径。也可以利用API来设置该属性： [DistributedCache.addCacheFile(URI,conf)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheFile" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheFile</a>(java.net.URI, org.apache.hadoop.conf.Configuration))/ [DistributedCache.addCacheArchive(URI,conf)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheArchive" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addCacheArchive</a>(java.net.URI, org.apache.hadoop.conf.Configuration)) and [DistributedCache.setCacheFiles(URIs,conf)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheFiles" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheFiles</a>(java.net.URI[], org.apache.hadoop.conf.Configuration))/ [DistributedCache.setCacheArchives(URIs,conf)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheArchives" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#setCacheArchives</a>(java.net.URI[], org.apache.hadoop.conf.Configuration)) 其中URI的形式是 hdfs://host:port/absolute-path#link-name 在Streaming程序中，可以通过命令行选项 -cacheFile/-cacheArchive 分发文件。</p>
<p>用户可以通过<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#createSymlink(org.apache.hadoop.conf.Configuration)" target="_blank" rel="noopener"> DistributedCache.createSymlink(Configuration)</a>方法让DistributedCache 在<em>当前工作目录</em>下创建到缓存文件的符号链接。 或者通过设置配置文件属性mapred.create.symlink为yes。 分布式缓存会截取URI的片段作为链接的名字。 例如，URI是 hdfs://namenode:port/lib.so.1#lib.so， 则在task当前工作目录会有名为lib.so的链接， 它会链接分布式缓存中的lib.so.1。</p>
<p>DistributedCache可在map/reduce任务中作为 一种基础软件分发机制使用。它可以被用于分发jar包和本地库（native libraries）。 [DistributedCache.addArchiveToClassPath(Path, Configuration)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addArchiveToClassPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addArchiveToClassPath</a>(org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration))和 [DistributedCache.addFileToClassPath(Path, Configuration)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addFileToClassPath" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/filecache/DistributedCache.html#addFileToClassPath</a>(org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration)) API能够被用于 缓存文件和jar包，并把它们加入子jvm的<em>classpath</em>。也可以通过设置配置文档里的属性 mapred.job.classpath.{files|archives}达到相同的效果。缓存文件可用于分发和装载本地库。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/Tool.html" target="_blank" rel="noopener">Tool</a> 接口支持处理常用的Hadoop命令行选项。</p>
<p>Tool 是Map/Reduce工具或应用的标准。应用程序应只处理其定制参数， 要把标准命令行选项通过 [ToolRunner.run(Tool, String[])](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/ToolRunner.html#run" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/ToolRunner.html#run</a>(org.apache.hadoop.util.Tool, java.lang.String[])) 委托给 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/util/GenericOptionsParser.html" target="_blank" rel="noopener">GenericOptionsParser</a>处理。</p>
<p>Hadoop命令行的常用选项有：<br>-conf <configuration file=""><br>-D &lt;property=value&gt;<br>-fs &lt;local|namenode:port&gt;<br>-jt &lt;local|jobtracker:port&gt;</configuration></p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/IsolationRunner.html" target="_blank" rel="noopener">IsolationRunner</a> 是帮助调试Map/Reduce程序的工具。</p>
<p>使用IsolationRunner的方法是，首先设置 keep.failed.task.files属性为true （同时参考keep.task.files.pattern）。</p>
<p>然后，登录到任务运行失败的节点上，进入 TaskTracker的本地路径运行 IsolationRunner：<br>$ cd <local path="">/taskTracker/${taskid}/work<br>$ bin/hadoop org.apache.hadoop.mapred.IsolationRunner ../job.xml</local></p>
<p>IsolationRunner会把失败的任务放在单独的一个能够调试的jvm上运行，并且采用和之前完全一样的输入数据。</p>
<p>Profiling是一个工具，它使用内置的java profiler工具进行分析获得(2-3个)map或reduce样例运行分析报告。</p>
<p>用户可以通过设置属性mapred.task.profile指定系统是否采集profiler信息。 利用api<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileEnabled(boolean)" target="_blank" rel="noopener"> JobConf.setProfileEnabled(boolean)可以修改属性值</a>。如果设为true， 则开启profiling功能。profiler信息保存在用户日志目录下。缺省情况，profiling功能是关闭的。</p>
<p>如果用户设定使用profiling功能，可以使用配置文档里的属性 mapred.task.profile.{maps|reduces} 设置要profile map/reduce task的范围。设置该属性值的api是 [JobConf.setProfileTaskRange(boolean,String)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileTaskRange" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileTaskRange</a>(boolean, java.lang.String))。 范围的缺省值是0-2。</p>
<p>用户可以通过设定配置文档里的属性mapred.task.profile.params 来指定profiler配置参数。修改属性要使用api <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setProfileParams(java.lang.String)" target="_blank" rel="noopener">JobConf.setProfileParams(String)</a>。当运行task时，如果字符串包含%s。 它会被替换成profileing的输出文件名。这些参数会在命令行里传递到子JVM中。缺省的profiling 参数是 -agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s。</p>
<p>Map/Reduce框架能够运行用户提供的用于调试的脚本程序。 当map/reduce任务失败时，用户可以通过运行脚本在任务日志（例如任务的标准输出、标准错误、系统日志以及作业配置文件）上做后续处理工作。用户提供的调试脚本程序的标准输出和标准错误会输出为诊断文件。如果需要的话这些输出结果也可以打印在用户界面上。</p>
<p>在接下来的章节，我们讨论如何与作业一起提交调试脚本。为了提交调试脚本， 首先要把这个脚本分发出去，而且还要在配置文件里设置。</p>
<p>用户要用 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/mapred_tutorial.html#DistributedCache" target="_blank" rel="noopener">DistributedCache</a> 机制来<em>分发</em>和<em>链接</em>脚本文件</p>
<p>一个快速提交调试脚本的方法是分别为需要调试的map任务和reduce任务设置 “mapred.map.task.debug.script” 和 “mapred.reduce.task.debug.script” 属性的值。这些属性也可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapDebugScript(java.lang.String)" target="_blank" rel="noopener">JobConf.setMapDebugScript(String) </a>和 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setReduceDebugScript(java.lang.String)" target="_blank" rel="noopener">JobConf.setReduceDebugScript(String) </a>API来设置。对于streaming， 可以分别为需要调试的map任务和reduce任务使用命令行选项-mapdebug 和 -reducedegug来提交调试脚本。</p>
<p>脚本的参数是任务的标准输出、标准错误、系统日志以及作业配置文件。在运行map/reduce失败的节点上运行调试命令是：<br>$script $stdout $stderr $syslog $jobconf</p>
<p>Pipes 程序根据第五个参数获得c++程序名。 因此调试pipes程序的命令是<br>$script $stdout $stderr $syslog $jobconf $program</p>
<p>对于pipes，默认的脚本会用gdb处理core dump， 打印 stack trace并且给出正在运行线程的信息。</p>
<p><a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/jobcontrol/package-summary.html" target="_blank" rel="noopener">JobControl</a>是一个工具，它封装了一组Map/Reduce作业以及他们之间的依赖关系。</p>
<p>Hadoop Map/Reduce框架为应用程序的写入文件操作提供压缩工具，这些工具可以为map输出的中间数据和作业最终输出数据（例如reduce的输出）提供支持。它还附带了一些 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/io/compress/CompressionCodec.html" target="_blank" rel="noopener">CompressionCodec</a>的实现，比如实现了 <a href="http://www.zlib.net/" target="_blank" rel="noopener">zlib</a>和<a href="http://www.oberhumer.com/opensource/lzo/" target="_blank" rel="noopener">lzo</a>压缩算法。 Hadoop同样支持<a href="http://www.gzip.org/" target="_blank" rel="noopener">gzip</a>文件格式。</p>
<p>考虑到性能问题（zlib）以及Java类库的缺失（lzo）等因素，Hadoop也为上述压缩解压算法提供本地库的实现。更多的细节请参考 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/native_libraries.html" target="_blank" rel="noopener">这里</a>。</p>
<p>应用程序可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setCompressMapOutput(boolean)" target="_blank" rel="noopener">JobConf.setCompressMapOutput(boolean)</a>api控制map输出的中间结果，并且可以通过 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/JobConf.html#setMapOutputCompressorClass(java.lang.Class)" target="_blank" rel="noopener">JobConf.setMapOutputCompressorClass(Class)</a>api指定 CompressionCodec。</p>
<p>应用程序可以通过 [FileOutputFormat.setCompressOutput(JobConf, boolean)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setCompressOutput" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setCompressOutput</a>(org.apache.hadoop.mapred.JobConf, boolean)) api控制输出是否需要压缩并且可以使用 [FileOutputFormat.setOutputCompressorClass(JobConf, Class)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputCompressorClass" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#setOutputCompressorClass</a>(org.apache.hadoop.mapred.JobConf, java.lang.Class))api指定CompressionCodec。</p>
<p>如果作业输出要保存成 <a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/SequenceFileOutputFormat.html" target="_blank" rel="noopener">SequenceFileOutputFormat</a>格式，需要使用 [SequenceFileOutputFormat.setOutputCompressionType(JobConf, SequenceFile.CompressionType)](<a href="https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/SequenceFileOutputFormat.html#setOutputCompressionType" target="_blank" rel="noopener">https://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/SequenceFileOutputFormat.html#setOutputCompressionType</a>(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.io.SequenceFile.CompressionType))api，来设定 SequenceFile.CompressionType (i.e. RECORD / BLOCK - 默认是RECORD)。</p>
<h2 id="例子：WordCount-v2-0"><a href="#例子：WordCount-v2-0" class="headerlink" title="例子：WordCount v2.0"></a>例子：WordCount v2.0</h2><p>这里是一个更全面的WordCount例子，它使用了我们已经讨论过的很多Map/Reduce框架提供的功能。</p>
<p>运行这个例子需要HDFS的某些功能，特别是 DistributedCache相关功能。因此这个例子只能运行在 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#SingleNodeSetup" target="_blank" rel="noopener">伪分布式</a> 或者 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html#Fully-Distributed+Operation" target="_blank" rel="noopener">完全分布式模式</a>的 Hadoop上。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">WordCount.java</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1.</td>
<td align="center">package org.myorg;</td>
</tr>
<tr>
<td align="center">2.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3.</td>
<td align="center">import java.io.*;</td>
</tr>
<tr>
<td align="center">4.</td>
<td align="center">import java.util.*;</td>
</tr>
<tr>
<td align="center">5.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6.</td>
<td align="center">import org.apache.hadoop.fs.Path;</td>
</tr>
<tr>
<td align="center">7.</td>
<td align="center">import org.apache.hadoop.filecache.DistributedCache;</td>
</tr>
<tr>
<td align="center">8.</td>
<td align="center">import org.apache.hadoop.conf.*;</td>
</tr>
<tr>
<td align="center">9.</td>
<td align="center">import org.apache.hadoop.io.*;</td>
</tr>
<tr>
<td align="center">10.</td>
<td align="center">import org.apache.hadoop.mapred.*;</td>
</tr>
<tr>
<td align="center">11.</td>
<td align="center">import org.apache.hadoop.util.*;</td>
</tr>
<tr>
<td align="center">12.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">13.</td>
<td align="center">public class WordCount extends Configured implements Tool {</td>
</tr>
<tr>
<td align="center">14.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">15.</td>
<td align="center">public static class Map extends MapReduceBase implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {</td>
</tr>
<tr>
<td align="center">16.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">17.</td>
<td align="center">static enum Counters { INPUT_WORDS }</td>
</tr>
<tr>
<td align="center">18.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">19.</td>
<td align="center">private final static IntWritable one = new IntWritable(1);</td>
</tr>
<tr>
<td align="center">20.</td>
<td align="center">private Text word = new Text();</td>
</tr>
<tr>
<td align="center">21.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">22.</td>
<td align="center">private boolean caseSensitive = true;</td>
</tr>
<tr>
<td align="center">23.</td>
<td align="center">private Set<string> patternsToSkip = new HashSet<string>();</string></string></td>
</tr>
<tr>
<td align="center">24.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">25.</td>
<td align="center">private long numRecords = 0;</td>
</tr>
<tr>
<td align="center">26.</td>
<td align="center">private String inputFile;</td>
</tr>
<tr>
<td align="center">27.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">28.</td>
<td align="center">public void configure(JobConf job) {</td>
</tr>
<tr>
<td align="center">29.</td>
<td align="center">caseSensitive = job.getBoolean(“wordcount.case.sensitive”, true);</td>
</tr>
<tr>
<td align="center">30.</td>
<td align="center">inputFile = job.get(“map.input.file”);</td>
</tr>
<tr>
<td align="center">31.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">32.</td>
<td align="center">if (job.getBoolean(“wordcount.skip.patterns”, false)) {</td>
</tr>
<tr>
<td align="center">33.</td>
<td align="center">Path[] patternsFiles = new Path[0];</td>
</tr>
<tr>
<td align="center">34.</td>
<td align="center">try {</td>
</tr>
<tr>
<td align="center">35.</td>
<td align="center">patternsFiles = DistributedCache.getLocalCacheFiles(job);</td>
</tr>
<tr>
<td align="center">36.</td>
<td align="center">} catch (IOException ioe) {</td>
</tr>
<tr>
<td align="center">37.</td>
<td align="center">System.err.println(“Caught exception while getting cached files: “ + StringUtils.stringifyException(ioe));</td>
</tr>
<tr>
<td align="center">38.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">39.</td>
<td align="center">for (Path patternsFile : patternsFiles) {</td>
</tr>
<tr>
<td align="center">40.</td>
<td align="center">parseSkipFile(patternsFile);</td>
</tr>
<tr>
<td align="center">41.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">42.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">43.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">44.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">45.</td>
<td align="center">private void parseSkipFile(Path patternsFile) {</td>
</tr>
<tr>
<td align="center">46.</td>
<td align="center">try {</td>
</tr>
<tr>
<td align="center">47.</td>
<td align="center">BufferedReader fis = new BufferedReader(new FileReader(patternsFile.toString()));</td>
</tr>
<tr>
<td align="center">48.</td>
<td align="center">String pattern = null;</td>
</tr>
<tr>
<td align="center">49.</td>
<td align="center">while ((pattern = fis.readLine()) != null) {</td>
</tr>
<tr>
<td align="center">50.</td>
<td align="center">patternsToSkip.add(pattern);</td>
</tr>
<tr>
<td align="center">51.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">52.</td>
<td align="center">} catch (IOException ioe) {</td>
</tr>
<tr>
<td align="center">53.</td>
<td align="center">System.err.println(“Caught exception while parsing the cached file ‘“ + patternsFile + “‘ : “ + StringUtils.stringifyException(ioe));</td>
</tr>
<tr>
<td align="center">54.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">55.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">56.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">57.</td>
<td align="center">public void map(LongWritable key, Text value, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {</td>
</tr>
<tr>
<td align="center">58.</td>
<td align="center">String line = (caseSensitive) ? value.toString() : value.toString().toLowerCase();</td>
</tr>
<tr>
<td align="center">59.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">60.</td>
<td align="center">for (String pattern : patternsToSkip) {</td>
</tr>
<tr>
<td align="center">61.</td>
<td align="center">line = line.replaceAll(pattern, “”);</td>
</tr>
<tr>
<td align="center">62.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">63.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">64.</td>
<td align="center">StringTokenizer tokenizer = new StringTokenizer(line);</td>
</tr>
<tr>
<td align="center">65.</td>
<td align="center">while (tokenizer.hasMoreTokens()) {</td>
</tr>
<tr>
<td align="center">66.</td>
<td align="center">word.set(tokenizer.nextToken());</td>
</tr>
<tr>
<td align="center">67.</td>
<td align="center">output.collect(word, one);</td>
</tr>
<tr>
<td align="center">68.</td>
<td align="center">reporter.incrCounter(Counters.INPUT_WORDS, 1);</td>
</tr>
<tr>
<td align="center">69.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">70.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">71.</td>
<td align="center">if ((++numRecords % 100) == 0) {</td>
</tr>
<tr>
<td align="center">72.</td>
<td align="center">reporter.setStatus(“Finished processing “ + numRecords + “ records “ + “from the input file: “ + inputFile);</td>
</tr>
<tr>
<td align="center">73.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">74.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">75.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">76.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">77.</td>
<td align="center">public static class Reduce extends MapReduceBase implements Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {</td>
</tr>
<tr>
<td align="center">78.</td>
<td align="center">public void reduce(Text key, Iterator<intwritable> values, OutputCollector&lt;Text, IntWritable&gt; output, Reporter reporter) throws IOException {</intwritable></td>
</tr>
<tr>
<td align="center">79.</td>
<td align="center">int sum = 0;</td>
</tr>
<tr>
<td align="center">80.</td>
<td align="center">while (values.hasNext()) {</td>
</tr>
<tr>
<td align="center">81.</td>
<td align="center">sum += values.next().get();</td>
</tr>
<tr>
<td align="center">82.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">83.</td>
<td align="center">output.collect(key, new IntWritable(sum));</td>
</tr>
<tr>
<td align="center">84.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">85.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">86.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">87.</td>
<td align="center">public int run(String[] args) throws Exception {</td>
</tr>
<tr>
<td align="center">88.</td>
<td align="center">JobConf conf = new JobConf(getConf(), WordCount.class);</td>
</tr>
<tr>
<td align="center">89.</td>
<td align="center">conf.setJobName(“wordcount”);</td>
</tr>
<tr>
<td align="center">90.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">91.</td>
<td align="center">conf.setOutputKeyClass(Text.class);</td>
</tr>
<tr>
<td align="center">92.</td>
<td align="center">conf.setOutputValueClass(IntWritable.class);</td>
</tr>
<tr>
<td align="center">93.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">94.</td>
<td align="center">conf.setMapperClass(Map.class);</td>
</tr>
<tr>
<td align="center">95.</td>
<td align="center">conf.setCombinerClass(Reduce.class);</td>
</tr>
<tr>
<td align="center">96.</td>
<td align="center">conf.setReducerClass(Reduce.class);</td>
</tr>
<tr>
<td align="center">97.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">98.</td>
<td align="center">conf.setInputFormat(TextInputFormat.class);</td>
</tr>
<tr>
<td align="center">99.</td>
<td align="center">conf.setOutputFormat(TextOutputFormat.class);</td>
</tr>
<tr>
<td align="center">100.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">101.</td>
<td align="center">List<string> other_args = new ArrayList<string>();</string></string></td>
</tr>
<tr>
<td align="center">102.</td>
<td align="center">for (int i=0; i &lt; args.length; ++i) {</td>
</tr>
<tr>
<td align="center">103.</td>
<td align="center">if (“-skip”.equals(args[i])) {</td>
</tr>
<tr>
<td align="center">104.</td>
<td align="center">DistributedCache.addCacheFile(new Path(args[++i]).toUri(), conf);</td>
</tr>
<tr>
<td align="center">105.</td>
<td align="center">conf.setBoolean(“wordcount.skip.patterns”, true);</td>
</tr>
<tr>
<td align="center">106.</td>
<td align="center">} else {</td>
</tr>
<tr>
<td align="center">107.</td>
<td align="center">other_args.add(args[i]);</td>
</tr>
<tr>
<td align="center">108.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">109.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">110.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">111.</td>
<td align="center">FileInputFormat.setInputPaths(conf, new Path(other_args.get(0)));</td>
</tr>
<tr>
<td align="center">112.</td>
<td align="center">FileOutputFormat.setOutputPath(conf, new Path(other_args.get(1)));</td>
</tr>
<tr>
<td align="center">113.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">114.</td>
<td align="center">JobClient.runJob(conf);</td>
</tr>
<tr>
<td align="center">115.</td>
<td align="center">return 0;</td>
</tr>
<tr>
<td align="center">116.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">117.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">118.</td>
<td align="center">public static void main(String[] args) throws Exception {</td>
</tr>
<tr>
<td align="center">119.</td>
<td align="center">int res = ToolRunner.run(new Configuration(), new WordCount(), args);</td>
</tr>
<tr>
<td align="center">120.</td>
<td align="center">System.exit(res);</td>
</tr>
<tr>
<td align="center">121.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">122.</td>
<td align="center">}</td>
</tr>
<tr>
<td align="center">123.</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>输入样例：</p>
<p>$ bin/hadoop dfs -ls /usr/joe/wordcount/input/<br>/usr/joe/wordcount/input/file01<br>/usr/joe/wordcount/input/file02</p>
<p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file01<br>Hello World, Bye World!</p>
<p>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file02<br>Hello Hadoop, Goodbye to hadoop.</p>
<p>运行程序：</p>
<p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount /usr/joe/wordcount/input /usr/joe/wordcount/output</p>
<p>输出：</p>
<p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>Bye 1<br>Goodbye 1<br>Hadoop, 1<br>Hello 2<br>World! 1<br>World, 1<br>hadoop. 1<br>to 1</p>
<p>注意此时的输入与第一个版本的不同，输出的结果也有不同。</p>
<p>现在通过DistributedCache插入一个模式文件，文件中保存了要被忽略的单词模式。</p>
<p>$ hadoop dfs -cat /user/joe/wordcount/patterns.txt<br>.<br>,<br>!<br>to</p>
<p>再运行一次，这次使用更多的选项：</p>
<p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount -Dwordcount.case.sensitive=true /usr/joe/wordcount/input /usr/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt</p>
<p>应该得到这样的输出：</p>
<p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>Bye 1<br>Goodbye 1<br>Hadoop 1<br>Hello 2<br>World 2<br>hadoop 1</p>
<p>再运行一次，这一次关闭大小写敏感性（case-sensitivity）：</p>
<p>$ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount -Dwordcount.case.sensitive=false /usr/joe/wordcount/input /usr/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt</p>
<p>输出：</p>
<p>$ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000<br>bye 1<br>goodbye 1<br>hadoop 2<br>hello 2<br>world 2</p>
<p>通过使用一些Map/Reduce框架提供的功能，WordCount的第二个版本在原始版本基础上有了如下的改进：</p>
<ul>
<li>展示了应用程序如何在Mapper (和Reducer)中通过configure方法 修改配置参数(28-43行)。</li>
<li>展示了作业如何使用DistributedCache 来分发只读数据。 这里允许用户指定单词的模式，在计数时忽略那些符合模式的单词(104行)。</li>
<li>展示Tool接口和GenericOptionsParser处理Hadoop命令行选项的功能 (87-116, 119行)。</li>
<li>展示了应用程序如何使用Counters(68行)，如何通过传递给map（和reduce） 方法的Reporter实例来设置应用程序的状态信息(72行)。</li>
</ul>
<p><em>Java和JNI是Sun Microsystems, Inc.在美国和其它国家的注册商标。</em></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Hadoop/">Hadoop</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/06/25/Hadoop-HDFS%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hadoop HDFS使用指南</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/06/22/%E4%BA%94%E5%88%86%E9%92%9F%E8%AF%BB%E6%87%82%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/">
                        <span class="hidden-mobile">五分钟读懂电脑配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const mathjax = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
