

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#3cbdfe">
  <meta name="description" content="EC存储">
  <meta name="author" content="CAIWEI">
  <meta name="keywords" content="">
  <meta name="description" content="EC存储">
<meta property="og:type" content="article">
<meta property="og:title" content="EC存储原理及简单工程化实现">
<meta property="og:url" content="http://example.com/2022/03/26/ec_cun_chu_yuan_li_ji_jian_dan_gong_cheng_hua_shi_xian/index.html">
<meta property="og:site_name" content="CAIWEI的博客">
<meta property="og:description" content="EC存储">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326053704.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326194803.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326060953.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220328004300.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326195929.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327044741.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326081529.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326202757.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326202007.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327053941.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327080403.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327080512.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326202446.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327054646.png">
<meta property="article:published_time" content="2022-03-25T20:52:41.000Z">
<meta property="article:modified_time" content="2022-03-27T18:12:07.301Z">
<meta property="article:author" content="CAIWEI">
<meta property="article:tag" content="存储">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326053704.png">
  
  <title>EC存储原理及简单工程化实现 - CAIWEI的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="CAIWEI的博客" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> </strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://auto2dev.coding.net/p/ImageHostingService/d/ImageHostingService/git/raw/master/higan/catoon_thumbnail/catoon_2200.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="EC存储原理及简单工程化实现">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-26 04:52" pubdate>
        2022年3月26日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      47 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">EC存储原理及简单工程化实现</h1>
            
            <div class="markdown-body">
              <h1 id="ec存储">EC存储</h1>
<a id="more"></a>
<h2 id="为什么要ec">1. 为什么要EC？</h2>
<p><strong>主要是为了省钱</strong>~ 众所周知（不知道也行），HDFS默认是三副本存储策略，即数据在不同机架上保存三份，这样的好处是保证了数据存储的<strong>高容错性</strong>（其中的一两份数据损坏或者丢失了还能恢复）以及在使用的时候能够快速读取数据（因为机架位置、IO以及一些别的原因，这里略过暂时不说）</p>
<p>HDFS的这种三副本存储类似在现实中一些重要文件会电脑、U盘、网盘里各存一份，但这里带来了一个问题：<strong>存储利用率低</strong>。当文件很小的时候，其实这个问题都可以说不算什么问题...但是当今大数据时代，许多公司（尤其头部互联网公司）的数据量动辄几EB（以一般家庭电脑1TB的存储来计算，1EB相当于100万台电脑的存储。。），这就导致在保证数据可靠、稳定等前提下，需要付出在数据三倍的存储成本。为了解决存储冗余这个问题，所以会用到纠删码（Erasure Coding，简称<strong>EC</strong>）存储。</p>
<blockquote>
<p>本篇文章中默认只讲最经典的纠删码算法——里德-所罗门码（Reed-Solomon 码，简称 RS 码）以及其扩展的编码方式</p>
</blockquote>
<h2 id="ec原理">2. EC原理</h2>
<h3 id="ec如何节省存储">2.1 EC如何节省存储</h3>
<p>纠删码<strong>计算得到校验块</strong>和<strong>恢复数据</strong>分为三个步骤:</p>
<ol type="1">
<li>把一个文件（副本）均分为K个数据块</li>
<li>将这K个数据块通过一定的方式联系起来生成M个校验块</li>
<li>当某几个数据块丢失时（需要满足丢失个数小于M），可由剩下的数据块和校验块计算出丢失的数据块</li>
</ol>
<p>例如当K=5（文件切分为5个数据块）、M=3（生成3个校验块）时，对比一下两种方式的存储利用率：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>三副本存储</th>
<th>EC存储</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>存储利用率</td>
<td>5/( 5+3 ) = <strong>62.5%</strong></td>
<td>1/3 = <strong>33.33%</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>存储利用率：单份原始文件大小/文件总存储大小</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326053704.png" srcset="/img/loading.gif" lazyload="" style="zoom: 50%;"></p>
<p>当然，根据校验块与数据块比例的改变，存储利用率也会改变，校验块文件大小/数据块文件大小越小，存储利用率就越高，但相对的可靠性就降低了，具体RS码中不同策略的存储利用率（存储效率）和可靠性可以看下图（直接简单计算下就能算出来了）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326194803.jpg" srcset="/img/loading.gif" lazyload="" style="zoom:50%;"></p>
<blockquote>
<p><strong>RS-10-4-1024k：</strong>使用RS编码，每10个数据单元（cell），生成4个校验单元，共14个单元，每个单元的大小是1024k=1024*1024=1048576。</p>
</blockquote>
<h3 id="生成校验快">2.2 生成校验快</h3>
<p>EC存储生成校验块后能恢复数据，乍一看挺神奇，但实际上小学数学里已经学过了，先来看个简单的例子。</p>
<p>如果有三个整数如下： <span class="math display">\[
\left\{
\begin{array}{**lr**}  
x_1 = 1 \\
x_2 = 2 \\
x_3 = 3 
\end{array}  
\right.
\]</span> 如果有其中一个数可能会丢失，就需要从这几个数里搞出点新的信息用来以备数据丢失一部分后还能恢复，我们把这个信息称为<strong>校验块</strong></p>
<ul>
<li><p>当丢失一个数据</p>
<p>最简单的方式有，直接把这三个累加得到一个数值<span class="math inline">\(s_1\)</span>，那么当丢失其中一个数据后，将<span class="math inline">\(s_1\)</span>减去剩下的两个数据即可得到丢失的数据。</p></li>
<li><p>当丢失两个数据</p>
<p>还是按照上面那样再构造一个校验块，例如<span class="math inline">\(s_2=x_1+x_2+x_3\)</span>，但是这个不行，因为跟<span class="math inline">\(s_1=x_1+x_2+x_3\)</span>联立得到的两个方程显然无解，这种线性相关的就不行（线性代数中有讲）</p>
<p>如果改成<span class="math inline">\(s2=7d_1+6d_2+3d_3\)</span>，联立两个方程显然可以解出<span class="math inline">\(s_1,s_2\)</span>，这两个就是校验块，用矩阵形式表示如下： <span class="math display">\[
\begin{equation}
\left[ \begin{array}{ccc}
1 &amp; 1 &amp; 1\\
7 &amp; 6 &amp; 3
\end{array} 
\right ]
\left[ \begin{array}{ccc}
x_1\\
x_2\\
x_3
\end{array} 
\right ]
=
\left[ \begin{array}{ccc}
s_1\\
s_2
\end{array} 
\right ]
\end{equation}
\]</span> 左边这个[[1,1,1],[7,6,3]]叫做<strong>生成矩阵</strong>(generator matrix, GM) ，他需要保证是<strong>可逆</strong>的（生成矩阵可逆保证了不会出现上面那种线性相关的情况），所以一般需要有一个规律性取值的生成矩阵，比如<strong>范德蒙德矩阵</strong>。 <span class="math display">\[
\left[ \begin{array}{ccc}
1 &amp; 1 &amp;...&amp; 1 \\
1 &amp; 2 &amp; ...&amp;n \\
...   &amp;...&amp;...&amp;...        \\
1^{m-1} &amp; 2^{m-1} &amp;...&amp; n^{m-1}
\end{array} 
\right ]
\]</span></p>
<p>关于上面例子中为什么不能线性相关的补充：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326060953.png" srcset="/img/loading.gif" lazyload=""></p></li>
</ul>
<p>在EC存储里出现这种线性相关，简单来讲类似下面这种方程解出<span class="math inline">\(x_1,x_2\)</span>： <span class="math display">\[
  \left\{
\begin{array}{**lr**}  
  x_1 + x_2  = 1 \\
  x_1 + x_2  = 1
  \end{array}  
  \right.
\]</span> （小学生都知道解个锤子哦。。）</p>
<h3 id="数据恢复">2.3 数据恢复</h3>
<p>这部分生成矩阵用范德蒙德矩阵为例，因为两个相乘的矩阵大小需要满足大小分别为m1*m2、m2*m3（即要对齐），所以在范德蒙德矩阵上面增加个单位矩阵扩展下，<kbd>生成矩阵</kbd> * <kbd>数据块</kbd> = <kbd>数据块+校验块</kbd>： <span class="math display">\[
\begin{equation}
\left[ \begin{array}{ccc}
1 &amp; 0 &amp; ... &amp; 0\\
0 &amp; 1 &amp; ... &amp; 0\\
...&amp;...&amp;...&amp;...\\
1 &amp; 1 &amp;...&amp; 1 \\
1 &amp; 2 &amp; ...&amp;n \\
... &amp;...&amp;...&amp;...        \\
1^{m-1} &amp; 2^{m-1} &amp;...&amp; n^{m-1}
\end{array} 
\right ]
\left[ \begin{array}{ccc}
x_1\\
x_2\\
...\\
x_k
\end{array} 
\right ]
=
\left[ \begin{array}{ccc}
x_1\\
x_2\\
...\\
x_k \\
s_1 \\
... \\
s_m
\end{array} 
\right ]
\end{equation}
\]</span> 假设前m个数据块缺失了（两个相乘的矩阵行列要对应上，所以不管是缺失1个还是缺失m个数据，都得用一样大小的矩阵），现在要恢复数据。</p>
<p>因为缺失的是前面的m个数据块，所以这里把生成矩阵的前m行去掉，数据块对应矩阵的前m行也去掉再后面补上校验块，相乘得到的就是<kbd>数据块+校验块</kbd>，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220328004300.png" srcset="/img/loading.gif" lazyload=""></p>
<p>式子写出来大概是这样： $$ <span class="math display">\[\begin{equation}

\left[ \begin{array}{ccc}
0 &amp; 0 &amp; ... &amp; 0\\
...&amp;...&amp;...&amp;...\\
1 &amp; 1 &amp;...&amp; 1 \\
1 &amp; 2 &amp; ...&amp;n \\
... &amp;...&amp;...&amp;...        \\
1^{m-1} &amp; 2^{m-1} &amp;...&amp; n^{m-1}
\end{array} 
\right ]
\left[ \begin{array}{ccc}
x_{m+1}\\
...\\
x_k\\
s_1\\
...\\
s_m
\end{array} 
\right ]
=
\left[ \begin{array}{ccc}
x_1\\
x_2\\
...\\
x_k \\
s_1 \\
... \\
s_m
\end{array} 
\right ]
\end{equation}\]</span> $$ （这部分就不举具体的数值例子了）这样缺失的m个数据块<span class="math inline">\(x_1,x_2...x_m\)</span>就被恢复回来了</p>
<h2 id="工程实现">3. 工程实现</h2>
<h3 id="数学理论工程化">3.1 数学理论工程化</h3>
<p>上面已经讲了EC存储原理了，但是仅仅是有了生成校验块和恢复数据的方法是不够的，具体工程化<strong>必要的</strong>步骤有下：</p>
<p>（由于EC存储的一些限制，所以具体工程实现可能会做一些看似奇怪的事）</p>
<ol type="1">
<li><p>生成校验块</p>
<p>EC的方式有很多种，而不同EC方式的区别主要在生成校验块这个过程不一样，先来看看较简单的一种方式（Hadoop3.0之前的版本实现的就是类似这种方式）：</p>
<ul>
<li>在创建数据块以及数据块远远未写满的情况下，使用副本策略做数据容错</li>
<li>当若干数据块（比如k个数据块）都基本写满，则禁止对这些数据块做写（包括修改、删除）等操作，此时以特定方式产生生成矩阵，从而计算生成校验块。</li>
<li>当校验块计算完成时，删除冗余的数据块副本。此时就从副本策略变成纠删码策略。</li>
</ul></li>
<li><p>定期扫描</p>
<p>一个线程定期扫描数据，比如对数据块和校验块做<a href="https://blog.csdn.net/qq_44743166/article/details/104883123" target="_blank" rel="noopener">CRC校验</a>，如果发现有数据块或者校验块失效，则启动恢复数据线程</p></li>
<li><p>恢复数据</p></li>
</ol>
<p>​ 恢复线程先根据EC组现有的数据情况，从远程或本地获取必要的数据进行解码，恢复失效数据。</p>
<p>架构大致如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326195929.jpg" srcset="/img/loading.gif" lazyload="" style="zoom:50%;"></p>
<p>除了上述必要的模块，还需要用一些数学方法来优化计算，否则对计算资源的消耗实在太大。</p>
<h4 id="生成矩阵优化">3.1.1 生成矩阵优化</h4>
<p>生成矩阵定义了如何将原始数据块编码为冗余数据块，单位矩阵对应的是原始数据块，冗余矩阵对应的是校验块。如何使用一个适合的生成矩阵，很大程度上决定了EC效率。</p>
<p>因为解码需要对矩阵求逆，因此生成矩阵除了单位矩阵部分，必须满足矩阵可逆的性质。常见的生成矩阵是<strong>范德蒙矩阵</strong>（Vandermonde matrix ）和<strong>柯西矩阵</strong>（Cauchy matrix）。</p>
<p>如果用<kbd>单位矩阵+范德蒙德矩阵</kbd>作为生成矩阵，需要通过高斯消元后才能使用，这是因为在数据块和校验块数量即<span class="math inline">\((k+m)\)</span> 比较大时会存在矩阵不可逆的风险，所以目前生成矩阵基本上都用<kbd>单位矩阵+柯西矩阵</kbd></p>
<p>接下来先介绍下柯西矩阵，对于给定的向量<span class="math inline">\(x_i\)</span>和<span class="math inline">\(y_j\)</span>，其中<span class="math inline">\(1\le i \le m\)</span>，<span class="math inline">\(1 \le j \le n\)</span>（即向量<span class="math inline">\(i\)</span>有<span class="math inline">\(m\)</span>个数，向量<span class="math inline">\(j\)</span>有<span class="math inline">\(n\)</span>个数），通过如下公式计算得到<span class="math inline">\(m \times n\)</span>阶的柯西矩阵： <span class="math display">\[
C_{ij} = \frac{1}{x_i-y_j}
\]</span> 从上面可知，柯西矩阵是由两个给定的向量决定的，其python实现如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>y = np.array([<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>])<br>C = <span class="hljs-number">1.0</span> / (x.reshape((<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)) - y)	<span class="hljs-comment"># 利用数组广播向量化计算</span><br></code></pre></div></td></tr></tbody></table></figure>
<p>另外，需要<strong>限制生成矩阵中数值的范围</strong>，不然计算量可能会变得很大，想想大量32位的整数和8位的整数计算对内存来说区别会有多大，所以需要引入<strong>有限域运算</strong>。通常使用自定义的伽罗华域 <span class="math inline">\(GF(2^8)\)</span>，即 0～255 这一有限域，这是因为其长度刚好为1字节。</p>
<p>伽罗华域的加法和减法为异或运算，乘法和除法需要基于生成多项式计算出<span class="math inline">\(gfilog\)</span>表，例如<span class="math inline">\(GF(2^4)\)</span>的<span class="math inline">\(gfilog\)</span>表如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327044741.png" srcset="/img/loading.gif" lazyload="" style="zoom: 80%;"></p>
<p>在该<span class="math inline">\(GF(2^8)\)</span>中以<span class="math inline">\(8*9\)</span>的计算过程如下所示（如果值大于<span class="math inline">\(2^w\)</span>，需要模<span class="math inline">\(2^w\)</span>）： <span class="math display">\[
8∗9=x_8 x_9=x^{17}=x^{17\%15}=x^2=4
\]</span> 另外，因为恢复数据的时候涉及逆矩阵，柯西矩阵求逆计算较为复杂，所以工程实现上一般建议提前准备好柯西矩阵的乘法逆元表。创建以柯西矩阵为生成矩阵的伪代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 数据块大小为k</span><br><span class="hljs-comment"># 校验块个数为m</span><br><br><span class="hljs-comment"># rows为行数，cols为列数</span><br><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>A = np.zeros((k,k))	<span class="hljs-comment">#单位矩阵</span><br><span class="hljs-comment"># 生成单位矩阵</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<br>    A[i][i] = <span class="hljs-number">1</span><br>    <br>C = np.zeros((m,k)) <span class="hljs-comment">#柯西矩阵</span><br><span class="hljs-comment"># 生成柯西矩阵</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k):<br>        d = i**j<br>        C[i][j] = inverseTable[d] <span class="hljs-comment">#查乘法逆元表(这个是自定义的函数)</span><br></code></pre></div></td></tr></tbody></table></figure>
<p>Intel 的EC库有实现柯西矩阵作为生成矩阵的EC存储</p>
<h4 id="超大矩阵运算">3.1.2 超大矩阵运算</h4>
<p>有限域运算里，生成矩阵可能会出现大量的0，对于这种情况我们不妨采用对矩阵进行特殊的处理，使得适用于稀疏矩阵乘法从而加速矩阵计算.以下将以Spark为例子.</p>
<ul>
<li>基于 RDD 实现矩阵乘法，思路：</li>
</ul>
<ol type="1">
<li>先通过 map 函数构建以左矩阵的列号<span class="math inline">\((j)\)</span>和右矩阵的行号<span class="math inline">\((j)\)</span>作为 key 的数据结构。即 <span class="math inline">\((j, (i,L_val))\)</span> 和 <span class="math inline">\((j, (k,R_val))\)</span>。</li>
<li>对上一步骤进行 join 运算得到 <span class="math inline">\((j, [(i,L_val), (k,R_val)])\)</span>。</li>
<li>对上一步骤的值通过 map 函数构建以左矩阵的行号(i)和右矩阵的列号<span class="math inline">\((k)\)</span>作为 key , 且对应元素的积作为 value 的数据结构。即$ ((i,k), L_val*R_val)$。</li>
<li>对上一步骤进行 reduceByKey, 对$ (i,k)$ 相同的两两结果进行相加即得到第i行第k列的结果, 即 <span class="math inline">\(P_{ik}\)</span>。</li>
</ol>
<p>RDD版本的实现：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyspark.mllib.linalg.distributed <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyspark.sql <span class="hljs-keyword">import</span> SparkSession<br><br>ss = SparkSession.builder.appName(<span class="hljs-string">"test"</span>) \<br>    .config(<span class="hljs-string">"spark.serializer"</span>, <span class="hljs-string">"org.apache.spark.serializer.KryoSerializer"</span>) \<br>    .getOrCreate()<br><br>sc = ss.sparkContext<br><br>M_rdd = sc.parallelize([(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>)])<br>N_rdd = sc.parallelize([(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>)])<br>M = CoordinateMatrix(M_rdd)<br>N = CoordinateMatrix(N_rdd)<br><br>M = M.entries.map(<span class="hljs-keyword">lambda</span> entry: (entry.j, (entry.i, entry.value)))<br>N = N.entries.map(<span class="hljs-keyword">lambda</span> entry: (entry.i, (entry.j, entry.value)))<br><br>matrix_entries = M.join(N).values().map(<br>    <span class="hljs-keyword">lambda</span> x: ((x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]), x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] * x[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br>).reduceByKey(<br>    <span class="hljs-keyword">lambda</span> x, y: x + y<br>).map(<br>    <span class="hljs-keyword">lambda</span> x: MatrixEntry(x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], x[<span class="hljs-number">1</span>])<br>)<br><br>matrix = CoordinateMatrix(matrix_entries)<br>matrix.entries.collect()<br><br><span class="hljs-comment">######## 输出 #############</span><br><span class="hljs-comment"># [MatrixEntry(0, 0, 58.0),</span><br><span class="hljs-comment">#  MatrixEntry(1, 0, 139.0),</span><br><span class="hljs-comment">#  MatrixEntry(0, 1, 64.0),</span><br><span class="hljs-comment">#  MatrixEntry(1, 1, 154.0)]</span><br></code></pre></div></td></tr></tbody></table></figure>
<ul>
<li>基于 DataFrame 实现矩阵乘法，思路：</li>
</ul>
<ol type="1">
<li>基于 DataFrame 方式并非将每一列号作为一个单独字段，而是将矩阵里面的每一个元素看成一个三维数据，即（行号，列号，值），将一个矩阵转化为一个包含三个字段的 table，对于一个稀疏矩阵，只需要记录非零元素，即 100 个非零元素就对应 DataFrame 的 100 行。</li>
<li>计算逻辑与 RDD 方式非常相似，主要有三个流程 join =&gt; groupby =&gt; agg。</li>
<li>基于 DataFrame 方式能大幅度提升运算速度，因为 DataFrame 相比 RDD 有更佳的优化支持。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyspark.mllib.linalg.distributed <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyspark.sql <span class="hljs-keyword">import</span> SparkSession, functions <span class="hljs-keyword">as</span> F<br><br>ss = SparkSession.builder.appName(<span class="hljs-string">"test"</span>) \<br>    .config(<span class="hljs-string">"spark.serializer"</span>, <span class="hljs-string">"org.apache.spark.serializer.KryoSerializer"</span>) \<br>    .getOrCreate()<br><br>sc = ss.sparkContext<br><br>M_rdd = sc.parallelize([(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>)])<br>N_rdd = sc.parallelize([(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>)])<br><br>M = ss.createDataFrame(M_rdd, [<span class="hljs-string">'l_row'</span>, <span class="hljs-string">'l_column'</span>, <span class="hljs-string">'l_val'</span>])<br>N = ss.createDataFrame(N_rdd, [<span class="hljs-string">'r_row'</span>, <span class="hljs-string">'r_column'</span>, <span class="hljs-string">'r_val'</span>])<br>M.join(<br>    N, M[<span class="hljs-string">'l_column'</span>]==N[<span class="hljs-string">'r_row'</span>]<br>).groupBy(<br>    <span class="hljs-string">'l_row'</span>, <span class="hljs-string">'r_column'</span><br>).agg(<br>    F.sum(M[<span class="hljs-string">'l_val'</span>]*N[<span class="hljs-string">'r_val'</span>])<br>).toDF(<span class="hljs-string">'row'</span>, <span class="hljs-string">'column'</span>, <span class="hljs-string">'val'</span>).show()<br><br><span class="hljs-comment">######## 输出 #############</span><br><span class="hljs-comment"># +---+------+---+</span><br><span class="hljs-comment"># |row|column|val|</span><br><span class="hljs-comment"># +---+------+---+</span><br><span class="hljs-comment"># |  1|     1|154|</span><br><span class="hljs-comment"># |  0|     1| 64|</span><br><span class="hljs-comment"># |  1|     0|139|</span><br><span class="hljs-comment"># |  0|     0| 58|</span><br><span class="hljs-comment"># +---+------+---+</span><br></code></pre></div></td></tr></tbody></table></figure>
<p>看一下一般的矩阵乘法优化过后的乘法性能对比：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326081529.png" srcset="/img/loading.gif" lazyload="" alt="性能对比"><figcaption aria-hidden="true">性能对比</figcaption>
</figure>
<h4 id="利用-simd-加速有限域运算">3.1.3 利用 SIMD 加速有限域运算</h4>
<p>这部分过于底层了，在此只介绍工程实现中用 SIMD 指令集加速运算的必要性。</p>
<p>在生成矩阵那一部分可知，有限域上的乘法是通过查表得到的，每个字节和生成矩阵中元素的乘法结果通过查表得到，下图给出了按字节对原始数据进行编码的过程（生成多项式为<span class="math inline">\(x^8 + x^4 + x^3 + x^2 + 1\)</span>）。 对于任意 1 字节来说，在 $GF(2^8) $内有256种可能的值，所以没有元素对应的乘法表大小为 256 字节。每次查表可以进行一个字节数据的乘法运算，效率很低，所以务必需要SIMD加速。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326202757.png" srcset="/img/loading.gif" lazyload="" style="zoom: 25%;"></p>
<p>目前主流的支持 SIMD 相关指令的寄存器有 128bit（XMM 指令)、256bit (YMM 指令)这两种容量，这意味着对于64位的机器来说，分别提供了2到4倍的处理能力，我们可以考虑采用 SIMD 指令并行地为更多数据进行乘法运算。</p>
<blockquote>
<p>详细的底层优化部分可看 <a href="https://www.cnblogs.com/qiniu/p/6898547.html" target="_blank" rel="noopener">实现高性能纠删码引擎 | 纠删码技术详解（下）</a></p>
</blockquote>
<h3 id="工程优化">3.2 工程优化</h3>
<h4 id="改进的编码方式">3.2.1 改进的编码方式</h4>
<p>上面有提到，全文默认介绍的是Reed-Solomon码，因为在业界普遍用的都是RS码。常见的还有<strong>XOR码</strong>，仅通过异或运算来实现，因为几乎不用所以略过。</p>
<p>普通的RS编码存在一些问题：以下图为例，假设X1～X6 ，Y1～Y6为数据块，P1和P2为校验块，若其中任意一块丢失，需要读其余12个块才能修复数据，磁盘IO损耗大，数据修复所需带宽高，在多AZ部署时，问题尤为明显。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326202007.png" srcset="/img/loading.gif" lazyload="" style="zoom: 50%;"></p>
<p>微软提出的<strong>LRC编码</strong>，通过引入局部校验块来解决该问题，如图所示，在原来全局校验块P1和P2的基础上，新增2个局部校验块PX和PY，假设X1损坏，只需读取与其关联X1～X6共6个块即可修复数据。</p>
<p>统计表明，在数据中心，一个<strong>条带</strong>在一定时间内单块盘故障的概率是98%，2个盘同时损坏的概率是1%，因此LRC在大多数场景可大幅提升数据修复效率，但缺点是其非最大距离可分编码，无法做到像全局RS编码那样损失任意m份数据能把所有的丢修复回来。所以如果用这种编码，每个条件增加1个局部校验块即可保证大概98%的修复场景能够快速恢复。用局部这种办法相对来说会略增大存储，但是恢复效率会高很多而且恢复时对计算资源的消耗也会下降很多。</p>
<h4 id="连续存储-条带存储">3.2.2 连续存储 &amp; 条带存储</h4>
<p>上面提到了<strong>条带</strong>这一概念，这个又涉及到了EC存储里的存储方式了。</p>
<blockquote>
<p>条纹单元(条带)：官方称之为Stripe Unit，我把它隐喻为斑马身上的黑白条纹，就称每个文件经过EC处理后的就是一个个的条纹单元。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327053941.png" srcset="/img/loading.gif" lazyload="" style="zoom:50%;"></p>
<p>上图看着太抽象,来看看<strong>连续存储</strong>与<strong>条带存储</strong>的区别:</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327080403.png" srcset="/img/loading.gif" lazyload="" alt="3副本存储示意图" style="zoom:50%;"></p>
<p>上图是连续存储(连续布局),HDFS的三副本以及Hadoop 3.0之前的EC存储就是这种存储方法.</p>
<p><strong>条形布局</strong>(条带存储)</p>
<p>再来看看下图的条带存储(条带布局,条形存储,条形布局)，这张图实际上跟上面的黑白条形图是相同的</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327080512.png" srcset="/img/loading.gif" lazyload="" alt="EC 存储示意图"><figcaption aria-hidden="true">EC 存储示意图</figcaption>
</figure>
<p>条（stripe）是由若干个相同大小的单元（cell）构成的序列。文件数据被依次写入条的各个单元中，当一个条写满之后再写入下一个条，一个条的不同单元位于不同的数据块中。这种分布方式称为条形布局。</p>
<p>但用这种方式存储,会让hdfs概念中的一个数据块切分到不同节点上,之后执行时需要从不同节点上读取导致增大网络开销.</p>
<p><code>离线EC &amp; 在线EC</code></p>
<p>有时候连续存储 &amp; 条带存储也被以离线EC&amp;在线EC来表述</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220326202446.png" srcset="/img/loading.gif" lazyload="" style="zoom: 67%;"></p>
<p><strong>离线EC</strong></p>
<ul>
<li>整个条带k个数据单元都写满后，整体计算生成m校验块</li>
<li>数据先以副本的方式写入存储,攒满了再做EC然后删除副本</li>
</ul>
<p><strong>在线EC</strong></p>
<ul>
<li>收到数据后同步拆分并实时计算校验块后，同时写入k个数据块和m个校验块</li>
<li>数据以EC的方式写入</li>
</ul>
<p>一般来说尽可能用在线EC的方式，主要是比较快，但实现起来会麻烦点</p>
<h2 id="简单demo实现">4. 简单demo实现</h2>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20220327054646.png" srcset="/img/loading.gif" lazyload="" style="zoom: 50%;"></p>
<p>原本计划实现上述的架构作为一个简单的项目，但是因为某些原因只实现了python版本的API，而且DataFrame还是直接调用RDD的。。</p>
<p><strong>list格式数据的EC存储demo</strong></p>
<p>这里以list格式的数据作为例子，来看看怎么对一个list类型的数据做EC存储吧</p>
<p>首先最核心的<code>reedsolomon</code>函数，该函数的功能是计算得到校验块</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">'''</span><br><span class="hljs-string">生成校验块</span><br><span class="hljs-string">输入:</span><br><span class="hljs-string">    data:   输入数据</span><br><span class="hljs-string">    m:      校验块个数</span><br><span class="hljs-string">    generator_matrix_case: 生成矩阵方式(默认柯西矩阵)</span><br><span class="hljs-string">输出:</span><br><span class="hljs-string">    check_block: 校验块</span><br><span class="hljs-string">'''</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reedsolomon</span><span class="hljs-params">(data,m,generator_matrix_case = <span class="hljs-string">'cauchy'</span>,)</span>:</span><br><br>    k = len(data)<br>    <br>    <span class="hljs-comment"># 产生生成矩阵</span><br>    generator_matrix = np.mat(generator(k,m))   <span class="hljs-comment">#生成矩阵（matrix格式）</span><br><br>    check_block = generator_matrix.dot(data).tolist()[<span class="hljs-number">0</span>]  <span class="hljs-comment">#生成矩阵与数据块矩阵相乘</span><br>    check_block = check_block[-m:]	<span class="hljs-comment">#获取列表的最后m个数据（前面的数据是数据块）</span><br>    <span class="hljs-keyword">return</span> check_block[-m:]<br></code></pre></div></td></tr></tbody></table></figure>
<p>再来看看生成矩阵的代码：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">'''</span><br><span class="hljs-string">范德蒙德矩阵</span><br><span class="hljs-string">'''</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vander_matrix</span><span class="hljs-params">(k,m)</span>:</span><br>    data = np.arange(<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-keyword">return</span> np.vander(data,m).transpose()<br><br><span class="hljs-string">'''</span><br><span class="hljs-string">柯西矩阵（有点问题，仅供参考）</span><br><span class="hljs-string">'''</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cauchy_matrix</span><span class="hljs-params">(data)</span>:</span><br><br>    k = len(data)<br>    x = np.arange(<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>    y = np.arange(<span class="hljs-number">0</span>,k,<span class="hljs-number">1</span>)<br>	C = <span class="hljs-number">1.0</span> / (x.reshape((<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)) - y)<br>    <br>    <span class="hljs-keyword">return</span> C<br><br><span class="hljs-string">'''</span><br><span class="hljs-string">创建生成矩阵</span><br><span class="hljs-string">输入:</span><br><span class="hljs-string">    k:      数据个数</span><br><span class="hljs-string">    m:      校验块个数</span><br><span class="hljs-string">输出:</span><br><span class="hljs-string">    generator_matrix: 生成矩阵（枚举：'cauchy','vander'）</span><br><span class="hljs-string">'''</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generator</span><span class="hljs-params">(k,m,generator_method)</span>:</span><br>    <span class="hljs-keyword">if</span> generator_method == <span class="hljs-string">'cauchy'</span>:<br>        A = cauchy_matrix(data,m)   <span class="hljs-comment">#柯西矩阵(未实现)</span><br>    <span class="hljs-keyword">elif</span> generator_method == <span class="hljs-string">'vander'</span>:<br>        A = vander_matrix(k,m)      <span class="hljs-comment">#范德蒙德矩阵</span><br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">"error"</span>)<br><br>    generator_matrix = np.concatenate((np.mat(np.identity(k)), A), axis=<span class="hljs-number">0</span>)  <span class="hljs-comment"># matrix格式</span><br><br>    <span class="hljs-keyword">return</span> generator_matrix<br></code></pre></div></td></tr></tbody></table></figure>
<p>经过上面的一堆操作，校验块算是实现了，那么接下来是实现数据恢复的功能，这里保留缺失数据的位置并且用<code>None</code>代替，例如<code>[1, 0, 0, 8, 6]</code>缺失前两个数据后变成<code>[None, None, 0, 8, 6]</code>。</p>
<p>恢复数据的核心代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">'''</span><br><span class="hljs-string">恢复数据</span><br><span class="hljs-string">输入:</span><br><span class="hljs-string">    loss_data: 数据块(可有缺失)</span><br><span class="hljs-string">    check_block: 校验块(可有缺失)</span><br><span class="hljs-string">    generator_matrix_case: 生成矩阵采用的方法(缺省值),默认是 'cauchy'</span><br><span class="hljs-string">    arraytype:  数组计算类型(缺省值),默认是 'int'（python浮点数计算可能结果错误）</span><br><span class="hljs-string">    </span><br><span class="hljs-string">调用例子:</span><br><span class="hljs-string">	data = verify(loss_data,check_block)</span><br><span class="hljs-string">'''</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">verify</span><span class="hljs-params">(loss_data,check_block,generator_matrix_case = <span class="hljs-string">'cauchy'</span>,arraytype = <span class="hljs-string">'int'</span>)</span>:</span><br><br>    k = len(loss_data)<br>    m = len(check_block)<br><br>    <span class="hljs-comment"># 生成矩阵</span><br>    generator_matrix = generator(k,m)<br><br>    <span class="hljs-comment"># 将数据块与校验块拼接 </span><br>    check_data = loss_data + check_block<br>    <br>    <span class="hljs-comment"># 获取缺失数据的索引（None所在行数）</span><br>    loss_idx = np.where(np.array(check_data) == <span class="hljs-literal">None</span>)[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-string">'''</span><br><span class="hljs-string">    奇怪的操作出现了(指下面三行代码)</span><br><span class="hljs-string">    '''</span><br>    <span class="hljs-comment"># 如果None不够就删掉一些好让后续生成矩阵是方阵求逆</span><br>    check_data,loss_idx = none_enough(check_data,loss_idx,m)<br>          <br>    <span class="hljs-comment"># 删除生成矩阵(generator_matrix) 中对应缺失数据的行 </span><br>    generator_matrix = np.delete(generator_matrix,loss_idx, axis = <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 删除数据中值为None的数据</span><br>    check_data = np.delete(check_data,loss_idx, axis = <span class="hljs-number">0</span>)<br><br>    <span class="hljs-string">'''</span><br><span class="hljs-string">    数据类型转换</span><br><span class="hljs-string">    '''</span><br>    <span class="hljs-keyword">if</span> arraytype == <span class="hljs-string">'int'</span>:<br>        generator_matrix = generator_matrix.astype(int)<br>        check_data = check_data.astype(int)<br>        recover_data = np.linalg.inv(generator_matrix).dot(check_data).astype(int)<br>    <span class="hljs-keyword">else</span>:<br>        recover_data = np.linalg.inv(generator_matrix).dot(check_data)<br><br>    <span class="hljs-keyword">return</span> recover_data<br></code></pre></div></td></tr></tbody></table></figure>
<p>之前说了因为EC存储的一些限制，工程实现上可能会做一些奇怪的操作（也有限于数学水平和工程能力的原因），因为需要将矩阵相乘时需要将矩阵大小对齐以及求逆，所以需要对数据块缺失个数<span class="math inline">\(+\)</span>校验块缺失个数<span class="math inline">\(&lt;m\)</span>（<span class="math inline">\(m\)</span>为校验块个数）的数据做一些删除操作，让它们总共缺失<span class="math inline">\(m\)</span>个数据，也就是上面生成校验块的原理中提到的矩阵中删除<span class="math inline">\(m\)</span>行（这时候是不是觉得改进后有局部校验块的LRC编码确实挺好...）。顺便放一下代码：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">'''</span><br><span class="hljs-string">作用：对小于m个None的list,将其部分元素改成None保证刚好m个None</span><br><span class="hljs-string"></span><br><span class="hljs-string">输入:</span><br><span class="hljs-string">    check_data: 包含校验块的缺失数据</span><br><span class="hljs-string">    loss_idx:   缺失数据的索引</span><br><span class="hljs-string">    m:          校验块个数</span><br><span class="hljs-string">输出:</span><br><span class="hljs-string">    check_data: 相比输入更多缺失的数据（缺失个数为m）</span><br><span class="hljs-string">    loss_idx:   输出check_data缺失数据的索引</span><br><span class="hljs-string">'''</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">none_enough</span><span class="hljs-params">(check_data,loss_idx,m)</span>:</span><br>    loss_idx = loss_idx.tolist()<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> len(loss_idx) &lt; m:<br>        check_data[i] = <span class="hljs-literal">None</span><br>        loss_idx = np.where(np.array(check_data) == <span class="hljs-literal">None</span>)[<span class="hljs-number">0</span>]<br>        i = i + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> check_data,loss_idx<br></code></pre></div></td></tr></tbody></table></figure>
<p>对list类型的数据EC生成校验块并恢复的主要程序如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>m = <span class="hljs-number">3</span>                       <span class="hljs-comment">#生成校验块个数</span><br>generator_matrix = <span class="hljs-string">'vander'</span> <span class="hljs-comment">#生成矩阵选择范德蒙德矩阵</span><br><br>data = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>]<br><span class="hljs-comment"># data = np.arange(1,6,1)</span><br>k = len(data)<br><br>check_block = reedsolomon(data,m,generator_matrix)<br><br><span class="hljs-comment"># test</span><br>data[<span class="hljs-number">0</span>] = <span class="hljs-literal">None</span>          <span class="hljs-comment"># 缺失数据（缺失个数小于等于m）</span><br>data[<span class="hljs-number">1</span>] = <span class="hljs-literal">None</span><br>data[<span class="hljs-number">2</span>] = <span class="hljs-literal">None</span><br>print(data)<br><span class="hljs-comment"># check_block[1] = None	 #校验块缺失数据也可以</span><br><br><span class="hljs-comment"># 恢复数据</span><br>recover_data = verify(data,check_block,generator_matrix)<br>print(recover_data)<br></code></pre></div></td></tr></tbody></table></figure>
<p>至今最简单的demo就完成了，在这个demo里数学原理上不涉及稀疏矩阵计算也不涉及超大矩阵运算，更不涉及底层的SIMD指令集加速；在工程实现也不涉及定时监控，离线EC、在线EC等方式 ~ 写个demo简简单单.</p>
<p>那完成单机版demo后可是试试适用分布式的操作，鉴于技术水平借助一下spark框架(pyspark)来实现.</p>
<p><strong>RDD格式数据的EC存储demo</strong></p>
<p>因为spark需要创建应用,之后的所有数据操作几乎都要用这个来,所以先看运行的主程序,代码如下:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> ecstorage.rdd <span class="hljs-keyword">as</span> ec<br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> SparkContext<br><span class="hljs-keyword">from</span> pyspark.mllib.linalg.distributed <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyspark.sql <span class="hljs-keyword">import</span> SparkSession<br><span class="hljs-keyword">from</span> ecstorage.mathematics.matrix_optimization <span class="hljs-keyword">import</span> sparse<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">"PYSPARK_PYTHON"</span>]=<span class="hljs-string">"/Users/caiwei/opt/anaconda3/bin/python"</span><br>os.environ[<span class="hljs-string">"PYSPARK_DRIVER_PYTHON"</span>]=<span class="hljs-string">"/Users/caiwei/opt/anaconda3/bin/python"</span><br><br>m = <span class="hljs-number">3</span>                       <span class="hljs-comment">#生成校验块个数</span><br>generator_matrix = <span class="hljs-string">'vander'</span> <span class="hljs-comment">#生成矩阵选择范德蒙德矩阵</span><br><br>sc = SparkContext()<br><span class="hljs-comment"># sc.setLogLevel("WARN")</span><br>spark = SparkSession(sc)<br>data = np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>)<br>data = sc.parallelize(data) <span class="hljs-comment">#rdd格式数据</span><br><br><span class="hljs-comment"># 生成校验块</span><br>check_block = ec.reedsolomon(sc,data,m,generator_matrix)<br><br><span class="hljs-comment"># 测试</span><br>data = list(np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>))   <span class="hljs-comment">#换成list格式方便填补None值</span><br>data[<span class="hljs-number">0</span>] = <span class="hljs-literal">None</span>          		<span class="hljs-comment"># 缺失数据（缺失个数小于等于m）</span><br>data[<span class="hljs-number">1</span>] = <span class="hljs-literal">None</span><br><span class="hljs-comment"># data[2] = None</span><br>check_block = check_block.collect()<br>check_block[<span class="hljs-number">0</span>] = <span class="hljs-literal">None</span><br>check_block = sc.parallelize(check_block)<br>data = sc.parallelize(data)<br><br><span class="hljs-comment"># 恢复数据</span><br>recover_data = ec.verify(sc,data,check_block,generator_matrix)  <br>print(recover_data.collect())<br></code></pre></div></td></tr></tbody></table></figure>
<p>生成校验块的核心函数还是叫<code>reedsolomon</code>,代码如下:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">'''</span><br><span class="hljs-string">生成校验块</span><br><span class="hljs-string">输入:</span><br><span class="hljs-string">    sc:     SparkContext</span><br><span class="hljs-string">    data:   输入数据 (rdd格式数据)</span><br><span class="hljs-string">    m:      校验块个数 (python int型数据)</span><br><span class="hljs-string">输出:</span><br><span class="hljs-string">    generator_matrix: 生成矩阵</span><br><span class="hljs-string">    generator_matrix.dot(data): 数据块+校验块</span><br><span class="hljs-string">'''</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reedsolomon</span><span class="hljs-params">(sc,data,m,generator_matrix_case = <span class="hljs-string">'cauchy'</span>)</span>:</span><br>    data = sc.parallelize( sparse(np.array(data.collect() ))  )<br>    <br>    k = data.count()<br><br>    <span class="hljs-comment"># 产生生成矩阵</span><br>    generator_matrix = np.array(generator(k,m))<br><br>    generator_matrix = sc.parallelize(sparse(generator_matrix))     <span class="hljs-comment">#将稠密矩阵转换为稀疏矩阵并创建RDD</span><br><br>    data = CoordinateMatrix(data).toBlockMatrix()<br>    generator_matrix = CoordinateMatrix(generator_matrix).toBlockMatrix()<br>    check_block = generator_matrix.multiply(data).toCoordinateMatrix().entries.collect()    <span class="hljs-comment"># MatrixEntry格式</span><br>    <br>    <span class="hljs-comment"># 格式转换</span><br>    check_block = sc.parallelize(check_block[-m:])<br>    check_block = MatrixEntrytoArray(check_block)   <span class="hljs-comment"># 元素全为MatrixEntry的RDD 转 list</span><br>    check_block = sc.parallelize(dense(np.array(check_block)).tolist())   <span class="hljs-comment">#稀疏矩阵格式 转 稠密矩阵格式</span><br>    <br>    <span class="hljs-keyword">return</span> check_block<br></code></pre></div></td></tr></tbody></table></figure>
<p>整体来说跟<code>list</code>格式类型的EC还是差不多，只是数据处理上不太一样了。先来看看第一行<code>data = sc.parallelize( sparse(np.array(data.collect() ))  )</code>，其中<code>sparse</code>是一个自定义的将稠密矩阵转换为稀疏矩阵的函数，然后通过<code>parallelize</code>创建spark数据集.</p>
<p><code>generator_matrix.multiply(data).toCoordinateMatrix().entries.collect()</code>是将生成矩阵与缺失数据的数据块和校验块拼接的矩阵相乘,这里可以实现下超大矩阵的优化用来代替spark原生的矩阵乘法.</p>
<p>这个函数里后面的数据格式转换部分的代码不应该这样实现(虽然能用),因为直接<code>collect()</code>会占用很大的内存,而且转换成list之后不再是分布式数据集(rdd不好操作,这里我就直接转成list操作了,只是个示例,切勿模仿).</p>
<p>恢复数据的代码也是类似,这里就不放了.</p>
<p><strong>demo完整源码</strong></p>
<p>源码放在这了→_→<a href="https://pypi.org/project/ec-storage/" target="_blank" rel="noopener">ec-storage</a></p>
<p>（PS：1.0.0版本的代码里没实现柯西矩阵作为生成矩阵以及伽罗华域优化）</p>
<h2 id="知名开源库">5. 知名开源库</h2>
<p>上面纯属只当入门阅读参考，实际上用于生产环境的比较多用以下知名的开源库（当然也可以全自己造）：</p>
<ul>
<li><p><a href="https://github.com/intel/isa-l" target="_blank" rel="noopener">Intel 出品的 ISA-L</a></p>
<p>汇编写的，生成矩阵就是本文中提到拼接单位矩阵的方式，支持柯西矩阵作为生成矩阵，支持的指令集扩展丰富，下至 SSE，上到 AVX512，平台适应性最强。</p></li>
<li><p><a href="http://jerasure.org/" target="_blank" rel="noopener">J.S.Plank 教授领导的 Jerasure</a></p>
<p>C语言写的，支持 <span class="math inline">\(GF(2^4)\)</span> - <span class="math inline">\(GF(2^{128})\)</span> 之间的有限域运算</p></li>
<li><p><a href="https://github.com/klauspost/reedsolomon" target="_blank" rel="noopener">klauspost 的个人项目</a></p>
<p>golang语言写的，借助go的特性实现了SIMD加速，语法简单，可作为入门阅读参考</p>
<p>其对于较大的数据块，编码速度会有巨大的下滑，而且复速度明显慢于编码速度</p></li>
</ul>
<blockquote>
<p>上面的demo本来想继续做的，但是很遗憾python因为有GIL锁的原因，计算密集型任务开启多线程未必会加速，所以在线EC的方法难以实现，而且本文在理论阐述和工程实现上有挺多纰漏，最后就在此画上句号吧。</p>
<p>希望下一篇能写一下<strong>极限存储</strong>o(<em>￣▽￣</em>)ブ</p>
</blockquote>
<h2 id="ref">Ref</h2>
<p><a href="https://blog.csdn.net/weixin_31059129/article/details/79794928" target="_blank" rel="noopener">EC存储原理初探</a></p>
<p><a href="https://www.cnblogs.com/qiniu/p/6703629.html" target="_blank" rel="noopener">如何选择纠删码编码引擎 | 纠删码技术详解（上）</a></p>
<p><a href="https://www.cnblogs.com/qiniu/p/6898547.html" target="_blank" rel="noopener">实现高性能纠删码引擎 | 纠删码技术详解（下）</a></p>
<p><a href="https://www.cnblogs.com/zhenlingcn/p/10366644.html" target="_blank" rel="noopener">RS（纠删码）技术浅析及Python实现</a></p>
<p><a href="http://hejunhao.me/archives/1503" target="_blank" rel="noopener">Spark 大规模稀疏矩阵乘法</a></p>
<p><a href="https://blog.csdn.net/m0_37870649/article/details/104302318" target="_blank" rel="noopener">spark实现大矩阵运算</a></p>
<p><a href="https://blog.csdn.net/u010376788/article/details/49764805" target="_blank" rel="noopener">基于Spark实现的超大矩阵运算</a></p>
<p><a href="https://blog.csdn.net/sinat_22510827/article/details/108291786?utm_medium=distribute.wap_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-108291786.wap_agg_so&amp;utm_term=ec%E5%AD%98%E5%82%A8hadoop" target="_blank" rel="noopener">Hadoop EC的一个实现</a></p>
<p><a href="https://mp.weixin.qq.com/s/AW0MmiBxTlkweJFaluu4vQ" target="_blank" rel="noopener">HDFS EC在滴滴的实践</a></p>
<p><a href="https://mp.weixin.qq.com/s/q5oOdjE59A_7Oetq5hL8zw" target="_blank" rel="noopener">OPPO数据湖统一存储技术实践</a></p>
<p><a href="https://www.zhihu.com/question/22072020" target="_blank" rel="noopener">有人能解释一下伽罗瓦域和GF(2^8)吗？</a></p>
<p><a href="https://www.cnblogs.com/mr-bigdata/p/14407008.html" target="_blank" rel="noopener">Hadoop 3.0 EC技术</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%98%E5%82%A8/">存储</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/04/05/shu_ju_zhi_li_zhi_xiang_si_mo_xing/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据治理之相似模型</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/20/java_he_xin_ji_zhu_juan_i_yue_du_bi_ji/">
                        <span class="hidden-mobile">《Java核心技术 卷I》阅读笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     
  </div>
  

  

  



  
    <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
    <script>
      if (window.mermaid) {
        mermaid.initialize({theme: 'forest'});
      }
    </script>
  


</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const mathjax = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
