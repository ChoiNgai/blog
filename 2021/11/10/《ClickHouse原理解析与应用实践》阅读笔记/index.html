

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#3cbdfe">
  <meta name="description" content="ClickHouse好秀啊">
  <meta name="author" content="CAIWEI">
  <meta name="keywords" content="">
  <meta name="description" content="ClickHouse好秀啊">
<meta property="og:type" content="article">
<meta property="og:title" content="《ClickHouse原理解析与应用实践》阅读笔记">
<meta property="og:url" content="http://example.com/2021/11/10/%E3%80%8AClickHouse%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="CAIWEI的博客">
<meta property="og:description" content="ClickHouse好秀啊">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109165101.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109214943.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215057.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215201.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215215.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215238.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110102012.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104346.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104410.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104432.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104609.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110330.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110112518.png">
<meta property="article:published_time" content="2021-11-10T03:20:33.000Z">
<meta property="article:modified_time" content="2021-11-24T08:12:09.988Z">
<meta property="article:author" content="CAIWEI">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109165101.png">
  
  <title>《ClickHouse原理解析与应用实践》阅读笔记 - CAIWEI的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="CAIWEI的博客" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong> </strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/0.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="《ClickHouse原理解析与应用实践》阅读笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-10 11:20" pubdate>
        2021年11月10日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      37 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《ClickHouse原理解析与应用实践》阅读笔记</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：39 分钟前
                
              </p>
            
            <div class="markdown-body">
              <p>ClickHouse好秀啊</p>
<a id="more"></a>

<h2 id="第2章-ClickHouse架构概述"><a href="#第2章-ClickHouse架构概述" class="headerlink" title="第2章 ClickHouse架构概述"></a>第2章 ClickHouse架构概述</h2><h3 id="2-1-ClickHouse的核心特性"><a href="#2-1-ClickHouse的核心特性" class="headerlink" title="2.1 ClickHouse的核心特性"></a>2.1 ClickHouse的核心特性</h3><h4 id="2-1-2-列式存储与数据压缩"><a href="#2-1-2-列式存储与数据压缩" class="headerlink" title="2.1.2 列式存储与数据压缩"></a>2.1.2 列式存储与数据压缩</h4><p>行式存储：逐行扫描</p>
<p>列式存储：逐列扫描</p>
<h4 id="2-1-3-向量化执行引擎"><a href="#2-1-3-向量化执行引擎" class="headerlink" title="2.1.3 向量化执行引擎"></a>2.1.3 向量化执行引擎</h4><p>向量化执行引擎：一项消除程序循环的优化<br>（原理上类似增加空间复杂度减少时间复杂度）</p>
<p>通过CPU的SIMD指令（Single Instruction Multiple Data,SIMD）即用单条指令操作多条数据，从而通过数据并行以提高性能，它的原理是在CPU寄存器层面实现数据的并行操作。</p>
<blockquote>
<p>ClickHouse目前用SSE4.2指令集实现向量化执行</p>
</blockquote>
<h4 id="2-1-4-关系模型与SQL查询"><a href="#2-1-4-关系模型与SQL查询" class="headerlink" title="2.1.4 关系模型与SQL查询"></a>2.1.4 关系模型与SQL查询</h4><p>相比HBase和Redis这类NoSQL数据库，ClickHouse使用关系模型描述并提供了传统数据库的概念（数据库、表、视图、函数等）。此外ClickHouse完全使用SQL作为查询语言。</p>
<h4 id="2-1-5-表引擎"><a href="#2-1-5-表引擎" class="headerlink" title="2.1.5 表引擎"></a>2.1.5 表引擎</h4><p>ClickHouse共拥有合并树、内存、文件、接口和其他等6大类20多种的表引擎。</p>
<h4 id="2-1-7-多主架构"><a href="#2-1-7-多主架构" class="headerlink" title="2.1.7 多主架构"></a>2.1.7 多主架构</h4><p>不同于HDFS、Spark、ElasticSearch这类采用主从架构（Master-Slave）的分布式系统，ClickHouse采用多主架构（Multi-Master）。</p>
<h4 id="2-1-8-在线查询"><a href="#2-1-8-在线查询" class="headerlink" title="2.1.8 在线查询"></a>2.1.8 在线查询</h4><p>在线查询（好像就是即席查询，指用户临时写的查询语句并且需要立刻得到返回结果）</p>
<p>ClickHouse在在线查询方面很快（相比Hive、Spark SQL），而且开源（Vertica性能很好，但是价格很高）</p>
<h4 id="2-1-9-数据分片与分布式查询"><a href="#2-1-9-数据分片与分布式查询" class="headerlink" title="2.1.9 数据分片与分布式查询"></a>2.1.9 数据分片与分布式查询</h4><ul>
<li><p>数据分片</p>
<p>分片是一种大数据处理下的分治思想，ClickHouse支持数据分片。</p>
<p>一个集群由1到多个分片组成，每个分片对应ClickHouse的1个服务节点（故数据分片数量取决于ClickHouse服务节点数）</p>
</li>
</ul>
<ul>
<li><p>分布式查询</p>
<p>ClickHouse提供本地表（Local Tabel）和分布式表（Distributed Table）。</p>
<p>本地表等同于一份数据分片</p>
<p>分布式表不存储数据，它是本地表的代理访问，类似分库中间件，能够代理访问多个数据分片，从而实现分布式查询。ClickHouse</p>
</li>
</ul>
<h3 id="2-2-ClickHouse的架构设计"><a href="#2-2-ClickHouse的架构设计" class="headerlink" title="2.2 ClickHouse的架构设计"></a>2.2 ClickHouse的架构设计</h3><h4 id="2-2-1-Column和Field"><a href="#2-2-1-Column和Field" class="headerlink" title="2.2.1 Column和Field"></a>2.2.1 Column和Field</h4><p>ClickHouse按列存储数据，内存中一列数据由一个Column对象表示；Column采用泛化的设计模式。</p>
<p>ClickHouse都会以整列的方式操作数据，除非需要操作具体单个的数值（也就是单列中的一行数据），则需要使用Field对象，Field对象代表一个单值；Field采用聚合的设计模式，内部聚合了Null、UInt64、String、Array等13种数据类型及相应的处理逻辑。</p>
<h4 id="2-2-2-DataType"><a href="#2-2-2-DataType" class="headerlink" title="2.2.2 DataType"></a>2.2.2 DataType</h4><p>ClickHouse数据的序列化和反序列化工作由DataType负责。IDataType采用泛华的设计模式，支持二进制、文本、json、xml、csv、protobuf等多种格式。</p>
<h4 id="2-2-3-Block和Block流"><a href="#2-2-3-Block和Block流" class="headerlink" title="2.2.3 Block和Block流"></a>2.2.3 Block和Block流</h4><p>Column和Filed组成了数据的基本映射单元，但对应实际操作中缺少了必要补充信息，所以ClickHouse设计了Block。</p>
<p>Block对象本质是由数据对象、数据类型和列名称组成的三元组，即（Column，DataType，列名称字符串）。</p>
<p>Column提供数据读取能力，DataType负责正反序列化，所以Block在这些对象的基础上实现了进一步的抽象和封装，使得仅通过Block对象就能完成一系列的数据操作（Block并没有直接聚合Column和DataType对象，而是间接引用）。</p>
<p>Block流有两个顶层接口，分别是IBlockInputStream和IBlockOutputStream，每个顶层接口又有很多类方法。</p>
<pre class="mermaid">graph LR
A[Block流] --&gt;B(IBlockInputStream)
    A --&gt; C(IBlockOutputStream)
    B --&gt; D(DDL操作)
    B --&gt; E(关系运算)
    B --&gt; F(表引擎)
    C --&gt; G(表引擎)</pre>

<h4 id="2-2-4-Table"><a href="#2-2-4-Table" class="headerlink" title="2.2.4 Table"></a>2.2.4 Table</h4><p>数据表的底层设计中并没有所谓的Table对象，它直接使用<code>IStorage接口</code>指代数据表。</p>
<p>IStorage定义了DDL（如ALTER、RENAME、OPTIMIZE、DROP等）、read、write方法，它们分别负责数据的定义、查询、写入。</p>
<p>对Table发起的一次操作通常都会经历这样的过程：接收AST查询语句（抽象语法树，简称AST），根据AST返回指定列的数据，之后再将数据交由Interpreter做进一步处理。</p>
<h4 id="2-2-5-Parser和Interpreter"><a href="#2-2-5-Parser和Interpreter" class="headerlink" title="2.2.5 Parser和Interpreter"></a>2.2.5 Parser和Interpreter</h4><p>Parser负责创建AST对象（将SQL以递归下降的方法发解析成AST语法树）；Interpreter负责解释AST，并进一步创建查询的执行管道（起到串联查询过程的作用，会根据解释器的雷系聚合它所需要的资源）。</p>
<h4 id="2-2-6-Functions和Aggregate-Functions"><a href="#2-2-6-Functions和Aggregate-Functions" class="headerlink" title="2.2.6 Functions和Aggregate Functions"></a>2.2.6 Functions和Aggregate Functions</h4><p>ClickHouse主要提供两类函数：普通函数（无状态）和聚合函数（有状态）。</p>
<p>普通函数由IFunctions定义，聚合函数由IAggregateFunctions接口定义，并支持序列化和反序列化。</p>
<h4 id="2-2-7-Cluster和Replication"><a href="#2-2-7-Cluster和Replication" class="headerlink" title="2.2.7 Cluster和Replication"></a>2.2.7 Cluster和Replication</h4><p>ClickHouse的集群由分片（Shard）组成，而每个分片又通过副本（Replica）组成，其具有以下特性：</p>
<ol>
<li>ClickHouse的1个节点只能拥有1个分片</li>
<li>分片只是一个逻辑概念，其物理承载还是由副本承担。</li>
</ol>
<h2 id="第3章-安装与部署（略）"><a href="#第3章-安装与部署（略）" class="headerlink" title="第3章 安装与部署（略）"></a>第3章 安装与部署（略）</h2><h2 id="第4章-数据定义"><a href="#第4章-数据定义" class="headerlink" title="第4章 数据定义"></a>第4章 数据定义</h2><h3 id="4-1-数据类型"><a href="#4-1-数据类型" class="headerlink" title="4.1 数据类型"></a>4.1 数据类型</h3><ul>
<li>基础类型</li>
</ul>
<table>
<thead>
<tr>
<th>基础类型</th>
<th>具体类型</th>
</tr>
</thead>
<tbody><tr>
<td>数值类型</td>
<td>Int、Float、Decimal</td>
</tr>
<tr>
<td>字符串类型</td>
<td>String、FixedString、UUID</td>
</tr>
<tr>
<td>时间类型</td>
<td>DateTime、DateTime64、Date</td>
</tr>
</tbody></table>
<ul>
<li><p>复合类型</p>
<ol>
<li>Array</li>
<li>Tuple</li>
<li>Enum</li>
<li>Nested</li>
</ol>
</li>
<li><p>特殊类型</p>
<ol>
<li>Nullable</li>
<li>Domain</li>
</ol>
</li>
</ul>
<h3 id="4-2-如何定义数据表"><a href="#4-2-如何定义数据表" class="headerlink" title="4.2 如何定义数据表"></a>4.2 如何定义数据表</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> db_name [<span class="hljs-keyword">ENGINE</span> = Oridinary]<br></code></pre></td></tr></tbody></table></figure>

<p>ENGINE处的参数表示数据库所使用的引擎，一共有五种：</p>
<ul>
<li>Oridinary：默认引擎，大部分情况都用这个</li>
<li>Dictionary：字典引擎</li>
<li>Memory：内存引擎</li>
<li>Lazy：日志引擎</li>
<li>MySQL：MySQL引擎</li>
</ul>
<h3 id="4-5-分布式DDL执行"><a href="#4-5-分布式DDL执行" class="headerlink" title="4.5 分布式DDL执行"></a>4.5 分布式DDL执行</h3><p>普通DDL语句转化为分布式DDL语句，只需加上<code>ON CLUSTER cluster_name</code>声明即可，如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t1 <span class="hljs-keyword">ON</span> CLUSTER ch_cluster (<br>	<span class="hljs-keyword">id</span> <span class="hljs-keyword">String</span>,<br>    <span class="hljs-keyword">url</span> <span class="hljs-keyword">String</span>,<br>    EventTime <span class="hljs-built_in">Date</span><br>) <span class="hljs-keyword">ENGINE</span> = MergeTree()<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(EventTime)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">id</span><br></code></pre></td></tr></tbody></table></figure>

<p> 该语句会对ch_cluster集群内所有节点广播这条DDL语句</p>
<h2 id="第5章-数据字典"><a href="#第5章-数据字典" class="headerlink" title="第5章 数据字典"></a>第5章 数据字典</h2><p>数据字典是ClickHouse提供的一种存储介质，它以（键值，属性映射）的形式定义数据。</p>
<p>数据字典被<strong>加载到内存</strong>，支持动态更新，因而数据字典非常适合保存常量或者经常使用的维度表数据，以避免不必要的JOIN查询。</p>
<pre class="mermaid">graph LR
A[数据字典] --&gt;B(内置字典 _ ClickHouse默认自带的字典)
    A --&gt; C(外部扩展字典 _ 用户自定义配置实现的字典)</pre>

<p>字典中的数据只能通过<strong>字典函数</strong>访问（有一种例外情况，就是使用特殊的字典表引擎）</p>
<ul>
<li>7种类型字典的特点总结</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>存储结构</th>
<th>字典键类型</th>
<th>支持的数据来源</th>
</tr>
</thead>
<tbody><tr>
<td>flat</td>
<td>数组</td>
<td>UInt64</td>
<td>Local file、 Executable file、 HTTP、DBMS</td>
</tr>
<tr>
<td>hashed</td>
<td>散列</td>
<td>UInt64</td>
<td>Local file、 Executable file、 HTTP、DBMS</td>
</tr>
<tr>
<td>range_hashed</td>
<td>散列并按时间排序</td>
<td>UInt64和时间</td>
<td>Local file、 Executable file、 HTTP、DBMS</td>
</tr>
<tr>
<td>complex_key_hashed</td>
<td>散列</td>
<td>复合型Key</td>
<td>Local file、 Executable file、 HTTP、DBMS</td>
</tr>
<tr>
<td>ip_trie</td>
<td>层次结构</td>
<td>复合型Key（单个String）</td>
<td>Local file、 Executable file、 HTTP、DBMS</td>
</tr>
<tr>
<td>cache</td>
<td>固定大小数组</td>
<td>UInt64</td>
<td>Executable file、HTTP、 ClickHouse、MySQL</td>
</tr>
<tr>
<td>complex_key_cache</td>
<td>固定大小数组</td>
<td>复合型Key</td>
<td>Executable file、HTTP、 ClickHouse、MySQL</td>
</tr>
</tbody></table>
<h2 id="第6章-MergeTree原理解析"><a href="#第6章-MergeTree原理解析" class="headerlink" title="第6章 MergeTree原理解析"></a>第6章 MergeTree原理解析</h2><p>表引擎是ClickHouse的一大特色，表引擎决定了一张表的特性，比如数据以何种形式被存储以及如何被加载。</p>
<p>合并树（MergeTree）是ClickHouse中最常用的表引擎，因为只有MergeTree系列（MergeTree的变种表引擎有很多）的表引擎才支持<strong>主键索引</strong>、<strong>数据分区</strong>、<strong>数据副本</strong>、<strong>数据采样</strong>这些特性，同时也只有此系列表引擎支持ALTER相关操作。</p>
<h3 id="6-1-MergeTree的创建方式与存储结构"><a href="#6-1-MergeTree的创建方式与存储结构" class="headerlink" title="6.1 MergeTree的创建方式与存储结构"></a>6.1 MergeTree的创建方式与存储结构</h3><ul>
<li><p>MergeTree创建方式</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [<span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [db_name.]table_name (<br>	name1 [<span class="hljs-keyword">type</span>] [<span class="hljs-keyword">DEFAULT</span>|<span class="hljs-keyword">MATERIALIZED</span>|<span class="hljs-keyword">ALIAS</span> expr],<br>    name2 [<span class="hljs-keyword">type</span>] [<span class="hljs-keyword">DEFAULT</span>|<span class="hljs-keyword">MATERIALIZED</span>|<span class="hljs-keyword">ALIAS</span> expr],<br>    <span class="hljs-comment">--省略 ...</span><br>) <span class="hljs-keyword">ENGINE</span> = MergeTree()	  <span class="hljs-comment">--选择合并树表引擎</span><br>[<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> expr]		<span class="hljs-comment">--选填，分区键	</span><br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> expr]			<span class="hljs-comment">--必填，排序键</span><br>[PRIMARY <span class="hljs-keyword">KEY</span> expr]		<span class="hljs-comment">--选题，主键</span><br>[<span class="hljs-keyword">SAMPLE</span> <span class="hljs-keyword">BY</span> expr]		<span class="hljs-comment">--选题，抽样表达式</span><br>[<span class="hljs-keyword">SETTINGS</span> <span class="hljs-keyword">name</span> = <span class="hljs-keyword">value</span>,省略...]	<span class="hljs-comment">--index_granularity[选填]，索引粒度，默认8192（每隔8192行生成一条索引）;index_granularity[选填]，每一批写书数据的体量大小，默认10M；enable_mixed_granularity_parts[选填]，设置是否开启自适应索引间隔，默认开启；merge_mixed_with_ttl_timeout[选填]；storage_policy[选填]</span><br></code></pre></td></tr></tbody></table></figure>



</li>
</ul>
<ul>
<li><p>MergeTree存储结构</p>
<blockquote>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">table_name<br>│<br>├─partition_1	<span class="hljs-comment">-- 分区目录</span><br>│    ├─ checksums.txt	<span class="hljs-comment">-- 检验文件，二进制格式存储</span><br>│    ├─ colums.txt		<span class="hljs-comment">-- 列文件，明文格式存储，保存该分区下的字段信息</span><br>│    ├─ count.txt		<span class="hljs-comment">-- 计数文件，明文格式存储，记录该分区下数据的总行数</span><br>│    ├─ primary.idx		<span class="hljs-comment">-- 一级索引文件，二进制格式存储，用于存放稀疏索引</span><br>│    ├─ [Column].bin	<span class="hljs-comment">-- 数据文件，压缩格式存储（默认LZ4压缩格式）</span><br>│    ├─ [Column].mrk	<span class="hljs-comment">-- 列字段标记文件，二进制格式存储，保存了.bin文件的数据偏移量</span><br>│    ├─ [Column].mrk2	<span class="hljs-comment">-- 如果使用了适应性大小的间隔索引，作用和原理与.mrk文件相同</span><br>│    ├─ partition.dat	<span class="hljs-comment">-- 使用了分区才会生成，保存当前分区表达式最终生成的值</span><br>│    ├─ minmax_[Column].idx	<span class="hljs-comment">-- 使用了分区才会生成，记录当前分区原始字段最大值和最小值</span><br>│    ├─ skp_idx _[Column].idx	<span class="hljs-comment">-- 使用了二级索引才会生成</span><br>│    ├─ skp_idx _[Column].mrk	<span class="hljs-comment">-- 使用了二级索引才会生成</span><br>│    <br>└─ partition_2<br>│ <br>└─ partition_n<br></code></pre></td></tr></tbody></table></figure>
</blockquote>
</li>
</ul>
<h3 id="6-2-数据分区"><a href="#6-2-数据分区" class="headerlink" title="6.2 数据分区"></a>6.2 数据分区</h3><h4 id="6-2-1-数据的分区规则"><a href="#6-2-1-数据的分区规则" class="headerlink" title="6.2.1 数据的分区规则"></a>6.2.1 数据的分区规则</h4><ul>
<li>ID在不同分区类型下的示例</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>样例数据</th>
<th>分区表达式</th>
<th>分区ID</th>
</tr>
</thead>
<tbody><tr>
<td>整型</td>
<td>18，19，20</td>
<td>PARTITION BY Age</td>
<td>分区1：18；分区2：19；分区3：20</td>
</tr>
<tr>
<td>日期</td>
<td>2021-05-01，2021-05-2</td>
<td>PARTITION BY EventTime</td>
<td>分区1：20210501；分区2：20210502</td>
</tr>
<tr>
<td>其他</td>
<td>‘<a href="http://www.nauu.com’" target="_blank" rel="noopener">www.nauu.com’</a></td>
<td>PARTITION BY URL</td>
<td>分区1：15b31467</td>
</tr>
</tbody></table>
<h4 id="6-2-2-分区目录的命名规则"><a href="#6-2-2-分区目录的命名规则" class="headerlink" title="6.2.2 分区目录的命名规则"></a>6.2.2 分区目录的命名规则</h4><p>分区目录 = 分区ID（PartitionID）+MaxBlockNum+MinBlockNum+Level</p>
<p>例如分区目录是202105_1_1_0</p>
<blockquote>
<p>MaxBlockNum和MinBlockNum是最大数据块编号和最小数据块编号（跟数据压缩的数据压缩块无关）</p>
</blockquote>
<h4 id="6-2-3-分区目录的合并过程"><a href="#6-2-3-分区目录的合并过程" class="headerlink" title="6.2.3 分区目录的合并过程"></a>6.2.3 分区目录的合并过程</h4><p>MinBlockNum：取同一分区内所有目录中最小的MinBlockNum值</p>
<p>MaxBlockNum：取同一分区内所有目录中最小的MaxBlockNum值</p>
<p>Level：取同一分区内最大Level值并加1</p>
<h3 id="6-3-一级索引"><a href="#6-3-一级索引" class="headerlink" title="6.3 一级索引"></a>6.3 一级索引</h3><h4 id="6-3-1-稀疏索引"><a href="#6-3-1-稀疏索引" class="headerlink" title="6.3.1 稀疏索引"></a>6.3.1 稀疏索引</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109165101.png" srcset="/img/loading.gif" lazyload width="50%"> </p>
<h4 id="6-3-2-索引粒度"><a href="#6-3-2-索引粒度" class="headerlink" title="6.3.2 索引粒度"></a>6.3.2 索引粒度</h4><p>ClickHouse中索引粒度默认为8192，数据以index_granularity的粒度（默认8192）被标记成多个小的区间，其中每个区间最多8192行数据。</p>
<h4 id="6-3-3-索引数据的生成规则"><a href="#6-3-3-索引数据的生成规则" class="headerlink" title="6.3.3 索引数据的生成规则"></a>6.3.3 索引数据的生成规则</h4><p>由于是稀疏索引，所以MergeTree需要间隔 index_granularity 行数据才会生成一条索引记录。</p>
<h4 id="6-3-4-索引的查询过程"><a href="#6-3-4-索引的查询过程" class="headerlink" title="6.3.4 索引的查询过程"></a>6.3.4 索引的查询过程</h4><p>根据索引粒度生成多个MarkRange，两个相邻的MarkRange相距步长为1，所有MarkRange（整个数据片段）的最大数值区间为[0,+inf]</p>
<p>索引查询过程分为3个步骤：</p>
<ol>
<li><p>生成查询条件区间。例如：</p>
<p>WHERE ID = ‘A003’ → [‘A003’ , ‘A003’]</p>
<p>WHERE ID &gt; ‘A003’ → [‘A003’ ,  +inf]</p>
</li>
<li><p>递归交集判断：以递归的形式，依次对MarkRange的数值区间与条件区间做交集判断，从最大的区间[0 , +inf]开始：</p>
<ul>
<li>如果不存在交集，则直接通过剪枝算法优化此整段MarkRange</li>
<li>如果存在交集，且MarkRange不可再分解（步长小于8），则记录MarkRange并返回</li>
</ul>
</li>
<li><p>合并MarkRange区间：将最终匹配的MarkRange聚在一起，合并它们的范围。</p>
</li>
</ol>
<h3 id="6-4-二级索引"><a href="#6-4-二级索引" class="headerlink" title="6.4 二级索引"></a>6.4 二级索引</h3><p>二级索引又称为跳数索引，默认关闭，开启命令为：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> allow_experimental_data_skipping_indices = <span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure>

<h3 id="6-5-数据存储"><a href="#6-5-数据存储" class="headerlink" title="6.5 数据存储"></a>6.5 数据存储</h3><h4 id="6-5-1-各列独立存储"><a href="#6-5-1-各列独立存储" class="headerlink" title="6.5.1 各列独立存储"></a>6.5.1 各列独立存储</h4><p>每个字段都有一个对应的.bin文件，这些.bin文件承载着物理存储。</p>
<p>存储的具体实现L：数据经过压缩后按照ORDER BY的声明排序，最后数据以压缩数据块的形式被组织写入.bin文件中</p>
<h4 id="6-5-2-压缩数据块"><a href="#6-5-2-压缩数据块" class="headerlink" title="6.5.2 压缩数据块"></a>6.5.2 压缩数据块</h4><p>JavaEnable.bin</p>
<blockquote>
<blockquote>
<p>压缩数据块0</p>
<p>hear stat(65536, 12000)</p>
</blockquote>
<blockquote>
<p>压缩数据块1</p>
<p>hear stat(65536, 14660)</p>
</blockquote>
<p>…</p>
</blockquote>
<p>MergeTree在数据具体的写入过程中，会按照索引粒度（默认8192行），按批次获取数据并进行处理。如果把一批数据的未压缩大小设为size，则整个写入过程遵循以下规则：</p>
<ol>
<li>单个批次数据 size &lt; 64KB：继续获取下一个批数据，直至累积到 size &gt;= 64 KB，生成下一个压缩数据块</li>
<li>单个批次数据  64 KB &lt;= size &lt;= 1 MB​：直接生成下一个压缩数据块</li>
<li>单个批次数据  size &gt;= 1 MB​：先按照1MB大小截断并生成下一个数据块，剩余数据继续依照上述规则执行。</li>
</ol>
<h3 id="6-6-数据标记"><a href="#6-6-数据标记" class="headerlink" title="6.6 数据标记"></a>6.6 数据标记</h3><p>下面用一个类比来说明数据标记是什么及其作用</p>
<blockquote>
<p>MergeTree表：书</p>
<p>primary.idx（一级索引）：章节目录</p>
<p>.bin（数据文件）：书中的内容</p>
<p>.mrk（数据标记）：章节与内容之间的联系（数据标记记录两个信息：1、页码；2、某段内容起始位置）</p>
</blockquote>
<h3 id="6-7-对于分区、索引、标记和压缩数据的协同总结"><a href="#6-7-对于分区、索引、标记和压缩数据的协同总结" class="headerlink" title="6.7 对于分区、索引、标记和压缩数据的协同总结"></a>6.7 对于分区、索引、标记和压缩数据的协同总结</h3><h4 id="6-7-1-写入过程"><a href="#6-7-1-写入过程" class="headerlink" title="6.7.1 写入过程"></a>6.7.1 写入过程</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109214943.png" srcset="/img/loading.gif" lazyload="" alt=""></p>
<h4 id="6-7-2-查询过程"><a href="#6-7-2-查询过程" class="headerlink" title="6.7.2 查询过程"></a>6.7.2 查询过程</h4><p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215057.png" srcset="/img/loading.gif" lazyload="" alt=""></p>
<h4 id="6-7-3-数据标记与压缩数据块的对应关系"><a href="#6-7-3-数据标记与压缩数据块的对应关系" class="headerlink" title="6.7.3 数据标记与压缩数据块的对应关系"></a>6.7.3 数据标记与压缩数据块的对应关系</h4><ol>
<li><p>多对一</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215201.png" srcset="/img/loading.gif" lazyload="" alt=""></p>
</li>
<li><p>一对一</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215215.png" srcset="/img/loading.gif" lazyload="" alt=""></p>
</li>
<li><p>一对多</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211109215238.png" srcset="/img/loading.gif" lazyload="" alt=""></p>
</li>
</ol>
<h2 id="第9章-数据查询"><a href="#第9章-数据查询" class="headerlink" title="第9章 数据查询"></a>第9章 数据查询</h2><h3 id="9-3-SAMPLE语句"><a href="#9-3-SAMPLE语句" class="headerlink" title="9.3 SAMPLE语句"></a>9.3 SAMPLE语句</h3><p>SAMPLE子句能够实现数据采样的功能，使查询返回采样数而不是全部数据，从而减少查询负载。SAMPLE子句的采样机制是一种<strong>幂等</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="幂等性：指多次操作,结果是一致。 数学表达式为： f(x) = f(f(x))
">[1]</span></a></sup>设计，所以相同的采样规则能返回相同的数据，这项特性适用于那些可以接受近似查询结果的场景。</p>
<p>SAMPLE子句只能用于MergeTree系列引擎的数据表，并且要求在<code>CREATE TABLE</code>时声明<code>SAMPLE BY</code>抽样表达式，例如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> hits_t1 (<br>    <span class="hljs-keyword">ID</span> UInt64,<br>    EventTime <span class="hljs-built_in">DATE</span>,<br>    UserID UInt64<br>) <span class="hljs-keyword">ENGINE</span> = MergeTree()<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(EventTime)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (<span class="hljs-keyword">ID</span>,intHash32(UserID))<br><span class="hljs-comment">-- SAMPLE Key声明的表达式必须也包含在主键的声明中</span><br><span class="hljs-keyword">SAMPLE</span> <span class="hljs-keyword">BY</span> intHash32(UserID)<br></code></pre></td></tr></tbody></table></figure>

<p><code>SAMPLE BY intHash32(UserID)</code>表示该表内的数据，按照<code>intHash32(UserID)</code>分布后的结果采样查询。</p>
<blockquote>
<p>声明 SAMPLE Key的注意事项：</p>
<ol>
<li>SAMPLE BY 所声明的表达式必须同时包含在主键的声明内；</li>
<li>SAMPLE Key 必须是int类型（如果不是，建表时不会报错但会在查询时得到异常）。</li>
</ol>
</blockquote>
<ul>
<li><p>SAMPLE factor</p>
<p>factor范围在[0,1]，当factor是0或1的时候等同于不采样</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ID</span> <span class="hljs-keyword">FROM</span> hits_t1 <span class="hljs-keyword">SAMPLE</span> <span class="hljs-number">0.1</span><br></code></pre></td></tr></tbody></table></figure>

<p>近似取10%的数据</p>
</li>
<li><p>SAMPLE rows</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>() <span class="hljs-keyword">FROM</span> hits_t1 <span class="hljs-keyword">SAMPLE</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></tbody></table></figure>

<p>近似采样10000行的数据</p>
</li>
<li><p>SAMPLE factor OFFSET n</p>
<p>OFFSET 表示偏移量</p>
</li>
</ul>
  <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>() <span class="hljs-keyword">FROM</span> hits_t1 <span class="hljs-keyword">SAMPLE</span> <span class="hljs-number">0.5</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0.4</span><br></code></pre></td></tr></tbody></table></figure>

<p>  从二分之一处按0.4的系数采样（若出现了溢出则自动截断）</p>
<h3 id="9-4-ARRAY-JOIN子句"><a href="#9-4-ARRAY-JOIN子句" class="headerlink" title="9.4 ARRAY JOIN子句"></a>9.4 ARRAY JOIN子句</h3><p>ARRAY JOIN 允许在表的内部，与数组或嵌套类型的字段进行JOIN操作，从而将一行数组展开为多行。（类似Hive里的<code>LATERNAL VIEW EXPLODE</code>函数）</p>
<p>例如在表query_t1中：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[1,2,3]</td>
</tr>
<tr>
<td>2</td>
<td>[3,4]</td>
</tr>
<tr>
<td>3</td>
<td>[ ]</td>
</tr>
</tbody></table>
<h4 id="9-4-1-INNER-ARRAY-JOIN"><a href="#9-4-1-INNER-ARRAY-JOIN" class="headerlink" title="9.4.1 INNER ARRAY JOIN"></a>9.4.1 INNER ARRAY JOIN</h4><ul>
<li>demo</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span> <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span><br></code></pre></td></tr></tbody></table></figure>

<p>得到结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<p>排除掉了空行</p>
<blockquote>
<p>跟Hive的数组行转列很像，Hive中是这样写的：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,v <span class="hljs-keyword">FROM</span> <br>LATERNAL <span class="hljs-keyword">VIEW</span> <span class="hljs-keyword">EXPLODE</span>(<span class="hljs-keyword">value</span>,<span class="hljs-string">','</span>) table_tmp <span class="hljs-keyword">AS</span> v<br></code></pre></td></tr></tbody></table></figure>
</blockquote>
<ul>
<li>添加别名</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span>,v <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> v<br></code></pre></td></tr></tbody></table></figure>



<p>得到结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>value</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[1,2,3]</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>[1,2,3]</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>[1,2,3]</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>[3,4]</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>[3,4]</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="9-4-2-LEFT-ARRAY-JOIN"><a href="#9-4-2-LEFT-ARRAY-JOIN" class="headerlink" title="9.4.2 LEFT ARRAY JOIN"></a>9.4.2 LEFT ARRAY JOIN</h4><ul>
<li><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span>,v <span class="hljs-keyword">FROM</span> query_t1 <span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> v<br></code></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>得到结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>value</th>
<th>v</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[1,2,3]</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>[1,2,3]</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>[1,2,3]</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>[3,4]</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>[3,4]</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>[ ]</td>
<td>0</td>
</tr>
</tbody></table>
<p>改为LEFT查询以后，在INNER JOIN 中被排除的空数组出现了在返回的结果集中。</p>
<blockquote>
<p>当同时对多个数组字段进行ARRAY JOIN 操作时，查询的计算逻辑是按行合并而不是产生笛卡尔积，例如</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">value</span>,v,arrayMap(x -&gt; x * <span class="hljs-number">2</span>,<span class="hljs-keyword">value</span>) <span class="hljs-keyword">AS</span> mapv,v_1 <br><span class="hljs-keyword">FROM</span> query_t1 <br><span class="hljs-built_in">ARRAY</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">AS</span> v,mapv <span class="hljs-keyword">AS</span> v_1<br></code></pre></td></tr></tbody></table></figure>

<p>得到结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>value</th>
<th>v</th>
<th>mapv</th>
<th>v_1</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[1,2,3]</td>
<td>1</td>
<td>[2,4,6]</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>[1,2,3]</td>
<td>2</td>
<td>[2,4,6]</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>[1,2,3]</td>
<td>3</td>
<td>[2,4,6]</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>[3,4]</td>
<td>3</td>
<td>[6,8]</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>[3,4]</td>
<td>4</td>
<td>[6,8]</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td>[ ]</td>
<td>0</td>
<td>[ ]</td>
<td>0</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="9-5-JOIN子句"><a href="#9-5-JOIN子句" class="headerlink" title="9.5 JOIN子句"></a>9.5 JOIN子句</h3><p>ClickHouse的JOIN语法包含<strong>连接精度</strong>和<strong>连接类型</strong>两部分：连接精度+连接类型+JOIN</p>
<p>连接精度：ALL / ANY / ASOF (默认ALL)</p>
<p>连接类型：</p>
<ol>
<li>外连接：LEFT / RIGHT / FULL(OUTER)</li>
<li>内连接：INNER</li>
<li>外连接：CROSS</li>
</ol>
<h4 id="9-5-1-连接精度"><a href="#9-5-1-连接精度" class="headerlink" title="9.5.1 连接精度"></a>9.5.1 连接精度</h4><p>ALL：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中全部连接数据。</p>
<p>ANY：如果左边作为基表，右表中有多行数据与之连接匹配，则返回右表中<strong>第一行</strong>连接数据。</p>
<p>ASOF：ASOF是一种模糊连接，它允许在连接键之后追加定义一个模糊连接的匹配条件 asof_column（感觉有点玄学，插个眼，mark）</p>
<h4 id="9-5-2-连接类型"><a href="#9-5-2-连接类型" class="headerlink" title="9.5.2 连接类型"></a>9.5.2 连接类型</h4><p>跟MySQL一样</p>
<h4 id="9-5-3-多表连接"><a href="#9-5-3-多表连接" class="headerlink" title="9.5.3 多表连接"></a>9.5.3 多表连接</h4><p>跟MySQL一样</p>
<h4 id="9-5-4-注意事项"><a href="#9-5-4-注意事项" class="headerlink" title="9.5.4 注意事项"></a>9.5.4 注意事项</h4><ol>
<li><p>关于性能</p>
<p>首先，应该遵循<strong>左大又小</strong>的原则，即将数据量小的表放在右侧（跟MySQL或Hive的小表JOIN大表不太一样），因为ClickHouse中所有连接方式，右表都会被全部加载到内存中与左表进行比较。</p>
<p>其次，<strong>JOIN查询目前没有缓存的支持</strong>，这意味着每一次JOIN查询，即便是连续执行的相同SQL，也都会生成一次全新的执行计划。故如果大量使用JOIN查询，则需要进一步考虑借助上次应用侧的缓存服务或使用JOIN表引擎来改善性能。</p>
<p>最后，如果是<strong>在大量维度属性不全的查询场景中，建议使用字典代替JOIN查询</strong>。因为在进行多表的连接查询时，查询会转换成两两连接的形式，这种“滚雪球”式的查询很可能带来性能问题。</p>
</li>
<li><p>关于空值策略与简写形式</p>
<p>ClickHouse中连接查询的空值（未被连接的数据）是由默认值填充的，这跟其他常见的数据库的策略不同（由Null填充）。ClickHouse中连接查询的空值策略是通过<code>join_use_nulls</code>参数指定的，默认为0，默认充填0（当该参数为1时，空值由Null填充）。</p>
<p>此外，JOIN Key支持简化写法，当数据表的连接字段名相同时，可以用<code>USING</code>语法简写，例如下面两条语句的效果是等同的：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a.id,a.name,b.rate <span class="hljs-keyword">FROM</span> join_tb1 a<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> join_tb2 b <span class="hljs-keyword">ON</span> a.id = b.id<br><br><span class="hljs-comment">-- USING简写</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span>,<span class="hljs-keyword">name</span>,rate <span class="hljs-keyword">FROM</span> join_tb1<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> join_tb2 <span class="hljs-keyword">USING</span> <span class="hljs-keyword">id</span><br></code></pre></td></tr></tbody></table></figure>


</li>
</ol>
<h3 id="9-6-WHERE与PREWHERE子句"><a href="#9-6-WHERE与PREWHERE子句" class="headerlink" title="9.6 WHERE与PREWHERE子句"></a>9.6 WHERE与PREWHERE子句</h3><p>WHERE子句基于条件表达式来实现数据过滤（这个跟其他数据库一样），如果过滤条件恰好是主键字段，则能够借助索引进一步加速查询，所以WHERE子句是查询语句能否启用索引的判断依据（前提是表引擎支持索引特性）。</p>
<p>PREWHERE目前只能用于MergeTree系列的表引擎，它是WHERE的一种优化，结果相同。它的不同之处在于：使用PREWHERE时，首先只会读取PREWHERE指定的列字段数据，用于数据过滤的条件判断，待数据过滤之后再读取SELECT声明的列字段以补全其余属性。所以再一些场合中PREWHERE相比WHERE处理的数据量更少（处理的数据行数可能没变，但是数据大小变小了），性能更高。</p>
<p>PREWHERE优化默认打开，会在条件合适的情况下将WHERE替换为PREWHERE，其参数设置语句如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> optimize_move_to_prewhere = <span class="hljs-number">1</span> <span class="hljs-comment">--参数为0时强制关闭</span><br></code></pre></td></tr></tbody></table></figure>

<h3 id="9-7-GROUP-BY子句"><a href="#9-7-GROUP-BY子句" class="headerlink" title="9.7 GROUP BY子句"></a>9.7 GROUP BY子句</h3><p>GROUP BY后声明的字段通常称为<strong>聚合键</strong>或Key，在ClickHouse中的聚合查询中 SELECT 后只声明了聚合函数，则可以省略GROUP BY关键字，例如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SUM</span>(a1),<span class="hljs-keyword">SUM</span>(a2) <span class="hljs-keyword">FROM</span> t1<br></code></pre></td></tr></tbody></table></figure>

<p>SELECT的字段只能是聚合键、聚合函数，否则会报错。</p>
<p>除了上述特性外，聚合查询还能配合<code>WITH ROLLUP</code>、<code>WITH CUBE</code>、<code>WITH TOTALS</code>三种修饰符获取额外的汇总信息。</p>
<h4 id="9-7-1-WITH-ROLLUP"><a href="#9-7-1-WITH-ROLLUP" class="headerlink" title="9.7.1 WITH ROLLUP"></a>9.7.1 WITH ROLLUP</h4><p>ROLLUP能够按照聚合键从右向左上卷，基于聚合函数依次生成分组小计和总计。如果聚合键为n​，则最终会生成小计的个数为n+1​。</p>
<h4 id="9-7-2-WITH-ROLLUP"><a href="#9-7-2-WITH-ROLLUP" class="headerlink" title="9.7.2 WITH ROLLUP"></a>9.7.2 WITH ROLLUP</h4><p>CUBE会像立方体模型一样，基于聚合键之间所有的组合生成小计信息。如果聚合键为n，则最终会生成小计的个数为2的n​次方。</p>
<h4 id="9-7-3-WITH-TOTALS"><a href="#9-7-3-WITH-TOTALS" class="headerlink" title="9.7.3 WITH TOTALS"></a>9.7.3 WITH TOTALS</h4><p>TOTALS会基于聚合函数对所有数据进行总计，例如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> a1,<span class="hljs-keyword">SUM</span>(a2),<span class="hljs-keyword">COUNT</span>(a3) <span class="hljs-keyword">FROM</span> t1<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a1 <span class="hljs-keyword">WITH</span> TOTALS<br></code></pre></td></tr></tbody></table></figure>

<p>其结果会额外显示累计总和的结果。</p>
<h3 id="9-10-LIMIT-BY子句"><a href="#9-10-LIMIT-BY子句" class="headerlink" title="9.10 LIMIT BY子句"></a>9.10 LIMIT BY子句</h3><p>LIMIT BY子句运行于ORDER BY 之后和LIMIT之前，最多返回<strong>前n​个字段</strong>的数据，其常规语法如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">LIMIT n BY 字段<br></code></pre></td></tr></tbody></table></figure>

<h2 id="第10章"><a href="#第10章" class="headerlink" title="第10章"></a>第10章</h2><h3 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h3><p>用Nx表示一个节点（服务器），例如N1,N2</p>
<p>副本和分片有时候一样，有时候不一样，区分方法：</p>
<p>如果N1的Y和N2的Y数据相同，则它们互为副本（N1Y = N2Y），否则互为分片（N1Y != N2Y）</p>
<h3 id="10-2-数据副本"><a href="#10-2-数据副本" class="headerlink" title="10.2 数据副本"></a>10.2 数据副本</h3><p>MegreTree表引擎前缀加了Replicated才有应用副本的能力（还有另一种副本的实现方式），例如ReplicatedMergeTree、ReplicatedReplacingMergeTree、ReplicatedSummingMergeTree，这类表引擎称为复制表系列引擎。</p>
<p>ReplicatedMergeTree在MergeTree的基础上加入了分布式协同的能力，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110102012.png" srcset="/img/loading.gif" lazyload="" width="70%"></p>
<p>在MergeTree中，一个数据分区由开始创建到全部完成，会经历两类存储区域：</p>
<ol>
<li>内存：数据首先会被写入内存缓冲区</li>
<li>本地磁盘：数据接着会被写入tmp临时目录分区，待全部完成后再将临时目录重新命名为正式分区</li>
</ol>
<ul>
<li>ReplicatedMergeTree在上述基础上增加了Zookeeper的部分，它会进一步在Zookeeper内创建一系列的监听节点，并以此实现多个实例之间的通信。在整个通信过程中，Zookeeper并不会涉及数据表的传输。</li>
</ul>
<h3 id="10-3-ReplicatedMergeTree原理解析"><a href="#10-3-ReplicatedMergeTree原理解析" class="headerlink" title="10.3 ReplicatedMergeTree原理解析"></a>10.3 ReplicatedMergeTree原理解析</h3><p>ReplicatedMergeTree的核心逻辑中，大量运用了Zookeeper的能力，以实现ReplicatedMergeTree副本实例之间的协同，包括主副本选举、副本状态感知、操作日志分发、任务队列和BlockID去重判断等。</p>
<p>副本协同的核心流程主要有<strong>INSERT</strong>、<strong>MERGE</strong>、<strong>MUTATION</strong>、<strong>ALTER</strong>，分别对应了数据写入、分区合并、数据修改、元数据修改。（其他查询不支持分布式执行，包括SELECT、CREATE、DROP、RENAME、ATTACH）</p>
<p>拟定一个用ReplicatedMergeTree实现一张拥有1分片、1副本的数据表的演示场景，其完整过程如下：</p>
<ul>
<li><p>INSERT的核心执行流程</p>
<ol>
<li>创建第一个副本实例</li>
<li>创建第二个副本实例</li>
<li>向第一个副本实例写入数据</li>
<li>由第一个副本实例推送Log日志</li>
<li>第二个副本实例拉取Log日志</li>
<li>第二个副本实例向其他副本发起下载请求</li>
<li>第一个副本实例响应数据下载</li>
<li>第二个实例下载数据并完成本地写入</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104346.png" srcset="/img/loading.gif" lazyload="" alt=""></p>
</li>
<li><p>MERGE的核心执行流程</p>
<ol>
<li>创建远程连接，尝试与主副本通信</li>
<li>主副本接收通信</li>
<li>由主副本制定MERGE计划并推送Log日志</li>
<li>各副本分别拉取Log日志</li>
<li>各个副本分别在本地执行MERGE</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104410.png" srcset="/img/loading.gif" lazyload="" alt=""></p>
</li>
<li><p>MUTATION的核心执行流程</p>
<ol>
<li>推送MUTATION日志</li>
<li>所有副本实例各自监听MUTATION日志</li>
<li>由主副本实例响应MUTATION日志并推送Log日志</li>
<li>各个副本实例分别拉取Log日志</li>
<li>各个副本实例分别在本地执行MUTATION</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104432.png" srcset="/img/loading.gif" lazyload="" alt=""></p>
</li>
<li><p>ALTER的核心执行流程</p>
<ol>
<li>修改共享元数据</li>
<li>监听共享元数据变更并各自执行本地修改</li>
<li>确认所有副本完成修改</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110104609.png" srcset="/img/loading.gif" lazyload="" alt=""></p>
</li>
</ul>
<h3 id="10-4-数据分片"><a href="#10-4-数据分片" class="headerlink" title="10.4 数据分片"></a>10.4 数据分片</h3><p>通过引入副本可以有效降低数据丢失的风险（多份存储），并提升查询的性能（分摊查询、读写分离），但是仍没有解决数据表容量的问题。每个副本保存了数据表全量的数据，所以在业务庞大的场景中，依靠副本并不能解决单表的性能瓶颈，所以需要将数据水平切分，也就分片（shard）。</p>
<p>数据表A分布在N个ClickHouse服务节点，且这些数据彼此之间没有重复数据，则称为数据表A有N个分片。为了进一步考虑数据在写入时，如何被均匀地写至各个分片，以及查询时路由到每个分片并组成结果集，所以ClickHouse的数据分片需要结合Distributed表引擎一同使用，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110330.png" srcset="/img/loading.gif" lazyload="" width="60%"></p>
<p>Distributed表引擎自身不存储任何数据，它能够作为分布式表的一层透明代理，在集群内部自动开展数据的写入、分发、查询、路由等工作。</p>
<p>接下来以创建test_1_local的过程为例子，解释分布式DDL的核心执行流程</p>
<ul>
<li><p>分布式DDL的核心执行流程</p>
<ol>
<li>推送DDL日志</li>
<li>拉取日志并执行</li>
<li>确认执行进度</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110110947.png" srcset="/img/loading.gif" lazyload="" width="60%"></p>
</li>
</ul>
<h3 id="10-5-Distributed原理解析"><a href="#10-5-Distributed原理解析" class="headerlink" title="10.5 Distributed原理解析"></a>10.5 Distributed原理解析</h3><p>Distributed表引擎是作为数据分片的透明代理，能自动路由数据至集群中的各个节点，所以Distributed表引擎和其他数据表一起协同工作，如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChoiNgai/ImageServer/img/20211110112518.png" srcset="/img/loading.gif" lazyload="" width="60%"></p>
<ul>
<li>本地表：通常以 _local 为后缀进行命名。本地表是承载数据的载体，可以使用非Distributed的任意表引擎，一张本地表对应了一个数据分片</li>
<li>分布式表：通常以 _all 为后缀进行命名。分布式表只能用Distributed表引擎，它与本地表形成一对多的映射关系，日后将通过分布式表代理操作多张本地表<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>幂等性：指多次操作,结果是一致。 数学表达式为： f(x) = f(f(x))<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF/">大数据技术</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/20/%E3%80%8AJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%8D%B7I%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《Java核心技术 卷I》阅读笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/04/%E7%89%9B%E5%AE%A2SQL%E4%BA%8C%E5%88%B7/">
                        <span class="hidden-mobile">牛客SQL二刷</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const mathjax = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
